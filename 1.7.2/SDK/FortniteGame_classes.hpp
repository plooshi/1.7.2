#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: FortniteGame

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Account_structs.hpp"
#include "Account_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "FortniteGame_structs.hpp"
#include "SlateCore_structs.hpp"
#include "McpProfileSys_structs.hpp"
#include "McpProfileSys_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "GameplayAbilities_structs.hpp"
#include "GameplayAbilities_classes.hpp"
#include "Hotfix_classes.hpp"
#include "BlueprintContext_classes.hpp"
#include "PhysXVehicles_classes.hpp"
#include "Party_structs.hpp"
#include "Party_classes.hpp"
#include "Rejoin_classes.hpp"
#include "Lobby_classes.hpp"
#include "OnlineSubsystemUtils_structs.hpp"
#include "OnlineSubsystemUtils_classes.hpp"
#include "Foliage_classes.hpp"
#include "SignificanceManager_classes.hpp"
#include "Gauntlet_classes.hpp"


namespace SDK
{

// Class FortniteGame.AIHotSpotRenderingComponent
// 0x0000 (0x0670 - 0x0670)
class UAIHotSpotRenderingComponent final : public UPrimitiveComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIHotSpotRenderingComponent">();
	}
	static class UAIHotSpotRenderingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIHotSpotRenderingComponent>();
	}
};
static_assert(alignof(UAIHotSpotRenderingComponent) == 0x000010, "Wrong alignment on UAIHotSpotRenderingComponent");
static_assert(sizeof(UAIHotSpotRenderingComponent) == 0x000670, "Wrong size on UAIHotSpotRenderingComponent");

// Class FortniteGame.FortInventorySortFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UFortInventorySortFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class FText GetCriterionDisplayNameOfSortType(EInventoryContentSortType SortType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortInventorySortFunctionLibrary">();
	}
	static class UFortInventorySortFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortInventorySortFunctionLibrary>();
	}
};
static_assert(alignof(UFortInventorySortFunctionLibrary) == 0x000008, "Wrong alignment on UFortInventorySortFunctionLibrary");
static_assert(sizeof(UFortInventorySortFunctionLibrary) == 0x000028, "Wrong size on UFortInventorySortFunctionLibrary");

// Class FortniteGame.BuildingStructuralSupportSystem
// 0x0448 (0x0470 - 0x0028)
class UBuildingStructuralSupportSystem final : public UObject
{
public:
	uint8                                         Pad_28[0x240];                                     // 0x0028(0x0240)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ABuildingLayoutRequirement*>     LayoutRequirementActorsToRegister;                 // 0x0268(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_278[0x1E8];                                    // 0x0278(0x01E8)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortNavigationGraph*                   NavGraph;                                          // 0x0460(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_468[0x8];                                      // 0x0468(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetLogicalBuildingGroundSupportedActors(int32 LogicalIndex, TArray<class ABuildingSMActor*>* LogicalBuildingGroundSupportedActors);
	void K2_GetLogicalBuildingActors(int32 LogicalIdx, TArray<class ABuildingSMActor*>* LogicalBuildingActors);

	bool IsBuildingActorStructurallySupported(const class ABuildingSMActor* ActorToCheck) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingStructuralSupportSystem">();
	}
	static class UBuildingStructuralSupportSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingStructuralSupportSystem>();
	}
};
static_assert(alignof(UBuildingStructuralSupportSystem) == 0x000008, "Wrong alignment on UBuildingStructuralSupportSystem");
static_assert(sizeof(UBuildingStructuralSupportSystem) == 0x000470, "Wrong size on UBuildingStructuralSupportSystem");
static_assert(offsetof(UBuildingStructuralSupportSystem, LayoutRequirementActorsToRegister) == 0x000268, "Member 'UBuildingStructuralSupportSystem::LayoutRequirementActorsToRegister' has a wrong offset!");
static_assert(offsetof(UBuildingStructuralSupportSystem, NavGraph) == 0x000460, "Member 'UBuildingStructuralSupportSystem::NavGraph' has a wrong offset!");

// Class FortniteGame.AIHotSpotSlot
// 0x0098 (0x00C0 - 0x0028)
class UAIHotSpotSlot : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LocalTransform;                                    // 0x0030(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         Height;                                            // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Radius;                                            // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DistanceToFocusActor;                              // 0x0068(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         UserId;                                            // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bStartEnabled : 1;                                 // 0x0070(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bHasCachedAgentData : 1;                           // 0x0070(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bHasOverlappingSlots : 1;                          // 0x0070(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bHasDistanceToFocusActor : 1;                      // 0x0070(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsBlockingOthers : 1;                             // 0x0070(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsEnabled : 1;                                    // 0x0070(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AAIController*                          Owner;                                             // 0x0078(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SlotIndex;                                         // 0x0080(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAIHotSpotSlot                                SlotState;                                         // 0x0084(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_85[0x3B];                                      // 0x0085(0x003B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearSlot();
	void OnStateChanged(class AAIController* SlotOwner, EAIHotSpotSlot NewState);
	void SetSlotEnabled(bool bNewEnabled);
	void SetSlotOwnerAndState(class AAIController* NewOwner, EAIHotSpotSlot NewState);
	void SetSlotState(EAIHotSpotSlot NewState);

	class AAIHotSpot* GetHotSpot() const;
	struct FBox GetSlotBounds() const;
	float GetSlotHeight() const;
	int32 GetSlotIndex() const;
	struct FVector GetSlotLocation() const;
	class AAIController* GetSlotOwner() const;
	float GetSlotRadius() const;
	struct FRotator GetSlotRotation() const;
	EAIHotSpotSlot GetSlotState() const;
	int32 GetSlotUserId() const;
	bool HasUserId() const;
	bool IsAIAllowed(const class AAIController* AI) const;
	bool IsEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIHotSpotSlot">();
	}
	static class UAIHotSpotSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIHotSpotSlot>();
	}
};
static_assert(alignof(UAIHotSpotSlot) == 0x000010, "Wrong alignment on UAIHotSpotSlot");
static_assert(sizeof(UAIHotSpotSlot) == 0x0000C0, "Wrong size on UAIHotSpotSlot");
static_assert(offsetof(UAIHotSpotSlot, LocalTransform) == 0x000030, "Member 'UAIHotSpotSlot::LocalTransform' has a wrong offset!");
static_assert(offsetof(UAIHotSpotSlot, Height) == 0x000060, "Member 'UAIHotSpotSlot::Height' has a wrong offset!");
static_assert(offsetof(UAIHotSpotSlot, Radius) == 0x000064, "Member 'UAIHotSpotSlot::Radius' has a wrong offset!");
static_assert(offsetof(UAIHotSpotSlot, DistanceToFocusActor) == 0x000068, "Member 'UAIHotSpotSlot::DistanceToFocusActor' has a wrong offset!");
static_assert(offsetof(UAIHotSpotSlot, UserId) == 0x00006C, "Member 'UAIHotSpotSlot::UserId' has a wrong offset!");
static_assert(offsetof(UAIHotSpotSlot, Owner) == 0x000078, "Member 'UAIHotSpotSlot::Owner' has a wrong offset!");
static_assert(offsetof(UAIHotSpotSlot, SlotIndex) == 0x000080, "Member 'UAIHotSpotSlot::SlotIndex' has a wrong offset!");
static_assert(offsetof(UAIHotSpotSlot, SlotState) == 0x000084, "Member 'UAIHotSpotSlot::SlotState' has a wrong offset!");

// Class FortniteGame.FortSearchPass
// 0x0268 (0x0290 - 0x0028)
class UFortSearchPass final : public UObject
{
public:
	uint8                                         Pad_28[0x148];                                     // 0x0028(0x0148)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortSessionHelper*                     SessionHelper;                                     // 0x0170(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_178[0x48];                                     // 0x0178(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortSearchPassParams                  CurrentSearchParams;                               // 0x01C0(0x0028)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FFortSearchPassState                   CurrentSearchPassState;                            // 0x01E8(0x0018)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_200[0x90];                                     // 0x0200(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortSearchPass">();
	}
	static class UFortSearchPass* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortSearchPass>();
	}
};
static_assert(alignof(UFortSearchPass) == 0x000008, "Wrong alignment on UFortSearchPass");
static_assert(sizeof(UFortSearchPass) == 0x000290, "Wrong size on UFortSearchPass");
static_assert(offsetof(UFortSearchPass, SessionHelper) == 0x000170, "Member 'UFortSearchPass::SessionHelper' has a wrong offset!");
static_assert(offsetof(UFortSearchPass, CurrentSearchParams) == 0x0001C0, "Member 'UFortSearchPass::CurrentSearchParams' has a wrong offset!");
static_assert(offsetof(UFortSearchPass, CurrentSearchPassState) == 0x0001E8, "Member 'UFortSearchPass::CurrentSearchPassState' has a wrong offset!");

// Class FortniteGame.FortAttributeSet
// 0x0000 (0x0030 - 0x0030)
class UFortAttributeSet : public UAttributeSet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAttributeSet">();
	}
	static class UFortAttributeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAttributeSet>();
	}
};
static_assert(alignof(UFortAttributeSet) == 0x000008, "Wrong alignment on UFortAttributeSet");
static_assert(sizeof(UFortAttributeSet) == 0x000030, "Wrong size on UFortAttributeSet");

// Class FortniteGame.FortWeaponAttrSet
// 0x0100 (0x0130 - 0x0030)
class UFortWeaponAttrSet final : public UFortAttributeSet
{
public:
	struct FFortGameplayAttributeData             WeaponChanceToNotConsumeAmmo;                      // 0x0030(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             AccumulatedWeaponChanceToNotConsumeAmmo;           // 0x0050(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             WeaponRateOfFire;                                  // 0x0070(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             WeaponHorizontalRecoil;                            // 0x0090(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             WeaponVerticalRecoil;                              // 0x00B0(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             WeaponReloadSpeed;                                 // 0x00D0(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             WeaponAmmoClipSize;                                // 0x00F0(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             CharacterItemDurabilityDecayModifier;              // 0x0110(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)

public:
	void OnRep_AccumulatedWeaponChanceToNotConsumeAmmo();
	void OnRep_CharacterItemDurabilityDecayModifier();
	void OnRep_WeaponAmmoClipSize();
	void OnRep_WeaponChanceToNotConsumeAmmo();
	void OnRep_WeaponHorizontalRecoil();
	void OnRep_WeaponRateOfFire();
	void OnRep_WeaponReloadSpeed();
	void OnRep_WeaponVerticalRecoil();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortWeaponAttrSet">();
	}
	static class UFortWeaponAttrSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortWeaponAttrSet>();
	}
};
static_assert(alignof(UFortWeaponAttrSet) == 0x000008, "Wrong alignment on UFortWeaponAttrSet");
static_assert(sizeof(UFortWeaponAttrSet) == 0x000130, "Wrong size on UFortWeaponAttrSet");
static_assert(offsetof(UFortWeaponAttrSet, WeaponChanceToNotConsumeAmmo) == 0x000030, "Member 'UFortWeaponAttrSet::WeaponChanceToNotConsumeAmmo' has a wrong offset!");
static_assert(offsetof(UFortWeaponAttrSet, AccumulatedWeaponChanceToNotConsumeAmmo) == 0x000050, "Member 'UFortWeaponAttrSet::AccumulatedWeaponChanceToNotConsumeAmmo' has a wrong offset!");
static_assert(offsetof(UFortWeaponAttrSet, WeaponRateOfFire) == 0x000070, "Member 'UFortWeaponAttrSet::WeaponRateOfFire' has a wrong offset!");
static_assert(offsetof(UFortWeaponAttrSet, WeaponHorizontalRecoil) == 0x000090, "Member 'UFortWeaponAttrSet::WeaponHorizontalRecoil' has a wrong offset!");
static_assert(offsetof(UFortWeaponAttrSet, WeaponVerticalRecoil) == 0x0000B0, "Member 'UFortWeaponAttrSet::WeaponVerticalRecoil' has a wrong offset!");
static_assert(offsetof(UFortWeaponAttrSet, WeaponReloadSpeed) == 0x0000D0, "Member 'UFortWeaponAttrSet::WeaponReloadSpeed' has a wrong offset!");
static_assert(offsetof(UFortWeaponAttrSet, WeaponAmmoClipSize) == 0x0000F0, "Member 'UFortWeaponAttrSet::WeaponAmmoClipSize' has a wrong offset!");
static_assert(offsetof(UFortWeaponAttrSet, CharacterItemDurabilityDecayModifier) == 0x000110, "Member 'UFortWeaponAttrSet::CharacterItemDurabilityDecayModifier' has a wrong offset!");

// Class FortniteGame.AIHotSpotSlotGenerator
// 0x0000 (0x0028 - 0x0028)
class UAIHotSpotSlotGenerator : public UObject
{
public:
	void GenerateSlots();

	class UAIHotSpotSlot* AddSlot(const struct FVector& RelativeLocation, const struct FRotator& RelativeRotation, TSubclassOf<class UAIHotSpotSlot> CustomSlotClass, bool bEnabled) const;
	class AAIHotSpot* GetHotSpot() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIHotSpotSlotGenerator">();
	}
	static class UAIHotSpotSlotGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIHotSpotSlotGenerator>();
	}
};
static_assert(alignof(UAIHotSpotSlotGenerator) == 0x000008, "Wrong alignment on UAIHotSpotSlotGenerator");
static_assert(sizeof(UAIHotSpotSlotGenerator) == 0x000028, "Wrong size on UAIHotSpotSlotGenerator");

// Class FortniteGame.AIHotSpotSlotGenerator_OnBoundingBox
// 0x0048 (0x0070 - 0x0028)
class UAIHotSpotSlotGenerator_OnBoundingBox : public UAIHotSpotSlotGenerator
{
public:
	TSubclassOf<class UAIHotSpotSlot>             SlotClass;                                         // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MaxExtent;                                         // 0x0030(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExpandBy;                                          // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetFromEdge;                                    // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Spacing;                                           // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bLimitMaxExtent : 1;                               // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bMustHitFocusActor : 1;                            // 0x0048(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EBoundingBoxSlotDirectionCalculation          SlotDirectionCalculation;                          // 0x004C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x23];                                      // 0x004D(0x0023)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIHotSpotSlotGenerator_OnBoundingBox">();
	}
	static class UAIHotSpotSlotGenerator_OnBoundingBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIHotSpotSlotGenerator_OnBoundingBox>();
	}
};
static_assert(alignof(UAIHotSpotSlotGenerator_OnBoundingBox) == 0x000008, "Wrong alignment on UAIHotSpotSlotGenerator_OnBoundingBox");
static_assert(sizeof(UAIHotSpotSlotGenerator_OnBoundingBox) == 0x000070, "Wrong size on UAIHotSpotSlotGenerator_OnBoundingBox");
static_assert(offsetof(UAIHotSpotSlotGenerator_OnBoundingBox, SlotClass) == 0x000028, "Member 'UAIHotSpotSlotGenerator_OnBoundingBox::SlotClass' has a wrong offset!");
static_assert(offsetof(UAIHotSpotSlotGenerator_OnBoundingBox, MaxExtent) == 0x000030, "Member 'UAIHotSpotSlotGenerator_OnBoundingBox::MaxExtent' has a wrong offset!");
static_assert(offsetof(UAIHotSpotSlotGenerator_OnBoundingBox, ExpandBy) == 0x00003C, "Member 'UAIHotSpotSlotGenerator_OnBoundingBox::ExpandBy' has a wrong offset!");
static_assert(offsetof(UAIHotSpotSlotGenerator_OnBoundingBox, OffsetFromEdge) == 0x000040, "Member 'UAIHotSpotSlotGenerator_OnBoundingBox::OffsetFromEdge' has a wrong offset!");
static_assert(offsetof(UAIHotSpotSlotGenerator_OnBoundingBox, Spacing) == 0x000044, "Member 'UAIHotSpotSlotGenerator_OnBoundingBox::Spacing' has a wrong offset!");
static_assert(offsetof(UAIHotSpotSlotGenerator_OnBoundingBox, SlotDirectionCalculation) == 0x00004C, "Member 'UAIHotSpotSlotGenerator_OnBoundingBox::SlotDirectionCalculation' has a wrong offset!");

// Class FortniteGame.FortQueryGenerator_TerrainDonut
// 0x00D0 (0x0120 - 0x0050)
class UFortQueryGenerator_TerrainDonut final : public UEnvQueryGenerator
{
public:
	TSubclassOf<class UEnvQueryContext>           Center;                                            // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              Radius;                                            // 0x0058(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              RadiusWidth;                                       // 0x0088(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              SpacingArc;                                        // 0x00B8(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderIntValue                NumRings;                                          // 0x00E8(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bFilterAllowTerrain : 1;                           // 0x0118(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFilterAllowBuildings : 1;                         // 0x0118(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_119[0x7];                                      // 0x0119(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_TerrainDonut">();
	}
	static class UFortQueryGenerator_TerrainDonut* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_TerrainDonut>();
	}
};
static_assert(alignof(UFortQueryGenerator_TerrainDonut) == 0x000008, "Wrong alignment on UFortQueryGenerator_TerrainDonut");
static_assert(sizeof(UFortQueryGenerator_TerrainDonut) == 0x000120, "Wrong size on UFortQueryGenerator_TerrainDonut");
static_assert(offsetof(UFortQueryGenerator_TerrainDonut, Center) == 0x000050, "Member 'UFortQueryGenerator_TerrainDonut::Center' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_TerrainDonut, Radius) == 0x000058, "Member 'UFortQueryGenerator_TerrainDonut::Radius' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_TerrainDonut, RadiusWidth) == 0x000088, "Member 'UFortQueryGenerator_TerrainDonut::RadiusWidth' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_TerrainDonut, SpacingArc) == 0x0000B8, "Member 'UFortQueryGenerator_TerrainDonut::SpacingArc' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_TerrainDonut, NumRings) == 0x0000E8, "Member 'UFortQueryGenerator_TerrainDonut::NumRings' has a wrong offset!");

// Class FortniteGame.FortDifficultyOption
// 0x0018 (0x0040 - 0x0028)
class UFortDifficultyOption : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    CostAndAvailability;                               // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOption">();
	}
	static class UFortDifficultyOption* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOption>();
	}
};
static_assert(alignof(UFortDifficultyOption) == 0x000008, "Wrong alignment on UFortDifficultyOption");
static_assert(sizeof(UFortDifficultyOption) == 0x000040, "Wrong size on UFortDifficultyOption");
static_assert(offsetof(UFortDifficultyOption, CostAndAvailability) == 0x000030, "Member 'UFortDifficultyOption::CostAndAvailability' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionEncounter
// 0x0008 (0x0048 - 0x0040)
class UFortDifficultyOptionEncounter : public UFortDifficultyOption
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionEncounter">();
	}
	static class UFortDifficultyOptionEncounter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionEncounter>();
	}
};
static_assert(alignof(UFortDifficultyOptionEncounter) == 0x000008, "Wrong alignment on UFortDifficultyOptionEncounter");
static_assert(sizeof(UFortDifficultyOptionEncounter) == 0x000048, "Wrong size on UFortDifficultyOptionEncounter");

// Class FortniteGame.FortDifficultyOptionEncounter_UtilitiesAdjustment
// 0x0008 (0x0050 - 0x0048)
class UFortDifficultyOptionEncounter_UtilitiesAdjustment final : public UFortDifficultyOptionEncounter
{
public:
	float                                         UtilitiesAdjustmentIntervalSeconds;                // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionEncounter_UtilitiesAdjustment">();
	}
	static class UFortDifficultyOptionEncounter_UtilitiesAdjustment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionEncounter_UtilitiesAdjustment>();
	}
};
static_assert(alignof(UFortDifficultyOptionEncounter_UtilitiesAdjustment) == 0x000008, "Wrong alignment on UFortDifficultyOptionEncounter_UtilitiesAdjustment");
static_assert(sizeof(UFortDifficultyOptionEncounter_UtilitiesAdjustment) == 0x000050, "Wrong size on UFortDifficultyOptionEncounter_UtilitiesAdjustment");
static_assert(offsetof(UFortDifficultyOptionEncounter_UtilitiesAdjustment, UtilitiesAdjustmentIntervalSeconds) == 0x000048, "Member 'UFortDifficultyOptionEncounter_UtilitiesAdjustment::UtilitiesAdjustmentIntervalSeconds' has a wrong offset!");

// Class FortniteGame.FortMultiSizeBrushAsset
// 0x0360 (0x0388 - 0x0028)
class UFortMultiSizeBrushAsset final : public UDataAsset
{
public:
	struct FFortMultiSizeBrush                    Brush;                                             // 0x0028(0x0360)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMultiSizeBrushAsset">();
	}
	static class UFortMultiSizeBrushAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMultiSizeBrushAsset>();
	}
};
static_assert(alignof(UFortMultiSizeBrushAsset) == 0x000008, "Wrong alignment on UFortMultiSizeBrushAsset");
static_assert(sizeof(UFortMultiSizeBrushAsset) == 0x000388, "Wrong size on UFortMultiSizeBrushAsset");
static_assert(offsetof(UFortMultiSizeBrushAsset, Brush) == 0x000028, "Member 'UFortMultiSizeBrushAsset::Brush' has a wrong offset!");

// Class FortniteGame.FortReplaySpectatorPawnBase
// 0x0008 (0x0418 - 0x0410)
class AFortReplaySpectatorPawnBase : public ASpectatorPawn
{
public:
	class UFortReplaySpectatorCameraComponent*    SpectatorCameraComponent;                          // 0x0410(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortReplaySpectatorPawnBase">();
	}
	static class AFortReplaySpectatorPawnBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortReplaySpectatorPawnBase>();
	}
};
static_assert(alignof(AFortReplaySpectatorPawnBase) == 0x000008, "Wrong alignment on AFortReplaySpectatorPawnBase");
static_assert(sizeof(AFortReplaySpectatorPawnBase) == 0x000418, "Wrong size on AFortReplaySpectatorPawnBase");
static_assert(offsetof(AFortReplaySpectatorPawnBase, SpectatorCameraComponent) == 0x000410, "Member 'AFortReplaySpectatorPawnBase::SpectatorCameraComponent' has a wrong offset!");

// Class FortniteGame.FortConstructionSet
// 0x01A0 (0x01D0 - 0x0030)
class UFortConstructionSet final : public UFortAttributeSet
{
public:
	struct FFortGameplayAttributeData             BuildSpeed;                                        // 0x0030(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             RepairSpeed;                                       // 0x0050(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             BuildCost;                                         // 0x0070(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             RepairCost;                                        // 0x0090(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             MaxBuildLevel;                                     // 0x00B0(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             BuildingSkill;                                     // 0x00D0(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             TrapArmSpeed;                                      // 0x00F0(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             TrapReloadSpeed;                                   // 0x0110(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             TrapBaseDamage;                                    // 0x0130(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             TrapMaxDurability;                                 // 0x0150(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             TrapDiceCritChance;                                // 0x0170(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             TrapDiceCritMultiplier;                            // 0x0190(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             TrapHealingSource;                                 // 0x01B0(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)

public:
	void OnRep_BuildCost();
	void OnRep_BuildingSkill();
	void OnRep_BuildSpeed();
	void OnRep_MaxBuildLevel();
	void OnRep_RepairCost();
	void OnRep_RepairSpeed();
	void OnRep_TrapArmSpeed();
	void OnRep_TrapBaseDamage();
	void OnRep_TrapDiceCritChance();
	void OnRep_TrapDiceCritMultiplier();
	void OnRep_TrapHealingSource();
	void OnRep_TrapMaxDurability();
	void OnRep_TrapReloadSpeed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortConstructionSet">();
	}
	static class UFortConstructionSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortConstructionSet>();
	}
};
static_assert(alignof(UFortConstructionSet) == 0x000008, "Wrong alignment on UFortConstructionSet");
static_assert(sizeof(UFortConstructionSet) == 0x0001D0, "Wrong size on UFortConstructionSet");
static_assert(offsetof(UFortConstructionSet, BuildSpeed) == 0x000030, "Member 'UFortConstructionSet::BuildSpeed' has a wrong offset!");
static_assert(offsetof(UFortConstructionSet, RepairSpeed) == 0x000050, "Member 'UFortConstructionSet::RepairSpeed' has a wrong offset!");
static_assert(offsetof(UFortConstructionSet, BuildCost) == 0x000070, "Member 'UFortConstructionSet::BuildCost' has a wrong offset!");
static_assert(offsetof(UFortConstructionSet, RepairCost) == 0x000090, "Member 'UFortConstructionSet::RepairCost' has a wrong offset!");
static_assert(offsetof(UFortConstructionSet, MaxBuildLevel) == 0x0000B0, "Member 'UFortConstructionSet::MaxBuildLevel' has a wrong offset!");
static_assert(offsetof(UFortConstructionSet, BuildingSkill) == 0x0000D0, "Member 'UFortConstructionSet::BuildingSkill' has a wrong offset!");
static_assert(offsetof(UFortConstructionSet, TrapArmSpeed) == 0x0000F0, "Member 'UFortConstructionSet::TrapArmSpeed' has a wrong offset!");
static_assert(offsetof(UFortConstructionSet, TrapReloadSpeed) == 0x000110, "Member 'UFortConstructionSet::TrapReloadSpeed' has a wrong offset!");
static_assert(offsetof(UFortConstructionSet, TrapBaseDamage) == 0x000130, "Member 'UFortConstructionSet::TrapBaseDamage' has a wrong offset!");
static_assert(offsetof(UFortConstructionSet, TrapMaxDurability) == 0x000150, "Member 'UFortConstructionSet::TrapMaxDurability' has a wrong offset!");
static_assert(offsetof(UFortConstructionSet, TrapDiceCritChance) == 0x000170, "Member 'UFortConstructionSet::TrapDiceCritChance' has a wrong offset!");
static_assert(offsetof(UFortConstructionSet, TrapDiceCritMultiplier) == 0x000190, "Member 'UFortConstructionSet::TrapDiceCritMultiplier' has a wrong offset!");
static_assert(offsetof(UFortConstructionSet, TrapHealingSource) == 0x0001B0, "Member 'UFortConstructionSet::TrapHealingSource' has a wrong offset!");

// Class FortniteGame.AIHotSpot
// 0x0188 (0x0510 - 0x0388)
class AAIHotSpot : public AActor
{
public:
	uint8                                         Pad_388[0x8];                                      // 0x0388(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAIHotSpotSlot*>                 UserSlots;                                         // 0x0390(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UAIHotSpotSlotGenerator*                SlotGenerator;                                     // 0x03A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UAIHotSpotSlot*>                 Slots;                                             // 0x03A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	class AActor*                                 FocusActor;                                        // 0x03B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UNavigationQueryFilter>     FilterClass;                                       // 0x03C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                CustomNavmeshSearchExtent;                         // 0x03C8(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bStartEnabled : 1;                                 // 0x03D4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAllowSlotlessAssignment : 1;                      // 0x03D4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAllowClaimingMultipleSlots : 1;                   // 0x03D4(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bTrackOverlappingSlots : 1;                        // 0x03D4(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bProjectSlotsOnNavmesh : 1;                        // 0x03D4(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCustomNavmeshSearchExtent : 1;                    // 0x03D4(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsEnabled : 1;                                    // 0x03D4(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_3D5[0x3];                                      // 0x03D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AAIController*>                  NoSlotAssignees;                                   // 0x03D8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E8[0x110];                                    // 0x03E8(0x0110)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    RenderingComponent;                                // 0x04F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBillboardComponent*                    SpriteComponent;                                   // 0x0500(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_508[0x8];                                      // 0x0508(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AssignFromWaitingList();
	int32 AssignGroupToHotspot(const TArray<class AAIController*>& GroupOfAI);
	bool AssignToHotspot(class AAIController* AI);
	bool AssignToSlotByIndex(class AAIController* AI, int32 Index_0);
	bool OccupySlotByIndex(int32 Index_0);
	bool OnAssignedClaimedBehavior(class AAIController* AI, int32 Index_0, int32 UserId, bool bWasOnWaitingList);
	bool OnAssignedOccupiedBehavior(class AAIController* AI, int32 Index_0, int32 UserId);
	bool OnAssignedSlotlessBehavior(class AAIController* AI);
	void OnHotSpotDisabled();
	void OnHotSpotEnabled();
	void OnMoveToSlotFinished(class AAIController* AI, int32 Index_0, int32 UserId, bool bResult);
	void OnRemovedBehavior(class AAIController* AI, int32 Index_0, int32 UserId, EAIHotSpotSlot PrevState, bool bWasOnWaitingList);
	void OnRemovedSlotlessBehavior(class AAIController* AI, bool bIsClamingSlot);
	void OnSlotBlocked(class AAIController* AI, int32 Index_0, int32 UserId);
	void OnSlotClaimed(class AAIController* AI, int32 Index_0, int32 UserId);
	void OnSlotDisabled(int32 Index_0, int32 UserId);
	void OnSlotEnabled(int32 Index_0, int32 UserId);
	void OnSlotFreed(class AAIController* AI, int32 Index_0, int32 UserId);
	void OnSlotOccupied(class AAIController* AI, int32 Index_0, int32 UserId);
	bool RemoveFromHotspot(class AAIController* AI, bool bAssignFromWaitingList);
	int32 RemoveGroupFromHotspot(const TArray<class AAIController*>& GroupOfAI);
	void SetEnabled(bool bEnabled);

	bool CanUseSlotByIndex(const class AAIController* AI, int32 Index_0) const;
	int32 FindBestSlotIndex(class AAIController* AI) const;
	TArray<int32> FindBestSlotIndices(const TArray<class AAIController*>& AI) const;
	TArray<class AAIController*> GetAssignedAI(EAIHotSpotAssignmentFilter Filter) const;
	int32 GetAssignedAICount(EAIHotSpotAssignmentFilter Filter) const;
	class UAIHotSpotSlot* GetSlotByIndex(int32 Index_0) const;
	class UAIHotSpotSlot* GetSlotByOwner(const class AAIController* AIOwner) const;
	int32 GetSlotCount(EAIHotSpotSlotFilter Filter) const;
	int32 GetSlotIndexByOwner(const class AAIController* AIOwner) const;
	struct FVector GetSlotLocationByIndex(int32 Index_0) const;
	class AAIController* GetSlotOwnerByIndex(int32 Index_0) const;
	struct FRotator GetSlotRotationByIndex(int32 Index_0) const;
	EAIHotSpotSlot GetSlotStateByIndex(int32 Index_0) const;
	EAIHotSpotSlot GetSlotStateByOwner(const class AAIController* AIOwner) const;
	int32 GetSlotUserIdByIndex(int32 Index_0) const;
	bool HasAssignedAI(const class AAIController* AI, EAIHotSpotAssignmentFilter Filter) const;
	bool HasEnabledSlots() const;
	bool IsAIAllowed(const class AAIController* AI) const;
	bool IsEnabled() const;
	bool IsSlotlessAssignmentAllowed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIHotSpot">();
	}
	static class AAIHotSpot* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAIHotSpot>();
	}
};
static_assert(alignof(AAIHotSpot) == 0x000008, "Wrong alignment on AAIHotSpot");
static_assert(sizeof(AAIHotSpot) == 0x000510, "Wrong size on AAIHotSpot");
static_assert(offsetof(AAIHotSpot, UserSlots) == 0x000390, "Member 'AAIHotSpot::UserSlots' has a wrong offset!");
static_assert(offsetof(AAIHotSpot, SlotGenerator) == 0x0003A0, "Member 'AAIHotSpot::SlotGenerator' has a wrong offset!");
static_assert(offsetof(AAIHotSpot, Slots) == 0x0003A8, "Member 'AAIHotSpot::Slots' has a wrong offset!");
static_assert(offsetof(AAIHotSpot, FocusActor) == 0x0003B8, "Member 'AAIHotSpot::FocusActor' has a wrong offset!");
static_assert(offsetof(AAIHotSpot, FilterClass) == 0x0003C0, "Member 'AAIHotSpot::FilterClass' has a wrong offset!");
static_assert(offsetof(AAIHotSpot, CustomNavmeshSearchExtent) == 0x0003C8, "Member 'AAIHotSpot::CustomNavmeshSearchExtent' has a wrong offset!");
static_assert(offsetof(AAIHotSpot, NoSlotAssignees) == 0x0003D8, "Member 'AAIHotSpot::NoSlotAssignees' has a wrong offset!");
static_assert(offsetof(AAIHotSpot, RenderingComponent) == 0x0004F8, "Member 'AAIHotSpot::RenderingComponent' has a wrong offset!");
static_assert(offsetof(AAIHotSpot, SpriteComponent) == 0x000500, "Member 'AAIHotSpot::SpriteComponent' has a wrong offset!");

// Class FortniteGame.FortAIHotSpot
// 0x0028 (0x0538 - 0x0510)
class AFortAIHotSpot : public AAIHotSpot
{
public:
	uint8                                         Pad_510[0x28];                                     // 0x0510(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIHotSpot">();
	}
	static class AFortAIHotSpot* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAIHotSpot>();
	}
};
static_assert(alignof(AFortAIHotSpot) == 0x000008, "Wrong alignment on AFortAIHotSpot");
static_assert(sizeof(AFortAIHotSpot) == 0x000538, "Wrong size on AFortAIHotSpot");

// Class FortniteGame.FortAIHotSpot_Shooting
// 0x0000 (0x0538 - 0x0538)
class AFortAIHotSpot_Shooting final : public AFortAIHotSpot
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIHotSpot_Shooting">();
	}
	static class AFortAIHotSpot_Shooting* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAIHotSpot_Shooting>();
	}
};
static_assert(alignof(AFortAIHotSpot_Shooting) == 0x000008, "Wrong alignment on AFortAIHotSpot_Shooting");
static_assert(sizeof(AFortAIHotSpot_Shooting) == 0x000538, "Wrong size on AFortAIHotSpot_Shooting");

// Class FortniteGame.FortQueryGenerator_HotspotSlots
// 0x0048 (0x0098 - 0x0050)
class UFortQueryGenerator_HotspotSlots final : public UEnvQueryGenerator
{
public:
	TSubclassOf<class UEnvQueryContext>           GenerateAround;                                    // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              Radius;                                            // 0x0058(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bUseTetherZone : 1;                                // 0x0088(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AFortAIHotSpot>             HotspotClass;                                      // 0x0090(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_HotspotSlots">();
	}
	static class UFortQueryGenerator_HotspotSlots* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_HotspotSlots>();
	}
};
static_assert(alignof(UFortQueryGenerator_HotspotSlots) == 0x000008, "Wrong alignment on UFortQueryGenerator_HotspotSlots");
static_assert(sizeof(UFortQueryGenerator_HotspotSlots) == 0x000098, "Wrong size on UFortQueryGenerator_HotspotSlots");
static_assert(offsetof(UFortQueryGenerator_HotspotSlots, GenerateAround) == 0x000050, "Member 'UFortQueryGenerator_HotspotSlots::GenerateAround' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_HotspotSlots, Radius) == 0x000058, "Member 'UFortQueryGenerator_HotspotSlots::Radius' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_HotspotSlots, HotspotClass) == 0x000090, "Member 'UFortQueryGenerator_HotspotSlots::HotspotClass' has a wrong offset!");

// Class FortniteGame.OutpostPOSTRequirementData
// 0x0020 (0x0048 - 0x0028)
class UOutpostPOSTRequirementData final : public UObject
{
public:
	class UFortItemDefinition*                    RequirementItemDefinition;                         // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalRequired;                                     // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AlreadyDeposited;                                  // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AmountOwned;                                       // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasEnough;                                        // 0x003C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AmountToDeposit;                                   // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OutpostPOSTRequirementData">();
	}
	static class UOutpostPOSTRequirementData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOutpostPOSTRequirementData>();
	}
};
static_assert(alignof(UOutpostPOSTRequirementData) == 0x000008, "Wrong alignment on UOutpostPOSTRequirementData");
static_assert(sizeof(UOutpostPOSTRequirementData) == 0x000048, "Wrong size on UOutpostPOSTRequirementData");
static_assert(offsetof(UOutpostPOSTRequirementData, RequirementItemDefinition) == 0x000028, "Member 'UOutpostPOSTRequirementData::RequirementItemDefinition' has a wrong offset!");
static_assert(offsetof(UOutpostPOSTRequirementData, TotalRequired) == 0x000030, "Member 'UOutpostPOSTRequirementData::TotalRequired' has a wrong offset!");
static_assert(offsetof(UOutpostPOSTRequirementData, AlreadyDeposited) == 0x000034, "Member 'UOutpostPOSTRequirementData::AlreadyDeposited' has a wrong offset!");
static_assert(offsetof(UOutpostPOSTRequirementData, AmountOwned) == 0x000038, "Member 'UOutpostPOSTRequirementData::AmountOwned' has a wrong offset!");
static_assert(offsetof(UOutpostPOSTRequirementData, bHasEnough) == 0x00003C, "Member 'UOutpostPOSTRequirementData::bHasEnough' has a wrong offset!");
static_assert(offsetof(UOutpostPOSTRequirementData, AmountToDeposit) == 0x000040, "Member 'UOutpostPOSTRequirementData::AmountToDeposit' has a wrong offset!");

// Class FortniteGame.AIHotSpotManagerProxy
// 0x0058 (0x0080 - 0x0028)
class UAIHotSpotManagerProxy : public UAIHotSpotManager
{
public:
	uint8                                         Pad_28[0x58];                                      // 0x0028(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIHotSpotManagerProxy">();
	}
	static class UAIHotSpotManagerProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIHotSpotManagerProxy>();
	}
};
static_assert(alignof(UAIHotSpotManagerProxy) == 0x000008, "Wrong alignment on UAIHotSpotManagerProxy");
static_assert(sizeof(UAIHotSpotManagerProxy) == 0x000080, "Wrong size on UAIHotSpotManagerProxy");

// Class FortniteGame.FortScriptedAction
// 0x0060 (0x03E8 - 0x0388)
class AFortScriptedAction : public AActor
{
public:
	uint8                                         Pad_388[0x8];                                      // 0x0388(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EFortScriptedActionEnvironment                ActionEnvironment;                                 // 0x0390(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_391[0x7];                                      // 0x0391(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortClientEventName                   ClientEventTrigger;                                // 0x0398(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ActionPriority;                                    // 0x03A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3AC[0x4];                                      // 0x03AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortScriptedActionParams              CachedParams;                                      // 0x03B0(0x0030)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsActive;                                         // 0x03E0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E1[0x7];                                      // 0x03E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelAction(bool bRegisterActionAgain);
	void CompleteAction(bool bRegisterActionAgain);
	void Execute(const struct FFortScriptedActionParams& Params_0);
	void GetParams(struct FFortScriptedActionParams* Params_0);

	bool CanExecute(const struct FFortScriptedActionParams& Params_0) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortScriptedAction">();
	}
	static class AFortScriptedAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortScriptedAction>();
	}
};
static_assert(alignof(AFortScriptedAction) == 0x000008, "Wrong alignment on AFortScriptedAction");
static_assert(sizeof(AFortScriptedAction) == 0x0003E8, "Wrong size on AFortScriptedAction");
static_assert(offsetof(AFortScriptedAction, ActionEnvironment) == 0x000390, "Member 'AFortScriptedAction::ActionEnvironment' has a wrong offset!");
static_assert(offsetof(AFortScriptedAction, ClientEventTrigger) == 0x000398, "Member 'AFortScriptedAction::ClientEventTrigger' has a wrong offset!");
static_assert(offsetof(AFortScriptedAction, ActionPriority) == 0x0003A8, "Member 'AFortScriptedAction::ActionPriority' has a wrong offset!");
static_assert(offsetof(AFortScriptedAction, CachedParams) == 0x0003B0, "Member 'AFortScriptedAction::CachedParams' has a wrong offset!");
static_assert(offsetof(AFortScriptedAction, bIsActive) == 0x0003E0, "Member 'AFortScriptedAction::bIsActive' has a wrong offset!");

// Class FortniteGame.FortCharacterAttrSet
// 0x00A0 (0x00D0 - 0x0030)
class UFortCharacterAttrSet : public UFortAttributeSet
{
public:
	struct FFortGameplayAttributeData             Fortitude;                                         // 0x0030(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             Offense;                                           // 0x0050(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             Tech;                                              // 0x0070(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             Resistance;                                        // 0x0090(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             MaxCharacterLevel;                                 // 0x00B0(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)

public:
	void OnRep_Fortitude();
	void OnRep_MaxCharacterLevel();
	void OnRep_Offense();
	void OnRep_Resistance();
	void OnRep_Tech();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCharacterAttrSet">();
	}
	static class UFortCharacterAttrSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCharacterAttrSet>();
	}
};
static_assert(alignof(UFortCharacterAttrSet) == 0x000008, "Wrong alignment on UFortCharacterAttrSet");
static_assert(sizeof(UFortCharacterAttrSet) == 0x0000D0, "Wrong size on UFortCharacterAttrSet");
static_assert(offsetof(UFortCharacterAttrSet, Fortitude) == 0x000030, "Member 'UFortCharacterAttrSet::Fortitude' has a wrong offset!");
static_assert(offsetof(UFortCharacterAttrSet, Offense) == 0x000050, "Member 'UFortCharacterAttrSet::Offense' has a wrong offset!");
static_assert(offsetof(UFortCharacterAttrSet, Tech) == 0x000070, "Member 'UFortCharacterAttrSet::Tech' has a wrong offset!");
static_assert(offsetof(UFortCharacterAttrSet, Resistance) == 0x000090, "Member 'UFortCharacterAttrSet::Resistance' has a wrong offset!");
static_assert(offsetof(UFortCharacterAttrSet, MaxCharacterLevel) == 0x0000B0, "Member 'UFortCharacterAttrSet::MaxCharacterLevel' has a wrong offset!");

// Class FortniteGame.FortAIHotSpotSlot
// 0x0010 (0x00D0 - 0x00C0)
class UFortAIHotSpotSlot final : public UAIHotSpotSlot
{
public:
	EFortHotSpotSlot                              SlotType;                                          // 0x00C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bHasProjectedLocation : 1;                         // 0x00C4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bProjectedOnLowArea : 1;                           // 0x00C4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsAutoGenerated : 1;                              // 0x00C4(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanDuplicateOnProjection : 1;                     // 0x00C4(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanProjectUp : 1;                                 // 0x00C4(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C5[0xB];                                       // 0x00C5(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIHotSpotSlot">();
	}
	static class UFortAIHotSpotSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIHotSpotSlot>();
	}
};
static_assert(alignof(UFortAIHotSpotSlot) == 0x000010, "Wrong alignment on UFortAIHotSpotSlot");
static_assert(sizeof(UFortAIHotSpotSlot) == 0x0000D0, "Wrong size on UFortAIHotSpotSlot");
static_assert(offsetof(UFortAIHotSpotSlot, SlotType) == 0x0000C0, "Member 'UFortAIHotSpotSlot::SlotType' has a wrong offset!");

// Class FortniteGame.FortQueryGenerator_PointsOnBuildingGrid
// 0x0070 (0x00F0 - 0x0080)
class UFortQueryGenerator_PointsOnBuildingGrid final : public UEnvQueryGenerator_ProjectedPoints
{
public:
	struct FAIDataProviderIntValue                HorizontalGridSize;                                // 0x0080(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderIntValue                VerticalGridSize;                                  // 0x00B0(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bStartGridFromBottom;                              // 0x00E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePointInVerticalCenterOfCell;                   // 0x00E1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E2[0x6];                                       // 0x00E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UEnvQueryContext>           GenerateAround;                                    // 0x00E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_PointsOnBuildingGrid">();
	}
	static class UFortQueryGenerator_PointsOnBuildingGrid* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_PointsOnBuildingGrid>();
	}
};
static_assert(alignof(UFortQueryGenerator_PointsOnBuildingGrid) == 0x000008, "Wrong alignment on UFortQueryGenerator_PointsOnBuildingGrid");
static_assert(sizeof(UFortQueryGenerator_PointsOnBuildingGrid) == 0x0000F0, "Wrong size on UFortQueryGenerator_PointsOnBuildingGrid");
static_assert(offsetof(UFortQueryGenerator_PointsOnBuildingGrid, HorizontalGridSize) == 0x000080, "Member 'UFortQueryGenerator_PointsOnBuildingGrid::HorizontalGridSize' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsOnBuildingGrid, VerticalGridSize) == 0x0000B0, "Member 'UFortQueryGenerator_PointsOnBuildingGrid::VerticalGridSize' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsOnBuildingGrid, bStartGridFromBottom) == 0x0000E0, "Member 'UFortQueryGenerator_PointsOnBuildingGrid::bStartGridFromBottom' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsOnBuildingGrid, bUsePointInVerticalCenterOfCell) == 0x0000E1, "Member 'UFortQueryGenerator_PointsOnBuildingGrid::bUsePointInVerticalCenterOfCell' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsOnBuildingGrid, GenerateAround) == 0x0000E8, "Member 'UFortQueryGenerator_PointsOnBuildingGrid::GenerateAround' has a wrong offset!");

// Class FortniteGame.FortGamepadSettings
// 0x0108 (0x0130 - 0x0028)
class UFortGamepadSettings final : public UDataAsset
{
public:
	class UCurveFloat*                            GamepadLookYawCurve;                               // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            GamepadLookPitchCurve;                             // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            GamepadLookSensitivityCurve;                       // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              GamepadLookScale;                                  // 0x0040(0x0008)(Edit, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GamepadLookScaleDownsights;                        // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GamepadLookScaleScope;                             // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GamepadLookScaleEditMode;                          // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GamepadLookScaleDownsightsDecayTime;               // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimAssistStrength;                                 // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimAssistStrengthDownsights;                       // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              GamepadLookAccelTime;                              // 0x0060(0x0008)(Edit, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              GamepadEditModeLookAccelTime;                      // 0x0068(0x0008)(Edit, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              GamepadLookDecelTime;                              // 0x0070(0x0008)(Edit, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimAssistPullStrength;                             // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimAssistPullMaxRate;                              // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimAssistPullRampUpTime;                           // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimAssistPullDecayTime;                            // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimAssistInitialDownsightStrength;                 // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimAssistInitialDownsightTime;                     // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlowMinDistance;                                   // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlowMinStrength;                                   // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlowMaxDistance;                                   // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlowMaxStrength;                                   // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlowDecayTime;                                     // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EditModePullStrengthStationary;                    // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EditModePullStrengthMovingNewTile;                 // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EditModePullStrengthMovingWithinTile;              // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EditModePullMinDistance;                           // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EditModePullMaxDistance;                           // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EditModePullScaleFlat;                             // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EditModePullMaxRate;                               // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EditModeSlowMinDistance;                           // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EditModeSlowMinStrength;                           // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EditModeSlowMaxDistance;                           // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EditModeSlowMaxStrength;                           // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFortAbilityTargetSelection            AimAssistTargetSelection;                          // 0x00D0(0x0060)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGamepadSettings">();
	}
	static class UFortGamepadSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGamepadSettings>();
	}
};
static_assert(alignof(UFortGamepadSettings) == 0x000008, "Wrong alignment on UFortGamepadSettings");
static_assert(sizeof(UFortGamepadSettings) == 0x000130, "Wrong size on UFortGamepadSettings");
static_assert(offsetof(UFortGamepadSettings, GamepadLookYawCurve) == 0x000028, "Member 'UFortGamepadSettings::GamepadLookYawCurve' has a wrong offset!");
static_assert(offsetof(UFortGamepadSettings, GamepadLookPitchCurve) == 0x000030, "Member 'UFortGamepadSettings::GamepadLookPitchCurve' has a wrong offset!");
static_assert(offsetof(UFortGamepadSettings, GamepadLookSensitivityCurve) == 0x000038, "Member 'UFortGamepadSettings::GamepadLookSensitivityCurve' has a wrong offset!");
static_assert(offsetof(UFortGamepadSettings, GamepadLookScale) == 0x000040, "Member 'UFortGamepadSettings::GamepadLookScale' has a wrong offset!");
static_assert(offsetof(UFortGamepadSettings, GamepadLookScaleDownsights) == 0x000048, "Member 'UFortGamepadSettings::GamepadLookScaleDownsights' has a wrong offset!");
static_assert(offsetof(UFortGamepadSettings, GamepadLookScaleScope) == 0x00004C, "Member 'UFortGamepadSettings::GamepadLookScaleScope' has a wrong offset!");
static_assert(offsetof(UFortGamepadSettings, GamepadLookScaleEditMode) == 0x000050, "Member 'UFortGamepadSettings::GamepadLookScaleEditMode' has a wrong offset!");
static_assert(offsetof(UFortGamepadSettings, GamepadLookScaleDownsightsDecayTime) == 0x000054, "Member 'UFortGamepadSettings::GamepadLookScaleDownsightsDecayTime' has a wrong offset!");
static_assert(offsetof(UFortGamepadSettings, AimAssistStrength) == 0x000058, "Member 'UFortGamepadSettings::AimAssistStrength' has a wrong offset!");
static_assert(offsetof(UFortGamepadSettings, AimAssistStrengthDownsights) == 0x00005C, "Member 'UFortGamepadSettings::AimAssistStrengthDownsights' has a wrong offset!");
static_assert(offsetof(UFortGamepadSettings, GamepadLookAccelTime) == 0x000060, "Member 'UFortGamepadSettings::GamepadLookAccelTime' has a wrong offset!");
static_assert(offsetof(UFortGamepadSettings, GamepadEditModeLookAccelTime) == 0x000068, "Member 'UFortGamepadSettings::GamepadEditModeLookAccelTime' has a wrong offset!");
static_assert(offsetof(UFortGamepadSettings, GamepadLookDecelTime) == 0x000070, "Member 'UFortGamepadSettings::GamepadLookDecelTime' has a wrong offset!");
static_assert(offsetof(UFortGamepadSettings, AimAssistPullStrength) == 0x000078, "Member 'UFortGamepadSettings::AimAssistPullStrength' has a wrong offset!");
static_assert(offsetof(UFortGamepadSettings, AimAssistPullMaxRate) == 0x00007C, "Member 'UFortGamepadSettings::AimAssistPullMaxRate' has a wrong offset!");
static_assert(offsetof(UFortGamepadSettings, AimAssistPullRampUpTime) == 0x000080, "Member 'UFortGamepadSettings::AimAssistPullRampUpTime' has a wrong offset!");
static_assert(offsetof(UFortGamepadSettings, AimAssistPullDecayTime) == 0x000084, "Member 'UFortGamepadSettings::AimAssistPullDecayTime' has a wrong offset!");
static_assert(offsetof(UFortGamepadSettings, AimAssistInitialDownsightStrength) == 0x000088, "Member 'UFortGamepadSettings::AimAssistInitialDownsightStrength' has a wrong offset!");
static_assert(offsetof(UFortGamepadSettings, AimAssistInitialDownsightTime) == 0x00008C, "Member 'UFortGamepadSettings::AimAssistInitialDownsightTime' has a wrong offset!");
static_assert(offsetof(UFortGamepadSettings, SlowMinDistance) == 0x000090, "Member 'UFortGamepadSettings::SlowMinDistance' has a wrong offset!");
static_assert(offsetof(UFortGamepadSettings, SlowMinStrength) == 0x000094, "Member 'UFortGamepadSettings::SlowMinStrength' has a wrong offset!");
static_assert(offsetof(UFortGamepadSettings, SlowMaxDistance) == 0x000098, "Member 'UFortGamepadSettings::SlowMaxDistance' has a wrong offset!");
static_assert(offsetof(UFortGamepadSettings, SlowMaxStrength) == 0x00009C, "Member 'UFortGamepadSettings::SlowMaxStrength' has a wrong offset!");
static_assert(offsetof(UFortGamepadSettings, SlowDecayTime) == 0x0000A0, "Member 'UFortGamepadSettings::SlowDecayTime' has a wrong offset!");
static_assert(offsetof(UFortGamepadSettings, EditModePullStrengthStationary) == 0x0000A4, "Member 'UFortGamepadSettings::EditModePullStrengthStationary' has a wrong offset!");
static_assert(offsetof(UFortGamepadSettings, EditModePullStrengthMovingNewTile) == 0x0000A8, "Member 'UFortGamepadSettings::EditModePullStrengthMovingNewTile' has a wrong offset!");
static_assert(offsetof(UFortGamepadSettings, EditModePullStrengthMovingWithinTile) == 0x0000AC, "Member 'UFortGamepadSettings::EditModePullStrengthMovingWithinTile' has a wrong offset!");
static_assert(offsetof(UFortGamepadSettings, EditModePullMinDistance) == 0x0000B0, "Member 'UFortGamepadSettings::EditModePullMinDistance' has a wrong offset!");
static_assert(offsetof(UFortGamepadSettings, EditModePullMaxDistance) == 0x0000B4, "Member 'UFortGamepadSettings::EditModePullMaxDistance' has a wrong offset!");
static_assert(offsetof(UFortGamepadSettings, EditModePullScaleFlat) == 0x0000B8, "Member 'UFortGamepadSettings::EditModePullScaleFlat' has a wrong offset!");
static_assert(offsetof(UFortGamepadSettings, EditModePullMaxRate) == 0x0000BC, "Member 'UFortGamepadSettings::EditModePullMaxRate' has a wrong offset!");
static_assert(offsetof(UFortGamepadSettings, EditModeSlowMinDistance) == 0x0000C0, "Member 'UFortGamepadSettings::EditModeSlowMinDistance' has a wrong offset!");
static_assert(offsetof(UFortGamepadSettings, EditModeSlowMinStrength) == 0x0000C4, "Member 'UFortGamepadSettings::EditModeSlowMinStrength' has a wrong offset!");
static_assert(offsetof(UFortGamepadSettings, EditModeSlowMaxDistance) == 0x0000C8, "Member 'UFortGamepadSettings::EditModeSlowMaxDistance' has a wrong offset!");
static_assert(offsetof(UFortGamepadSettings, EditModeSlowMaxStrength) == 0x0000CC, "Member 'UFortGamepadSettings::EditModeSlowMaxStrength' has a wrong offset!");
static_assert(offsetof(UFortGamepadSettings, AimAssistTargetSelection) == 0x0000D0, "Member 'UFortGamepadSettings::AimAssistTargetSelection' has a wrong offset!");

// Class FortniteGame.FortBrushSizeFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UFortBrushSizeFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static EFortBrushSize GrowBrushSize(const EFortBrushSize OriginalBrushSize, const int32 Steps);
	static EFortBrushSize ShrinkBrushSize(const EFortBrushSize OriginalBrushSize, const int32 Steps);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBrushSizeFunctionLibrary">();
	}
	static class UFortBrushSizeFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBrushSizeFunctionLibrary>();
	}
};
static_assert(alignof(UFortBrushSizeFunctionLibrary) == 0x000008, "Wrong alignment on UFortBrushSizeFunctionLibrary");
static_assert(sizeof(UFortBrushSizeFunctionLibrary) == 0x000028, "Wrong size on UFortBrushSizeFunctionLibrary");

// Class FortniteGame.FortAIHotSpotSlotGenerator_OnBoundingBox
// 0x0008 (0x0078 - 0x0070)
class UFortAIHotSpotSlotGenerator_OnBoundingBox final : public UAIHotSpotSlotGenerator_OnBoundingBox
{
public:
	float                                         DistanceForRangedSlots;                            // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceForHugeSlots;                              // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIHotSpotSlotGenerator_OnBoundingBox">();
	}
	static class UFortAIHotSpotSlotGenerator_OnBoundingBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIHotSpotSlotGenerator_OnBoundingBox>();
	}
};
static_assert(alignof(UFortAIHotSpotSlotGenerator_OnBoundingBox) == 0x000008, "Wrong alignment on UFortAIHotSpotSlotGenerator_OnBoundingBox");
static_assert(sizeof(UFortAIHotSpotSlotGenerator_OnBoundingBox) == 0x000078, "Wrong size on UFortAIHotSpotSlotGenerator_OnBoundingBox");
static_assert(offsetof(UFortAIHotSpotSlotGenerator_OnBoundingBox, DistanceForRangedSlots) == 0x000070, "Member 'UFortAIHotSpotSlotGenerator_OnBoundingBox::DistanceForRangedSlots' has a wrong offset!");
static_assert(offsetof(UFortAIHotSpotSlotGenerator_OnBoundingBox, DistanceForHugeSlots) == 0x000074, "Member 'UFortAIHotSpotSlotGenerator_OnBoundingBox::DistanceForHugeSlots' has a wrong offset!");

// Class FortniteGame.BuildingActorHotSpotConfig
// 0x00F0 (0x0118 - 0x0028)
class UBuildingActorHotSpotConfig final : public UDataAsset
{
public:
	struct FBuildingActorHotSpotDirection         DirectionSetup[0x6];                               // 0x0028(0x0020)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FBuildingActorHotSpotDirection         DefaultSetup;                                      // 0x00E8(0x0020)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UAIHotSpotConfig*                       ExtraTypeConfig;                                   // 0x0108(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bHasDirectionalSetup : 1;                          // 0x0110(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingActorHotSpotConfig">();
	}
	static class UBuildingActorHotSpotConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingActorHotSpotConfig>();
	}
};
static_assert(alignof(UBuildingActorHotSpotConfig) == 0x000008, "Wrong alignment on UBuildingActorHotSpotConfig");
static_assert(sizeof(UBuildingActorHotSpotConfig) == 0x000118, "Wrong size on UBuildingActorHotSpotConfig");
static_assert(offsetof(UBuildingActorHotSpotConfig, DirectionSetup) == 0x000028, "Member 'UBuildingActorHotSpotConfig::DirectionSetup' has a wrong offset!");
static_assert(offsetof(UBuildingActorHotSpotConfig, DefaultSetup) == 0x0000E8, "Member 'UBuildingActorHotSpotConfig::DefaultSetup' has a wrong offset!");
static_assert(offsetof(UBuildingActorHotSpotConfig, ExtraTypeConfig) == 0x000108, "Member 'UBuildingActorHotSpotConfig::ExtraTypeConfig' has a wrong offset!");

// Class FortniteGame.FortAsyncAction_MCPContextRecycleItems
// 0x0028 (0x0050 - 0x0028)
class UFortAsyncAction_MCPContextRecycleItems final : public UBlueprintAsyncActionBase
{
public:
	UMulticastDelegateProperty_                   OnMCPRequestComplete;                              // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UFortMcpContext>         MCPContext;                                        // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class UFortItem>>       ItemsToRecycle;                                    // 0x0040(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UFortAsyncAction_MCPContextRecycleItems* RecycleItems(const class UFortMcpContext* MCPContext_0, const TArray<class UFortItem*>& ItemsToRecycle_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAsyncAction_MCPContextRecycleItems">();
	}
	static class UFortAsyncAction_MCPContextRecycleItems* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAsyncAction_MCPContextRecycleItems>();
	}
};
static_assert(alignof(UFortAsyncAction_MCPContextRecycleItems) == 0x000008, "Wrong alignment on UFortAsyncAction_MCPContextRecycleItems");
static_assert(sizeof(UFortAsyncAction_MCPContextRecycleItems) == 0x000050, "Wrong size on UFortAsyncAction_MCPContextRecycleItems");
static_assert(offsetof(UFortAsyncAction_MCPContextRecycleItems, OnMCPRequestComplete) == 0x000028, "Member 'UFortAsyncAction_MCPContextRecycleItems::OnMCPRequestComplete' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_MCPContextRecycleItems, MCPContext) == 0x000038, "Member 'UFortAsyncAction_MCPContextRecycleItems::MCPContext' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_MCPContextRecycleItems, ItemsToRecycle) == 0x000040, "Member 'UFortAsyncAction_MCPContextRecycleItems::ItemsToRecycle' has a wrong offset!");

// Class FortniteGame.FortRiftBlockerComponent
// 0x0010 (0x06B0 - 0x06A0)
class UFortRiftBlockerComponent final : public UBoxComponent
{
public:
	uint8                                         bStartActive : 1;                                  // 0x06A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_6A1[0xF];                                      // 0x06A1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortRiftBlockerComponent">();
	}
	static class UFortRiftBlockerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortRiftBlockerComponent>();
	}
};
static_assert(alignof(UFortRiftBlockerComponent) == 0x000010, "Wrong alignment on UFortRiftBlockerComponent");
static_assert(sizeof(UFortRiftBlockerComponent) == 0x0006B0, "Wrong size on UFortRiftBlockerComponent");

// Class FortniteGame.FortAIHotSpotManager
// 0x0140 (0x01C0 - 0x0080)
class UFortAIHotSpotManager final : public UAIHotSpotManagerProxy
{
public:
	TSoftObjectPtr<class UBuildingActorHotSpotConfig> FallbackHotspotConfig;                             // 0x0080(0x0020)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0xF0];                                      // 0x00A0(0x00F0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAutoAcquireSlot>               AutoAcquireSlots;                                  // 0x0190(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A0[0x20];                                     // 0x01A0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIHotSpotManager">();
	}
	static class UFortAIHotSpotManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIHotSpotManager>();
	}
};
static_assert(alignof(UFortAIHotSpotManager) == 0x000008, "Wrong alignment on UFortAIHotSpotManager");
static_assert(sizeof(UFortAIHotSpotManager) == 0x0001C0, "Wrong size on UFortAIHotSpotManager");
static_assert(offsetof(UFortAIHotSpotManager, FallbackHotspotConfig) == 0x000080, "Member 'UFortAIHotSpotManager::FallbackHotspotConfig' has a wrong offset!");
static_assert(offsetof(UFortAIHotSpotManager, AutoAcquireSlots) == 0x000190, "Member 'UFortAIHotSpotManager::AutoAcquireSlots' has a wrong offset!");

// Class FortniteGame.FortMcpProfile
// 0x0030 (0x02E0 - 0x02B0)
class UFortMcpProfile : public UMcpProfile
{
public:
	uint8                                         Pad_2B0[0x30];                                     // 0x02B0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMcpProfile">();
	}
	static class UFortMcpProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMcpProfile>();
	}
};
static_assert(alignof(UFortMcpProfile) == 0x000008, "Wrong alignment on UFortMcpProfile");
static_assert(sizeof(UFortMcpProfile) == 0x0002E0, "Wrong size on UFortMcpProfile");

// Class FortniteGame.FortMcpProfileCollectionBook
// 0x0000 (0x02E0 - 0x02E0)
class UFortMcpProfileCollectionBook final : public UFortMcpProfile
{
public:
	void ClaimCollectionBookPageRewards(const class FString& PageTemplateId, const class FString& SectionId, int32 SelectedRewardIndex, struct FClientUrlContext* Context);
	void ConvertSlottedItem(const class FString& TargetItemId, int32 ConversionIndex, struct FClientUrlContext* Context);
	void UpgradeSlottedItem(const class FString& TargetItemId, struct FClientUrlContext* Context);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMcpProfileCollectionBook">();
	}
	static class UFortMcpProfileCollectionBook* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMcpProfileCollectionBook>();
	}
};
static_assert(alignof(UFortMcpProfileCollectionBook) == 0x000008, "Wrong alignment on UFortMcpProfileCollectionBook");
static_assert(sizeof(UFortMcpProfileCollectionBook) == 0x0002E0, "Wrong size on UFortMcpProfileCollectionBook");

// Class FortniteGame.FortDifficultyOptionEncounter_ModifierTags
// 0x0020 (0x0068 - 0x0048)
class UFortDifficultyOptionEncounter_ModifierTags final : public UFortDifficultyOptionEncounter
{
public:
	struct FGameplayTagContainer                  ModifierTags;                                      // 0x0048(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionEncounter_ModifierTags">();
	}
	static class UFortDifficultyOptionEncounter_ModifierTags* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionEncounter_ModifierTags>();
	}
};
static_assert(alignof(UFortDifficultyOptionEncounter_ModifierTags) == 0x000008, "Wrong alignment on UFortDifficultyOptionEncounter_ModifierTags");
static_assert(sizeof(UFortDifficultyOptionEncounter_ModifierTags) == 0x000068, "Wrong size on UFortDifficultyOptionEncounter_ModifierTags");
static_assert(offsetof(UFortDifficultyOptionEncounter_ModifierTags, ModifierTags) == 0x000048, "Member 'UFortDifficultyOptionEncounter_ModifierTags::ModifierTags' has a wrong offset!");

// Class FortniteGame.FortSaveFileBuildingInstructionsHandler
// 0x02F0 (0x0678 - 0x0388)
#pragma pack(push, 0x1)
class alignas(0x08) AFortSaveFileBuildingInstructionsHandler : public AActor
{
public:
	class FString                                 SaveFilename;                                      // 0x0388(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LoadedBuildingsScale;                              // 0x0398(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LoadedBuildingsAdditionalTranslation;              // 0x03A4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseAbsoluteCoordinates : 1;                       // 0x03B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTrackDestroyedBuildings : 1;                      // 0x03B0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3B1[0x7];                                      // 0x03B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UFortBuildingInstructions> DefaultBuildingInstructions;                       // 0x03B8(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bLoadInvisible : 1;                                // 0x03D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDespawnOnBuildingsSpawned : 1;                    // 0x03D8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSpawnBuildingsAutomaticallyAfterLoad : 1;         // 0x03D8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3D9[0x207];                                    // 0x03D9(0x0207)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUniqueNetIdRepl                       OperationUserId;                                   // 0x05E0(0x0018)(Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F8[0x80];                                     // 0x05F8(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AreBuildingsLoaded();
	void LoadBuildings(class AFortPlayerController* FortPC);
	bool ResetBuildings();
	bool SaveBuildings(class AFortPlayerController* FortPC);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortSaveFileBuildingInstructionsHandler">();
	}
	static class AFortSaveFileBuildingInstructionsHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortSaveFileBuildingInstructionsHandler>();
	}
};
#pragma pack(pop)
static_assert(alignof(AFortSaveFileBuildingInstructionsHandler) == 0x000008, "Wrong alignment on AFortSaveFileBuildingInstructionsHandler");
static_assert(sizeof(AFortSaveFileBuildingInstructionsHandler) == 0x000678, "Wrong size on AFortSaveFileBuildingInstructionsHandler");
static_assert(offsetof(AFortSaveFileBuildingInstructionsHandler, SaveFilename) == 0x000388, "Member 'AFortSaveFileBuildingInstructionsHandler::SaveFilename' has a wrong offset!");
static_assert(offsetof(AFortSaveFileBuildingInstructionsHandler, LoadedBuildingsScale) == 0x000398, "Member 'AFortSaveFileBuildingInstructionsHandler::LoadedBuildingsScale' has a wrong offset!");
static_assert(offsetof(AFortSaveFileBuildingInstructionsHandler, LoadedBuildingsAdditionalTranslation) == 0x0003A4, "Member 'AFortSaveFileBuildingInstructionsHandler::LoadedBuildingsAdditionalTranslation' has a wrong offset!");
static_assert(offsetof(AFortSaveFileBuildingInstructionsHandler, DefaultBuildingInstructions) == 0x0003B8, "Member 'AFortSaveFileBuildingInstructionsHandler::DefaultBuildingInstructions' has a wrong offset!");
static_assert(offsetof(AFortSaveFileBuildingInstructionsHandler, OperationUserId) == 0x0005E0, "Member 'AFortSaveFileBuildingInstructionsHandler::OperationUserId' has a wrong offset!");

// Class FortniteGame.FOBSaveFileBuildingInstructionsHandler
// 0x0008 (0x0680 - 0x0678)
class AFOBSaveFileBuildingInstructionsHandler final : public AFortSaveFileBuildingInstructionsHandler
{
public:
	float                                         BuildingPieceConstructionTime;                     // 0x0678(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_67C[0x4];                                      // 0x067C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FOBSaveFileBuildingInstructionsHandler">();
	}
	static class AFOBSaveFileBuildingInstructionsHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFOBSaveFileBuildingInstructionsHandler>();
	}
};
static_assert(alignof(AFOBSaveFileBuildingInstructionsHandler) == 0x000008, "Wrong alignment on AFOBSaveFileBuildingInstructionsHandler");
static_assert(sizeof(AFOBSaveFileBuildingInstructionsHandler) == 0x000680, "Wrong size on AFOBSaveFileBuildingInstructionsHandler");
static_assert(offsetof(AFOBSaveFileBuildingInstructionsHandler, BuildingPieceConstructionTime) == 0x000678, "Member 'AFOBSaveFileBuildingInstructionsHandler::BuildingPieceConstructionTime' has a wrong offset!");

// Class FortniteGame.FortMissionConfigData
// 0x0000 (0x0028 - 0x0028)
class UFortMissionConfigData : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMissionConfigData">();
	}
	static class UFortMissionConfigData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMissionConfigData>();
	}
};
static_assert(alignof(UFortMissionConfigData) == 0x000008, "Wrong alignment on UFortMissionConfigData");
static_assert(sizeof(UFortMissionConfigData) == 0x000028, "Wrong size on UFortMissionConfigData");

// Class FortniteGame.FortMissionEventParams
// 0x0000 (0x0028 - 0x0028)
class UFortMissionEventParams : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMissionEventParams">();
	}
	static class UFortMissionEventParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMissionEventParams>();
	}
};
static_assert(alignof(UFortMissionEventParams) == 0x000008, "Wrong alignment on UFortMissionEventParams");
static_assert(sizeof(UFortMissionEventParams) == 0x000028, "Wrong size on UFortMissionEventParams");

// Class FortniteGame.FortDifficultyOptionEncounter_SpawnGroupProgression
// 0x0008 (0x0050 - 0x0048)
class UFortDifficultyOptionEncounter_SpawnGroupProgression final : public UFortDifficultyOptionEncounter
{
public:
	class UFortAISpawnGroupProgressionInfo*       SpawnGroupProgression;                             // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionEncounter_SpawnGroupProgression">();
	}
	static class UFortDifficultyOptionEncounter_SpawnGroupProgression* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionEncounter_SpawnGroupProgression>();
	}
};
static_assert(alignof(UFortDifficultyOptionEncounter_SpawnGroupProgression) == 0x000008, "Wrong alignment on UFortDifficultyOptionEncounter_SpawnGroupProgression");
static_assert(sizeof(UFortDifficultyOptionEncounter_SpawnGroupProgression) == 0x000050, "Wrong size on UFortDifficultyOptionEncounter_SpawnGroupProgression");
static_assert(offsetof(UFortDifficultyOptionEncounter_SpawnGroupProgression, SpawnGroupProgression) == 0x000048, "Member 'UFortDifficultyOptionEncounter_SpawnGroupProgression::SpawnGroupProgression' has a wrong offset!");

// Class FortniteGame.FortStartMissionParams
// 0x0000 (0x0028 - 0x0028)
class UFortStartMissionParams final : public UFortMissionEventParams
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortStartMissionParams">();
	}
	static class UFortStartMissionParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortStartMissionParams>();
	}
};
static_assert(alignof(UFortStartMissionParams) == 0x000008, "Wrong alignment on UFortStartMissionParams");
static_assert(sizeof(UFortStartMissionParams) == 0x000028, "Wrong size on UFortStartMissionParams");

// Class FortniteGame.FortItemCollectedParams
// 0x0018 (0x0040 - 0x0028)
class UFortItemCollectedParams final : public UFortMissionEventParams
{
public:
	class UFortWorldItemDefinition*               CollectedItemDefinition;                           // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AFortPlayerController*                  CollectedBy;                                       // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AmountCollected;                                   // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BreakParams(class UFortWorldItemDefinition** _CollectedItemDefinition, class AFortPlayerController** _CollectedBy, int32* _AmountCollected);
	void SetParams(const class UFortWorldItemDefinition* _CollectedItemDefinition, class AFortPlayerController* _CollectedBy, int32 _AmountCollected, class UFortItemCollectedParams** ThisParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortItemCollectedParams">();
	}
	static class UFortItemCollectedParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortItemCollectedParams>();
	}
};
static_assert(alignof(UFortItemCollectedParams) == 0x000008, "Wrong alignment on UFortItemCollectedParams");
static_assert(sizeof(UFortItemCollectedParams) == 0x000040, "Wrong size on UFortItemCollectedParams");
static_assert(offsetof(UFortItemCollectedParams, CollectedItemDefinition) == 0x000028, "Member 'UFortItemCollectedParams::CollectedItemDefinition' has a wrong offset!");
static_assert(offsetof(UFortItemCollectedParams, CollectedBy) == 0x000030, "Member 'UFortItemCollectedParams::CollectedBy' has a wrong offset!");
static_assert(offsetof(UFortItemCollectedParams, AmountCollected) == 0x000038, "Member 'UFortItemCollectedParams::AmountCollected' has a wrong offset!");

// Class FortniteGame.FortNotificationHandler
// 0x0018 (0x0040 - 0x0028)
class UFortNotificationHandler : public UObject
{
public:
	UMulticastDelegateProperty_                   OnNotificationCleared;                             // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bNotificationCleared;                              // 0x0038(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearNotification();
	class UUserWidget* CreateWidget(class APlayerController* OwningPlayer);
	void NotificationShown();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNotificationHandler">();
	}
	static class UFortNotificationHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNotificationHandler>();
	}
};
static_assert(alignof(UFortNotificationHandler) == 0x000008, "Wrong alignment on UFortNotificationHandler");
static_assert(sizeof(UFortNotificationHandler) == 0x000040, "Wrong size on UFortNotificationHandler");
static_assert(offsetof(UFortNotificationHandler, OnNotificationCleared) == 0x000028, "Member 'UFortNotificationHandler::OnNotificationCleared' has a wrong offset!");
static_assert(offsetof(UFortNotificationHandler, bNotificationCleared) == 0x000038, "Member 'UFortNotificationHandler::bNotificationCleared' has a wrong offset!");

// Class FortniteGame.FortItemDroppedParams
// 0x0018 (0x0040 - 0x0028)
class UFortItemDroppedParams final : public UFortMissionEventParams
{
public:
	class UFortWorldItemDefinition*               DroppedItemDefinition;                             // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AFortPlayerController*                  DroppedBy;                                         // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AmountDropped;                                     // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BreakParams(class UFortWorldItemDefinition** _DroppedItemDefinition, class AFortPlayerController** _DroppedBy, int32* _AmountCollected);
	void SetParams(const class UFortWorldItemDefinition* _DroppedItemDefinition, class AFortPlayerController* _DroppedBy, int32 _AmountCollected, class UFortItemDroppedParams** ThisParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortItemDroppedParams">();
	}
	static class UFortItemDroppedParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortItemDroppedParams>();
	}
};
static_assert(alignof(UFortItemDroppedParams) == 0x000008, "Wrong alignment on UFortItemDroppedParams");
static_assert(sizeof(UFortItemDroppedParams) == 0x000040, "Wrong size on UFortItemDroppedParams");
static_assert(offsetof(UFortItemDroppedParams, DroppedItemDefinition) == 0x000028, "Member 'UFortItemDroppedParams::DroppedItemDefinition' has a wrong offset!");
static_assert(offsetof(UFortItemDroppedParams, DroppedBy) == 0x000030, "Member 'UFortItemDroppedParams::DroppedBy' has a wrong offset!");
static_assert(offsetof(UFortItemDroppedParams, AmountDropped) == 0x000038, "Member 'UFortItemDroppedParams::AmountDropped' has a wrong offset!");

// Class FortniteGame.FortItemCraftedParams
// 0x0018 (0x0040 - 0x0028)
class UFortItemCraftedParams final : public UFortMissionEventParams
{
public:
	class UFortSchematicItemDefinition*           SchematicDefinition;                               // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AFortPlayerController*                  CraftedBy;                                         // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AmountCrafted;                                     // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bItemWasQuickCrafted;                              // 0x003C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BreakParams(class UFortSchematicItemDefinition** _SchematicDefinition, class AFortPlayerController** _CraftedBy, int32* _AmountCrafted, bool* _bItemWasQuickCrafted);
	void SetParams(const class UFortSchematicItemDefinition* _SchematicDefinition, class AFortPlayerController* _CraftedBy, int32 _AmountCrafted, bool _bItemWasQuickCrafted, class UFortItemCraftedParams** ThisParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortItemCraftedParams">();
	}
	static class UFortItemCraftedParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortItemCraftedParams>();
	}
};
static_assert(alignof(UFortItemCraftedParams) == 0x000008, "Wrong alignment on UFortItemCraftedParams");
static_assert(sizeof(UFortItemCraftedParams) == 0x000040, "Wrong size on UFortItemCraftedParams");
static_assert(offsetof(UFortItemCraftedParams, SchematicDefinition) == 0x000028, "Member 'UFortItemCraftedParams::SchematicDefinition' has a wrong offset!");
static_assert(offsetof(UFortItemCraftedParams, CraftedBy) == 0x000030, "Member 'UFortItemCraftedParams::CraftedBy' has a wrong offset!");
static_assert(offsetof(UFortItemCraftedParams, AmountCrafted) == 0x000038, "Member 'UFortItemCraftedParams::AmountCrafted' has a wrong offset!");
static_assert(offsetof(UFortItemCraftedParams, bItemWasQuickCrafted) == 0x00003C, "Member 'UFortItemCraftedParams::bItemWasQuickCrafted' has a wrong offset!");

// Class FortniteGame.FortBotMissionLogic
// 0x0050 (0x0078 - 0x0028)
class UFortBotMissionLogic final : public UObject
{
public:
	class AFortMission*                           Mission;                                           // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         Goals;                                             // 0x0030(0x0010)(BlueprintVisible, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class AFortBotStructureBuilder*>       Builders;                                          // 0x0040(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class UBehaviorTree*                          CurrentBehaviorAsset;                              // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AFortBotController*>             AssignedAI;                                        // 0x0058(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<uint8>                                 GoalHasLocator;                                    // 0x0068(0x0010)(BlueprintVisible, ZeroConstructor, Transient, NativeAccessSpecifierPublic)

public:
	void ClearAllLocated();
	void MarkAllLocated();
	void MarkSingleLocator(const class AActor* LocatorActor);
	void OnAssignedBehavior(class AFortAIController* BotAI);
	bool OnCanStartOtherMission(class AFortAIController* BotAI, class AFortMission* OtherMission);
	bool OnInteractWithMissionGoal(class AFortAIController* BotAI, class AActor* MissionGoal);
	void OnMissionActivated();
	void OnMissionFinished();
	void OnMissionStarted();
	void ResetBehavior();
	void SetCurrentBehavior(class UBehaviorTree* Behavior);
	void SetGoalsInvulnerable(bool bGodMode);
	class AFortBotStructureBuilder* SpawnStructureBuilder(class AActor* MissionGoal, class UFortBuildingInstructions* BuildingInstructions);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBotMissionLogic">();
	}
	static class UFortBotMissionLogic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBotMissionLogic>();
	}
};
static_assert(alignof(UFortBotMissionLogic) == 0x000008, "Wrong alignment on UFortBotMissionLogic");
static_assert(sizeof(UFortBotMissionLogic) == 0x000078, "Wrong size on UFortBotMissionLogic");
static_assert(offsetof(UFortBotMissionLogic, Mission) == 0x000028, "Member 'UFortBotMissionLogic::Mission' has a wrong offset!");
static_assert(offsetof(UFortBotMissionLogic, Goals) == 0x000030, "Member 'UFortBotMissionLogic::Goals' has a wrong offset!");
static_assert(offsetof(UFortBotMissionLogic, Builders) == 0x000040, "Member 'UFortBotMissionLogic::Builders' has a wrong offset!");
static_assert(offsetof(UFortBotMissionLogic, CurrentBehaviorAsset) == 0x000050, "Member 'UFortBotMissionLogic::CurrentBehaviorAsset' has a wrong offset!");
static_assert(offsetof(UFortBotMissionLogic, AssignedAI) == 0x000058, "Member 'UFortBotMissionLogic::AssignedAI' has a wrong offset!");
static_assert(offsetof(UFortBotMissionLogic, GoalHasLocator) == 0x000068, "Member 'UFortBotMissionLogic::GoalHasLocator' has a wrong offset!");

// Class FortniteGame.FortServerBehaviorTrackerAthena
// 0x0080 (0x00A8 - 0x0028)
class UFortServerBehaviorTrackerAthena final : public UObject
{
public:
	class FString                                 PathToExperiment;                                  // 0x0028(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFortTrackedPlayerBehavior>     TrackedPlayers;                                    // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<class AFortPlayerControllerAthena*, int32> ControllerToIndexMap;                              // 0x0050(0x0050)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UFortServerBehaviorTrackerConfig*       Experiment;                                        // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortServerBehaviorTrackerAthena">();
	}
	static class UFortServerBehaviorTrackerAthena* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortServerBehaviorTrackerAthena>();
	}
};
static_assert(alignof(UFortServerBehaviorTrackerAthena) == 0x000008, "Wrong alignment on UFortServerBehaviorTrackerAthena");
static_assert(sizeof(UFortServerBehaviorTrackerAthena) == 0x0000A8, "Wrong size on UFortServerBehaviorTrackerAthena");
static_assert(offsetof(UFortServerBehaviorTrackerAthena, PathToExperiment) == 0x000028, "Member 'UFortServerBehaviorTrackerAthena::PathToExperiment' has a wrong offset!");
static_assert(offsetof(UFortServerBehaviorTrackerAthena, TrackedPlayers) == 0x000040, "Member 'UFortServerBehaviorTrackerAthena::TrackedPlayers' has a wrong offset!");
static_assert(offsetof(UFortServerBehaviorTrackerAthena, ControllerToIndexMap) == 0x000050, "Member 'UFortServerBehaviorTrackerAthena::ControllerToIndexMap' has a wrong offset!");
static_assert(offsetof(UFortServerBehaviorTrackerAthena, Experiment) == 0x0000A0, "Member 'UFortServerBehaviorTrackerAthena::Experiment' has a wrong offset!");

// Class FortniteGame.FortEnemyKilledParams
// 0x0010 (0x0038 - 0x0028)
class UFortEnemyKilledParams final : public UFortMissionEventParams
{
public:
	class AFortPawn*                              KilledPawn;                                        // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AFortPlayerController*                  KilledBy;                                          // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BreakParams(class AFortPawn** _KilledPawn, class AFortPlayerController** _KilledBy);
	void SetParams(class AFortPawn* _KilledPawn, class AFortPlayerController* _KilledBy, class UFortEnemyKilledParams** ThisParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortEnemyKilledParams">();
	}
	static class UFortEnemyKilledParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortEnemyKilledParams>();
	}
};
static_assert(alignof(UFortEnemyKilledParams) == 0x000008, "Wrong alignment on UFortEnemyKilledParams");
static_assert(sizeof(UFortEnemyKilledParams) == 0x000038, "Wrong size on UFortEnemyKilledParams");
static_assert(offsetof(UFortEnemyKilledParams, KilledPawn) == 0x000028, "Member 'UFortEnemyKilledParams::KilledPawn' has a wrong offset!");
static_assert(offsetof(UFortEnemyKilledParams, KilledBy) == 0x000030, "Member 'UFortEnemyKilledParams::KilledBy' has a wrong offset!");

// Class FortniteGame.FortEnemyDamagedParams
// 0x0018 (0x0040 - 0x0028)
class UFortEnemyDamagedParams final : public UFortMissionEventParams
{
public:
	class AFortPawn*                              DamagedPawn;                                       // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AFortPlayerController*                  DamagedBy;                                         // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageAmount;                                      // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BreakParams(class AFortPawn** _DamagedPawn, class AFortPlayerController** _DamagedBy, float* _DamageAmount);
	void SetParams(class AFortPawn* _DamagedPawn, class AFortPlayerController* _DamagedBy, float _DamageAmount, class UFortEnemyDamagedParams** ThisParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortEnemyDamagedParams">();
	}
	static class UFortEnemyDamagedParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortEnemyDamagedParams>();
	}
};
static_assert(alignof(UFortEnemyDamagedParams) == 0x000008, "Wrong alignment on UFortEnemyDamagedParams");
static_assert(sizeof(UFortEnemyDamagedParams) == 0x000040, "Wrong size on UFortEnemyDamagedParams");
static_assert(offsetof(UFortEnemyDamagedParams, DamagedPawn) == 0x000028, "Member 'UFortEnemyDamagedParams::DamagedPawn' has a wrong offset!");
static_assert(offsetof(UFortEnemyDamagedParams, DamagedBy) == 0x000030, "Member 'UFortEnemyDamagedParams::DamagedBy' has a wrong offset!");
static_assert(offsetof(UFortEnemyDamagedParams, DamageAmount) == 0x000038, "Member 'UFortEnemyDamagedParams::DamageAmount' has a wrong offset!");

// Class FortniteGame.FortMissionOutpostConfigData
// 0x0010 (0x0038 - 0x0028)
class UFortMissionOutpostConfigData final : public UFortMissionConfigData
{
public:
	struct FDataTableRowHandle                    DifficultyData;                                    // 0x0028(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMissionOutpostConfigData">();
	}
	static class UFortMissionOutpostConfigData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMissionOutpostConfigData>();
	}
};
static_assert(alignof(UFortMissionOutpostConfigData) == 0x000008, "Wrong alignment on UFortMissionOutpostConfigData");
static_assert(sizeof(UFortMissionOutpostConfigData) == 0x000038, "Wrong size on UFortMissionOutpostConfigData");
static_assert(offsetof(UFortMissionOutpostConfigData, DifficultyData) == 0x000028, "Member 'UFortMissionOutpostConfigData::DifficultyData' has a wrong offset!");

// Class FortniteGame.FortExpeditionAnalytics
// 0x0000 (0x0028 - 0x0028)
class UFortExpeditionAnalytics final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortExpeditionAnalytics">();
	}
	static class UFortExpeditionAnalytics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortExpeditionAnalytics>();
	}
};
static_assert(alignof(UFortExpeditionAnalytics) == 0x000008, "Wrong alignment on UFortExpeditionAnalytics");
static_assert(sizeof(UFortExpeditionAnalytics) == 0x000028, "Wrong size on UFortExpeditionAnalytics");

// Class FortniteGame.FortNewPlayerParams
// 0x0008 (0x0030 - 0x0028)
class UFortNewPlayerParams final : public UFortMissionEventParams
{
public:
	class AFortPlayerController*                  NewPlayerController;                               // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BreakParams(class AFortPlayerController** _NewPlayerController);
	void SetParams(class AFortPlayerController* _NewPlayerController, class UFortNewPlayerParams** ThisParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNewPlayerParams">();
	}
	static class UFortNewPlayerParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNewPlayerParams>();
	}
};
static_assert(alignof(UFortNewPlayerParams) == 0x000008, "Wrong alignment on UFortNewPlayerParams");
static_assert(sizeof(UFortNewPlayerParams) == 0x000030, "Wrong size on UFortNewPlayerParams");
static_assert(offsetof(UFortNewPlayerParams, NewPlayerController) == 0x000028, "Member 'UFortNewPlayerParams::NewPlayerController' has a wrong offset!");

// Class FortniteGame.FortPlayerAbandonParams
// 0x0018 (0x0040 - 0x0028)
class UFortPlayerAbandonParams final : public UFortMissionEventParams
{
public:
	struct FUniqueNetIdRepl                       AbandoningPlayerId;                                // 0x0028(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerAbandonParams">();
	}
	static class UFortPlayerAbandonParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPlayerAbandonParams>();
	}
};
static_assert(alignof(UFortPlayerAbandonParams) == 0x000008, "Wrong alignment on UFortPlayerAbandonParams");
static_assert(sizeof(UFortPlayerAbandonParams) == 0x000040, "Wrong size on UFortPlayerAbandonParams");
static_assert(offsetof(UFortPlayerAbandonParams, AbandoningPlayerId) == 0x000028, "Member 'UFortPlayerAbandonParams::AbandoningPlayerId' has a wrong offset!");

// Class FortniteGame.FortPlayerState
// 0x06A8 (0x0AC8 - 0x0420)
#pragma pack(push, 0x1)
class alignas(0x08) AFortPlayerState : public APlayerState
{
public:
	uint8                                         Pad_420[0x18];                                     // 0x0420(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bIsWorldDataOwner : 1;                             // 0x0438(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsGameSessionOwner : 1;                           // 0x0438(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Net, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_438_2 : 6;                                  // 0x0438(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         Pad_439[0xE7];                                     // 0x0439(0x00E7)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bIsGameSessionAdmin : 1;                           // 0x0520(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsReadyToContinue : 1;                            // 0x0520(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Net, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHasFinishedLoading : 1;                           // 0x0520(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHasStartedPlaying : 1;                            // 0x0520(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShowHeroBackpack : 1;                             // 0x0520(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Net, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShowHeroHeadAccessories : 1;                      // 0x0520(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Net, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_521[0x7];                                      // 0x0521(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUniqueNetIdRepl                       PartyOwnerUniqueId;                                // 0x0528(0x0018)(Net, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WorldPlayerId;                                     // 0x0540(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_544[0x4];                                      // 0x0544(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 HeroId;                                            // 0x0548(0x0010)(Net, ZeroConstructor, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortHeroType*                          HeroType;                                          // 0x0558(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HeroSquadId;                                       // 0x0560(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_568[0x78];                                     // 0x0568(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentCharXP;                                     // 0x05E0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E4[0x15C];                                    // 0x05E4(0x015C)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AFortPickup>             MyBackpackPickup;                                  // 0x0740(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InitialExperienceAmount;                           // 0x0748(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74C[0x4];                                      // 0x074C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFortExperienceDelta>           ExperienceDeltas;                                  // 0x0750(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPublic)
	EFortCustomGender                             CharacterGender;                                   // 0x0760(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortCustomBodyType                           CharacterBodyType;                                 // 0x0761(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_762[0x6];                                      // 0x0762(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UCustomCharacterPart*                   CharacterParts[0x6];                               // 0x0768(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCustomColorSwatch*                     CharacterColorSwatches[0x2];                       // 0x0798(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCustomPlayerComponent*                 CustomPRIComponent;                                // 0x07A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AFortPlayerPawn>         CachedPawn;                                        // 0x07B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCustomColorSwatch*                     CharacterPartColorSwatches[0x6];                   // 0x07B8(0x0008)(Edit, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortTeamInfo*                          PlayerTeam;                                        // 0x07E8(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSkipReplicatedStats;                              // 0x07F0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7F1[0x3];                                      // 0x07F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FReplicatedStatValues                  ReplicatedStats_Campaign[0x22];                    // 0x07F4(0x0008)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FReplicatedStatValues                  ReplicatedStats_Zone[0x22];                        // 0x0904(0x0008)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A14[0x4];                                      // 0x0A14(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAreZoneStatsFinalized;                            // 0x0A18(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EReadyCheckState                              ReadyCheckState;                                   // 0x0A19(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1A[0x6];                                      // 0x0A1A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 HomeActor;                                         // 0x0A20(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFortPlayerAttributeSets               AttributeSets;                                     // 0x0A28(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UFortAbilitySystemComponent*            AbilitySystemComponent;                            // 0x0A70(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PlayerOSSName;                                     // 0x0A78(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETrustedPlatformType                          TrustedPlatformType;                               // 0x0A80(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A81[0x7];                                      // 0x0A81(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUniqueNetIdRepl                       PlatformUniqueNetId;                               // 0x0A88(0x0018)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 PlatformUniqueNetIdString;                         // 0x0AA0(0x0010)(Net, ZeroConstructor, RepNotify, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AB0[0x10];                                     // 0x0AB0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bInvitedToConsoleSession;                          // 0x0AC0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInitializedPlayerCustomizationOptionsFromClientSettings; // 0x0AC1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AC2[0x6];                                      // 0x0AC2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool AreUniqueIDsIdentical(const struct FUniqueNetIdRepl& A, const struct FUniqueNetIdRepl& B);

	class AFortPlayerPawn* GetCurrentPawn();
	void OnRep_AccessoryColorSwatches();
	void OnRep_bHasStartedPlaying();
	void OnRep_CharacterColorSwatches();
	void OnRep_CharacterParts();
	void OnRep_CurrentCharXP();
	void OnRep_HeroId();
	void OnRep_HeroType();
	void OnRep_HomeActor(class AActor* OldHomeActor);
	void OnRep_PartyOwner();
	void OnRep_PlatformUniqueNetIdString();
	void OnRep_PlayerName();
	void OnRep_PlayerTeam();
	void OnRep_ScoreStatChanged();
	void OnRep_SessionOwner();
	void OnRep_ShowHeroBackpack();
	void OnRep_ShowHeroHeadAccessories();
	void ServerSetShowHeroBackpack(bool bShow);
	void ServerSetShowHeroHeadAccessories(bool bShow);
	void UpdateScoreStatChanged();

	struct FUniqueNetIdRepl GetPlatformUniqueNetId() const;
	class FName GetPlayerOSSName() const;
	struct FUniqueNetIdRepl GetUniqueID() const;
	bool IsConsolePlayer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerState">();
	}
	static class AFortPlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerState>();
	}
};
#pragma pack(pop)
static_assert(alignof(AFortPlayerState) == 0x000008, "Wrong alignment on AFortPlayerState");
static_assert(sizeof(AFortPlayerState) == 0x000AC8, "Wrong size on AFortPlayerState");
static_assert(offsetof(AFortPlayerState, PartyOwnerUniqueId) == 0x000528, "Member 'AFortPlayerState::PartyOwnerUniqueId' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, WorldPlayerId) == 0x000540, "Member 'AFortPlayerState::WorldPlayerId' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, HeroId) == 0x000548, "Member 'AFortPlayerState::HeroId' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, HeroType) == 0x000558, "Member 'AFortPlayerState::HeroType' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, HeroSquadId) == 0x000560, "Member 'AFortPlayerState::HeroSquadId' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, CurrentCharXP) == 0x0005E0, "Member 'AFortPlayerState::CurrentCharXP' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, MyBackpackPickup) == 0x000740, "Member 'AFortPlayerState::MyBackpackPickup' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, InitialExperienceAmount) == 0x000748, "Member 'AFortPlayerState::InitialExperienceAmount' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, ExperienceDeltas) == 0x000750, "Member 'AFortPlayerState::ExperienceDeltas' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, CharacterGender) == 0x000760, "Member 'AFortPlayerState::CharacterGender' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, CharacterBodyType) == 0x000761, "Member 'AFortPlayerState::CharacterBodyType' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, CharacterParts) == 0x000768, "Member 'AFortPlayerState::CharacterParts' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, CharacterColorSwatches) == 0x000798, "Member 'AFortPlayerState::CharacterColorSwatches' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, CustomPRIComponent) == 0x0007A8, "Member 'AFortPlayerState::CustomPRIComponent' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, CachedPawn) == 0x0007B0, "Member 'AFortPlayerState::CachedPawn' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, CharacterPartColorSwatches) == 0x0007B8, "Member 'AFortPlayerState::CharacterPartColorSwatches' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, PlayerTeam) == 0x0007E8, "Member 'AFortPlayerState::PlayerTeam' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, bSkipReplicatedStats) == 0x0007F0, "Member 'AFortPlayerState::bSkipReplicatedStats' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, ReplicatedStats_Campaign) == 0x0007F4, "Member 'AFortPlayerState::ReplicatedStats_Campaign' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, ReplicatedStats_Zone) == 0x000904, "Member 'AFortPlayerState::ReplicatedStats_Zone' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, bAreZoneStatsFinalized) == 0x000A18, "Member 'AFortPlayerState::bAreZoneStatsFinalized' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, ReadyCheckState) == 0x000A19, "Member 'AFortPlayerState::ReadyCheckState' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, HomeActor) == 0x000A20, "Member 'AFortPlayerState::HomeActor' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, AttributeSets) == 0x000A28, "Member 'AFortPlayerState::AttributeSets' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, AbilitySystemComponent) == 0x000A70, "Member 'AFortPlayerState::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, PlayerOSSName) == 0x000A78, "Member 'AFortPlayerState::PlayerOSSName' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, TrustedPlatformType) == 0x000A80, "Member 'AFortPlayerState::TrustedPlatformType' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, PlatformUniqueNetId) == 0x000A88, "Member 'AFortPlayerState::PlatformUniqueNetId' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, PlatformUniqueNetIdString) == 0x000AA0, "Member 'AFortPlayerState::PlatformUniqueNetIdString' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, bInvitedToConsoleSession) == 0x000AC0, "Member 'AFortPlayerState::bInvitedToConsoleSession' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, bInitializedPlayerCustomizationOptionsFromClientSettings) == 0x000AC1, "Member 'AFortPlayerState::bInitializedPlayerCustomizationOptionsFromClientSettings' has a wrong offset!");

// Class FortniteGame.FortPlayerStateZone
// 0x0250 (0x0D18 - 0x0AC8)
#pragma pack(push, 0x1)
class alignas(0x08) AFortPlayerStateZone : public AFortPlayerState
{
public:
	UMulticastDelegateProperty_                   OnCurrentPawnChanged;                              // 0x0AC8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_AD8[0x78];                                     // 0x0AD8(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	struct FReplicatedStatValues                  RS_Zone_Old[0x22];                                 // 0x0B50(0x0008)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class AFortCarriedObject*                     CarriedObject;                                     // 0x0C60(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumRejoins;                                        // 0x0C68(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         OldTotalScoreStat;                                 // 0x0C6C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C70[0x70];                                     // 0x0C70(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bInvincibleDueToUI;                                // 0x0CE0(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CE1[0x3];                                      // 0x0CE1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentHealth;                                     // 0x0CE4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHealth;                                         // 0x0CE8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentShield;                                     // 0x0CEC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxShield;                                         // 0x0CF0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CF4[0x4];                                      // 0x0CF4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAccumulatedItemEntry>          AccumulatedItems;                                  // 0x0CF8(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnAccumulatedItemsChanged;                         // 0x0D08(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void OnRep_AccumulatedItems();
	void OnRep_NumRejoins();

	int32 GetNumOfAccumulatedItem(const class UFortWorldItemDefinition* ItemDefinition) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerStateZone">();
	}
	static class AFortPlayerStateZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerStateZone>();
	}
};
#pragma pack(pop)
static_assert(alignof(AFortPlayerStateZone) == 0x000008, "Wrong alignment on AFortPlayerStateZone");
static_assert(sizeof(AFortPlayerStateZone) == 0x000D18, "Wrong size on AFortPlayerStateZone");
static_assert(offsetof(AFortPlayerStateZone, OnCurrentPawnChanged) == 0x000AC8, "Member 'AFortPlayerStateZone::OnCurrentPawnChanged' has a wrong offset!");
static_assert(offsetof(AFortPlayerStateZone, RS_Zone_Old) == 0x000B50, "Member 'AFortPlayerStateZone::RS_Zone_Old' has a wrong offset!");
static_assert(offsetof(AFortPlayerStateZone, CarriedObject) == 0x000C60, "Member 'AFortPlayerStateZone::CarriedObject' has a wrong offset!");
static_assert(offsetof(AFortPlayerStateZone, NumRejoins) == 0x000C68, "Member 'AFortPlayerStateZone::NumRejoins' has a wrong offset!");
static_assert(offsetof(AFortPlayerStateZone, OldTotalScoreStat) == 0x000C6C, "Member 'AFortPlayerStateZone::OldTotalScoreStat' has a wrong offset!");
static_assert(offsetof(AFortPlayerStateZone, bInvincibleDueToUI) == 0x000CE0, "Member 'AFortPlayerStateZone::bInvincibleDueToUI' has a wrong offset!");
static_assert(offsetof(AFortPlayerStateZone, CurrentHealth) == 0x000CE4, "Member 'AFortPlayerStateZone::CurrentHealth' has a wrong offset!");
static_assert(offsetof(AFortPlayerStateZone, MaxHealth) == 0x000CE8, "Member 'AFortPlayerStateZone::MaxHealth' has a wrong offset!");
static_assert(offsetof(AFortPlayerStateZone, CurrentShield) == 0x000CEC, "Member 'AFortPlayerStateZone::CurrentShield' has a wrong offset!");
static_assert(offsetof(AFortPlayerStateZone, MaxShield) == 0x000CF0, "Member 'AFortPlayerStateZone::MaxShield' has a wrong offset!");
static_assert(offsetof(AFortPlayerStateZone, AccumulatedItems) == 0x000CF8, "Member 'AFortPlayerStateZone::AccumulatedItems' has a wrong offset!");
static_assert(offsetof(AFortPlayerStateZone, OnAccumulatedItemsChanged) == 0x000D08, "Member 'AFortPlayerStateZone::OnAccumulatedItemsChanged' has a wrong offset!");

// Class FortniteGame.FortPlayerStateManor
// 0x0008 (0x0D20 - 0x0D18)
class AFortPlayerStateManor final : public AFortPlayerStateZone
{
public:
	uint8                                         Pad_D18[0x8];                                      // 0x0D18(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerStateManor">();
	}
	static class AFortPlayerStateManor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerStateManor>();
	}
};
static_assert(alignof(AFortPlayerStateManor) == 0x000008, "Wrong alignment on AFortPlayerStateManor");
static_assert(sizeof(AFortPlayerStateManor) == 0x000D20, "Wrong size on AFortPlayerStateManor");

// Class FortniteGame.FortUIFeedbackBank
// 0x0070 (0x0098 - 0x0028)
class UFortUIFeedbackBank final : public UDataAsset
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFortUIFeedback>                FeedbackEvents;                                    // 0x0078(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FFortUIFeedbackBlueprintOnly>   BankDefinedFeedbackEvents;                         // 0x0088(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortUIFeedbackBank">();
	}
	static class UFortUIFeedbackBank* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortUIFeedbackBank>();
	}
};
static_assert(alignof(UFortUIFeedbackBank) == 0x000008, "Wrong alignment on UFortUIFeedbackBank");
static_assert(sizeof(UFortUIFeedbackBank) == 0x000098, "Wrong size on UFortUIFeedbackBank");
static_assert(offsetof(UFortUIFeedbackBank, FeedbackEvents) == 0x000078, "Member 'UFortUIFeedbackBank::FeedbackEvents' has a wrong offset!");
static_assert(offsetof(UFortUIFeedbackBank, BankDefinedFeedbackEvents) == 0x000088, "Member 'UFortUIFeedbackBank::BankDefinedFeedbackEvents' has a wrong offset!");

// Class FortniteGame.FortPlayerExitParams
// 0x0008 (0x0030 - 0x0028)
class UFortPlayerExitParams final : public UFortMissionEventParams
{
public:
	class AFortPlayerController*                  ExitingPlayerController;                           // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BreakParams(class AFortPlayerController** _ExitingPlayerController);
	void SetParams(class AFortPlayerController* _ExitingPlayerController, class UFortPlayerExitParams** ThisParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerExitParams">();
	}
	static class UFortPlayerExitParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPlayerExitParams>();
	}
};
static_assert(alignof(UFortPlayerExitParams) == 0x000008, "Wrong alignment on UFortPlayerExitParams");
static_assert(sizeof(UFortPlayerExitParams) == 0x000030, "Wrong size on UFortPlayerExitParams");
static_assert(offsetof(UFortPlayerExitParams, ExitingPlayerController) == 0x000028, "Member 'UFortPlayerExitParams::ExitingPlayerController' has a wrong offset!");

// Class FortniteGame.FortPlayerSpawnedParams
// 0x0008 (0x0030 - 0x0028)
class UFortPlayerSpawnedParams final : public UFortMissionEventParams
{
public:
	class AFortPlayerController*                  SpawnedPlayerController;                           // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BreakParams(class AFortPlayerController** _SpawnedPlayerController);
	void SetParams(class AFortPlayerController* _SpawnedPlayerController, class UFortPlayerSpawnedParams** ThisParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerSpawnedParams">();
	}
	static class UFortPlayerSpawnedParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPlayerSpawnedParams>();
	}
};
static_assert(alignof(UFortPlayerSpawnedParams) == 0x000008, "Wrong alignment on UFortPlayerSpawnedParams");
static_assert(sizeof(UFortPlayerSpawnedParams) == 0x000030, "Wrong size on UFortPlayerSpawnedParams");
static_assert(offsetof(UFortPlayerSpawnedParams, SpawnedPlayerController) == 0x000028, "Member 'UFortPlayerSpawnedParams::SpawnedPlayerController' has a wrong offset!");

// Class FortniteGame.FortMissionLibrary
// 0x0000 (0x0028 - 0x0028)
class UFortMissionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AddCompletionTagsToMission(class UObject* WorldContextObject, const struct FGuid& MissionGuid, const struct FGameplayTagContainer& NewCompletionTagContainer);
	static void AddCompletionTagToMission(class UObject* WorldContextObject, const struct FGuid& MissionGuid, const struct FGameplayTag& NewCompletionTag);
	static void AdjustWaveBasedGameDifficulty(class UObject* WorldContextObject, float fDifficultyAddMod);
	static void CreateDynamicBuildingDeconstructor(class UObject* WorldContextObject, const struct FVector& Origin, const struct FVector& BoxExtent, bool bIgnoreMissionActors, bool bShrinkAndDestroy);
	static struct FFortMissionEvent CreateMissionEvent(class UObject* WorldContextObject, class FName EventType, const struct FGuid& MissionGuid, const struct FGameplayTagContainer& ObjectiveHandle, class UFortMissionEventParams* Params_0, bool DO_NOT_USE_THIS_OR_VARIABLES_BELOW, class UObject* EventFocus, class UDataAsset* EventContent, class AActor* EventInstigator, int32 GenericInt, float GenericFloat, const class FText& GenericText, const struct FGameplayTagContainer& GameplayTags);
	static void ExecuteMissionEvent(class UObject* WorldContextObject, class FName EventType, const struct FGuid& MissionGuid, const struct FGameplayTagContainer& ObjectiveHandle, class UFortMissionEventParams* Params_0, bool DO_NOT_USE_THIS_OR_VARIABLES_BELOW, class UObject* EventFocus, class UDataAsset* EventContent, class AActor* EventInstigator, int32 GenericInt, float GenericFloat, const class FText& GenericText, const struct FGameplayTagContainer& GameplayTags);
	static void ExecuteMissionEventEx(class UObject* WorldContextObject, const struct FFortMissionEventName& EventType, const struct FGuid& MissionGuid, const struct FGameplayTagContainer& ObjectiveHandle, class UFortMissionEventParams* Params_0, bool DO_NOT_USE_THIS_OR_VARIABLES_BELOW, class UObject* EventFocus, class UDataAsset* EventContent, class AActor* EventInstigator, int32 GenericInt, float GenericFloat, const class FText& GenericText, const struct FGameplayTagContainer& GameplayTags);
	static TArray<class ABuildingActor*> FindActorsWithTags(class UObject* WorldContextObject, const struct FGameplayTagContainer& Tags);
	static class AFortPlacementActor* FindOriginatingPlacementActor(class ABuildingActor* BuildingActor);
	static TArray<class AFortMission*> GetAllLoadedMissions(class UObject* WorldContextObject);
	static class AFortBluGloManager* GetBluGloManager(class UObject* WorldContextObject);
	static TArray<class AActor*> GetMissionActorsInEncounterDirection(class UObject* WorldContextObject, TSubclassOf<class AActor> ActorSubclass, const struct FVector& StartLocation, EFortEncounterDirection DirectionToLookForActors, float Angle, float MaxDistance);
	static TArray<class AActor*> GetMissionActorsInVectorDirection(class UObject* WorldContextObject, TSubclassOf<class AActor> ActorSubclass, const struct FVector& StartLocation, const struct FVector& DirectionToLookForActors, float Angle, float MaxDistance);
	static class AFortMission* GetMissionFromGuid(class UObject* WorldContextObject, const struct FGuid& MissionGuid);
	static float GetMissionHUDTextLineHeightEstimate(const class FText& Text);
	static void GetTieredWaveBaseNumKillPoints(class UObject* WorldContextObject, class FName BaseNumOfKillPointsRowName, float OverrideDifficulty, float* OutBaseNumKillPoints);
	static void GetTieredWaveBaseNumKills(class UObject* WorldContextObject, class FName BaseNumOfKillsRowName, float OverrideDifficulty, float* OutBaseNumKills);
	static void GetTieredWaveBaseWaveLength(class UObject* WorldContextObject, class FName BaseWaveLengthRowName, float OverrideDifficulty, float* OutBaseWaveLength);
	static void GetTieredWaveSet(class FName TieredWaveCollectionName, int32 Tier, struct FTieredWaveSetCollectionData* WaveCollectionInfo, TArray<struct FTieredWaveSetData>* OutWaveData);
	static void GiveMissionRewardsToPlayer(class UObject* WorldContextObject, const struct FGuid& EventGuid, class AFortPlayerController* PlayerController, const class FText& TitleText, const class FText& DescriptionText, class FName LootTierGroup, int32 LootTier, float RewardDisplayTime);
	static void GiveMissionRewardsToPlayerAsPickups(class UObject* WorldContextObject, const struct FGuid& MissionGuid, class AFortPlayerController* PlayerController, const struct FVector& StartPosition, float Radius, class FName LootTierGroup, int32 LootTier);
	static bool GiveMissionSchematicItemDirectlyToPlayer(class UObject* WorldContextObject, class AFortPlayerController* TargetPlayer, const struct FGuid& MissionGuid, class UFortSchematicItemDefinition* SchematicDefinition);
	static bool HasTags(const struct FGameplayTagContainer& ContainerToCheck, const struct FGameplayTagContainer& TagsToCheck, bool bRequireAll, bool bCountEmptyAsMatch);
	static bool IsUsingNewMissionGeneration(class UObject* WorldContextObject);
	static void LoadMission(class UObject* WorldContextObject, class UFortMissionInfo* MissionInfo);
	static int32 NumBluGloFromPlayerPawn(class AFortPlayerPawn* PlayerPawn);
	static int32 NumBluGloFromPlayerState(class AFortPlayerStateZone* PlayerState);
	static void PingMinimap(class UObject* WorldContextObject, const struct FVector& WorldLocation, const struct FLinearColor& PingColor, EFortTeam RequiredTeam);
	static int32 PollActorsInVolume(class UObject* WorldContextObject, class UBoxComponent* VolumeBoxComponent, EPollActorsInVolumeTypes PollBuildingTypes, TSubclassOf<class AActor> ActorClassToPoll);
	static bool RegisterForMissionEvents(class AActor* ActorToRegister, const struct FGuid& MissionGuid);
	static bool RegisterMissionInfoUIActor(class AActor* AttachmentActor, const struct FGuid& MissionGuid, const struct FVector& AttachementOffset, float MaxVisibleDistance);
	static void RespawnOutlanderFragments(class UObject* WorldContextObject);
	static void SetOnlinePresenceDoNotDisturb(class UObject* WorldContextObject, bool bDoNotDisturb, class AFortPlayerController* SpecificPlayer);
	static void SetWorldSavingEnabled(class UObject* WorldContextObject, bool bEnabled);
	static bool ShouldUseAlternateAIDirectorBalance();
	static void SpawnAndCollectPlayerPickups(class UObject* WorldContextObject, class AFortPlayerController* PlayerController, const struct FVector& StartPosition, class FName LootTierGroup, int32 LootTier);
	static TArray<class AActor*> SpawnAtPlacementActorsHelper(class UObject* WorldContextObject, class UClass* Entries, bool* bSucceeded);
	static class ABuildingActor* SpawnBuildingActorAtTransform(class UObject* WorldContextObject, const struct FGuid& MissionGuid, TSubclassOf<class ABuildingActor> BuildingClass, const struct FTransform& Transform);
	static class AFortPickup* SpawnMissionItemPickup(class UObject* WorldContextObject, const struct FGuid& MissionGuid, class UFortMissionItemDefinition* MissionItemDefinition, const struct FVector& StartPosition, class AFortPawn* TargetPawn);
	static class AFortPickup* SpawnMissionItemPickupInWorld(class UObject* WorldContextObject, const struct FGuid& MissionGuid, class UFortWorldItemDefinition* ItemDefinition, int32 NumberToSpawn, const struct FVector& Position, const struct FVector& Direction, int32 OverrideMaxStackCount);
	static bool SpawnPlacementMissionActor(class UObject* WorldContextObject, const TSubclassOf<class AActor>& ActorToSpawn, const struct FVector& SpawnLocation, const struct FRotator& SpawnRotation, class AActor* PlacementLocationActor, class AActor** OutSpawnedActor);
	static class UFortAIEncounterInfo* StartAIEncounter(class UObject* WorldContextObject, class FString* AssociatedMissionName, TSubclassOf<class UFortAIEncounterInfo> EncounterTemplate, class AActor* TargetActor, const struct FGameplayTagContainer& InjectedTags, const struct FFortEncounterSettings& EncounterSettings, int32 ActivationDelay);
	static class UFortAIEncounterInfo* StartAIEncounterWithEnvironmentQuery(class UObject* WorldContextObject, class FString* AssociatedMissionName, TSubclassOf<class UFortAIEncounterInfo> EncounterTemplate, class AActor* TargetActor, const struct FEncounterEnvironmentQueryInfo& EnvironmentQueryInfo, class AActor* QueryActor, const struct FGameplayTagContainer& InjectedTags, const struct FFortEncounterSettings& EncounterSettings, int32 ActivationDelay);
	static void StartPlayingMission(class UObject* WorldContextObject, const struct FGuid& MissionGuid);
	static void StopAIEncounter(class UObject* WorldContextObject, class UFortAIEncounterInfo* ActiveEncounter, EFortObjectiveStatus ObjectiveStatus);
	static void StopAIEncounterAgainstActor(class UObject* WorldContextObject, class AActor* TargetActor);
	static void TeleportPawnNearLocation(class AFortPawn* Pawn, const struct FVector& DestLocation);
	static void TeleportPlayerPawn(class AFortPlayerPawn* PlayerPawn, const struct FVector& DestLocation, const struct FRotator& DestRotation, bool bIgnoreCollision);
	static bool UnregisterForMissionEvents(class AActor* ActorToUnregister, const struct FGuid& MissionGuid);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMissionLibrary">();
	}
	static class UFortMissionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMissionLibrary>();
	}
};
static_assert(alignof(UFortMissionLibrary) == 0x000008, "Wrong alignment on UFortMissionLibrary");
static_assert(sizeof(UFortMissionLibrary) == 0x000028, "Wrong size on UFortMissionLibrary");

// Class FortniteGame.FortPlayerStatePvP
// 0x0080 (0x0D98 - 0x0D18)
#pragma pack(push, 0x1)
class alignas(0x08) AFortPlayerStatePvP : public AFortPlayerStateZone
{
public:
	uint8                                         Pad_D18[0x78];                                     // 0x0D18(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TotalQuantum;                                      // 0x0D90(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D94[0x4];                                      // 0x0D94(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_TotalQuantum(const int32 PrevTotalQuantum);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerStatePvP">();
	}
	static class AFortPlayerStatePvP* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerStatePvP>();
	}
};
#pragma pack(pop)
static_assert(alignof(AFortPlayerStatePvP) == 0x000008, "Wrong alignment on AFortPlayerStatePvP");
static_assert(sizeof(AFortPlayerStatePvP) == 0x000D98, "Wrong size on AFortPlayerStatePvP");
static_assert(offsetof(AFortPlayerStatePvP, TotalQuantum) == 0x000D90, "Member 'AFortPlayerStatePvP::TotalQuantum' has a wrong offset!");

// Class FortniteGame.FortBluGloManager
// 0x0098 (0x0420 - 0x0388)
class AFortBluGloManager : public AActor
{
public:
	float                                         BluGloPerMinute;                                   // 0x0388(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38C[0x4];                                      // 0x038C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            BluGloIcon;                                        // 0x0390(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	class UFortItemDefinition* GetBluGloItemDefinition() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBluGloManager">();
	}
	static class AFortBluGloManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortBluGloManager>();
	}
};
static_assert(alignof(AFortBluGloManager) == 0x000008, "Wrong alignment on AFortBluGloManager");
static_assert(sizeof(AFortBluGloManager) == 0x000420, "Wrong size on AFortBluGloManager");
static_assert(offsetof(AFortBluGloManager, BluGloPerMinute) == 0x000388, "Member 'AFortBluGloManager::BluGloPerMinute' has a wrong offset!");
static_assert(offsetof(AFortBluGloManager, BluGloIcon) == 0x000390, "Member 'AFortBluGloManager::BluGloIcon' has a wrong offset!");

// Class FortniteGame.FortPlayerDiedParams
// 0x0010 (0x0038 - 0x0028)
class UFortPlayerDiedParams final : public UFortMissionEventParams
{
public:
	class AFortPlayerPawn*                        KilledPlayer;                                      // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            KilledBy;                                          // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BreakParams(class AFortPlayerPawn** _KilledPlayer, class AController** _KilledBy);
	void SetParams(class AFortPlayerPawn* _KilledPlayer, class AController* _KilledBy, class UFortPlayerDiedParams** ThisParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerDiedParams">();
	}
	static class UFortPlayerDiedParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPlayerDiedParams>();
	}
};
static_assert(alignof(UFortPlayerDiedParams) == 0x000008, "Wrong alignment on UFortPlayerDiedParams");
static_assert(sizeof(UFortPlayerDiedParams) == 0x000038, "Wrong size on UFortPlayerDiedParams");
static_assert(offsetof(UFortPlayerDiedParams, KilledPlayer) == 0x000028, "Member 'UFortPlayerDiedParams::KilledPlayer' has a wrong offset!");
static_assert(offsetof(UFortPlayerDiedParams, KilledBy) == 0x000030, "Member 'UFortPlayerDiedParams::KilledBy' has a wrong offset!");

// Class FortniteGame.FortPlayerDBNOEnterParams
// 0x0010 (0x0038 - 0x0028)
class UFortPlayerDBNOEnterParams final : public UFortMissionEventParams
{
public:
	class AFortPlayerPawn*                        KilledPlayer;                                      // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            KilledBy;                                          // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BreakParams(class AFortPlayerPawn** _KilledPlayer, class AController** _KilledBy);
	void SetParams(class AFortPlayerPawn* _KilledPlayer, class AController* _KilledBy, class UFortPlayerDBNOEnterParams** ThisParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerDBNOEnterParams">();
	}
	static class UFortPlayerDBNOEnterParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPlayerDBNOEnterParams>();
	}
};
static_assert(alignof(UFortPlayerDBNOEnterParams) == 0x000008, "Wrong alignment on UFortPlayerDBNOEnterParams");
static_assert(sizeof(UFortPlayerDBNOEnterParams) == 0x000038, "Wrong size on UFortPlayerDBNOEnterParams");
static_assert(offsetof(UFortPlayerDBNOEnterParams, KilledPlayer) == 0x000028, "Member 'UFortPlayerDBNOEnterParams::KilledPlayer' has a wrong offset!");
static_assert(offsetof(UFortPlayerDBNOEnterParams, KilledBy) == 0x000030, "Member 'UFortPlayerDBNOEnterParams::KilledBy' has a wrong offset!");

// Class FortniteGame.FortGameData
// 0x23A8 (0x23D0 - 0x0028)
class UFortGameData final : public UPrimaryDataAsset
{
public:
	TSubclassOf<class UFortAIEncounterInfo>       TestEncounter;                                     // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AFortCombatManager>         CombatManager;                                     // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class APlayerCameraManager>       DefaultCameraManager;                              // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AFortInGameMapManager>      UIMapManager;                                      // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AFortMusicManager>          MusicManager;                                      // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DefaultHeroName;                                   // 0x0050(0x0018)(Edit, NativeAccessSpecifierPublic)
	class UFortTips*                              LoadingScreenTips;                                 // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortTooltipMap*                        ObjClassToTooltipClassMap;                         // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   DefaultDamageReceiverClass;                        // 0x0078(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   DefaultDamageReceiverClassAthena;                  // 0x0098(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortTooltipDisplayStatsLookupTable*    ObjClassToTooltipStatsMap;                         // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortTokenToTextTable*                  TooltipTokenToTextTable;                           // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortTokenToAttributeTable*             TooltipTokenToAttributeTable;                      // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PickupSplineOffsetRange[0x2];                      // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PickupSplineRandomMax;                             // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PickupSplineDropToGroundLength;                    // 0x00DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveVector*                           PickupSplineCurve;                                 // 0x00E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             PickupLandedSound;                                 // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFortTokenType>          AccountInventoryBonusToken;                        // 0x00F0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFortTokenType>          WorldInventoryBonusToken;                          // 0x0110(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFortTokenType>          FounderChatUnlockToken;                            // 0x0130(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortRarityData*                        RarityData;                                        // 0x0150(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortScoreStylingData*                  ScoreStylingData;                                  // 0x0158(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortItemCategory*                      ItemCategories;                                    // 0x0160(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQuickBarData                          QuickBarDefinitions[0x2];                          // 0x0168(0x0010)(Edit, NativeAccessSpecifierPublic)
	TArray<class FName>                           AutoEquipTags;                                     // 0x0188(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AutoEquipTagContainer;                             // 0x0198(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FLinearColor                           BuildingFullHealthFlashColor;                      // 0x01B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           InvalidEditPatternColor;                           // 0x01C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFortHighlightColorsContainer          HighlightColors[0x3];                              // 0x01D8(0x0060)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ScoreDisplayFactor;                                // 0x02F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFortReplicatedStatMapping>     StatMappings;                                      // 0x0300(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditFixedSize, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UDataTable*                             ScoreMultiplierDataTable;                          // 0x0310(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ScoreDivisor;                                      // 0x0318(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XPMult;                                            // 0x031C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroupScoreRates[0x5];                              // 0x0320(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScoreToXPLinearRate;                               // 0x0334(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LinearEnd;                                         // 0x0338(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XpPerAccountLevel;                                 // 0x033C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CriticalMatch_XpBonusPercent;                      // 0x0340(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PersonalBoost_XpBonusPercent;                      // 0x0344(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroupBoost_XpBonusPercent;                         // 0x0348(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroupBoost_BuffMultiplier;                         // 0x034C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rest_XpBonusPercent;                               // 0x0350(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_354[0x4];                                      // 0x0354(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundMix*                              LoadingScreenSoundMix;                             // 0x0358(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundMix*                              BaseSoundMix;                                      // 0x0360(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AFortGlobalAbilityTargetingActor> AbilityTargetingActorBlueprintClass;               // 0x0368(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UFortWeaponMeleeItemDefinition>> HarvestingTools;                                   // 0x0370(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UFortWeaponMeleeItemDefinition>> AthenaHarvestingToolsToPreload;                    // 0x0380(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FKeybindIcon>                   IconKeyList;                                       // 0x0390(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FKeybindIcon>                   IconKeyListPS4;                                    // 0x03A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FKeybindIcon>                   IconKeyListXboxOne;                                // 0x03B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSubGameInfo                           SubGameInfo[0x2];                                  // 0x03C0(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  PlacementActorUsedTags;                            // 0x03E0(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FFortPlayerSpawnPadPlacementData       DefaultPlayerSpawnPadPlacementData;                // 0x0400(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UCustomCharacterPart>    DefaultBackpackCharacterPart;                      // 0x0450(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UCustomCharacterPart>> DefaultCharacterParts;                             // 0x0470(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSubclassOf<class AFortAIGoalManager>         AIGoalManagerClass;                                // 0x0480(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UFortSharedMissionLists>    SharedMissionListsClass;                           // 0x0488(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         QueuedAnnouncementPauseTimes[0x3];                 // 0x0490(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_49C[0x4];                                      // 0x049C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCurveTableRowHandle                   WeakSpotEnabledTimeoutHandle;                      // 0x04A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         BuildingStructuralCollapseDelay;                   // 0x04B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BuildingStructuralCollapseDelayVariance;           // 0x04B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BuildingStructuralCollapseCellDistAdditiveDelay;   // 0x04B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BuildingStructuralCollapseCellDistAdditiveDelayVariance; // 0x04BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EditModeCancelDistance;                            // 0x04C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C4[0x4];                                      // 0x04C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCurveTableRowHandle                   BuildingExcessDamageRewardTimeoutHandle;           // 0x04C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   BuildingCostHandles[0x4];                          // 0x04D8(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   BuildingDeconCostMultHandles[0x4];                 // 0x0518(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   PlayerBuildingDeconCostMultHandles[0x4];           // 0x0558(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   BuildingInitialHealthPercentHandles[0x4];          // 0x0598(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   BuildingRepairCostMultiplierHandles[0x4];          // 0x05D8(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         FORTAttributeToPowerMultiplier;                    // 0x0618(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_61C[0x4];                                      // 0x061C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCurveTableRowHandle                   BuildingBreakAnimDurationHandles[0x4];             // 0x0620(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   BuildingDestroyAnimDurationHandles[0x4];           // 0x0660(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   BuildingPlacementAnimDurationHandles[0x4];         // 0x06A0(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   BuildingCritDamagePctHandles[0x4];                 // 0x06E0(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   BuildingCritDestroyAnimScaleCapHandles[0x4];       // 0x0720(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UMaterialParameterCollection> StencilDefinitionCollection;                       // 0x0760(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoundPerResourceLevel                 BuildingConstructionSounds[0x4];                   // 0x0780(0x0030)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSoundPerResourceLevel                 GenericBuildingDeathSounds[0x4];                   // 0x0840(0x0030)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSoundPerResourceLevel                 PlayerBuiltBuildingDeathSounds[0x4];               // 0x0900(0x0030)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class FText                                   ResourceNames[0x4];                                // 0x09C0(0x0018)(Protected, NativeAccessSpecifierProtected)
	class FText                                   BuildingTypeNames[0xC];                            // 0x0A20(0x0018)(Protected, NativeAccessSpecifierProtected)
	class UFortResourceItemDefinition*            StoneItemDefinition;                               // 0x0B40(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortResourceItemDefinition*            WoodItemDefinition;                                // 0x0B48(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortResourceItemDefinition*            MetalItemDefinition;                               // 0x0B50(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortAmmoItemDefinition*                PistolAmmoItemDefinition;                          // 0x0B58(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortResourceItemDefinition*            PermaniteItemDefinition;                           // 0x0B60(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortAmmoItemDefinition*                ShotgunAmmoItemDefinition;                         // 0x0B68(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortAmmoItemDefinition*                RifleAmmoItemDefinition;                           // 0x0B70(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortAmmoItemDefinition*                AssaultAmmoItemDefinition;                         // 0x0B78(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortAmmoItemDefinition*                EnergyAmmoItemDefinition;                          // 0x0B80(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortNeverPersistItemDefinition*        BluGloItemDefinition;                              // 0x0B88(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortItemDefinition*                    CriticalMissionRewardItemDefinition;               // 0x0B90(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortItemDefinition*                    ScoreBonusMultiplerItemDefinition;                 // 0x0B98(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFortWorldItemDefinition> BackpackItemDefinition;                            // 0x0BA0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFortWorldItemDefinition> MissionRewardPackItemDefinition;                   // 0x0BC0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   OutpostRefundDialogTitle;                          // 0x0BE0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   OutpostRefundDialogText;                           // 0x0BF8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   OutpostRefundButtonText;                           // 0x0C10(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFortGamepadSettings>    GamepadSettingsDefault;                            // 0x0C28(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFortGamepadSettings>    GamepadSettingsPS4;                                // 0x0C48(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFortGamepadSettings>    GamepadSettingsXboxOne;                            // 0x0C68(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UDataTable>>      LootTierDataTables;                                // 0x0C88(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSoftObjectPtr<class UDataTable>>      LootPackageDataTables;                             // 0x0C98(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UDataTable>              WaveSetCollectionData;                             // 0x0CA8(0x0020)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UDataTable>              WaveSetData;                                       // 0x0CC8(0x0020)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UDataTable>              ModifierSetData;                                   // 0x0CE8(0x0020)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UDataTable>              WaveSetCollectionLootData;                         // 0x0D08(0x0020)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UDataTable>              PlayerStatClampingData;                            // 0x0D28(0x0020)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  NonGameplayRelevantTags;                           // 0x0D48(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UCurveTable>             CraftingTimeTable;                                 // 0x0D68(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class USoundBase>              DefaultCraftingSuccessSound;                       // 0x0D88(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGameplayEffect>            TeamStatsGameplayEffect;                           // 0x0DA8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortDailyRewardScheduleDefinitions*    DailyRewardSchedules;                              // 0x0DB0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              ExpeditionCriteriaRequirementsData;                // 0x0DB8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             DifficultyData;                                    // 0x0DD8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowXpConningValue;                                 // 0x0DE0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VeryLowXpConningValue;                             // 0x0DE4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoXpConningValue;                                  // 0x0DE8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DEC[0x4];                                      // 0x0DEC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   FullXpConningMsg;                                  // 0x0DF0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   LowXpConningMsg;                                   // 0x0E08(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   VeryLowXpConningMsg;                               // 0x0E20(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   NoXpConningMsg;                                    // 0x0E38(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UDataTable*                             LootQuotaData;                                     // 0x0E50(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             LootLevelData;                                     // 0x0E58(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             SurfaceRatioBySurfaceCategoryData;                 // 0x0E60(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             SurfaceRatioByAffiliationData;                     // 0x0E68(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             QuestObjectiveStatData;                            // 0x0E70(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             XPAccountLevelsTable;                              // 0x0E78(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             XPHeroLevelsTable;                                 // 0x0E80(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveTable*                            XPAccountItemLevelsTable;                          // 0x0E88(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveTable*                            XPAccountItemRewardsTable;                         // 0x0E90(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveTable*                            XPConningTable;                                    // 0x0E98(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UFortTeamIdentification>    TeamIdentifications[0x68];                         // 0x0EA0(0x0008)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFortQuestPackInfo>             QuestPackInfos;                                    // 0x11E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UFortQuestItemDefinition*               OnboardingQuestItemDefinition;                     // 0x11F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    OnboardingCompleteZoneObjective;                   // 0x11F8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              QuestAchievementData;                              // 0x1208(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateBrush                            LoadingScreenBackground_Generic;                   // 0x1228(0x0090)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateBrush                            LoadingScreenEABackground;                         // 0x12B8(0x0090)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FConditionalFoundationQuota            ConditionalFoundationQuota;                        // 0x1348(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UFortItemDefinition*                    SkillPointItemDef;                                 // 0x1358(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortItemDefinition*                    ResearchPointItemDef;                              // 0x1360(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFortMissionGenerationData> MissionGenerationData;                             // 0x1368(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UFortWorldItemDefinition>> CheatInventoryItems;                               // 0x1388(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   TheaterMapViewerClass;                             // 0x1398(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              MissionAlertCategories;                            // 0x13B8(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              MissionAlertSpreadDatas;                           // 0x13D8(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              MissionAlerts;                                     // 0x13F8(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMyTownData>             MyFortData;                                        // 0x1418(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFortHomebaseManager>    HomebaseManager;                                   // 0x1438(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFortCollectionBookData> CollectionBookData;                                // 0x1458(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFortSurvivorData>       SurvivorData;                                      // 0x1478(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFortOutpostData>        OutpostData;                                       // 0x1498(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFortAttributeLookupTable> AttributeLookupTable;                              // 0x14B8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFortAttributeCategory>  AttributeCategories;                               // 0x14D8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFortTagUIDataLookupTable> UITagDataTable;                                    // 0x14F8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PowerPointDisplayMultiplier;                       // 0x1518(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_151C[0x4];                                     // 0x151C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCurveTableRowHandle                   PowerPointToRatingConversion;                      // 0x1520(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FSettingsHUDVisibilityAndText>  HUDVisibilityGameplayTags;                         // 0x1530(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   DamageNumbersActorClass;                           // 0x1540(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   CrackEffectBlueprintClass;                         // 0x1560(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PickupEffectBlueprintClass;                        // 0x1580(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    GameDifficultyRowPIE;                              // 0x15A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           AIDirectors;                                       // 0x15B0(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         AIDirectorIndex;                                   // 0x15C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AlternateBalanceAIDirectorIndex;                   // 0x15C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   FeedbackManagerClass;                              // 0x15C8(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFortUIFeedbackBank>     UIFeedbackBank;                                    // 0x15E8(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayTagTableManager*               TagTableManager;                                   // 0x1608(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   StatEventManagerClass;                             // 0x1610(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFortHeroType>           DefaultHero;                                       // 0x1630(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UFortHeroType>>   DefaultAthenaHeroes;                               // 0x1650(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FItemDefinitionAndCount>        DefaultInventoryList;                              // 0x1660(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FItemDefinitionAndCount>        FastLoadDefaultInventoryList;                      // 0x1670(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ThreatVisualsManager;                              // 0x1680(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   WindManager;                                       // 0x16A0(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFortEditToolItemDefinition> EditToolItem;                                      // 0x16C0(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFortAbilitySet>         GenericPlayerAbilitySet;                           // 0x16E0(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFortAbilitySet>         GenericTrapAbilitySet;                             // 0x1700(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFortAbilityTagRelationship>    AbilityTagRelationships;                           // 0x1720(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   EnvironmentDamageTemplateGE;                       // 0x1730(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   FallingDamageTemplateGE;                           // 0x1750(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   HealingTemplateGE;                                 // 0x1770(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   FatalDamageTemplateGE;                             // 0x1790(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   SquadMemberStatBonusGE;                            // 0x17B0(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   TeamTrapBonusGE;                                   // 0x17D0(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SquadMemberStatBonusMultiplier;                    // 0x17F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17F4[0x4];                                     // 0x17F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   BASEClass;                                         // 0x17F8(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   HeroManagementWidgetClass;                         // 0x1818(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PlayerChoiceWidgetClass;                           // 0x1838(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   RewardChoiceWidgetClass;                           // 0x1858(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   HeroNotifcationHandlerClass;                       // 0x1878(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   QuestNotificationHandlerClass;                     // 0x1898(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   BasicNotificationClass;                            // 0x18B8(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   FriendNotificationClass;                           // 0x18D8(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   TwitchNotificationClass;                           // 0x18F8(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUISoundFeedback                       FriendFeedbackSounds[0x3];                         // 0x1918(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInterface>      HealthScreenDamagePostProcessMat;                  // 0x1930(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ZoneModifiersAnnouncementClass;                    // 0x1950(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveTable>             SessionXPCurveTable;                               // 0x1970(0x0020)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveTable>             TieredWavesDefenseReqTable;                        // 0x1990(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UParticleSystem>         FallbackDeathParticles;                            // 0x19B0(0x0020)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UParticleSystem>         WallFallbackDeathParticles;                        // 0x19D0(0x0020)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UParticleSystem>         FallbackConstructedEffect;                         // 0x19F0(0x0020)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UParticleSystem>         RepairEffect;                                      // 0x1A10(0x0020)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              ConstructionCompleteSound;                         // 0x1A30(0x0020)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInterface>      DamageMaterial;                                    // 0x1A50(0x0020)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveFloat>             BounceCurve;                                       // 0x1A70(0x0020)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInterface>      BlueprintParentMaterial;                           // 0x1A90(0x0020)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveFloat>             EditCurve;                                         // 0x1AB0(0x0020)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveVector>            BlueprintDamageCurve;                              // 0x1AD0(0x0020)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveFloat>             FullHealthAnimCurve;                               // 0x1AF0(0x0020)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveFloat>             RepairAnimCurve;                                   // 0x1B10(0x0020)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveFloat>             DynamicLODEffectCurve;                             // 0x1B30(0x0020)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveFloat>             InteractFullBounceCurve;                           // 0x1B50(0x0020)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveFloat>             InteractFullBounceNormalCurve;                     // 0x1B70(0x0020)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveFloat>             InteractEmptyBounceCurve;                          // 0x1B90(0x0020)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveFloat>             InteractEmptyBounceNormalCurve;                    // 0x1BB0(0x0020)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ExpeditionUnlockedTag;                             // 0x1BD0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ExpeditionVehicleTags;                             // 0x1BD8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ExpeditionMasterWidgetClass;                       // 0x1BF8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DailyMissionAlertQuota;                            // 0x1C18(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C1C[0x4];                                     // 0x1C1C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOnlineAccountTexts                    OnlineAccountTexts;                                // 0x1C20(0x07B0)(Edit, NativeAccessSpecifierPublic)

public:
	static float GetPersonalXpBoost();
	static float GetTeamXpBoost();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameData">();
	}
	static class UFortGameData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGameData>();
	}
};
static_assert(alignof(UFortGameData) == 0x000008, "Wrong alignment on UFortGameData");
static_assert(sizeof(UFortGameData) == 0x0023D0, "Wrong size on UFortGameData");
static_assert(offsetof(UFortGameData, TestEncounter) == 0x000028, "Member 'UFortGameData::TestEncounter' has a wrong offset!");
static_assert(offsetof(UFortGameData, CombatManager) == 0x000030, "Member 'UFortGameData::CombatManager' has a wrong offset!");
static_assert(offsetof(UFortGameData, DefaultCameraManager) == 0x000038, "Member 'UFortGameData::DefaultCameraManager' has a wrong offset!");
static_assert(offsetof(UFortGameData, UIMapManager) == 0x000040, "Member 'UFortGameData::UIMapManager' has a wrong offset!");
static_assert(offsetof(UFortGameData, MusicManager) == 0x000048, "Member 'UFortGameData::MusicManager' has a wrong offset!");
static_assert(offsetof(UFortGameData, DefaultHeroName) == 0x000050, "Member 'UFortGameData::DefaultHeroName' has a wrong offset!");
static_assert(offsetof(UFortGameData, LoadingScreenTips) == 0x000068, "Member 'UFortGameData::LoadingScreenTips' has a wrong offset!");
static_assert(offsetof(UFortGameData, ObjClassToTooltipClassMap) == 0x000070, "Member 'UFortGameData::ObjClassToTooltipClassMap' has a wrong offset!");
static_assert(offsetof(UFortGameData, DefaultDamageReceiverClass) == 0x000078, "Member 'UFortGameData::DefaultDamageReceiverClass' has a wrong offset!");
static_assert(offsetof(UFortGameData, DefaultDamageReceiverClassAthena) == 0x000098, "Member 'UFortGameData::DefaultDamageReceiverClassAthena' has a wrong offset!");
static_assert(offsetof(UFortGameData, ObjClassToTooltipStatsMap) == 0x0000B8, "Member 'UFortGameData::ObjClassToTooltipStatsMap' has a wrong offset!");
static_assert(offsetof(UFortGameData, TooltipTokenToTextTable) == 0x0000C0, "Member 'UFortGameData::TooltipTokenToTextTable' has a wrong offset!");
static_assert(offsetof(UFortGameData, TooltipTokenToAttributeTable) == 0x0000C8, "Member 'UFortGameData::TooltipTokenToAttributeTable' has a wrong offset!");
static_assert(offsetof(UFortGameData, PickupSplineOffsetRange) == 0x0000D0, "Member 'UFortGameData::PickupSplineOffsetRange' has a wrong offset!");
static_assert(offsetof(UFortGameData, PickupSplineRandomMax) == 0x0000D8, "Member 'UFortGameData::PickupSplineRandomMax' has a wrong offset!");
static_assert(offsetof(UFortGameData, PickupSplineDropToGroundLength) == 0x0000DC, "Member 'UFortGameData::PickupSplineDropToGroundLength' has a wrong offset!");
static_assert(offsetof(UFortGameData, PickupSplineCurve) == 0x0000E0, "Member 'UFortGameData::PickupSplineCurve' has a wrong offset!");
static_assert(offsetof(UFortGameData, PickupLandedSound) == 0x0000E8, "Member 'UFortGameData::PickupLandedSound' has a wrong offset!");
static_assert(offsetof(UFortGameData, AccountInventoryBonusToken) == 0x0000F0, "Member 'UFortGameData::AccountInventoryBonusToken' has a wrong offset!");
static_assert(offsetof(UFortGameData, WorldInventoryBonusToken) == 0x000110, "Member 'UFortGameData::WorldInventoryBonusToken' has a wrong offset!");
static_assert(offsetof(UFortGameData, FounderChatUnlockToken) == 0x000130, "Member 'UFortGameData::FounderChatUnlockToken' has a wrong offset!");
static_assert(offsetof(UFortGameData, RarityData) == 0x000150, "Member 'UFortGameData::RarityData' has a wrong offset!");
static_assert(offsetof(UFortGameData, ScoreStylingData) == 0x000158, "Member 'UFortGameData::ScoreStylingData' has a wrong offset!");
static_assert(offsetof(UFortGameData, ItemCategories) == 0x000160, "Member 'UFortGameData::ItemCategories' has a wrong offset!");
static_assert(offsetof(UFortGameData, QuickBarDefinitions) == 0x000168, "Member 'UFortGameData::QuickBarDefinitions' has a wrong offset!");
static_assert(offsetof(UFortGameData, AutoEquipTags) == 0x000188, "Member 'UFortGameData::AutoEquipTags' has a wrong offset!");
static_assert(offsetof(UFortGameData, AutoEquipTagContainer) == 0x000198, "Member 'UFortGameData::AutoEquipTagContainer' has a wrong offset!");
static_assert(offsetof(UFortGameData, BuildingFullHealthFlashColor) == 0x0001B8, "Member 'UFortGameData::BuildingFullHealthFlashColor' has a wrong offset!");
static_assert(offsetof(UFortGameData, InvalidEditPatternColor) == 0x0001C8, "Member 'UFortGameData::InvalidEditPatternColor' has a wrong offset!");
static_assert(offsetof(UFortGameData, HighlightColors) == 0x0001D8, "Member 'UFortGameData::HighlightColors' has a wrong offset!");
static_assert(offsetof(UFortGameData, ScoreDisplayFactor) == 0x0002F8, "Member 'UFortGameData::ScoreDisplayFactor' has a wrong offset!");
static_assert(offsetof(UFortGameData, StatMappings) == 0x000300, "Member 'UFortGameData::StatMappings' has a wrong offset!");
static_assert(offsetof(UFortGameData, ScoreMultiplierDataTable) == 0x000310, "Member 'UFortGameData::ScoreMultiplierDataTable' has a wrong offset!");
static_assert(offsetof(UFortGameData, ScoreDivisor) == 0x000318, "Member 'UFortGameData::ScoreDivisor' has a wrong offset!");
static_assert(offsetof(UFortGameData, XPMult) == 0x00031C, "Member 'UFortGameData::XPMult' has a wrong offset!");
static_assert(offsetof(UFortGameData, GroupScoreRates) == 0x000320, "Member 'UFortGameData::GroupScoreRates' has a wrong offset!");
static_assert(offsetof(UFortGameData, ScoreToXPLinearRate) == 0x000334, "Member 'UFortGameData::ScoreToXPLinearRate' has a wrong offset!");
static_assert(offsetof(UFortGameData, LinearEnd) == 0x000338, "Member 'UFortGameData::LinearEnd' has a wrong offset!");
static_assert(offsetof(UFortGameData, XpPerAccountLevel) == 0x00033C, "Member 'UFortGameData::XpPerAccountLevel' has a wrong offset!");
static_assert(offsetof(UFortGameData, CriticalMatch_XpBonusPercent) == 0x000340, "Member 'UFortGameData::CriticalMatch_XpBonusPercent' has a wrong offset!");
static_assert(offsetof(UFortGameData, PersonalBoost_XpBonusPercent) == 0x000344, "Member 'UFortGameData::PersonalBoost_XpBonusPercent' has a wrong offset!");
static_assert(offsetof(UFortGameData, GroupBoost_XpBonusPercent) == 0x000348, "Member 'UFortGameData::GroupBoost_XpBonusPercent' has a wrong offset!");
static_assert(offsetof(UFortGameData, GroupBoost_BuffMultiplier) == 0x00034C, "Member 'UFortGameData::GroupBoost_BuffMultiplier' has a wrong offset!");
static_assert(offsetof(UFortGameData, Rest_XpBonusPercent) == 0x000350, "Member 'UFortGameData::Rest_XpBonusPercent' has a wrong offset!");
static_assert(offsetof(UFortGameData, LoadingScreenSoundMix) == 0x000358, "Member 'UFortGameData::LoadingScreenSoundMix' has a wrong offset!");
static_assert(offsetof(UFortGameData, BaseSoundMix) == 0x000360, "Member 'UFortGameData::BaseSoundMix' has a wrong offset!");
static_assert(offsetof(UFortGameData, AbilityTargetingActorBlueprintClass) == 0x000368, "Member 'UFortGameData::AbilityTargetingActorBlueprintClass' has a wrong offset!");
static_assert(offsetof(UFortGameData, HarvestingTools) == 0x000370, "Member 'UFortGameData::HarvestingTools' has a wrong offset!");
static_assert(offsetof(UFortGameData, AthenaHarvestingToolsToPreload) == 0x000380, "Member 'UFortGameData::AthenaHarvestingToolsToPreload' has a wrong offset!");
static_assert(offsetof(UFortGameData, IconKeyList) == 0x000390, "Member 'UFortGameData::IconKeyList' has a wrong offset!");
static_assert(offsetof(UFortGameData, IconKeyListPS4) == 0x0003A0, "Member 'UFortGameData::IconKeyListPS4' has a wrong offset!");
static_assert(offsetof(UFortGameData, IconKeyListXboxOne) == 0x0003B0, "Member 'UFortGameData::IconKeyListXboxOne' has a wrong offset!");
static_assert(offsetof(UFortGameData, SubGameInfo) == 0x0003C0, "Member 'UFortGameData::SubGameInfo' has a wrong offset!");
static_assert(offsetof(UFortGameData, PlacementActorUsedTags) == 0x0003E0, "Member 'UFortGameData::PlacementActorUsedTags' has a wrong offset!");
static_assert(offsetof(UFortGameData, DefaultPlayerSpawnPadPlacementData) == 0x000400, "Member 'UFortGameData::DefaultPlayerSpawnPadPlacementData' has a wrong offset!");
static_assert(offsetof(UFortGameData, DefaultBackpackCharacterPart) == 0x000450, "Member 'UFortGameData::DefaultBackpackCharacterPart' has a wrong offset!");
static_assert(offsetof(UFortGameData, DefaultCharacterParts) == 0x000470, "Member 'UFortGameData::DefaultCharacterParts' has a wrong offset!");
static_assert(offsetof(UFortGameData, AIGoalManagerClass) == 0x000480, "Member 'UFortGameData::AIGoalManagerClass' has a wrong offset!");
static_assert(offsetof(UFortGameData, SharedMissionListsClass) == 0x000488, "Member 'UFortGameData::SharedMissionListsClass' has a wrong offset!");
static_assert(offsetof(UFortGameData, QueuedAnnouncementPauseTimes) == 0x000490, "Member 'UFortGameData::QueuedAnnouncementPauseTimes' has a wrong offset!");
static_assert(offsetof(UFortGameData, WeakSpotEnabledTimeoutHandle) == 0x0004A0, "Member 'UFortGameData::WeakSpotEnabledTimeoutHandle' has a wrong offset!");
static_assert(offsetof(UFortGameData, BuildingStructuralCollapseDelay) == 0x0004B0, "Member 'UFortGameData::BuildingStructuralCollapseDelay' has a wrong offset!");
static_assert(offsetof(UFortGameData, BuildingStructuralCollapseDelayVariance) == 0x0004B4, "Member 'UFortGameData::BuildingStructuralCollapseDelayVariance' has a wrong offset!");
static_assert(offsetof(UFortGameData, BuildingStructuralCollapseCellDistAdditiveDelay) == 0x0004B8, "Member 'UFortGameData::BuildingStructuralCollapseCellDistAdditiveDelay' has a wrong offset!");
static_assert(offsetof(UFortGameData, BuildingStructuralCollapseCellDistAdditiveDelayVariance) == 0x0004BC, "Member 'UFortGameData::BuildingStructuralCollapseCellDistAdditiveDelayVariance' has a wrong offset!");
static_assert(offsetof(UFortGameData, EditModeCancelDistance) == 0x0004C0, "Member 'UFortGameData::EditModeCancelDistance' has a wrong offset!");
static_assert(offsetof(UFortGameData, BuildingExcessDamageRewardTimeoutHandle) == 0x0004C8, "Member 'UFortGameData::BuildingExcessDamageRewardTimeoutHandle' has a wrong offset!");
static_assert(offsetof(UFortGameData, BuildingCostHandles) == 0x0004D8, "Member 'UFortGameData::BuildingCostHandles' has a wrong offset!");
static_assert(offsetof(UFortGameData, BuildingDeconCostMultHandles) == 0x000518, "Member 'UFortGameData::BuildingDeconCostMultHandles' has a wrong offset!");
static_assert(offsetof(UFortGameData, PlayerBuildingDeconCostMultHandles) == 0x000558, "Member 'UFortGameData::PlayerBuildingDeconCostMultHandles' has a wrong offset!");
static_assert(offsetof(UFortGameData, BuildingInitialHealthPercentHandles) == 0x000598, "Member 'UFortGameData::BuildingInitialHealthPercentHandles' has a wrong offset!");
static_assert(offsetof(UFortGameData, BuildingRepairCostMultiplierHandles) == 0x0005D8, "Member 'UFortGameData::BuildingRepairCostMultiplierHandles' has a wrong offset!");
static_assert(offsetof(UFortGameData, FORTAttributeToPowerMultiplier) == 0x000618, "Member 'UFortGameData::FORTAttributeToPowerMultiplier' has a wrong offset!");
static_assert(offsetof(UFortGameData, BuildingBreakAnimDurationHandles) == 0x000620, "Member 'UFortGameData::BuildingBreakAnimDurationHandles' has a wrong offset!");
static_assert(offsetof(UFortGameData, BuildingDestroyAnimDurationHandles) == 0x000660, "Member 'UFortGameData::BuildingDestroyAnimDurationHandles' has a wrong offset!");
static_assert(offsetof(UFortGameData, BuildingPlacementAnimDurationHandles) == 0x0006A0, "Member 'UFortGameData::BuildingPlacementAnimDurationHandles' has a wrong offset!");
static_assert(offsetof(UFortGameData, BuildingCritDamagePctHandles) == 0x0006E0, "Member 'UFortGameData::BuildingCritDamagePctHandles' has a wrong offset!");
static_assert(offsetof(UFortGameData, BuildingCritDestroyAnimScaleCapHandles) == 0x000720, "Member 'UFortGameData::BuildingCritDestroyAnimScaleCapHandles' has a wrong offset!");
static_assert(offsetof(UFortGameData, StencilDefinitionCollection) == 0x000760, "Member 'UFortGameData::StencilDefinitionCollection' has a wrong offset!");
static_assert(offsetof(UFortGameData, BuildingConstructionSounds) == 0x000780, "Member 'UFortGameData::BuildingConstructionSounds' has a wrong offset!");
static_assert(offsetof(UFortGameData, GenericBuildingDeathSounds) == 0x000840, "Member 'UFortGameData::GenericBuildingDeathSounds' has a wrong offset!");
static_assert(offsetof(UFortGameData, PlayerBuiltBuildingDeathSounds) == 0x000900, "Member 'UFortGameData::PlayerBuiltBuildingDeathSounds' has a wrong offset!");
static_assert(offsetof(UFortGameData, ResourceNames) == 0x0009C0, "Member 'UFortGameData::ResourceNames' has a wrong offset!");
static_assert(offsetof(UFortGameData, BuildingTypeNames) == 0x000A20, "Member 'UFortGameData::BuildingTypeNames' has a wrong offset!");
static_assert(offsetof(UFortGameData, StoneItemDefinition) == 0x000B40, "Member 'UFortGameData::StoneItemDefinition' has a wrong offset!");
static_assert(offsetof(UFortGameData, WoodItemDefinition) == 0x000B48, "Member 'UFortGameData::WoodItemDefinition' has a wrong offset!");
static_assert(offsetof(UFortGameData, MetalItemDefinition) == 0x000B50, "Member 'UFortGameData::MetalItemDefinition' has a wrong offset!");
static_assert(offsetof(UFortGameData, PistolAmmoItemDefinition) == 0x000B58, "Member 'UFortGameData::PistolAmmoItemDefinition' has a wrong offset!");
static_assert(offsetof(UFortGameData, PermaniteItemDefinition) == 0x000B60, "Member 'UFortGameData::PermaniteItemDefinition' has a wrong offset!");
static_assert(offsetof(UFortGameData, ShotgunAmmoItemDefinition) == 0x000B68, "Member 'UFortGameData::ShotgunAmmoItemDefinition' has a wrong offset!");
static_assert(offsetof(UFortGameData, RifleAmmoItemDefinition) == 0x000B70, "Member 'UFortGameData::RifleAmmoItemDefinition' has a wrong offset!");
static_assert(offsetof(UFortGameData, AssaultAmmoItemDefinition) == 0x000B78, "Member 'UFortGameData::AssaultAmmoItemDefinition' has a wrong offset!");
static_assert(offsetof(UFortGameData, EnergyAmmoItemDefinition) == 0x000B80, "Member 'UFortGameData::EnergyAmmoItemDefinition' has a wrong offset!");
static_assert(offsetof(UFortGameData, BluGloItemDefinition) == 0x000B88, "Member 'UFortGameData::BluGloItemDefinition' has a wrong offset!");
static_assert(offsetof(UFortGameData, CriticalMissionRewardItemDefinition) == 0x000B90, "Member 'UFortGameData::CriticalMissionRewardItemDefinition' has a wrong offset!");
static_assert(offsetof(UFortGameData, ScoreBonusMultiplerItemDefinition) == 0x000B98, "Member 'UFortGameData::ScoreBonusMultiplerItemDefinition' has a wrong offset!");
static_assert(offsetof(UFortGameData, BackpackItemDefinition) == 0x000BA0, "Member 'UFortGameData::BackpackItemDefinition' has a wrong offset!");
static_assert(offsetof(UFortGameData, MissionRewardPackItemDefinition) == 0x000BC0, "Member 'UFortGameData::MissionRewardPackItemDefinition' has a wrong offset!");
static_assert(offsetof(UFortGameData, OutpostRefundDialogTitle) == 0x000BE0, "Member 'UFortGameData::OutpostRefundDialogTitle' has a wrong offset!");
static_assert(offsetof(UFortGameData, OutpostRefundDialogText) == 0x000BF8, "Member 'UFortGameData::OutpostRefundDialogText' has a wrong offset!");
static_assert(offsetof(UFortGameData, OutpostRefundButtonText) == 0x000C10, "Member 'UFortGameData::OutpostRefundButtonText' has a wrong offset!");
static_assert(offsetof(UFortGameData, GamepadSettingsDefault) == 0x000C28, "Member 'UFortGameData::GamepadSettingsDefault' has a wrong offset!");
static_assert(offsetof(UFortGameData, GamepadSettingsPS4) == 0x000C48, "Member 'UFortGameData::GamepadSettingsPS4' has a wrong offset!");
static_assert(offsetof(UFortGameData, GamepadSettingsXboxOne) == 0x000C68, "Member 'UFortGameData::GamepadSettingsXboxOne' has a wrong offset!");
static_assert(offsetof(UFortGameData, LootTierDataTables) == 0x000C88, "Member 'UFortGameData::LootTierDataTables' has a wrong offset!");
static_assert(offsetof(UFortGameData, LootPackageDataTables) == 0x000C98, "Member 'UFortGameData::LootPackageDataTables' has a wrong offset!");
static_assert(offsetof(UFortGameData, WaveSetCollectionData) == 0x000CA8, "Member 'UFortGameData::WaveSetCollectionData' has a wrong offset!");
static_assert(offsetof(UFortGameData, WaveSetData) == 0x000CC8, "Member 'UFortGameData::WaveSetData' has a wrong offset!");
static_assert(offsetof(UFortGameData, ModifierSetData) == 0x000CE8, "Member 'UFortGameData::ModifierSetData' has a wrong offset!");
static_assert(offsetof(UFortGameData, WaveSetCollectionLootData) == 0x000D08, "Member 'UFortGameData::WaveSetCollectionLootData' has a wrong offset!");
static_assert(offsetof(UFortGameData, PlayerStatClampingData) == 0x000D28, "Member 'UFortGameData::PlayerStatClampingData' has a wrong offset!");
static_assert(offsetof(UFortGameData, NonGameplayRelevantTags) == 0x000D48, "Member 'UFortGameData::NonGameplayRelevantTags' has a wrong offset!");
static_assert(offsetof(UFortGameData, CraftingTimeTable) == 0x000D68, "Member 'UFortGameData::CraftingTimeTable' has a wrong offset!");
static_assert(offsetof(UFortGameData, DefaultCraftingSuccessSound) == 0x000D88, "Member 'UFortGameData::DefaultCraftingSuccessSound' has a wrong offset!");
static_assert(offsetof(UFortGameData, TeamStatsGameplayEffect) == 0x000DA8, "Member 'UFortGameData::TeamStatsGameplayEffect' has a wrong offset!");
static_assert(offsetof(UFortGameData, DailyRewardSchedules) == 0x000DB0, "Member 'UFortGameData::DailyRewardSchedules' has a wrong offset!");
static_assert(offsetof(UFortGameData, ExpeditionCriteriaRequirementsData) == 0x000DB8, "Member 'UFortGameData::ExpeditionCriteriaRequirementsData' has a wrong offset!");
static_assert(offsetof(UFortGameData, DifficultyData) == 0x000DD8, "Member 'UFortGameData::DifficultyData' has a wrong offset!");
static_assert(offsetof(UFortGameData, LowXpConningValue) == 0x000DE0, "Member 'UFortGameData::LowXpConningValue' has a wrong offset!");
static_assert(offsetof(UFortGameData, VeryLowXpConningValue) == 0x000DE4, "Member 'UFortGameData::VeryLowXpConningValue' has a wrong offset!");
static_assert(offsetof(UFortGameData, NoXpConningValue) == 0x000DE8, "Member 'UFortGameData::NoXpConningValue' has a wrong offset!");
static_assert(offsetof(UFortGameData, FullXpConningMsg) == 0x000DF0, "Member 'UFortGameData::FullXpConningMsg' has a wrong offset!");
static_assert(offsetof(UFortGameData, LowXpConningMsg) == 0x000E08, "Member 'UFortGameData::LowXpConningMsg' has a wrong offset!");
static_assert(offsetof(UFortGameData, VeryLowXpConningMsg) == 0x000E20, "Member 'UFortGameData::VeryLowXpConningMsg' has a wrong offset!");
static_assert(offsetof(UFortGameData, NoXpConningMsg) == 0x000E38, "Member 'UFortGameData::NoXpConningMsg' has a wrong offset!");
static_assert(offsetof(UFortGameData, LootQuotaData) == 0x000E50, "Member 'UFortGameData::LootQuotaData' has a wrong offset!");
static_assert(offsetof(UFortGameData, LootLevelData) == 0x000E58, "Member 'UFortGameData::LootLevelData' has a wrong offset!");
static_assert(offsetof(UFortGameData, SurfaceRatioBySurfaceCategoryData) == 0x000E60, "Member 'UFortGameData::SurfaceRatioBySurfaceCategoryData' has a wrong offset!");
static_assert(offsetof(UFortGameData, SurfaceRatioByAffiliationData) == 0x000E68, "Member 'UFortGameData::SurfaceRatioByAffiliationData' has a wrong offset!");
static_assert(offsetof(UFortGameData, QuestObjectiveStatData) == 0x000E70, "Member 'UFortGameData::QuestObjectiveStatData' has a wrong offset!");
static_assert(offsetof(UFortGameData, XPAccountLevelsTable) == 0x000E78, "Member 'UFortGameData::XPAccountLevelsTable' has a wrong offset!");
static_assert(offsetof(UFortGameData, XPHeroLevelsTable) == 0x000E80, "Member 'UFortGameData::XPHeroLevelsTable' has a wrong offset!");
static_assert(offsetof(UFortGameData, XPAccountItemLevelsTable) == 0x000E88, "Member 'UFortGameData::XPAccountItemLevelsTable' has a wrong offset!");
static_assert(offsetof(UFortGameData, XPAccountItemRewardsTable) == 0x000E90, "Member 'UFortGameData::XPAccountItemRewardsTable' has a wrong offset!");
static_assert(offsetof(UFortGameData, XPConningTable) == 0x000E98, "Member 'UFortGameData::XPConningTable' has a wrong offset!");
static_assert(offsetof(UFortGameData, TeamIdentifications) == 0x000EA0, "Member 'UFortGameData::TeamIdentifications' has a wrong offset!");
static_assert(offsetof(UFortGameData, QuestPackInfos) == 0x0011E0, "Member 'UFortGameData::QuestPackInfos' has a wrong offset!");
static_assert(offsetof(UFortGameData, OnboardingQuestItemDefinition) == 0x0011F0, "Member 'UFortGameData::OnboardingQuestItemDefinition' has a wrong offset!");
static_assert(offsetof(UFortGameData, OnboardingCompleteZoneObjective) == 0x0011F8, "Member 'UFortGameData::OnboardingCompleteZoneObjective' has a wrong offset!");
static_assert(offsetof(UFortGameData, QuestAchievementData) == 0x001208, "Member 'UFortGameData::QuestAchievementData' has a wrong offset!");
static_assert(offsetof(UFortGameData, LoadingScreenBackground_Generic) == 0x001228, "Member 'UFortGameData::LoadingScreenBackground_Generic' has a wrong offset!");
static_assert(offsetof(UFortGameData, LoadingScreenEABackground) == 0x0012B8, "Member 'UFortGameData::LoadingScreenEABackground' has a wrong offset!");
static_assert(offsetof(UFortGameData, ConditionalFoundationQuota) == 0x001348, "Member 'UFortGameData::ConditionalFoundationQuota' has a wrong offset!");
static_assert(offsetof(UFortGameData, SkillPointItemDef) == 0x001358, "Member 'UFortGameData::SkillPointItemDef' has a wrong offset!");
static_assert(offsetof(UFortGameData, ResearchPointItemDef) == 0x001360, "Member 'UFortGameData::ResearchPointItemDef' has a wrong offset!");
static_assert(offsetof(UFortGameData, MissionGenerationData) == 0x001368, "Member 'UFortGameData::MissionGenerationData' has a wrong offset!");
static_assert(offsetof(UFortGameData, CheatInventoryItems) == 0x001388, "Member 'UFortGameData::CheatInventoryItems' has a wrong offset!");
static_assert(offsetof(UFortGameData, TheaterMapViewerClass) == 0x001398, "Member 'UFortGameData::TheaterMapViewerClass' has a wrong offset!");
static_assert(offsetof(UFortGameData, MissionAlertCategories) == 0x0013B8, "Member 'UFortGameData::MissionAlertCategories' has a wrong offset!");
static_assert(offsetof(UFortGameData, MissionAlertSpreadDatas) == 0x0013D8, "Member 'UFortGameData::MissionAlertSpreadDatas' has a wrong offset!");
static_assert(offsetof(UFortGameData, MissionAlerts) == 0x0013F8, "Member 'UFortGameData::MissionAlerts' has a wrong offset!");
static_assert(offsetof(UFortGameData, MyFortData) == 0x001418, "Member 'UFortGameData::MyFortData' has a wrong offset!");
static_assert(offsetof(UFortGameData, HomebaseManager) == 0x001438, "Member 'UFortGameData::HomebaseManager' has a wrong offset!");
static_assert(offsetof(UFortGameData, CollectionBookData) == 0x001458, "Member 'UFortGameData::CollectionBookData' has a wrong offset!");
static_assert(offsetof(UFortGameData, SurvivorData) == 0x001478, "Member 'UFortGameData::SurvivorData' has a wrong offset!");
static_assert(offsetof(UFortGameData, OutpostData) == 0x001498, "Member 'UFortGameData::OutpostData' has a wrong offset!");
static_assert(offsetof(UFortGameData, AttributeLookupTable) == 0x0014B8, "Member 'UFortGameData::AttributeLookupTable' has a wrong offset!");
static_assert(offsetof(UFortGameData, AttributeCategories) == 0x0014D8, "Member 'UFortGameData::AttributeCategories' has a wrong offset!");
static_assert(offsetof(UFortGameData, UITagDataTable) == 0x0014F8, "Member 'UFortGameData::UITagDataTable' has a wrong offset!");
static_assert(offsetof(UFortGameData, PowerPointDisplayMultiplier) == 0x001518, "Member 'UFortGameData::PowerPointDisplayMultiplier' has a wrong offset!");
static_assert(offsetof(UFortGameData, PowerPointToRatingConversion) == 0x001520, "Member 'UFortGameData::PowerPointToRatingConversion' has a wrong offset!");
static_assert(offsetof(UFortGameData, HUDVisibilityGameplayTags) == 0x001530, "Member 'UFortGameData::HUDVisibilityGameplayTags' has a wrong offset!");
static_assert(offsetof(UFortGameData, DamageNumbersActorClass) == 0x001540, "Member 'UFortGameData::DamageNumbersActorClass' has a wrong offset!");
static_assert(offsetof(UFortGameData, CrackEffectBlueprintClass) == 0x001560, "Member 'UFortGameData::CrackEffectBlueprintClass' has a wrong offset!");
static_assert(offsetof(UFortGameData, PickupEffectBlueprintClass) == 0x001580, "Member 'UFortGameData::PickupEffectBlueprintClass' has a wrong offset!");
static_assert(offsetof(UFortGameData, GameDifficultyRowPIE) == 0x0015A0, "Member 'UFortGameData::GameDifficultyRowPIE' has a wrong offset!");
static_assert(offsetof(UFortGameData, AIDirectors) == 0x0015B0, "Member 'UFortGameData::AIDirectors' has a wrong offset!");
static_assert(offsetof(UFortGameData, AIDirectorIndex) == 0x0015C0, "Member 'UFortGameData::AIDirectorIndex' has a wrong offset!");
static_assert(offsetof(UFortGameData, AlternateBalanceAIDirectorIndex) == 0x0015C4, "Member 'UFortGameData::AlternateBalanceAIDirectorIndex' has a wrong offset!");
static_assert(offsetof(UFortGameData, FeedbackManagerClass) == 0x0015C8, "Member 'UFortGameData::FeedbackManagerClass' has a wrong offset!");
static_assert(offsetof(UFortGameData, UIFeedbackBank) == 0x0015E8, "Member 'UFortGameData::UIFeedbackBank' has a wrong offset!");
static_assert(offsetof(UFortGameData, TagTableManager) == 0x001608, "Member 'UFortGameData::TagTableManager' has a wrong offset!");
static_assert(offsetof(UFortGameData, StatEventManagerClass) == 0x001610, "Member 'UFortGameData::StatEventManagerClass' has a wrong offset!");
static_assert(offsetof(UFortGameData, DefaultHero) == 0x001630, "Member 'UFortGameData::DefaultHero' has a wrong offset!");
static_assert(offsetof(UFortGameData, DefaultAthenaHeroes) == 0x001650, "Member 'UFortGameData::DefaultAthenaHeroes' has a wrong offset!");
static_assert(offsetof(UFortGameData, DefaultInventoryList) == 0x001660, "Member 'UFortGameData::DefaultInventoryList' has a wrong offset!");
static_assert(offsetof(UFortGameData, FastLoadDefaultInventoryList) == 0x001670, "Member 'UFortGameData::FastLoadDefaultInventoryList' has a wrong offset!");
static_assert(offsetof(UFortGameData, ThreatVisualsManager) == 0x001680, "Member 'UFortGameData::ThreatVisualsManager' has a wrong offset!");
static_assert(offsetof(UFortGameData, WindManager) == 0x0016A0, "Member 'UFortGameData::WindManager' has a wrong offset!");
static_assert(offsetof(UFortGameData, EditToolItem) == 0x0016C0, "Member 'UFortGameData::EditToolItem' has a wrong offset!");
static_assert(offsetof(UFortGameData, GenericPlayerAbilitySet) == 0x0016E0, "Member 'UFortGameData::GenericPlayerAbilitySet' has a wrong offset!");
static_assert(offsetof(UFortGameData, GenericTrapAbilitySet) == 0x001700, "Member 'UFortGameData::GenericTrapAbilitySet' has a wrong offset!");
static_assert(offsetof(UFortGameData, AbilityTagRelationships) == 0x001720, "Member 'UFortGameData::AbilityTagRelationships' has a wrong offset!");
static_assert(offsetof(UFortGameData, EnvironmentDamageTemplateGE) == 0x001730, "Member 'UFortGameData::EnvironmentDamageTemplateGE' has a wrong offset!");
static_assert(offsetof(UFortGameData, FallingDamageTemplateGE) == 0x001750, "Member 'UFortGameData::FallingDamageTemplateGE' has a wrong offset!");
static_assert(offsetof(UFortGameData, HealingTemplateGE) == 0x001770, "Member 'UFortGameData::HealingTemplateGE' has a wrong offset!");
static_assert(offsetof(UFortGameData, FatalDamageTemplateGE) == 0x001790, "Member 'UFortGameData::FatalDamageTemplateGE' has a wrong offset!");
static_assert(offsetof(UFortGameData, SquadMemberStatBonusGE) == 0x0017B0, "Member 'UFortGameData::SquadMemberStatBonusGE' has a wrong offset!");
static_assert(offsetof(UFortGameData, TeamTrapBonusGE) == 0x0017D0, "Member 'UFortGameData::TeamTrapBonusGE' has a wrong offset!");
static_assert(offsetof(UFortGameData, SquadMemberStatBonusMultiplier) == 0x0017F0, "Member 'UFortGameData::SquadMemberStatBonusMultiplier' has a wrong offset!");
static_assert(offsetof(UFortGameData, BASEClass) == 0x0017F8, "Member 'UFortGameData::BASEClass' has a wrong offset!");
static_assert(offsetof(UFortGameData, HeroManagementWidgetClass) == 0x001818, "Member 'UFortGameData::HeroManagementWidgetClass' has a wrong offset!");
static_assert(offsetof(UFortGameData, PlayerChoiceWidgetClass) == 0x001838, "Member 'UFortGameData::PlayerChoiceWidgetClass' has a wrong offset!");
static_assert(offsetof(UFortGameData, RewardChoiceWidgetClass) == 0x001858, "Member 'UFortGameData::RewardChoiceWidgetClass' has a wrong offset!");
static_assert(offsetof(UFortGameData, HeroNotifcationHandlerClass) == 0x001878, "Member 'UFortGameData::HeroNotifcationHandlerClass' has a wrong offset!");
static_assert(offsetof(UFortGameData, QuestNotificationHandlerClass) == 0x001898, "Member 'UFortGameData::QuestNotificationHandlerClass' has a wrong offset!");
static_assert(offsetof(UFortGameData, BasicNotificationClass) == 0x0018B8, "Member 'UFortGameData::BasicNotificationClass' has a wrong offset!");
static_assert(offsetof(UFortGameData, FriendNotificationClass) == 0x0018D8, "Member 'UFortGameData::FriendNotificationClass' has a wrong offset!");
static_assert(offsetof(UFortGameData, TwitchNotificationClass) == 0x0018F8, "Member 'UFortGameData::TwitchNotificationClass' has a wrong offset!");
static_assert(offsetof(UFortGameData, FriendFeedbackSounds) == 0x001918, "Member 'UFortGameData::FriendFeedbackSounds' has a wrong offset!");
static_assert(offsetof(UFortGameData, HealthScreenDamagePostProcessMat) == 0x001930, "Member 'UFortGameData::HealthScreenDamagePostProcessMat' has a wrong offset!");
static_assert(offsetof(UFortGameData, ZoneModifiersAnnouncementClass) == 0x001950, "Member 'UFortGameData::ZoneModifiersAnnouncementClass' has a wrong offset!");
static_assert(offsetof(UFortGameData, SessionXPCurveTable) == 0x001970, "Member 'UFortGameData::SessionXPCurveTable' has a wrong offset!");
static_assert(offsetof(UFortGameData, TieredWavesDefenseReqTable) == 0x001990, "Member 'UFortGameData::TieredWavesDefenseReqTable' has a wrong offset!");
static_assert(offsetof(UFortGameData, FallbackDeathParticles) == 0x0019B0, "Member 'UFortGameData::FallbackDeathParticles' has a wrong offset!");
static_assert(offsetof(UFortGameData, WallFallbackDeathParticles) == 0x0019D0, "Member 'UFortGameData::WallFallbackDeathParticles' has a wrong offset!");
static_assert(offsetof(UFortGameData, FallbackConstructedEffect) == 0x0019F0, "Member 'UFortGameData::FallbackConstructedEffect' has a wrong offset!");
static_assert(offsetof(UFortGameData, RepairEffect) == 0x001A10, "Member 'UFortGameData::RepairEffect' has a wrong offset!");
static_assert(offsetof(UFortGameData, ConstructionCompleteSound) == 0x001A30, "Member 'UFortGameData::ConstructionCompleteSound' has a wrong offset!");
static_assert(offsetof(UFortGameData, DamageMaterial) == 0x001A50, "Member 'UFortGameData::DamageMaterial' has a wrong offset!");
static_assert(offsetof(UFortGameData, BounceCurve) == 0x001A70, "Member 'UFortGameData::BounceCurve' has a wrong offset!");
static_assert(offsetof(UFortGameData, BlueprintParentMaterial) == 0x001A90, "Member 'UFortGameData::BlueprintParentMaterial' has a wrong offset!");
static_assert(offsetof(UFortGameData, EditCurve) == 0x001AB0, "Member 'UFortGameData::EditCurve' has a wrong offset!");
static_assert(offsetof(UFortGameData, BlueprintDamageCurve) == 0x001AD0, "Member 'UFortGameData::BlueprintDamageCurve' has a wrong offset!");
static_assert(offsetof(UFortGameData, FullHealthAnimCurve) == 0x001AF0, "Member 'UFortGameData::FullHealthAnimCurve' has a wrong offset!");
static_assert(offsetof(UFortGameData, RepairAnimCurve) == 0x001B10, "Member 'UFortGameData::RepairAnimCurve' has a wrong offset!");
static_assert(offsetof(UFortGameData, DynamicLODEffectCurve) == 0x001B30, "Member 'UFortGameData::DynamicLODEffectCurve' has a wrong offset!");
static_assert(offsetof(UFortGameData, InteractFullBounceCurve) == 0x001B50, "Member 'UFortGameData::InteractFullBounceCurve' has a wrong offset!");
static_assert(offsetof(UFortGameData, InteractFullBounceNormalCurve) == 0x001B70, "Member 'UFortGameData::InteractFullBounceNormalCurve' has a wrong offset!");
static_assert(offsetof(UFortGameData, InteractEmptyBounceCurve) == 0x001B90, "Member 'UFortGameData::InteractEmptyBounceCurve' has a wrong offset!");
static_assert(offsetof(UFortGameData, InteractEmptyBounceNormalCurve) == 0x001BB0, "Member 'UFortGameData::InteractEmptyBounceNormalCurve' has a wrong offset!");
static_assert(offsetof(UFortGameData, ExpeditionUnlockedTag) == 0x001BD0, "Member 'UFortGameData::ExpeditionUnlockedTag' has a wrong offset!");
static_assert(offsetof(UFortGameData, ExpeditionVehicleTags) == 0x001BD8, "Member 'UFortGameData::ExpeditionVehicleTags' has a wrong offset!");
static_assert(offsetof(UFortGameData, ExpeditionMasterWidgetClass) == 0x001BF8, "Member 'UFortGameData::ExpeditionMasterWidgetClass' has a wrong offset!");
static_assert(offsetof(UFortGameData, DailyMissionAlertQuota) == 0x001C18, "Member 'UFortGameData::DailyMissionAlertQuota' has a wrong offset!");
static_assert(offsetof(UFortGameData, OnlineAccountTexts) == 0x001C20, "Member 'UFortGameData::OnlineAccountTexts' has a wrong offset!");

// Class FortniteGame.FortQueryTest_DecoyDistance
// 0x0008 (0x01C8 - 0x01C0)
class UFortQueryTest_DecoyDistance final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           DistanceTo;                                        // 0x01C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_DecoyDistance">();
	}
	static class UFortQueryTest_DecoyDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_DecoyDistance>();
	}
};
static_assert(alignof(UFortQueryTest_DecoyDistance) == 0x000008, "Wrong alignment on UFortQueryTest_DecoyDistance");
static_assert(sizeof(UFortQueryTest_DecoyDistance) == 0x0001C8, "Wrong size on UFortQueryTest_DecoyDistance");
static_assert(offsetof(UFortQueryTest_DecoyDistance, DistanceTo) == 0x0001C0, "Member 'UFortQueryTest_DecoyDistance::DistanceTo' has a wrong offset!");

// Class FortniteGame.FortPlayerDBNORevivedParams
// 0x0010 (0x0038 - 0x0028)
class UFortPlayerDBNORevivedParams final : public UFortMissionEventParams
{
public:
	class AFortPlayerPawn*                        RevivedPlayer;                                     // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            RevivedBy;                                         // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BreakParams(class AFortPlayerPawn** _RevivedPlayer, class AController** _RevivedBy);
	void SetParams(class AFortPlayerPawn* _RevivedPlayer, class AController* _RevivedBy, class UFortPlayerDBNORevivedParams** ThisParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerDBNORevivedParams">();
	}
	static class UFortPlayerDBNORevivedParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPlayerDBNORevivedParams>();
	}
};
static_assert(alignof(UFortPlayerDBNORevivedParams) == 0x000008, "Wrong alignment on UFortPlayerDBNORevivedParams");
static_assert(sizeof(UFortPlayerDBNORevivedParams) == 0x000038, "Wrong size on UFortPlayerDBNORevivedParams");
static_assert(offsetof(UFortPlayerDBNORevivedParams, RevivedPlayer) == 0x000028, "Member 'UFortPlayerDBNORevivedParams::RevivedPlayer' has a wrong offset!");
static_assert(offsetof(UFortPlayerDBNORevivedParams, RevivedBy) == 0x000030, "Member 'UFortPlayerDBNORevivedParams::RevivedBy' has a wrong offset!");

// Class FortniteGame.FortDayPhaseChangeParams
// 0x0010 (0x0038 - 0x0028)
class UFortDayPhaseChangeParams final : public UFortMissionEventParams
{
public:
	class AFortTimeOfDayManager*                  LightingAndFogManager;                             // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortDayPhase                                 NewDayPhase;                                       // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BreakParams(class AFortTimeOfDayManager** _LightingAndFogManager, EFortDayPhase* _NewDayPhase);
	void SetParams(class AFortTimeOfDayManager* _LightingAndFogManager, EFortDayPhase _NewDayPhase, class UFortDayPhaseChangeParams** ThisParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDayPhaseChangeParams">();
	}
	static class UFortDayPhaseChangeParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDayPhaseChangeParams>();
	}
};
static_assert(alignof(UFortDayPhaseChangeParams) == 0x000008, "Wrong alignment on UFortDayPhaseChangeParams");
static_assert(sizeof(UFortDayPhaseChangeParams) == 0x000038, "Wrong size on UFortDayPhaseChangeParams");
static_assert(offsetof(UFortDayPhaseChangeParams, LightingAndFogManager) == 0x000028, "Member 'UFortDayPhaseChangeParams::LightingAndFogManager' has a wrong offset!");
static_assert(offsetof(UFortDayPhaseChangeParams, NewDayPhase) == 0x000030, "Member 'UFortDayPhaseChangeParams::NewDayPhase' has a wrong offset!");

// Class FortniteGame.FortLinkedAccountManager
// 0x0018 (0x0040 - 0x0028)
class UFortLinkedAccountManager final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UFortLinkedAccount*>             LinkedAccounts;                                    // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortLinkedAccountManager">();
	}
	static class UFortLinkedAccountManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortLinkedAccountManager>();
	}
};
static_assert(alignof(UFortLinkedAccountManager) == 0x000008, "Wrong alignment on UFortLinkedAccountManager");
static_assert(sizeof(UFortLinkedAccountManager) == 0x000040, "Wrong size on UFortLinkedAccountManager");
static_assert(offsetof(UFortLinkedAccountManager, LinkedAccounts) == 0x000030, "Member 'UFortLinkedAccountManager::LinkedAccounts' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionSetMission
// 0x0010 (0x0038 - 0x0028)
class UFortDifficultyOptionSetMission final : public UDataAsset
{
public:
	TArray<class UFortDifficultyOptionCategoryMission*> MissionOptionsCategories;                          // 0x0028(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionSetMission">();
	}
	static class UFortDifficultyOptionSetMission* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionSetMission>();
	}
};
static_assert(alignof(UFortDifficultyOptionSetMission) == 0x000008, "Wrong alignment on UFortDifficultyOptionSetMission");
static_assert(sizeof(UFortDifficultyOptionSetMission) == 0x000038, "Wrong size on UFortDifficultyOptionSetMission");
static_assert(offsetof(UFortDifficultyOptionSetMission, MissionOptionsCategories) == 0x000028, "Member 'UFortDifficultyOptionSetMission::MissionOptionsCategories' has a wrong offset!");

// Class FortniteGame.FortGameplayMutator
// 0x0008 (0x0390 - 0x0388)
class AFortGameplayMutator : public AInfo
{
public:
	uint8                                         bMutatorActive : 1;                                // 0x0388(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_389[0x7];                                      // 0x0389(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsMutatorActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameplayMutator">();
	}
	static class AFortGameplayMutator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGameplayMutator>();
	}
};
static_assert(alignof(AFortGameplayMutator) == 0x000008, "Wrong alignment on AFortGameplayMutator");
static_assert(sizeof(AFortGameplayMutator) == 0x000390, "Wrong size on AFortGameplayMutator");

// Class FortniteGame.FortQueryTest_GoalBase
// 0x0018 (0x01D8 - 0x01C0)
class UFortQueryTest_GoalBase : public UEnvQueryTest
{
public:
	uint8                                         bScoreEnemies : 1;                                 // 0x01C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bScoreEncounterGoals : 1;                          // 0x01C0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bScoreWorldGoals : 1;                              // 0x01C0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bScoreSpecificAssignments : 1;                     // 0x01C0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1C1[0x7];                                      // 0x01C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFortAIAssignmentIdentifier>    AssignmentIDs;                                     // 0x01C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_GoalBase">();
	}
	static class UFortQueryTest_GoalBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_GoalBase>();
	}
};
static_assert(alignof(UFortQueryTest_GoalBase) == 0x000008, "Wrong alignment on UFortQueryTest_GoalBase");
static_assert(sizeof(UFortQueryTest_GoalBase) == 0x0001D8, "Wrong size on UFortQueryTest_GoalBase");
static_assert(offsetof(UFortQueryTest_GoalBase, AssignmentIDs) == 0x0001C8, "Member 'UFortQueryTest_GoalBase::AssignmentIDs' has a wrong offset!");

// Class FortniteGame.FortPlayerBuiltParams
// 0x0018 (0x0040 - 0x0028)
class UFortPlayerBuiltParams final : public UFortMissionEventParams
{
public:
	class ABuildingActor*                         Building;                                          // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortBuildingType                             BuildingType;                                      // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortPlayerController*                  Builder;                                           // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BreakParams(class ABuildingActor** _Building, EFortBuildingType* _BuildingType, class AFortPlayerController** _Builder);
	void SetParams(class ABuildingActor* _Building, EFortBuildingType _BuildingType, class AFortPlayerController* _Builder, class UFortPlayerBuiltParams** ThisParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerBuiltParams">();
	}
	static class UFortPlayerBuiltParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPlayerBuiltParams>();
	}
};
static_assert(alignof(UFortPlayerBuiltParams) == 0x000008, "Wrong alignment on UFortPlayerBuiltParams");
static_assert(sizeof(UFortPlayerBuiltParams) == 0x000040, "Wrong size on UFortPlayerBuiltParams");
static_assert(offsetof(UFortPlayerBuiltParams, Building) == 0x000028, "Member 'UFortPlayerBuiltParams::Building' has a wrong offset!");
static_assert(offsetof(UFortPlayerBuiltParams, BuildingType) == 0x000030, "Member 'UFortPlayerBuiltParams::BuildingType' has a wrong offset!");
static_assert(offsetof(UFortPlayerBuiltParams, Builder) == 0x000038, "Member 'UFortPlayerBuiltParams::Builder' has a wrong offset!");

// Class FortniteGame.FortBuildingDestroyedParams
// 0x0018 (0x0040 - 0x0028)
class UFortBuildingDestroyedParams final : public UFortMissionEventParams
{
public:
	class ABuildingActor*                         Building;                                          // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortBuildingType                             BuildingType;                                      // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AController*                            Destroyer;                                         // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BreakParams(class ABuildingActor** _Building, EFortBuildingType* _BuildingType, class AController** _Destroyer);
	void SetParams(class ABuildingActor* _Building, EFortBuildingType _BuildingType, class AController* _Destroyer, class UFortBuildingDestroyedParams** ThisParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBuildingDestroyedParams">();
	}
	static class UFortBuildingDestroyedParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBuildingDestroyedParams>();
	}
};
static_assert(alignof(UFortBuildingDestroyedParams) == 0x000008, "Wrong alignment on UFortBuildingDestroyedParams");
static_assert(sizeof(UFortBuildingDestroyedParams) == 0x000040, "Wrong size on UFortBuildingDestroyedParams");
static_assert(offsetof(UFortBuildingDestroyedParams, Building) == 0x000028, "Member 'UFortBuildingDestroyedParams::Building' has a wrong offset!");
static_assert(offsetof(UFortBuildingDestroyedParams, BuildingType) == 0x000030, "Member 'UFortBuildingDestroyedParams::BuildingType' has a wrong offset!");
static_assert(offsetof(UFortBuildingDestroyedParams, Destroyer) == 0x000038, "Member 'UFortBuildingDestroyedParams::Destroyer' has a wrong offset!");

// Class FortniteGame.FortUINotification
// 0x0068 (0x0090 - 0x0028)
class UFortUINotification : public UObject
{
public:
	class FText                                   Title;                                             // 0x0028(0x0018)(BlueprintVisible, BlueprintReadOnly, ExposeOnSpawn, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0040(0x0018)(BlueprintVisible, BlueprintReadOnly, ExposeOnSpawn, NativeAccessSpecifierPublic)
	bool                                          bHasAction;                                        // 0x0058(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortNotificationType                         NotificationType;                                  // 0x0059(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUniqueNetIdRepl                       IdToRepresent;                                     // 0x0060(0x0018)(BlueprintVisible, BlueprintReadOnly, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnNotificationCleared;                             // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearNotification();
	class UUserWidget* CreateWidget(class APlayerController* OwningPlayer);
	class UTexture2D* GetImageOverride();
	void NotificationShown();
	void TakeAction();

	bool ShouldShowNotification() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortUINotification">();
	}
	static class UFortUINotification* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortUINotification>();
	}
};
static_assert(alignof(UFortUINotification) == 0x000008, "Wrong alignment on UFortUINotification");
static_assert(sizeof(UFortUINotification) == 0x000090, "Wrong size on UFortUINotification");
static_assert(offsetof(UFortUINotification, Title) == 0x000028, "Member 'UFortUINotification::Title' has a wrong offset!");
static_assert(offsetof(UFortUINotification, Description) == 0x000040, "Member 'UFortUINotification::Description' has a wrong offset!");
static_assert(offsetof(UFortUINotification, bHasAction) == 0x000058, "Member 'UFortUINotification::bHasAction' has a wrong offset!");
static_assert(offsetof(UFortUINotification, NotificationType) == 0x000059, "Member 'UFortUINotification::NotificationType' has a wrong offset!");
static_assert(offsetof(UFortUINotification, IdToRepresent) == 0x000060, "Member 'UFortUINotification::IdToRepresent' has a wrong offset!");
static_assert(offsetof(UFortUINotification, OnNotificationCleared) == 0x000078, "Member 'UFortUINotification::OnNotificationCleared' has a wrong offset!");

// Class FortniteGame.FortBuildingEditedParams
// 0x0020 (0x0048 - 0x0028)
class UFortBuildingEditedParams final : public UFortMissionEventParams
{
public:
	class ABuildingActor*                         OriginalBuilding;                                  // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABuildingActor*                         NewBuilding;                                       // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortBuildingType                             BuildingType;                                      // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortPlayerController*                  Editor;                                            // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BreakParams(class ABuildingActor** _OriginalBuilding, class ABuildingActor** _NewBuilding, EFortBuildingType* _BuildingType, class AFortPlayerController** _Editor);
	void SetParams(class ABuildingActor* _OriginalBuilding, class ABuildingActor* _NewBuilding, EFortBuildingType _BuildingType, class AFortPlayerController* _Editor, class UFortBuildingEditedParams** ThisParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBuildingEditedParams">();
	}
	static class UFortBuildingEditedParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBuildingEditedParams>();
	}
};
static_assert(alignof(UFortBuildingEditedParams) == 0x000008, "Wrong alignment on UFortBuildingEditedParams");
static_assert(sizeof(UFortBuildingEditedParams) == 0x000048, "Wrong size on UFortBuildingEditedParams");
static_assert(offsetof(UFortBuildingEditedParams, OriginalBuilding) == 0x000028, "Member 'UFortBuildingEditedParams::OriginalBuilding' has a wrong offset!");
static_assert(offsetof(UFortBuildingEditedParams, NewBuilding) == 0x000030, "Member 'UFortBuildingEditedParams::NewBuilding' has a wrong offset!");
static_assert(offsetof(UFortBuildingEditedParams, BuildingType) == 0x000038, "Member 'UFortBuildingEditedParams::BuildingType' has a wrong offset!");
static_assert(offsetof(UFortBuildingEditedParams, Editor) == 0x000040, "Member 'UFortBuildingEditedParams::Editor' has a wrong offset!");

// Class FortniteGame.FortBuildingDamagedParams
// 0x0020 (0x0048 - 0x0028)
class UFortBuildingDamagedParams final : public UFortMissionEventParams
{
public:
	class ABuildingActor*                         Building;                                          // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortBuildingType                             BuildingType;                                      // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AController*                            DamagedBy;                                         // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BreakParams(class ABuildingActor** _Building, EFortBuildingType* _BuildingType, class AController** _DamagedBy, float* _DamageAmount);
	void SetParams(class ABuildingActor* _Building, EFortBuildingType _BuildingType, class AController* _DamagedBy, float _DamageAmount, class UFortBuildingDamagedParams** ThisParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBuildingDamagedParams">();
	}
	static class UFortBuildingDamagedParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBuildingDamagedParams>();
	}
};
static_assert(alignof(UFortBuildingDamagedParams) == 0x000008, "Wrong alignment on UFortBuildingDamagedParams");
static_assert(sizeof(UFortBuildingDamagedParams) == 0x000048, "Wrong size on UFortBuildingDamagedParams");
static_assert(offsetof(UFortBuildingDamagedParams, Building) == 0x000028, "Member 'UFortBuildingDamagedParams::Building' has a wrong offset!");
static_assert(offsetof(UFortBuildingDamagedParams, BuildingType) == 0x000030, "Member 'UFortBuildingDamagedParams::BuildingType' has a wrong offset!");
static_assert(offsetof(UFortBuildingDamagedParams, DamagedBy) == 0x000038, "Member 'UFortBuildingDamagedParams::DamagedBy' has a wrong offset!");

// Class FortniteGame.FortClientAnnouncement
// 0x0070 (0x03F8 - 0x0388)
class AFortClientAnnouncement : public AActor
{
public:
	uint8                                         Pad_388[0x8];                                      // 0x0388(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  AnnouncementID;                                    // 0x0390(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                DisplayWidget;                                     // 0x03A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToLive;                                        // 0x03A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRetrigger;                                        // 0x03AC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDestroyOnAllClientsStopped;                       // 0x03AD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortAnnouncementChannel                      Channel;                                           // 0x03AE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3AF[0x1];                                      // 0x03AF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Priority;                                          // 0x03B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B4[0x1];                                      // 0x03B4(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EFortAnnouncementDelivery                     ClientDeliveryStatus;                              // 0x03B5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B6[0x2];                                      // 0x03B6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClientDeliveryTime;                                // 0x03B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3BC[0x4];                                      // 0x03BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnUpdateAnnouncementData;                          // 0x03C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnAnnouncementStopped;                             // 0x03D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class AFortPlayerController*>          RecipientControllers;                              // 0x03E0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F0[0x8];                                      // 0x03F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelClientAnnouncement();
	int32 GetPriority();
	void OnClientAnnouncementStart();
	void OnClientAnnouncementStop();
	void StopClientAnnouncement();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortClientAnnouncement">();
	}
	static class AFortClientAnnouncement* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortClientAnnouncement>();
	}
};
static_assert(alignof(AFortClientAnnouncement) == 0x000008, "Wrong alignment on AFortClientAnnouncement");
static_assert(sizeof(AFortClientAnnouncement) == 0x0003F8, "Wrong size on AFortClientAnnouncement");
static_assert(offsetof(AFortClientAnnouncement, AnnouncementID) == 0x000390, "Member 'AFortClientAnnouncement::AnnouncementID' has a wrong offset!");
static_assert(offsetof(AFortClientAnnouncement, DisplayWidget) == 0x0003A0, "Member 'AFortClientAnnouncement::DisplayWidget' has a wrong offset!");
static_assert(offsetof(AFortClientAnnouncement, TimeToLive) == 0x0003A8, "Member 'AFortClientAnnouncement::TimeToLive' has a wrong offset!");
static_assert(offsetof(AFortClientAnnouncement, bRetrigger) == 0x0003AC, "Member 'AFortClientAnnouncement::bRetrigger' has a wrong offset!");
static_assert(offsetof(AFortClientAnnouncement, bDestroyOnAllClientsStopped) == 0x0003AD, "Member 'AFortClientAnnouncement::bDestroyOnAllClientsStopped' has a wrong offset!");
static_assert(offsetof(AFortClientAnnouncement, Channel) == 0x0003AE, "Member 'AFortClientAnnouncement::Channel' has a wrong offset!");
static_assert(offsetof(AFortClientAnnouncement, Priority) == 0x0003B0, "Member 'AFortClientAnnouncement::Priority' has a wrong offset!");
static_assert(offsetof(AFortClientAnnouncement, ClientDeliveryStatus) == 0x0003B5, "Member 'AFortClientAnnouncement::ClientDeliveryStatus' has a wrong offset!");
static_assert(offsetof(AFortClientAnnouncement, ClientDeliveryTime) == 0x0003B8, "Member 'AFortClientAnnouncement::ClientDeliveryTime' has a wrong offset!");
static_assert(offsetof(AFortClientAnnouncement, OnUpdateAnnouncementData) == 0x0003C0, "Member 'AFortClientAnnouncement::OnUpdateAnnouncementData' has a wrong offset!");
static_assert(offsetof(AFortClientAnnouncement, OnAnnouncementStopped) == 0x0003D0, "Member 'AFortClientAnnouncement::OnAnnouncementStopped' has a wrong offset!");
static_assert(offsetof(AFortClientAnnouncement, RecipientControllers) == 0x0003E0, "Member 'AFortClientAnnouncement::RecipientControllers' has a wrong offset!");

// Class FortniteGame.FortClientAnnouncement_ZoneModifiers
// 0x0018 (0x0410 - 0x03F8)
class AFortClientAnnouncement_ZoneModifiers : public AFortClientAnnouncement
{
public:
	float                                         DisplayTime;                                       // 0x03F8(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3FC[0x4];                                      // 0x03FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortClientAnnouncementData_ZoneModifiers ModifiersData;                                     // 0x0400(0x0010)(Edit, BlueprintVisible, Net, ExposeOnSpawn, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortClientAnnouncement_ZoneModifiers">();
	}
	static class AFortClientAnnouncement_ZoneModifiers* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortClientAnnouncement_ZoneModifiers>();
	}
};
static_assert(alignof(AFortClientAnnouncement_ZoneModifiers) == 0x000008, "Wrong alignment on AFortClientAnnouncement_ZoneModifiers");
static_assert(sizeof(AFortClientAnnouncement_ZoneModifiers) == 0x000410, "Wrong size on AFortClientAnnouncement_ZoneModifiers");
static_assert(offsetof(AFortClientAnnouncement_ZoneModifiers, DisplayTime) == 0x0003F8, "Member 'AFortClientAnnouncement_ZoneModifiers::DisplayTime' has a wrong offset!");
static_assert(offsetof(AFortClientAnnouncement_ZoneModifiers, ModifiersData) == 0x000400, "Member 'AFortClientAnnouncement_ZoneModifiers::ModifiersData' has a wrong offset!");

// Class FortniteGame.FortGameplayTagVolume
// 0x0028 (0x03E8 - 0x03C0)
class AFortGameplayTagVolume final : public AVolume
{
public:
	uint8                                         Pad_3C0[0x8];                                      // 0x03C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  TagsToApplyOnSave;                                 // 0x03C8(0x0020)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameplayTagVolume">();
	}
	static class AFortGameplayTagVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGameplayTagVolume>();
	}
};
static_assert(alignof(AFortGameplayTagVolume) == 0x000008, "Wrong alignment on AFortGameplayTagVolume");
static_assert(sizeof(AFortGameplayTagVolume) == 0x0003E8, "Wrong size on AFortGameplayTagVolume");
static_assert(offsetof(AFortGameplayTagVolume, TagsToApplyOnSave) == 0x0003C8, "Member 'AFortGameplayTagVolume::TagsToApplyOnSave' has a wrong offset!");

// Class FortniteGame.FortMissionSucceededParams
// 0x0008 (0x0030 - 0x0028)
class UFortMissionSucceededParams final : public UFortMissionEventParams
{
public:
	class AFortMission*                           SucceededMission;                                  // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BreakParams(class AFortMission** _SucceededMission);
	void SetParams(class AFortMission* _SucceededMission, class UFortMissionSucceededParams** ThisParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMissionSucceededParams">();
	}
	static class UFortMissionSucceededParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMissionSucceededParams>();
	}
};
static_assert(alignof(UFortMissionSucceededParams) == 0x000008, "Wrong alignment on UFortMissionSucceededParams");
static_assert(sizeof(UFortMissionSucceededParams) == 0x000030, "Wrong size on UFortMissionSucceededParams");
static_assert(offsetof(UFortMissionSucceededParams, SucceededMission) == 0x000028, "Member 'UFortMissionSucceededParams::SucceededMission' has a wrong offset!");

// Class FortniteGame.FortMissionFailedParams
// 0x0008 (0x0030 - 0x0028)
class UFortMissionFailedParams final : public UFortMissionEventParams
{
public:
	class AFortMission*                           FailedMission;                                     // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BreakParams(class AFortMission** _FailedMission);
	void SetParams(class AFortMission* _FailedMission, class UFortMissionFailedParams** ThisParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMissionFailedParams">();
	}
	static class UFortMissionFailedParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMissionFailedParams>();
	}
};
static_assert(alignof(UFortMissionFailedParams) == 0x000008, "Wrong alignment on UFortMissionFailedParams");
static_assert(sizeof(UFortMissionFailedParams) == 0x000030, "Wrong size on UFortMissionFailedParams");
static_assert(offsetof(UFortMissionFailedParams, FailedMission) == 0x000028, "Member 'UFortMissionFailedParams::FailedMission' has a wrong offset!");

// Class FortniteGame.FortCameraMode
// 0x0028 (0x0050 - 0x0028)
class UFortCameraMode : public UObject
{
public:
	class AFortPlayerCameraBase*                  PlayerCamera;                                      // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransitionTime;                                    // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransitionOutTime;                                 // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FViewTargetTransitionParams            TransitionParams;                                  // 0x0038(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bResetInterpolation : 1;                           // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCameraMode">();
	}
	static class UFortCameraMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCameraMode>();
	}
};
static_assert(alignof(UFortCameraMode) == 0x000008, "Wrong alignment on UFortCameraMode");
static_assert(sizeof(UFortCameraMode) == 0x000050, "Wrong size on UFortCameraMode");
static_assert(offsetof(UFortCameraMode, PlayerCamera) == 0x000028, "Member 'UFortCameraMode::PlayerCamera' has a wrong offset!");
static_assert(offsetof(UFortCameraMode, TransitionTime) == 0x000030, "Member 'UFortCameraMode::TransitionTime' has a wrong offset!");
static_assert(offsetof(UFortCameraMode, TransitionOutTime) == 0x000034, "Member 'UFortCameraMode::TransitionOutTime' has a wrong offset!");
static_assert(offsetof(UFortCameraMode, TransitionParams) == 0x000038, "Member 'UFortCameraMode::TransitionParams' has a wrong offset!");

// Class FortniteGame.FortMissionForceSuccessParams
// 0x0008 (0x0030 - 0x0028)
class UFortMissionForceSuccessParams final : public UFortMissionEventParams
{
public:
	float                                         FractionCompleted;                                 // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BreakParams(float* _FractionCompleted);
	void SetParams(float _FractionCompleted, class UFortMissionForceSuccessParams** ThisParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMissionForceSuccessParams">();
	}
	static class UFortMissionForceSuccessParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMissionForceSuccessParams>();
	}
};
static_assert(alignof(UFortMissionForceSuccessParams) == 0x000008, "Wrong alignment on UFortMissionForceSuccessParams");
static_assert(sizeof(UFortMissionForceSuccessParams) == 0x000030, "Wrong size on UFortMissionForceSuccessParams");
static_assert(offsetof(UFortMissionForceSuccessParams, FractionCompleted) == 0x000028, "Member 'UFortMissionForceSuccessParams::FractionCompleted' has a wrong offset!");

// Class FortniteGame.FortMissionNeutralCompleteParams
// 0x0008 (0x0030 - 0x0028)
class UFortMissionNeutralCompleteParams final : public UFortMissionEventParams
{
public:
	class AFortMission*                           NeutrallyCompletedMission;                         // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BreakParams(class AFortMission** _NeutrallyCompletedMission);
	void SetParams(class AFortMission* _NeutrallyCompletedMission, class UFortMissionNeutralCompleteParams** ThisParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMissionNeutralCompleteParams">();
	}
	static class UFortMissionNeutralCompleteParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMissionNeutralCompleteParams>();
	}
};
static_assert(alignof(UFortMissionNeutralCompleteParams) == 0x000008, "Wrong alignment on UFortMissionNeutralCompleteParams");
static_assert(sizeof(UFortMissionNeutralCompleteParams) == 0x000030, "Wrong size on UFortMissionNeutralCompleteParams");
static_assert(offsetof(UFortMissionNeutralCompleteParams, NeutrallyCompletedMission) == 0x000028, "Member 'UFortMissionNeutralCompleteParams::NeutrallyCompletedMission' has a wrong offset!");

// Class FortniteGame.FortAsyncAction_OpenChoiceUI
// 0x0060 (0x0088 - 0x0028)
class UFortAsyncAction_OpenChoiceUI final : public UBlueprintAsyncActionBase
{
public:
	UMulticastDelegateProperty_                   OnSuccess;                                         // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFailure;                                         // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AFortPlayerController*                  PlayerController;                                  // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FChoiceData                            ChoiceItems;                                       // 0x0050(0x0030)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UFortAsyncAction_OpenChoiceUI* OpenChoiceUI(class AFortPlayerController* PlayerController_0, const struct FChoiceData& ChoiceItems_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAsyncAction_OpenChoiceUI">();
	}
	static class UFortAsyncAction_OpenChoiceUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAsyncAction_OpenChoiceUI>();
	}
};
static_assert(alignof(UFortAsyncAction_OpenChoiceUI) == 0x000008, "Wrong alignment on UFortAsyncAction_OpenChoiceUI");
static_assert(sizeof(UFortAsyncAction_OpenChoiceUI) == 0x000088, "Wrong size on UFortAsyncAction_OpenChoiceUI");
static_assert(offsetof(UFortAsyncAction_OpenChoiceUI, OnSuccess) == 0x000028, "Member 'UFortAsyncAction_OpenChoiceUI::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_OpenChoiceUI, OnFailure) == 0x000038, "Member 'UFortAsyncAction_OpenChoiceUI::OnFailure' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_OpenChoiceUI, PlayerController) == 0x000048, "Member 'UFortAsyncAction_OpenChoiceUI::PlayerController' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_OpenChoiceUI, ChoiceItems) == 0x000050, "Member 'UFortAsyncAction_OpenChoiceUI::ChoiceItems' has a wrong offset!");

// Class FortniteGame.FortPooledSkelMeshComponent
// 0x0040 (0x0F30 - 0x0EF0)
class UFortPooledSkelMeshComponent final : public USkeletalMeshComponent
{
public:
	uint8                                         Pad_EF0[0x40];                                     // 0x0EF0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPooledSkelMeshComponent">();
	}
	static class UFortPooledSkelMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPooledSkelMeshComponent>();
	}
};
static_assert(alignof(UFortPooledSkelMeshComponent) == 0x000010, "Wrong alignment on UFortPooledSkelMeshComponent");
static_assert(sizeof(UFortPooledSkelMeshComponent) == 0x000F30, "Wrong size on UFortPooledSkelMeshComponent");

// Class FortniteGame.FortObjectiveSucceededParams
// 0x0008 (0x0030 - 0x0028)
class UFortObjectiveSucceededParams final : public UFortMissionEventParams
{
public:
	class AFortObjectiveBase*                     SucceededObjective;                                // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BreakParams(class AFortObjectiveBase** _SucceededObjective);
	void SetParams(class AFortObjectiveBase* _SucceededObjective, class UFortObjectiveSucceededParams** ThisParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortObjectiveSucceededParams">();
	}
	static class UFortObjectiveSucceededParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortObjectiveSucceededParams>();
	}
};
static_assert(alignof(UFortObjectiveSucceededParams) == 0x000008, "Wrong alignment on UFortObjectiveSucceededParams");
static_assert(sizeof(UFortObjectiveSucceededParams) == 0x000030, "Wrong size on UFortObjectiveSucceededParams");
static_assert(offsetof(UFortObjectiveSucceededParams, SucceededObjective) == 0x000028, "Member 'UFortObjectiveSucceededParams::SucceededObjective' has a wrong offset!");

// Class FortniteGame.FortObjectiveFailedParams
// 0x0008 (0x0030 - 0x0028)
class UFortObjectiveFailedParams final : public UFortMissionEventParams
{
public:
	class AFortObjectiveBase*                     FailedObjective;                                   // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BreakParams(class AFortObjectiveBase** _FailedObjective);
	void SetParams(class AFortObjectiveBase* _FailedObjective, class UFortObjectiveFailedParams** ThisParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortObjectiveFailedParams">();
	}
	static class UFortObjectiveFailedParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortObjectiveFailedParams>();
	}
};
static_assert(alignof(UFortObjectiveFailedParams) == 0x000008, "Wrong alignment on UFortObjectiveFailedParams");
static_assert(sizeof(UFortObjectiveFailedParams) == 0x000030, "Wrong size on UFortObjectiveFailedParams");
static_assert(offsetof(UFortObjectiveFailedParams, FailedObjective) == 0x000028, "Member 'UFortObjectiveFailedParams::FailedObjective' has a wrong offset!");

// Class FortniteGame.FortMissionGenerator
// 0x0680 (0x06A8 - 0x0028)
class UFortMissionGenerator : public UPrimaryDataAsset
{
public:
	class FText                                   MissionName;                                       // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   MissionDescription;                                // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            MissionIcon;                                       // 0x0058(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FFortMultiSizeBrush                    MissionIcons;                                      // 0x00E8(0x0360)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FZoneLoadingScreenConfig               LoadingScreenConfig;                               // 0x0448(0x0108)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FPerDifficultyMissionGenerationInfo> PerDifficultyMissionGenerationInfos;               // 0x0550(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagQuery                      OptionalRequirementsForAllOtherMissions;           // 0x0560(0x0048)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         MissionGenerationChance[0x4];                      // 0x05A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFortMissionInfo>        PrimaryMissionInfo;                                // 0x05B8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FFortPossibleMission>           SecondaryMissionList;                              // 0x05D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortPossibleMission>           TertiaryMissionList;                               // 0x05E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortPossibleMission>           SurvivorMissionList;                               // 0x05F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFortMissionInfo>        MissionInfo;                                       // 0x0608(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FFortMissionInfoOption>         MissionInfoList;                                   // 0x0628(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsRequiredForVictoryTile;                         // 0x0638(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_639[0x7];                                      // 0x0639(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    CostAndAvailability;                               // 0x0640(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bUseOverridePlayerSpawnPadPlacementData;           // 0x0650(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_651[0x7];                                      // 0x0651(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortPlayerSpawnPadPlacementData       OverridePlayerSpawnPadPlacementData;               // 0x0658(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMissionGenerator">();
	}
	static class UFortMissionGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMissionGenerator>();
	}
};
static_assert(alignof(UFortMissionGenerator) == 0x000008, "Wrong alignment on UFortMissionGenerator");
static_assert(sizeof(UFortMissionGenerator) == 0x0006A8, "Wrong size on UFortMissionGenerator");
static_assert(offsetof(UFortMissionGenerator, MissionName) == 0x000028, "Member 'UFortMissionGenerator::MissionName' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerator, MissionDescription) == 0x000040, "Member 'UFortMissionGenerator::MissionDescription' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerator, MissionIcon) == 0x000058, "Member 'UFortMissionGenerator::MissionIcon' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerator, MissionIcons) == 0x0000E8, "Member 'UFortMissionGenerator::MissionIcons' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerator, LoadingScreenConfig) == 0x000448, "Member 'UFortMissionGenerator::LoadingScreenConfig' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerator, PerDifficultyMissionGenerationInfos) == 0x000550, "Member 'UFortMissionGenerator::PerDifficultyMissionGenerationInfos' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerator, OptionalRequirementsForAllOtherMissions) == 0x000560, "Member 'UFortMissionGenerator::OptionalRequirementsForAllOtherMissions' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerator, MissionGenerationChance) == 0x0005A8, "Member 'UFortMissionGenerator::MissionGenerationChance' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerator, PrimaryMissionInfo) == 0x0005B8, "Member 'UFortMissionGenerator::PrimaryMissionInfo' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerator, SecondaryMissionList) == 0x0005D8, "Member 'UFortMissionGenerator::SecondaryMissionList' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerator, TertiaryMissionList) == 0x0005E8, "Member 'UFortMissionGenerator::TertiaryMissionList' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerator, SurvivorMissionList) == 0x0005F8, "Member 'UFortMissionGenerator::SurvivorMissionList' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerator, MissionInfo) == 0x000608, "Member 'UFortMissionGenerator::MissionInfo' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerator, MissionInfoList) == 0x000628, "Member 'UFortMissionGenerator::MissionInfoList' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerator, bIsRequiredForVictoryTile) == 0x000638, "Member 'UFortMissionGenerator::bIsRequiredForVictoryTile' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerator, CostAndAvailability) == 0x000640, "Member 'UFortMissionGenerator::CostAndAvailability' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerator, bUseOverridePlayerSpawnPadPlacementData) == 0x000650, "Member 'UFortMissionGenerator::bUseOverridePlayerSpawnPadPlacementData' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerator, OverridePlayerSpawnPadPlacementData) == 0x000658, "Member 'UFortMissionGenerator::OverridePlayerSpawnPadPlacementData' has a wrong offset!");

// Class FortniteGame.FortObjectiveNeutralCompleteParams
// 0x0008 (0x0030 - 0x0028)
class UFortObjectiveNeutralCompleteParams final : public UFortMissionEventParams
{
public:
	class AFortObjectiveBase*                     NeutrallyCompletedObjective;                       // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BreakParams(class AFortObjectiveBase** _NeutrallyCompletedObjective);
	void SetParams(class AFortObjectiveBase* _NeutrallyCompletedObjective, class UFortObjectiveNeutralCompleteParams** ThisParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortObjectiveNeutralCompleteParams">();
	}
	static class UFortObjectiveNeutralCompleteParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortObjectiveNeutralCompleteParams>();
	}
};
static_assert(alignof(UFortObjectiveNeutralCompleteParams) == 0x000008, "Wrong alignment on UFortObjectiveNeutralCompleteParams");
static_assert(sizeof(UFortObjectiveNeutralCompleteParams) == 0x000030, "Wrong size on UFortObjectiveNeutralCompleteParams");
static_assert(offsetof(UFortObjectiveNeutralCompleteParams, NeutrallyCompletedObjective) == 0x000028, "Member 'UFortObjectiveNeutralCompleteParams::NeutrallyCompletedObjective' has a wrong offset!");

// Class FortniteGame.FortToggledCursorModeParams
// 0x0010 (0x0038 - 0x0028)
class UFortToggledCursorModeParams final : public UFortMissionEventParams
{
public:
	class AFortPlayerController*                  PlayerThatToggledCursorMode;                       // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInCursorMode;                                     // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BreakParams(class AFortPlayerController** _PlayerThatToggledCursorMode, bool* InCursorMode);
	void SetParams(class AFortPlayerController* _PlayerThatToggledCursorMode, bool InCursorMode, class UFortToggledCursorModeParams** ThisParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortToggledCursorModeParams">();
	}
	static class UFortToggledCursorModeParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortToggledCursorModeParams>();
	}
};
static_assert(alignof(UFortToggledCursorModeParams) == 0x000008, "Wrong alignment on UFortToggledCursorModeParams");
static_assert(sizeof(UFortToggledCursorModeParams) == 0x000038, "Wrong size on UFortToggledCursorModeParams");
static_assert(offsetof(UFortToggledCursorModeParams, PlayerThatToggledCursorMode) == 0x000028, "Member 'UFortToggledCursorModeParams::PlayerThatToggledCursorMode' has a wrong offset!");
static_assert(offsetof(UFortToggledCursorModeParams, bInCursorMode) == 0x000030, "Member 'UFortToggledCursorModeParams::bInCursorMode' has a wrong offset!");

// Class FortniteGame.FortLobbyBeaconClient
// 0x0000 (0x05E0 - 0x05E0)
class AFortLobbyBeaconClient : public ALobbyBeaconClient
{
public:
	void ClientCreateOrJoinChatRoom(const class FString& ChatRoomId);
	void ServerIncrementHomeBaseVersion(const struct FUniqueNetIdRepl& InUniqueId);
	void ServerSetCharacterGender(const struct FUniqueNetIdRepl& InUniqueId, EFortCustomGender GenderType);
	void ServerSetConsoleUniqueNetId(const struct FUniqueNetIdRepl& InUniqueId, const class FName NewConsoleOSS, const struct FUniqueNetIdRepl& NewConsoleNetId);
	void ServerSetCurrentCharacterXp(const struct FUniqueNetIdRepl& InUniqueId, const int32 CurrentCharacterXp);
	void ServerSetGadget(const struct FUniqueNetIdRepl& InUniqueId, int32 Index_0, const class FString& GadgetPersistentName);
	void ServerSetHeroId(const struct FUniqueNetIdRepl& InUniqueId, const class FString& InHeroId);
	void ServerSetHeroSquadId(const struct FUniqueNetIdRepl& InUniqueId, const class FName& InHeroSquadId);
	void ServerSetHeroType(const struct FUniqueNetIdRepl& InUniqueId, const class UFortHeroType* InHeroType);
	void ServerSetMatchmakingLevel(const struct FUniqueNetIdRepl& InUniqueId, const int32 MatchmakingLevel);
	void ServerTeamChatRoomReady(const class FString& ChatRoomId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortLobbyBeaconClient">();
	}
	static class AFortLobbyBeaconClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortLobbyBeaconClient>();
	}
};
static_assert(alignof(AFortLobbyBeaconClient) == 0x000008, "Wrong alignment on AFortLobbyBeaconClient");
static_assert(sizeof(AFortLobbyBeaconClient) == 0x0005E0, "Wrong size on AFortLobbyBeaconClient");

// Class FortniteGame.FortLobbyBeaconClientRM
// 0x0030 (0x0610 - 0x05E0)
class AFortLobbyBeaconClientRM final : public AFortLobbyBeaconClient
{
public:
	UMulticastDelegateProperty_                   LocalReadiedUpStatusChanged;                       // 0x05E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnUpdateLobbyPlayerPadTop;                         // 0x05F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_600[0x10];                                     // 0x0600(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ServerUpdateNewlyJoinedPlayerInternal();
	void ServerUpdateReadyStatus(bool bIsReady);
	void SetLocalReadyStatus(bool bIsReady);
	void UpdateNewlyJoinedPlayer();

	void ClientBroadcastLobbyPlayerPadTop(const struct FUniqueNetIdRepl& ReadiedPlayer, bool bIsReadiedUp) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortLobbyBeaconClientRM">();
	}
	static class AFortLobbyBeaconClientRM* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortLobbyBeaconClientRM>();
	}
};
static_assert(alignof(AFortLobbyBeaconClientRM) == 0x000008, "Wrong alignment on AFortLobbyBeaconClientRM");
static_assert(sizeof(AFortLobbyBeaconClientRM) == 0x000610, "Wrong size on AFortLobbyBeaconClientRM");
static_assert(offsetof(AFortLobbyBeaconClientRM, LocalReadiedUpStatusChanged) == 0x0005E0, "Member 'AFortLobbyBeaconClientRM::LocalReadiedUpStatusChanged' has a wrong offset!");
static_assert(offsetof(AFortLobbyBeaconClientRM, OnUpdateLobbyPlayerPadTop) == 0x0005F0, "Member 'AFortLobbyBeaconClientRM::OnUpdateLobbyPlayerPadTop' has a wrong offset!");

// Class FortniteGame.FortAsyncAction_TriggerNotification
// 0x01A8 (0x01D0 - 0x0028)
class UFortAsyncAction_TriggerNotification final : public UBlueprintAsyncActionBase
{
public:
	UMulticastDelegateProperty_                   OnConfirmed;                                       // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnDeclined;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UObject*                                WorldContextObject;                                // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EFortNotificationQueueType                    NotificationType;                                  // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_51[0xF];                                       // 0x0051(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortDialogDescription                 Description;                                       // 0x0060(0x0170)(ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UFortAsyncAction_TriggerNotification* TriggerNotification(class UObject* InWorldContextObject, EFortNotificationQueueType NotificationType_0, const struct FFortDialogDescription& NotificationDescription);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAsyncAction_TriggerNotification">();
	}
	static class UFortAsyncAction_TriggerNotification* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAsyncAction_TriggerNotification>();
	}
};
static_assert(alignof(UFortAsyncAction_TriggerNotification) == 0x000010, "Wrong alignment on UFortAsyncAction_TriggerNotification");
static_assert(sizeof(UFortAsyncAction_TriggerNotification) == 0x0001D0, "Wrong size on UFortAsyncAction_TriggerNotification");
static_assert(offsetof(UFortAsyncAction_TriggerNotification, OnConfirmed) == 0x000028, "Member 'UFortAsyncAction_TriggerNotification::OnConfirmed' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_TriggerNotification, OnDeclined) == 0x000038, "Member 'UFortAsyncAction_TriggerNotification::OnDeclined' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_TriggerNotification, WorldContextObject) == 0x000048, "Member 'UFortAsyncAction_TriggerNotification::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_TriggerNotification, NotificationType) == 0x000050, "Member 'UFortAsyncAction_TriggerNotification::NotificationType' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_TriggerNotification, Description) == 0x000060, "Member 'UFortAsyncAction_TriggerNotification::Description' has a wrong offset!");

// Class FortniteGame.FortToggledOptionsMenuParams
// 0x0010 (0x0038 - 0x0028)
class UFortToggledOptionsMenuParams final : public UFortMissionEventParams
{
public:
	class AFortPlayerController*                  PlayerThatToggledOptionsMenu;                      // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInOptionsMenu;                                    // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BreakParams(class AFortPlayerController** _PlayerThatToggledOptionsMenu, bool* Opened);
	void SetParams(class AFortPlayerController* _PlayerThatToggledOptionsMenu, bool Opened, class UFortToggledOptionsMenuParams** ThisParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortToggledOptionsMenuParams">();
	}
	static class UFortToggledOptionsMenuParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortToggledOptionsMenuParams>();
	}
};
static_assert(alignof(UFortToggledOptionsMenuParams) == 0x000008, "Wrong alignment on UFortToggledOptionsMenuParams");
static_assert(sizeof(UFortToggledOptionsMenuParams) == 0x000038, "Wrong size on UFortToggledOptionsMenuParams");
static_assert(offsetof(UFortToggledOptionsMenuParams, PlayerThatToggledOptionsMenu) == 0x000028, "Member 'UFortToggledOptionsMenuParams::PlayerThatToggledOptionsMenu' has a wrong offset!");
static_assert(offsetof(UFortToggledOptionsMenuParams, bInOptionsMenu) == 0x000030, "Member 'UFortToggledOptionsMenuParams::bInOptionsMenu' has a wrong offset!");

// Class FortniteGame.FortToggledEditModeParams
// 0x0018 (0x0040 - 0x0028)
class UFortToggledEditModeParams final : public UFortMissionEventParams
{
public:
	class AFortPlayerController*                  PlayerThatToggledEditMode;                         // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABuildingSMActor*                       EditableActor;                                     // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInEditMode;                                       // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BreakParams(class AFortPlayerController** _PlayerThatToggledEditMode, class ABuildingSMActor** EditableActor_0, bool* InEditMode);
	void SetParams(class AFortPlayerController* _PlayerThatToggledEditMode, class ABuildingSMActor* InEditableActor, bool InEditMode, class UFortToggledEditModeParams** ThisParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortToggledEditModeParams">();
	}
	static class UFortToggledEditModeParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortToggledEditModeParams>();
	}
};
static_assert(alignof(UFortToggledEditModeParams) == 0x000008, "Wrong alignment on UFortToggledEditModeParams");
static_assert(sizeof(UFortToggledEditModeParams) == 0x000040, "Wrong size on UFortToggledEditModeParams");
static_assert(offsetof(UFortToggledEditModeParams, PlayerThatToggledEditMode) == 0x000028, "Member 'UFortToggledEditModeParams::PlayerThatToggledEditMode' has a wrong offset!");
static_assert(offsetof(UFortToggledEditModeParams, EditableActor) == 0x000030, "Member 'UFortToggledEditModeParams::EditableActor' has a wrong offset!");
static_assert(offsetof(UFortToggledEditModeParams, bInEditMode) == 0x000038, "Member 'UFortToggledEditModeParams::bInEditMode' has a wrong offset!");

// Class FortniteGame.FortShutdownParams
// 0x0000 (0x0028 - 0x0028)
class UFortShutdownParams final : public UFortMissionEventParams
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortShutdownParams">();
	}
	static class UFortShutdownParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortShutdownParams>();
	}
};
static_assert(alignof(UFortShutdownParams) == 0x000008, "Wrong alignment on UFortShutdownParams");
static_assert(sizeof(UFortShutdownParams) == 0x000028, "Wrong size on UFortShutdownParams");

// Class FortniteGame.FortPvPVictoryParams
// 0x0008 (0x0030 - 0x0028)
class UFortPvPVictoryParams final : public UFortMissionEventParams
{
public:
	EFortTeam                                     WinningTeam;                                       // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPvPVictoryParams">();
	}
	static class UFortPvPVictoryParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPvPVictoryParams>();
	}
};
static_assert(alignof(UFortPvPVictoryParams) == 0x000008, "Wrong alignment on UFortPvPVictoryParams");
static_assert(sizeof(UFortPvPVictoryParams) == 0x000030, "Wrong size on UFortPvPVictoryParams");
static_assert(offsetof(UFortPvPVictoryParams, WinningTeam) == 0x000028, "Member 'UFortPvPVictoryParams::WinningTeam' has a wrong offset!");

// Class FortniteGame.FortNavArea
// 0x0008 (0x0048 - 0x0040)
class UFortNavArea : public UNavArea
{
public:
	uint8                                         bObstacle : 1;                                     // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSmashable : 1;                                    // 0x0040(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea">();
	}
	static class UFortNavArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea>();
	}
};
static_assert(alignof(UFortNavArea) == 0x000008, "Wrong alignment on UFortNavArea");
static_assert(sizeof(UFortNavArea) == 0x000048, "Wrong size on UFortNavArea");

// Class FortniteGame.FortNavArea_ClosedDoors
// 0x0000 (0x0048 - 0x0048)
class UFortNavArea_ClosedDoors final : public UFortNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_ClosedDoors">();
	}
	static class UFortNavArea_ClosedDoors* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_ClosedDoors>();
	}
};
static_assert(alignof(UFortNavArea_ClosedDoors) == 0x000008, "Wrong alignment on UFortNavArea_ClosedDoors");
static_assert(sizeof(UFortNavArea_ClosedDoors) == 0x000048, "Wrong size on UFortNavArea_ClosedDoors");

// Class FortniteGame.FortCameraMode_ThirdPerson
// 0x00C0 (0x0110 - 0x0050)
class UFortCameraMode_ThirdPerson : public UFortCameraMode
{
public:
	float                                         FOV;                                               // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraSpaceForwardDistance;                        // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECameraOrigin                                 CameraOrigin;                                      // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CameraOriginSocketName;                            // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                CameraOriginInterpSpeed;                           // 0x0068(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInterpOffset                          ViewTargetSpaceViewOffset;                         // 0x0078(0x0010)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FInterpOffset                          ViewTargetSpaceViewOffset_Crouch;                  // 0x0088(0x0010)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FVector                                ViewTargetSpaceViewOffseInterpSpeed;               // 0x0098(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInterpOffset                          CameraSpaceViewOffset;                             // 0x00A8(0x0010)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FVector                                LastCameraOrigin;                                  // 0x00B8(0x000C)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                CameraOriginLocalOffset;                           // 0x00C4(0x000C)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PenetrationBlendInTime;                            // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PenetrationBlendOutTime;                           // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreventPenetration;                               // 0x00D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoPredictiveAvoidance;                            // 0x00D9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DA[0x2];                                       // 0x00DA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CollisionPushOutDistance;                          // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HidePawnPenetrationPercent;                        // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPenetrationAvoidanceFeeler>    PenetrationAvoidanceFeelers;                       // 0x00E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         SafeLocToAimLineBlockedPct;                        // 0x00F8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AimLineToDesiredPosBlockedPct;                     // 0x00FC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LastDrawDebugTime;                                 // 0x0100(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                LastViewTargetSpaceViewOffset;                     // 0x0104(0x000C)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCameraMode_ThirdPerson">();
	}
	static class UFortCameraMode_ThirdPerson* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCameraMode_ThirdPerson>();
	}
};
static_assert(alignof(UFortCameraMode_ThirdPerson) == 0x000008, "Wrong alignment on UFortCameraMode_ThirdPerson");
static_assert(sizeof(UFortCameraMode_ThirdPerson) == 0x000110, "Wrong size on UFortCameraMode_ThirdPerson");
static_assert(offsetof(UFortCameraMode_ThirdPerson, FOV) == 0x000050, "Member 'UFortCameraMode_ThirdPerson::FOV' has a wrong offset!");
static_assert(offsetof(UFortCameraMode_ThirdPerson, CameraSpaceForwardDistance) == 0x000054, "Member 'UFortCameraMode_ThirdPerson::CameraSpaceForwardDistance' has a wrong offset!");
static_assert(offsetof(UFortCameraMode_ThirdPerson, CameraOrigin) == 0x000058, "Member 'UFortCameraMode_ThirdPerson::CameraOrigin' has a wrong offset!");
static_assert(offsetof(UFortCameraMode_ThirdPerson, CameraOriginSocketName) == 0x000060, "Member 'UFortCameraMode_ThirdPerson::CameraOriginSocketName' has a wrong offset!");
static_assert(offsetof(UFortCameraMode_ThirdPerson, CameraOriginInterpSpeed) == 0x000068, "Member 'UFortCameraMode_ThirdPerson::CameraOriginInterpSpeed' has a wrong offset!");
static_assert(offsetof(UFortCameraMode_ThirdPerson, ViewTargetSpaceViewOffset) == 0x000078, "Member 'UFortCameraMode_ThirdPerson::ViewTargetSpaceViewOffset' has a wrong offset!");
static_assert(offsetof(UFortCameraMode_ThirdPerson, ViewTargetSpaceViewOffset_Crouch) == 0x000088, "Member 'UFortCameraMode_ThirdPerson::ViewTargetSpaceViewOffset_Crouch' has a wrong offset!");
static_assert(offsetof(UFortCameraMode_ThirdPerson, ViewTargetSpaceViewOffseInterpSpeed) == 0x000098, "Member 'UFortCameraMode_ThirdPerson::ViewTargetSpaceViewOffseInterpSpeed' has a wrong offset!");
static_assert(offsetof(UFortCameraMode_ThirdPerson, CameraSpaceViewOffset) == 0x0000A8, "Member 'UFortCameraMode_ThirdPerson::CameraSpaceViewOffset' has a wrong offset!");
static_assert(offsetof(UFortCameraMode_ThirdPerson, LastCameraOrigin) == 0x0000B8, "Member 'UFortCameraMode_ThirdPerson::LastCameraOrigin' has a wrong offset!");
static_assert(offsetof(UFortCameraMode_ThirdPerson, CameraOriginLocalOffset) == 0x0000C4, "Member 'UFortCameraMode_ThirdPerson::CameraOriginLocalOffset' has a wrong offset!");
static_assert(offsetof(UFortCameraMode_ThirdPerson, PenetrationBlendInTime) == 0x0000D0, "Member 'UFortCameraMode_ThirdPerson::PenetrationBlendInTime' has a wrong offset!");
static_assert(offsetof(UFortCameraMode_ThirdPerson, PenetrationBlendOutTime) == 0x0000D4, "Member 'UFortCameraMode_ThirdPerson::PenetrationBlendOutTime' has a wrong offset!");
static_assert(offsetof(UFortCameraMode_ThirdPerson, bPreventPenetration) == 0x0000D8, "Member 'UFortCameraMode_ThirdPerson::bPreventPenetration' has a wrong offset!");
static_assert(offsetof(UFortCameraMode_ThirdPerson, bDoPredictiveAvoidance) == 0x0000D9, "Member 'UFortCameraMode_ThirdPerson::bDoPredictiveAvoidance' has a wrong offset!");
static_assert(offsetof(UFortCameraMode_ThirdPerson, CollisionPushOutDistance) == 0x0000DC, "Member 'UFortCameraMode_ThirdPerson::CollisionPushOutDistance' has a wrong offset!");
static_assert(offsetof(UFortCameraMode_ThirdPerson, HidePawnPenetrationPercent) == 0x0000E0, "Member 'UFortCameraMode_ThirdPerson::HidePawnPenetrationPercent' has a wrong offset!");
static_assert(offsetof(UFortCameraMode_ThirdPerson, PenetrationAvoidanceFeelers) == 0x0000E8, "Member 'UFortCameraMode_ThirdPerson::PenetrationAvoidanceFeelers' has a wrong offset!");
static_assert(offsetof(UFortCameraMode_ThirdPerson, SafeLocToAimLineBlockedPct) == 0x0000F8, "Member 'UFortCameraMode_ThirdPerson::SafeLocToAimLineBlockedPct' has a wrong offset!");
static_assert(offsetof(UFortCameraMode_ThirdPerson, AimLineToDesiredPosBlockedPct) == 0x0000FC, "Member 'UFortCameraMode_ThirdPerson::AimLineToDesiredPosBlockedPct' has a wrong offset!");
static_assert(offsetof(UFortCameraMode_ThirdPerson, LastDrawDebugTime) == 0x000100, "Member 'UFortCameraMode_ThirdPerson::LastDrawDebugTime' has a wrong offset!");
static_assert(offsetof(UFortCameraMode_ThirdPerson, LastViewTargetSpaceViewOffset) == 0x000104, "Member 'UFortCameraMode_ThirdPerson::LastViewTargetSpaceViewOffset' has a wrong offset!");

// Class FortniteGame.FortStartLeavingZoneParams
// 0x0008 (0x0030 - 0x0028)
class UFortStartLeavingZoneParams final : public UFortMissionEventParams
{
public:
	class AFortPlayerPawn*                        PlayerRequestingLeaving;                           // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BreakParams(class AFortPlayerPawn** _PlayerRequestingLeaving);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortStartLeavingZoneParams">();
	}
	static class UFortStartLeavingZoneParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortStartLeavingZoneParams>();
	}
};
static_assert(alignof(UFortStartLeavingZoneParams) == 0x000008, "Wrong alignment on UFortStartLeavingZoneParams");
static_assert(sizeof(UFortStartLeavingZoneParams) == 0x000030, "Wrong size on UFortStartLeavingZoneParams");
static_assert(offsetof(UFortStartLeavingZoneParams, PlayerRequestingLeaving) == 0x000028, "Member 'UFortStartLeavingZoneParams::PlayerRequestingLeaving' has a wrong offset!");

// Class FortniteGame.FortAsyncAction_RejoinSession
// 0x0030 (0x0058 - 0x0028)
class UFortAsyncAction_RejoinSession final : public UBlueprintAsyncActionBase
{
public:
	UMulticastDelegateProperty_                   OnSuccess;                                         // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFailure;                                         // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AFortPlayerController*                  PlayerController;                                  // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UFortAsyncAction_RejoinSession* RejoinSession(class AFortPlayerController* PlayerController_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAsyncAction_RejoinSession">();
	}
	static class UFortAsyncAction_RejoinSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAsyncAction_RejoinSession>();
	}
};
static_assert(alignof(UFortAsyncAction_RejoinSession) == 0x000008, "Wrong alignment on UFortAsyncAction_RejoinSession");
static_assert(sizeof(UFortAsyncAction_RejoinSession) == 0x000058, "Wrong size on UFortAsyncAction_RejoinSession");
static_assert(offsetof(UFortAsyncAction_RejoinSession, OnSuccess) == 0x000028, "Member 'UFortAsyncAction_RejoinSession::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_RejoinSession, OnFailure) == 0x000038, "Member 'UFortAsyncAction_RejoinSession::OnFailure' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_RejoinSession, PlayerController) == 0x000048, "Member 'UFortAsyncAction_RejoinSession::PlayerController' has a wrong offset!");

// Class FortniteGame.FortInteractInterface
// 0x0000 (0x0028 - 0x0028)
class IFortInteractInterface final : public IInterface
{
public:
	bool ServerOnAttemptInteract(const struct FInteractionType& InteractType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortInteractInterface">();
	}
	static class IFortInteractInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortInteractInterface>();
	}
};
static_assert(alignof(IFortInteractInterface) == 0x000008, "Wrong alignment on IFortInteractInterface");
static_assert(sizeof(IFortInteractInterface) == 0x000028, "Wrong size on IFortInteractInterface");

// Class FortniteGame.FortStatEventManager
// 0x0060 (0x0088 - 0x0028)
class UFortStatEventManager : public UObject
{
public:
	class AFortPlayerController*                  FPC;                                               // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFortStatEvent>                 StatEvents;                                        // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FFortStatEventSequence>         StatEventSequences;                                // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   PinnedSchematicNotification;                       // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           PinnedCanCraftStats;                               // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           PinnedCanNotCraftStats;                            // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FFortStatEventSequence>         PinnedSchematicSequences;                          // 0x0078(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortStatEventManager">();
	}
	static class UFortStatEventManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortStatEventManager>();
	}
};
static_assert(alignof(UFortStatEventManager) == 0x000008, "Wrong alignment on UFortStatEventManager");
static_assert(sizeof(UFortStatEventManager) == 0x000088, "Wrong size on UFortStatEventManager");
static_assert(offsetof(UFortStatEventManager, FPC) == 0x000028, "Member 'UFortStatEventManager::FPC' has a wrong offset!");
static_assert(offsetof(UFortStatEventManager, StatEvents) == 0x000030, "Member 'UFortStatEventManager::StatEvents' has a wrong offset!");
static_assert(offsetof(UFortStatEventManager, StatEventSequences) == 0x000040, "Member 'UFortStatEventManager::StatEventSequences' has a wrong offset!");
static_assert(offsetof(UFortStatEventManager, PinnedSchematicNotification) == 0x000050, "Member 'UFortStatEventManager::PinnedSchematicNotification' has a wrong offset!");
static_assert(offsetof(UFortStatEventManager, PinnedCanCraftStats) == 0x000058, "Member 'UFortStatEventManager::PinnedCanCraftStats' has a wrong offset!");
static_assert(offsetof(UFortStatEventManager, PinnedCanNotCraftStats) == 0x000068, "Member 'UFortStatEventManager::PinnedCanNotCraftStats' has a wrong offset!");
static_assert(offsetof(UFortStatEventManager, PinnedSchematicSequences) == 0x000078, "Member 'UFortStatEventManager::PinnedSchematicSequences' has a wrong offset!");

// Class FortniteGame.FortQueryContext_EncounterGoalsOnGround
// 0x0000 (0x0028 - 0x0028)
class UFortQueryContext_EncounterGoalsOnGround final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_EncounterGoalsOnGround">();
	}
	static class UFortQueryContext_EncounterGoalsOnGround* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_EncounterGoalsOnGround>();
	}
};
static_assert(alignof(UFortQueryContext_EncounterGoalsOnGround) == 0x000008, "Wrong alignment on UFortQueryContext_EncounterGoalsOnGround");
static_assert(sizeof(UFortQueryContext_EncounterGoalsOnGround) == 0x000028, "Wrong size on UFortQueryContext_EncounterGoalsOnGround");

// Class FortniteGame.FortDamageableActorInterface
// 0x0000 (0x0028 - 0x0028)
class IFortDamageableActorInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDamageableActorInterface">();
	}
	static class IFortDamageableActorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortDamageableActorInterface>();
	}
};
static_assert(alignof(IFortDamageableActorInterface) == 0x000008, "Wrong alignment on IFortDamageableActorInterface");
static_assert(sizeof(IFortDamageableActorInterface) == 0x000028, "Wrong size on IFortDamageableActorInterface");

// Class FortniteGame.FortClientEventInterface
// 0x0000 (0x0028 - 0x0028)
class IFortClientEventInterface final : public IInterface
{
public:
	void BlueprintCustomHandleClientEvent(class UObject* EventSource, class UObject* EventFocus, const struct FFortClientEvent& ClientEvent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortClientEventInterface">();
	}
	static class IFortClientEventInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortClientEventInterface>();
	}
};
static_assert(alignof(IFortClientEventInterface) == 0x000008, "Wrong alignment on IFortClientEventInterface");
static_assert(sizeof(IFortClientEventInterface) == 0x000028, "Wrong size on IFortClientEventInterface");

// Class FortniteGame.FortQueryContext_EncounterQueryActor
// 0x0000 (0x0028 - 0x0028)
class UFortQueryContext_EncounterQueryActor final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_EncounterQueryActor">();
	}
	static class UFortQueryContext_EncounterQueryActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_EncounterQueryActor>();
	}
};
static_assert(alignof(UFortQueryContext_EncounterQueryActor) == 0x000008, "Wrong alignment on UFortQueryContext_EncounterQueryActor");
static_assert(sizeof(UFortQueryContext_EncounterQueryActor) == 0x000028, "Wrong size on UFortQueryContext_EncounterQueryActor");

// Class FortniteGame.FortTeamActorInterface
// 0x0000 (0x0028 - 0x0028)
class IFortTeamActorInterface final : public IGenericTeamAgentInterface
{
public:
	EFortTeam GetTeam() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTeamActorInterface">();
	}
	static class IFortTeamActorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortTeamActorInterface>();
	}
};
static_assert(alignof(IFortTeamActorInterface) == 0x000008, "Wrong alignment on IFortTeamActorInterface");
static_assert(sizeof(IFortTeamActorInterface) == 0x000028, "Wrong size on IFortTeamActorInterface");

// Class FortniteGame.FortInitializationInterface
// 0x0000 (0x0028 - 0x0028)
class IFortInitializationInterface final : public IInterface
{
public:
	void MatchStarted();
	bool NeedsWorldReady();
	void WorldReady();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortInitializationInterface">();
	}
	static class IFortInitializationInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortInitializationInterface>();
	}
};
static_assert(alignof(IFortInitializationInterface) == 0x000008, "Wrong alignment on IFortInitializationInterface");
static_assert(sizeof(IFortInitializationInterface) == 0x000028, "Wrong size on IFortInitializationInterface");

// Class FortniteGame.FortAthenaAircraft
// 0x0128 (0x04B0 - 0x0388)
class AFortAthenaAircraft final : public AActor
{
public:
	uint8                                         Pad_388[0x30];                                     // 0x0388(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         JumpFlashCount;                                    // 0x03B8(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3BC[0x4];                                      // 0x03BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UFortCameraMode_AthenaAircraft> CameraModeClass;                                   // 0x03C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               CameraInitialRotation;                             // 0x03C8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                ExitLocation;                                      // 0x03D4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector_NetQuantize100                 FlightStartLocation;                               // 0x03E0(0x000C)(Net, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               FlightStartRotation;                               // 0x03EC(0x000C)(Net, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         FlightSpeed;                                       // 0x03F8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlightStartTime;                                   // 0x03FC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlightEndTime;                                     // 0x0400(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DropStartTime;                                     // 0x0404(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DropEndTime;                                       // 0x0408(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40C[0x10];                                     // 0x040C(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MiniMapIconScale;                                  // 0x041C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateBrush                            MiniMapIconBrush;                                  // 0x0420(0x0090)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void OnRep_JumpFlashCount();
	void PlayEffectsForPlayerJumped();

	float GetDropEndTime() const;
	float GetDropStartTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaAircraft">();
	}
	static class AFortAthenaAircraft* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAthenaAircraft>();
	}
};
static_assert(alignof(AFortAthenaAircraft) == 0x000008, "Wrong alignment on AFortAthenaAircraft");
static_assert(sizeof(AFortAthenaAircraft) == 0x0004B0, "Wrong size on AFortAthenaAircraft");
static_assert(offsetof(AFortAthenaAircraft, JumpFlashCount) == 0x0003B8, "Member 'AFortAthenaAircraft::JumpFlashCount' has a wrong offset!");
static_assert(offsetof(AFortAthenaAircraft, CameraModeClass) == 0x0003C0, "Member 'AFortAthenaAircraft::CameraModeClass' has a wrong offset!");
static_assert(offsetof(AFortAthenaAircraft, CameraInitialRotation) == 0x0003C8, "Member 'AFortAthenaAircraft::CameraInitialRotation' has a wrong offset!");
static_assert(offsetof(AFortAthenaAircraft, ExitLocation) == 0x0003D4, "Member 'AFortAthenaAircraft::ExitLocation' has a wrong offset!");
static_assert(offsetof(AFortAthenaAircraft, FlightStartLocation) == 0x0003E0, "Member 'AFortAthenaAircraft::FlightStartLocation' has a wrong offset!");
static_assert(offsetof(AFortAthenaAircraft, FlightStartRotation) == 0x0003EC, "Member 'AFortAthenaAircraft::FlightStartRotation' has a wrong offset!");
static_assert(offsetof(AFortAthenaAircraft, FlightSpeed) == 0x0003F8, "Member 'AFortAthenaAircraft::FlightSpeed' has a wrong offset!");
static_assert(offsetof(AFortAthenaAircraft, FlightStartTime) == 0x0003FC, "Member 'AFortAthenaAircraft::FlightStartTime' has a wrong offset!");
static_assert(offsetof(AFortAthenaAircraft, FlightEndTime) == 0x000400, "Member 'AFortAthenaAircraft::FlightEndTime' has a wrong offset!");
static_assert(offsetof(AFortAthenaAircraft, DropStartTime) == 0x000404, "Member 'AFortAthenaAircraft::DropStartTime' has a wrong offset!");
static_assert(offsetof(AFortAthenaAircraft, DropEndTime) == 0x000408, "Member 'AFortAthenaAircraft::DropEndTime' has a wrong offset!");
static_assert(offsetof(AFortAthenaAircraft, MiniMapIconScale) == 0x00041C, "Member 'AFortAthenaAircraft::MiniMapIconScale' has a wrong offset!");
static_assert(offsetof(AFortAthenaAircraft, MiniMapIconBrush) == 0x000420, "Member 'AFortAthenaAircraft::MiniMapIconBrush' has a wrong offset!");

// Class FortniteGame.FortSpawnableByPlacementSystemInterface
// 0x0000 (0x0028 - 0x0028)
class IFortSpawnableByPlacementSystemInterface final : public IInterface
{
public:
	class AFortMission* GetMission() const;
	struct FGuid GetMissionGuid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortSpawnableByPlacementSystemInterface">();
	}
	static class IFortSpawnableByPlacementSystemInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortSpawnableByPlacementSystemInterface>();
	}
};
static_assert(alignof(IFortSpawnableByPlacementSystemInterface) == 0x000008, "Wrong alignment on IFortSpawnableByPlacementSystemInterface");
static_assert(sizeof(IFortSpawnableByPlacementSystemInterface) == 0x000028, "Wrong size on IFortSpawnableByPlacementSystemInterface");

// Class FortniteGame.FortAbilitySystemInterface
// 0x0000 (0x0028 - 0x0028)
class IFortAbilitySystemInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAbilitySystemInterface">();
	}
	static class IFortAbilitySystemInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortAbilitySystemInterface>();
	}
};
static_assert(alignof(IFortAbilitySystemInterface) == 0x000008, "Wrong alignment on IFortAbilitySystemInterface");
static_assert(sizeof(IFortAbilitySystemInterface) == 0x000028, "Wrong size on IFortAbilitySystemInterface");

// Class FortniteGame.FortNavArea_WalkOverWall
// 0x0000 (0x0048 - 0x0048)
class UFortNavArea_WalkOverWall final : public UFortNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_WalkOverWall">();
	}
	static class UFortNavArea_WalkOverWall* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_WalkOverWall>();
	}
};
static_assert(alignof(UFortNavArea_WalkOverWall) == 0x000008, "Wrong alignment on UFortNavArea_WalkOverWall");
static_assert(sizeof(UFortNavArea_WalkOverWall) == 0x000048, "Wrong size on UFortNavArea_WalkOverWall");

// Class FortniteGame.FortQueryGenerator_ActorsAround
// 0x0000 (0x00C0 - 0x00C0)
class UFortQueryGenerator_ActorsAround final : public UEnvQueryGenerator_ActorsOfClass
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_ActorsAround">();
	}
	static class UFortQueryGenerator_ActorsAround* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_ActorsAround>();
	}
};
static_assert(alignof(UFortQueryGenerator_ActorsAround) == 0x000008, "Wrong alignment on UFortQueryGenerator_ActorsAround");
static_assert(sizeof(UFortQueryGenerator_ActorsAround) == 0x0000C0, "Wrong size on UFortQueryGenerator_ActorsAround");

// Class FortniteGame.FortItemDefinition
// 0x01F8 (0x0220 - 0x0028)
class UFortItemDefinition : public UMcpItemDefinitionBase
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnItemCountChanged;                                // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EFortItemType                                 ItemType;                                          // 0x0048(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AssetRegistrySearchable, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinLevel;                                          // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxLevel;                                          // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, AssetRegistrySearchable, Protected, NativeAccessSpecifierProtected)
	class FText                                   ShortDescription;                                  // 0x0070(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   Description;                                       // 0x0088(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   DisplayNamePrefix;                                 // 0x00A0(0x0018)(Protected, NativeAccessSpecifierProtected)
	class FText                                   SearchTags;                                        // 0x00B8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  GameplayTags;                                      // 0x00D0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	EFortInventoryFilter                          FilterOverride;                                    // 0x00F0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bIsAccountItem : 1;                                // 0x00F4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bNeverPersisted : 1;                               // 0x00F4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AssetRegistrySearchable, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_F5[0x3];                                       // 0x00F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  SecondaryCategoryOverrideTags;                     // 0x00F8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  TertiaryCategoryOverrideTags;                      // 0x0118(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         bAllowMultipleStacks : 1;                          // 0x0138(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_139[0x3];                                      // 0x0139(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxStackSize;                                      // 0x013C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPrivateTemplate;                                  // 0x0140(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInventorySizeLimited;                             // 0x0141(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortTemplateAccess                           Access;                                            // 0x0142(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCalculateRarityFromQualityAndTier;                // 0x0143(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortQuality                                  Quality;                                           // 0x0144(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortItemTier                                 Tier;                                              // 0x0145(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortItemTier                                 MaxTier;                                           // 0x0146(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_147[0x1];                                      // 0x0147(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   TooltipClass;                                      // 0x0148(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFortTooltipDisplayStatsList> StatList;                                          // 0x0168(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   RatingLookup;                                      // 0x0188(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UTexture2D*                             SmallPreviewImage;                                 // 0x0198(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              LargePreviewImage;                                 // 0x01A0(0x0020)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortRarity                                   Rarity;                                            // 0x01C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C1[0xF];                                      // 0x01C1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             FrontendPreviewMeshOffset;                         // 0x01D0(0x0030)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UStaticMesh>             FrontendPreviewMeshOverride;                       // 0x0200(0x0020)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UFortItem* CreateTemporaryInstanceFromExistingItemBP(class UFortItem* ExistingItem, int32 Count, int32 Level) const;
	class UFortItem* CreateTemporaryItemInstanceBP(int32 Count, int32 Level) const;
	TArray<class FText> GetDescription() const;
	class FText GetDisplayName(bool bBaseName) const;
	class UFortTooltipDisplayStatsList* GetDisplayStats() const;
	TSoftObjectPtr<class UTexture2D> GetLargePreviewImage() const;
	class FString GetPersistentName() const;
	struct FTransform GetPreviewMeshOffset() const;
	bool GetPreviewSkeletalMeshAsset(TSoftObjectPtr<class USkeletalMesh>* Asset) const;
	bool GetPreviewStaticMeshAsset(TSoftObjectPtr<class UStaticMesh>* Asset) const;
	class FText GetShortDescription() const;
	class FText GetSingleLineDescription() const;
	TSoftObjectPtr<class UTexture2D> GetSmallPreviewImage() const;
	struct FSlateBrush GetSmallPreviewImageBrush() const;
	TSubclassOf<class UFortTooltip> GetTooltip() const;
	bool IsInventorySizeLimited() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortItemDefinition">();
	}
	static class UFortItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortItemDefinition>();
	}
};
static_assert(alignof(UFortItemDefinition) == 0x000010, "Wrong alignment on UFortItemDefinition");
static_assert(sizeof(UFortItemDefinition) == 0x000220, "Wrong size on UFortItemDefinition");
static_assert(offsetof(UFortItemDefinition, OnItemCountChanged) == 0x000038, "Member 'UFortItemDefinition::OnItemCountChanged' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, ItemType) == 0x000048, "Member 'UFortItemDefinition::ItemType' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, MinLevel) == 0x00004C, "Member 'UFortItemDefinition::MinLevel' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, MaxLevel) == 0x000050, "Member 'UFortItemDefinition::MaxLevel' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, DisplayName) == 0x000058, "Member 'UFortItemDefinition::DisplayName' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, ShortDescription) == 0x000070, "Member 'UFortItemDefinition::ShortDescription' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, Description) == 0x000088, "Member 'UFortItemDefinition::Description' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, DisplayNamePrefix) == 0x0000A0, "Member 'UFortItemDefinition::DisplayNamePrefix' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, SearchTags) == 0x0000B8, "Member 'UFortItemDefinition::SearchTags' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, GameplayTags) == 0x0000D0, "Member 'UFortItemDefinition::GameplayTags' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, FilterOverride) == 0x0000F0, "Member 'UFortItemDefinition::FilterOverride' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, SecondaryCategoryOverrideTags) == 0x0000F8, "Member 'UFortItemDefinition::SecondaryCategoryOverrideTags' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, TertiaryCategoryOverrideTags) == 0x000118, "Member 'UFortItemDefinition::TertiaryCategoryOverrideTags' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, MaxStackSize) == 0x00013C, "Member 'UFortItemDefinition::MaxStackSize' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, bPrivateTemplate) == 0x000140, "Member 'UFortItemDefinition::bPrivateTemplate' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, bInventorySizeLimited) == 0x000141, "Member 'UFortItemDefinition::bInventorySizeLimited' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, Access) == 0x000142, "Member 'UFortItemDefinition::Access' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, bCalculateRarityFromQualityAndTier) == 0x000143, "Member 'UFortItemDefinition::bCalculateRarityFromQualityAndTier' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, Quality) == 0x000144, "Member 'UFortItemDefinition::Quality' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, Tier) == 0x000145, "Member 'UFortItemDefinition::Tier' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, MaxTier) == 0x000146, "Member 'UFortItemDefinition::MaxTier' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, TooltipClass) == 0x000148, "Member 'UFortItemDefinition::TooltipClass' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, StatList) == 0x000168, "Member 'UFortItemDefinition::StatList' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, RatingLookup) == 0x000188, "Member 'UFortItemDefinition::RatingLookup' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, SmallPreviewImage) == 0x000198, "Member 'UFortItemDefinition::SmallPreviewImage' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, LargePreviewImage) == 0x0001A0, "Member 'UFortItemDefinition::LargePreviewImage' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, Rarity) == 0x0001C0, "Member 'UFortItemDefinition::Rarity' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, FrontendPreviewMeshOffset) == 0x0001D0, "Member 'UFortItemDefinition::FrontendPreviewMeshOffset' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, FrontendPreviewMeshOverride) == 0x000200, "Member 'UFortItemDefinition::FrontendPreviewMeshOverride' has a wrong offset!");

// Class FortniteGame.FortWorldItemDefinition
// 0x0200 (0x0420 - 0x0220)
class UFortWorldItemDefinition : public UFortItemDefinition
{
public:
	struct FGameplayTagContainer                  RequiredEquipTags;                                 // 0x0220(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  OverrideAutoEquipTags;                             // 0x0240(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bCanAutoEquipByClass;                              // 0x0260(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_261[0x3];                                      // 0x0261(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bSupportsQuickbarFocus : 1;                        // 0x0264(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bShouldShowItemToast : 1;                          // 0x0264(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShowDirectionalArrowWhenFarOff : 1;               // 0x0264(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanBeDropped : 1;                                 // 0x0264(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bItemCanBeStolen : 1;                              // 0x0264(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanBeDepositedInStorageVault : 1;                 // 0x0264(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bItemHasDurability : 1;                            // 0x0264(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_265[0x3];                                      // 0x0265(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DropCount;                                         // 0x0268(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortReplicatedStat                           AccumulatingStatType;                              // 0x026C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26D[0x3];                                      // 0x026D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            MiniMapIconBrush;                                  // 0x0270(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         MiniMapViewableDistance;                           // 0x0300(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_304[0x4];                                      // 0x0304(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   OwnerPickupText;                                   // 0x0308(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FDataTableCategoryHandle               LootLevelData;                                     // 0x0320(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_338[0x8];                                      // 0x0338(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             PickupMeshTransform;                               // 0x0340(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverridePickupMeshTransform : 1;                  // 0x0370(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDropOnDeath : 1;                                  // 0x0370(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDropOnLogout : 1;                                 // 0x0370(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_371[0x7];                                      // 0x0371(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UStaticMesh>             PickupStaticMesh;                                  // 0x0378(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class USkeletalMesh>           PickupSkeletalMesh;                                // 0x0398(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class USoundBase>              PickupSound;                                       // 0x03B8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class USoundBase>              DropSound;                                         // 0x03D8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDataTableRowHandle                    DisassembleRecipe;                                 // 0x03F8(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         DisassembleDurabilityDegradeMinLootPercent;        // 0x0408(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DisassembleDurabilityDegradeMaxLootPercent;        // 0x040C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasDisintegrationValue;                           // 0x0410(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUsesCraftingRecipeToGetDisintegrationValue;       // 0x0411(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_412[0x2];                                      // 0x0412(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FabricationValueOverride;                          // 0x0414(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PreferredQuickbarSlot;                             // 0x0418(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41C[0x4];                                      // 0x041C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanBeDisassembled() const;
	class UFortWorldItemDefinition* GetAmmoWorldItemDefinition_BP() const;
	float GetDPSAtLevel(int32 ItemLevel) const;
	int32 GetFabricationValue(bool bUseDisintegrationOverride) const;
	float GetMaxDurability(int32 ItemLevel) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortWorldItemDefinition">();
	}
	static class UFortWorldItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortWorldItemDefinition>();
	}
};
static_assert(alignof(UFortWorldItemDefinition) == 0x000010, "Wrong alignment on UFortWorldItemDefinition");
static_assert(sizeof(UFortWorldItemDefinition) == 0x000420, "Wrong size on UFortWorldItemDefinition");
static_assert(offsetof(UFortWorldItemDefinition, RequiredEquipTags) == 0x000220, "Member 'UFortWorldItemDefinition::RequiredEquipTags' has a wrong offset!");
static_assert(offsetof(UFortWorldItemDefinition, OverrideAutoEquipTags) == 0x000240, "Member 'UFortWorldItemDefinition::OverrideAutoEquipTags' has a wrong offset!");
static_assert(offsetof(UFortWorldItemDefinition, bCanAutoEquipByClass) == 0x000260, "Member 'UFortWorldItemDefinition::bCanAutoEquipByClass' has a wrong offset!");
static_assert(offsetof(UFortWorldItemDefinition, DropCount) == 0x000268, "Member 'UFortWorldItemDefinition::DropCount' has a wrong offset!");
static_assert(offsetof(UFortWorldItemDefinition, AccumulatingStatType) == 0x00026C, "Member 'UFortWorldItemDefinition::AccumulatingStatType' has a wrong offset!");
static_assert(offsetof(UFortWorldItemDefinition, MiniMapIconBrush) == 0x000270, "Member 'UFortWorldItemDefinition::MiniMapIconBrush' has a wrong offset!");
static_assert(offsetof(UFortWorldItemDefinition, MiniMapViewableDistance) == 0x000300, "Member 'UFortWorldItemDefinition::MiniMapViewableDistance' has a wrong offset!");
static_assert(offsetof(UFortWorldItemDefinition, OwnerPickupText) == 0x000308, "Member 'UFortWorldItemDefinition::OwnerPickupText' has a wrong offset!");
static_assert(offsetof(UFortWorldItemDefinition, LootLevelData) == 0x000320, "Member 'UFortWorldItemDefinition::LootLevelData' has a wrong offset!");
static_assert(offsetof(UFortWorldItemDefinition, PickupMeshTransform) == 0x000340, "Member 'UFortWorldItemDefinition::PickupMeshTransform' has a wrong offset!");
static_assert(offsetof(UFortWorldItemDefinition, PickupStaticMesh) == 0x000378, "Member 'UFortWorldItemDefinition::PickupStaticMesh' has a wrong offset!");
static_assert(offsetof(UFortWorldItemDefinition, PickupSkeletalMesh) == 0x000398, "Member 'UFortWorldItemDefinition::PickupSkeletalMesh' has a wrong offset!");
static_assert(offsetof(UFortWorldItemDefinition, PickupSound) == 0x0003B8, "Member 'UFortWorldItemDefinition::PickupSound' has a wrong offset!");
static_assert(offsetof(UFortWorldItemDefinition, DropSound) == 0x0003D8, "Member 'UFortWorldItemDefinition::DropSound' has a wrong offset!");
static_assert(offsetof(UFortWorldItemDefinition, DisassembleRecipe) == 0x0003F8, "Member 'UFortWorldItemDefinition::DisassembleRecipe' has a wrong offset!");
static_assert(offsetof(UFortWorldItemDefinition, DisassembleDurabilityDegradeMinLootPercent) == 0x000408, "Member 'UFortWorldItemDefinition::DisassembleDurabilityDegradeMinLootPercent' has a wrong offset!");
static_assert(offsetof(UFortWorldItemDefinition, DisassembleDurabilityDegradeMaxLootPercent) == 0x00040C, "Member 'UFortWorldItemDefinition::DisassembleDurabilityDegradeMaxLootPercent' has a wrong offset!");
static_assert(offsetof(UFortWorldItemDefinition, bHasDisintegrationValue) == 0x000410, "Member 'UFortWorldItemDefinition::bHasDisintegrationValue' has a wrong offset!");
static_assert(offsetof(UFortWorldItemDefinition, bUsesCraftingRecipeToGetDisintegrationValue) == 0x000411, "Member 'UFortWorldItemDefinition::bUsesCraftingRecipeToGetDisintegrationValue' has a wrong offset!");
static_assert(offsetof(UFortWorldItemDefinition, FabricationValueOverride) == 0x000414, "Member 'UFortWorldItemDefinition::FabricationValueOverride' has a wrong offset!");
static_assert(offsetof(UFortWorldItemDefinition, PreferredQuickbarSlot) == 0x000418, "Member 'UFortWorldItemDefinition::PreferredQuickbarSlot' has a wrong offset!");

// Class FortniteGame.CustomCharacterPart
// 0x0110 (0x0530 - 0x0420)
class UCustomCharacterPart final : public UFortWorldItemDefinition
{
public:
	EFortCustomGender                             GenderPermitted;                                   // 0x0420(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortCustomBodyType                           BodyTypesPermitted;                                // 0x0421(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortCustomPartType                           CharacterPartType;                                 // 0x0422(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_423[0x5];                                      // 0x0423(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  PartTypeTags;                                      // 0x0428(0x0020)(Edit, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  AttachLocationTags;                                // 0x0448(0x0020)(Edit, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  CauseMorphOnLocationsTags;                         // 0x0468(0x0020)(Edit, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   PartModifierBlueprint;                             // 0x0488(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCustomCharacterPartData*               AdditionalData;                                    // 0x04A8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class USkeletalMesh>           SkeletalMesh;                                      // 0x04B0(0x0020)(Edit, AssetRegistrySearchable, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class USkeletalMesh>>   MasterSkeletalMeshes;                              // 0x04D0(0x0010)(Edit, ZeroConstructor, AssetRegistrySearchable, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                          bSinglePieceMesh;                                  // 0x04E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSupportsColorSwatches;                            // 0x04E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4E2[0x6];                                      // 0x04E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCustomPartMaterialOverrideData> MaterialOverrides;                                 // 0x04E8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FCustomPartTextureParameter>    TextureParameters;                                 // 0x04F8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FCustomPartScalarParameter>     ScalarParameters;                                  // 0x0508(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FCustomPartVectorParameter>     VectorParameters;                                  // 0x0518(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         MaterialOverrideFlags;                             // 0x0528(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_52C[0x4];                                      // 0x052C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomCharacterPart">();
	}
	static class UCustomCharacterPart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomCharacterPart>();
	}
};
static_assert(alignof(UCustomCharacterPart) == 0x000010, "Wrong alignment on UCustomCharacterPart");
static_assert(sizeof(UCustomCharacterPart) == 0x000530, "Wrong size on UCustomCharacterPart");
static_assert(offsetof(UCustomCharacterPart, GenderPermitted) == 0x000420, "Member 'UCustomCharacterPart::GenderPermitted' has a wrong offset!");
static_assert(offsetof(UCustomCharacterPart, BodyTypesPermitted) == 0x000421, "Member 'UCustomCharacterPart::BodyTypesPermitted' has a wrong offset!");
static_assert(offsetof(UCustomCharacterPart, CharacterPartType) == 0x000422, "Member 'UCustomCharacterPart::CharacterPartType' has a wrong offset!");
static_assert(offsetof(UCustomCharacterPart, PartTypeTags) == 0x000428, "Member 'UCustomCharacterPart::PartTypeTags' has a wrong offset!");
static_assert(offsetof(UCustomCharacterPart, AttachLocationTags) == 0x000448, "Member 'UCustomCharacterPart::AttachLocationTags' has a wrong offset!");
static_assert(offsetof(UCustomCharacterPart, CauseMorphOnLocationsTags) == 0x000468, "Member 'UCustomCharacterPart::CauseMorphOnLocationsTags' has a wrong offset!");
static_assert(offsetof(UCustomCharacterPart, PartModifierBlueprint) == 0x000488, "Member 'UCustomCharacterPart::PartModifierBlueprint' has a wrong offset!");
static_assert(offsetof(UCustomCharacterPart, AdditionalData) == 0x0004A8, "Member 'UCustomCharacterPart::AdditionalData' has a wrong offset!");
static_assert(offsetof(UCustomCharacterPart, SkeletalMesh) == 0x0004B0, "Member 'UCustomCharacterPart::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(UCustomCharacterPart, MasterSkeletalMeshes) == 0x0004D0, "Member 'UCustomCharacterPart::MasterSkeletalMeshes' has a wrong offset!");
static_assert(offsetof(UCustomCharacterPart, bSinglePieceMesh) == 0x0004E0, "Member 'UCustomCharacterPart::bSinglePieceMesh' has a wrong offset!");
static_assert(offsetof(UCustomCharacterPart, bSupportsColorSwatches) == 0x0004E1, "Member 'UCustomCharacterPart::bSupportsColorSwatches' has a wrong offset!");
static_assert(offsetof(UCustomCharacterPart, MaterialOverrides) == 0x0004E8, "Member 'UCustomCharacterPart::MaterialOverrides' has a wrong offset!");
static_assert(offsetof(UCustomCharacterPart, TextureParameters) == 0x0004F8, "Member 'UCustomCharacterPart::TextureParameters' has a wrong offset!");
static_assert(offsetof(UCustomCharacterPart, ScalarParameters) == 0x000508, "Member 'UCustomCharacterPart::ScalarParameters' has a wrong offset!");
static_assert(offsetof(UCustomCharacterPart, VectorParameters) == 0x000518, "Member 'UCustomCharacterPart::VectorParameters' has a wrong offset!");
static_assert(offsetof(UCustomCharacterPart, MaterialOverrideFlags) == 0x000528, "Member 'UCustomCharacterPart::MaterialOverrideFlags' has a wrong offset!");

// Class FortniteGame.BuildingActor
// 0x03B0 (0x0738 - 0x0388)
#pragma pack(push, 0x1)
class alignas(0x08) ABuildingActor : public AActor
{
public:
	uint8                                         Pad_388[0x68];                                     // 0x0388(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	EFortBuildingType                             BuildingType;                                      // 0x03F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F1[0x3];                                      // 0x03F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  MyGuid;                                            // 0x03F4(0x0010)(Net, DuplicateTransient, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_404[0x4];                                      // 0x0404(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   InteractionText;                                   // 0x0408(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0420(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         OwnerPersistentID;                                 // 0x0438(0x0004)(Net, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43C[0x4];                                      // 0x043C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   AreaClass;                                         // 0x0440(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   NavigationLinksClass;                              // 0x0460(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_480[0x10];                                     // 0x0480(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SavedHealthPct;                                    // 0x0490(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bHasRegisteredActorStateAtLeastOnce : 1;           // 0x0494(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDirtyForLevelRecordSave : 1;                      // 0x0494(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bSavedMetaPropertiesProcessed : 1;                 // 0x0494(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_495[0x3];                                      // 0x0495(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentBuildingLevel;                              // 0x0498(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, RepNotify, NoDestructor, AssetRegistrySearchable, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaximumBuildingLevel;                              // 0x049C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bUpgradeUsesSameClass : 1;                         // 0x04A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDisplayLevelInInfoWidget : 1;                     // 0x04A0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAllowUpgradeRegardlessOfPlayerBuildLevel : 1;     // 0x04A0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_4A1[0x7];                                      // 0x04A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UFortBuildingActorSet>      BuildingAttributeSetClass;                         // 0x04A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortBuildingActorSet*                  BuildingAttributeSet;                              // 0x04B0(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFortAttributeInitializationKey        AttributeInitKey;                                  // 0x04B8(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	EAttributeInitLevelSource                     AttributeInitLevelSource;                          // 0x04C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAbilitySystemComponentCreationPolicy         AbilitySystemComponentCreationPolicy;              // 0x04C9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4CA[0x6];                                      // 0x04CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAbilitySystemComponent*            AbilitySystemComponent;                            // 0x04D0(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FGameplayCueParameters>         PendingDamageImpactCues;                           // 0x04D8(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bIsInvulnerable : 1;                               // 0x04E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSurpressHealthBar : 1;                            // 0x04E8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCreateVerboseHealthLogs : 1;                      // 0x04E8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsIndestructibleForTargetSelection : 1;           // 0x04E8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_4E9[0x7];                                      // 0x04E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  DefaultTags;                                       // 0x04F0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  ConstTags;                                         // 0x0510(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, DisableEditOnInstance, EditConst, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  StaticGameplayTags;                                // 0x0530(0x0020)(Protected, NativeAccessSpecifierProtected)
	EDynamicBuildingPlacementType                 DynamicBuildingPlacementType;                      // 0x0550(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENavigationObstacleOverride                   NavigationObstacleOverride;                        // 0x0551(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_552[0x2];                                      // 0x0552(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bDestroyed : 1;                                    // 0x0554(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPersistToWorld : 1;                               // 0x0554(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRefreshFullSaveDataBeforeZoneSave : 1;            // 0x0554(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bBeingDragged : 1;                                 // 0x0554(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRotateInPlaceGame : 1;                            // 0x0554(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_554_5 : 1;                                  // 0x0554(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bIsNavigationModifier : 1;                         // 0x0554(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bBlockNavigationLinks : 1;                         // 0x0554(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanExportNavigationCollisions : 1;                // 0x0555(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanExportNavigationObstacle : 1;                  // 0x0555(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bMirrorNavLinksX : 1;                              // 0x0555(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bMirrorNavLinksY : 1;                              // 0x0555(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIgnoreMoveGoalCollisionRadius : 1;                // 0x0555(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bForceDisableRootNavigationRelevance : 1;          // 0x0555(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bForceAutomationPass : 1;                          // 0x0555(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bForceAutomationPass_NavmeshOnTop : 1;             // 0x0555(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bForceAutomationPass_SmashableFlat : 1;            // 0x0556(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bWorldReadyCalled : 1;                             // 0x0556(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUseDefaultCullDistance : 1;                       // 0x0556(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bBeingRotatedOrScaled : 1;                         // 0x0556(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bBeingTranslated : 1;                              // 0x0556(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bRotateInPlaceEditor : 1;                          // 0x0556(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bEditorPlaced : 1;                                 // 0x0556(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bPlayerPlaced : 1;                                 // 0x0556(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bShouldTick : 1;                                   // 0x0557(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUsesDayPhaseChange : 1;                           // 0x0557(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsDynamic : 1;                                    // 0x0557(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AssetRegistrySearchable, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsDynamicOnDedicatedServer : 1;                   // 0x0557(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AssetRegistrySearchable, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsMovable : 1;                                    // 0x0557(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AssetRegistrySearchable, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bRegisteredForDayPhaseChange : 1;                  // 0x0557(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bForceDamagePing : 1;                              // 0x0557(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDestroyFoliageWhenPlaced : 1;                     // 0x0557(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bObstructTrapTargeting : 1;                        // 0x0558(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_559[0x3];                                      // 0x0559(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LDMaxDrawDistance;                                 // 0x055C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AssetRegistrySearchable, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LifespanAfterDeath;                                // 0x0560(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bDoNotBlockBuildings : 1;                          // 0x0564(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, Net, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDestroyOnPlayerBuildingPlacement : 1;             // 0x0564(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, Net, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseCentroidForBlockBuildingsCheck : 1;            // 0x0564(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, Net, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsPlayerBuildable : 1;                            // 0x0564(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_565[0x3];                                      // 0x0565(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnDied;                                            // 0x0568(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnDamaged;                                         // 0x0578(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bFireBuiltAndDestroyedEvents;                      // 0x0588(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_589[0x7];                                      // 0x0589(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortMission*                           AssociatedMissionParam;                            // 0x0590(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPhysicalSurface                              PrimarySurfaceType;                                // 0x0598(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortBaseWeaponDamage                         WeaponResponseType;                                // 0x0599(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59A[0x6];                                      // 0x059A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortPlacementActor*                    OriginatingPlacementActor;                         // 0x05A0(0x0008)(Net, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnInteract;                                        // 0x05A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bAllowInteract;                                    // 0x05B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowHostileBlueprintInteraction;                 // 0x05B9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5BA[0x6];                                      // 0x05BA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCurveTableRowHandle                   InteractionSpeed;                                  // 0x05C0(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D0[0xE0];                                     // 0x05D0(0x00E0)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DataVersion;                                       // 0x06B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastTakeHitTimeTimeout;                            // 0x06B4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FFortDamageSource>              CurFrameDmgSources;                                // 0x06B8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	float                                         CullDistance;                                      // 0x06C8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHighlightState;                                   // 0x06CC(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRequestedHighlightState;                          // 0x06CD(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6CE[0x2];                                      // 0x06CE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             PlayHitSound;                                      // 0x06D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SnapGridSize;                                      // 0x06D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VertSnapGridSize;                                  // 0x06DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                SnapOffset;                                        // 0x06E0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                CentroidOffset;                                    // 0x06EC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                BaseLocToPivotOffset;                              // 0x06F8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_704[0x4];                                      // 0x0704(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CustomState;                                       // 0x0708(0x0010)(Net, ZeroConstructor, SaveGame, RepNotify, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bForceReplayRollback;                              // 0x0718(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortTeam                                     Team;                                              // 0x0719(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_71A[0x2];                                      // 0x071A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bIsNavigationRelevant : 1;                         // 0x071C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bBlockNavLinksInCell : 1;                          // 0x071C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUseHotSpotAsMoveGoalReplacement : 1;              // 0x071C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_71D[0x3];                                      // 0x071D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UBuildingActorHotSpotConfig*            HotSpotConfig;                                     // 0x0720(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnBuildingHealthChanged;                           // 0x0728(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void AddEditorOnlyInstanceGameplayTags(const struct FGameplayTagContainer& NewTags);
	void BlueprintOnBeginInteract();
	void BlueprintOnInteract(const class AFortPawn* InteractingPawn);
	bool BlueprintOnLocalInteract(class AFortPlayerPawn* InteractingPawn);
	void CustomStateChanged();
	void ForceBuildingHealth(float NewHealth);
	void GameplayCue_Damage(EGameplayCueEvent EventType, const struct FGameplayCueParameters& Parameters);
	void GameplayCue_Healing(EGameplayCueEvent EventType, const struct FGameplayCueParameters& Parameters);
	void GameplayCue_InstantDeath(EGameplayCueEvent EventType, const struct FGameplayCueParameters& Parameters);
	void HandleDestroyed();
	void InitializeKismetSpawnedBuildingActor(class ABuildingActor* BuildingOwner, class AFortPlayerController* SpawningController);
	void OnBuildingActorInitialized(EFortBuildingInitializationReason InitializationReason, EFortBuildingPersistentState BuildingPersistentState);
	void OnDamagePlayEffects(float Damage, const struct FGameplayTagContainer& DamageTags, const struct FVector& Momentum, const struct FHitResult& HitInfo, class AFortPawn* InstigatedBy, class AActor* DamageCauser, const struct FGameplayEffectContextHandle& EffectContext);
	void OnDamageServer(float Damage, const struct FGameplayTagContainer& DamageTags, const struct FVector& Momentum, const struct FHitResult& HitInfo, class AController* InstigatedBy, class AActor* DamageCauser, const struct FGameplayEffectContextHandle& EffectContext);
	void OnDayPhaseChanged(EFortDayPhase CurrentDayPhase, EFortDayPhase PreviousDayPhase, bool bAtCreation);
	void OnDeathPlayEffects(float Damage, const struct FGameplayTagContainer& DamageTags, const struct FVector& Momentum, const struct FHitResult& HitInfo, class AFortPawn* InstigatedBy, class AActor* DamageCauser, const struct FGameplayEffectContextHandle& EffectContext);
	void OnDeathServer(float Damage, const struct FGameplayTagContainer& DamageTags, const struct FVector& Momentum, const struct FHitResult& HitInfo, class AController* InstigatedBy, class AActor* DamageCauser, const struct FGameplayEffectContextHandle& EffectContext);
	void OnMatchStarted();
	void OnRep_AbilitySystemComponent();
	void OnRep_bForceReplayRollback();
	void OnRep_BuildingAttributeSet();
	void OnRep_CurrentBuildingLevel();
	void OnRep_CustomState();
	void OnWorldReady();
	void PlacedByPlacementTool();
	void RemoveEditorOnlyInstanceGameplayTags(const struct FGameplayTagContainer& TagsToRemove);
	void SetCanExportNavigationObstacle(bool InCanExportNavigationObstacle);
	void SetCustomState(const class FString& NewState);
	void SetNavigationModifier(bool bEnableModifier);
	bool ShouldDie(float Damage, class AController* EventInstigator, class AActor* DamageCauser);
	void SilentDie();

	bool BlueprintCanInteract(const class AFortPawn* InteractingPawn) const;
	class FText BlueprintGetFailedInteractionString(const class AFortPawn* InteractingPawn) const;
	class FText BlueprintGetInteractionString(const class AFortPawn* InteractingPawn) const;
	struct FVector GetCentroid() const;
	int32 GetCurrentBuildingLevel() const;
	class FString GetCustomState() const;
	void GetEditorTestTags(struct FGameplayTagContainer* TagContainer) const;
	float GetHealth() const;
	float GetHealthPercent() const;
	float GetMaxHealth() const;
	float GetMissingHealth() const;
	class AController* GetOwningController() const;
	class AFortPlayerState* GetOwningPlayerState() const;
	bool HasHealthLeft() const;
	bool IsAcceptablePositionForPlacement(const struct FVector& InLocation, const struct FRotator& InRotation, class AFortDecoTool* DecoTool, bool bIsCDO, class FText* OutFailureReason) const;
	bool IsDamaged() const;
	bool IsPlayerBuilt() const;
	bool UseDefaultHealthBar() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingActor">();
	}
	static class ABuildingActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingActor>();
	}
};
#pragma pack(pop)
static_assert(alignof(ABuildingActor) == 0x000008, "Wrong alignment on ABuildingActor");
static_assert(sizeof(ABuildingActor) == 0x000738, "Wrong size on ABuildingActor");
static_assert(offsetof(ABuildingActor, BuildingType) == 0x0003F0, "Member 'ABuildingActor::BuildingType' has a wrong offset!");
static_assert(offsetof(ABuildingActor, MyGuid) == 0x0003F4, "Member 'ABuildingActor::MyGuid' has a wrong offset!");
static_assert(offsetof(ABuildingActor, InteractionText) == 0x000408, "Member 'ABuildingActor::InteractionText' has a wrong offset!");
static_assert(offsetof(ABuildingActor, DisplayName) == 0x000420, "Member 'ABuildingActor::DisplayName' has a wrong offset!");
static_assert(offsetof(ABuildingActor, OwnerPersistentID) == 0x000438, "Member 'ABuildingActor::OwnerPersistentID' has a wrong offset!");
static_assert(offsetof(ABuildingActor, AreaClass) == 0x000440, "Member 'ABuildingActor::AreaClass' has a wrong offset!");
static_assert(offsetof(ABuildingActor, NavigationLinksClass) == 0x000460, "Member 'ABuildingActor::NavigationLinksClass' has a wrong offset!");
static_assert(offsetof(ABuildingActor, SavedHealthPct) == 0x000490, "Member 'ABuildingActor::SavedHealthPct' has a wrong offset!");
static_assert(offsetof(ABuildingActor, CurrentBuildingLevel) == 0x000498, "Member 'ABuildingActor::CurrentBuildingLevel' has a wrong offset!");
static_assert(offsetof(ABuildingActor, MaximumBuildingLevel) == 0x00049C, "Member 'ABuildingActor::MaximumBuildingLevel' has a wrong offset!");
static_assert(offsetof(ABuildingActor, BuildingAttributeSetClass) == 0x0004A8, "Member 'ABuildingActor::BuildingAttributeSetClass' has a wrong offset!");
static_assert(offsetof(ABuildingActor, BuildingAttributeSet) == 0x0004B0, "Member 'ABuildingActor::BuildingAttributeSet' has a wrong offset!");
static_assert(offsetof(ABuildingActor, AttributeInitKey) == 0x0004B8, "Member 'ABuildingActor::AttributeInitKey' has a wrong offset!");
static_assert(offsetof(ABuildingActor, AttributeInitLevelSource) == 0x0004C8, "Member 'ABuildingActor::AttributeInitLevelSource' has a wrong offset!");
static_assert(offsetof(ABuildingActor, AbilitySystemComponentCreationPolicy) == 0x0004C9, "Member 'ABuildingActor::AbilitySystemComponentCreationPolicy' has a wrong offset!");
static_assert(offsetof(ABuildingActor, AbilitySystemComponent) == 0x0004D0, "Member 'ABuildingActor::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(ABuildingActor, PendingDamageImpactCues) == 0x0004D8, "Member 'ABuildingActor::PendingDamageImpactCues' has a wrong offset!");
static_assert(offsetof(ABuildingActor, DefaultTags) == 0x0004F0, "Member 'ABuildingActor::DefaultTags' has a wrong offset!");
static_assert(offsetof(ABuildingActor, ConstTags) == 0x000510, "Member 'ABuildingActor::ConstTags' has a wrong offset!");
static_assert(offsetof(ABuildingActor, StaticGameplayTags) == 0x000530, "Member 'ABuildingActor::StaticGameplayTags' has a wrong offset!");
static_assert(offsetof(ABuildingActor, DynamicBuildingPlacementType) == 0x000550, "Member 'ABuildingActor::DynamicBuildingPlacementType' has a wrong offset!");
static_assert(offsetof(ABuildingActor, NavigationObstacleOverride) == 0x000551, "Member 'ABuildingActor::NavigationObstacleOverride' has a wrong offset!");
static_assert(offsetof(ABuildingActor, LDMaxDrawDistance) == 0x00055C, "Member 'ABuildingActor::LDMaxDrawDistance' has a wrong offset!");
static_assert(offsetof(ABuildingActor, LifespanAfterDeath) == 0x000560, "Member 'ABuildingActor::LifespanAfterDeath' has a wrong offset!");
static_assert(offsetof(ABuildingActor, OnDied) == 0x000568, "Member 'ABuildingActor::OnDied' has a wrong offset!");
static_assert(offsetof(ABuildingActor, OnDamaged) == 0x000578, "Member 'ABuildingActor::OnDamaged' has a wrong offset!");
static_assert(offsetof(ABuildingActor, bFireBuiltAndDestroyedEvents) == 0x000588, "Member 'ABuildingActor::bFireBuiltAndDestroyedEvents' has a wrong offset!");
static_assert(offsetof(ABuildingActor, AssociatedMissionParam) == 0x000590, "Member 'ABuildingActor::AssociatedMissionParam' has a wrong offset!");
static_assert(offsetof(ABuildingActor, PrimarySurfaceType) == 0x000598, "Member 'ABuildingActor::PrimarySurfaceType' has a wrong offset!");
static_assert(offsetof(ABuildingActor, WeaponResponseType) == 0x000599, "Member 'ABuildingActor::WeaponResponseType' has a wrong offset!");
static_assert(offsetof(ABuildingActor, OriginatingPlacementActor) == 0x0005A0, "Member 'ABuildingActor::OriginatingPlacementActor' has a wrong offset!");
static_assert(offsetof(ABuildingActor, OnInteract) == 0x0005A8, "Member 'ABuildingActor::OnInteract' has a wrong offset!");
static_assert(offsetof(ABuildingActor, bAllowInteract) == 0x0005B8, "Member 'ABuildingActor::bAllowInteract' has a wrong offset!");
static_assert(offsetof(ABuildingActor, bAllowHostileBlueprintInteraction) == 0x0005B9, "Member 'ABuildingActor::bAllowHostileBlueprintInteraction' has a wrong offset!");
static_assert(offsetof(ABuildingActor, InteractionSpeed) == 0x0005C0, "Member 'ABuildingActor::InteractionSpeed' has a wrong offset!");
static_assert(offsetof(ABuildingActor, DataVersion) == 0x0006B0, "Member 'ABuildingActor::DataVersion' has a wrong offset!");
static_assert(offsetof(ABuildingActor, LastTakeHitTimeTimeout) == 0x0006B4, "Member 'ABuildingActor::LastTakeHitTimeTimeout' has a wrong offset!");
static_assert(offsetof(ABuildingActor, CurFrameDmgSources) == 0x0006B8, "Member 'ABuildingActor::CurFrameDmgSources' has a wrong offset!");
static_assert(offsetof(ABuildingActor, CullDistance) == 0x0006C8, "Member 'ABuildingActor::CullDistance' has a wrong offset!");
static_assert(offsetof(ABuildingActor, bHighlightState) == 0x0006CC, "Member 'ABuildingActor::bHighlightState' has a wrong offset!");
static_assert(offsetof(ABuildingActor, bRequestedHighlightState) == 0x0006CD, "Member 'ABuildingActor::bRequestedHighlightState' has a wrong offset!");
static_assert(offsetof(ABuildingActor, PlayHitSound) == 0x0006D0, "Member 'ABuildingActor::PlayHitSound' has a wrong offset!");
static_assert(offsetof(ABuildingActor, SnapGridSize) == 0x0006D8, "Member 'ABuildingActor::SnapGridSize' has a wrong offset!");
static_assert(offsetof(ABuildingActor, VertSnapGridSize) == 0x0006DC, "Member 'ABuildingActor::VertSnapGridSize' has a wrong offset!");
static_assert(offsetof(ABuildingActor, SnapOffset) == 0x0006E0, "Member 'ABuildingActor::SnapOffset' has a wrong offset!");
static_assert(offsetof(ABuildingActor, CentroidOffset) == 0x0006EC, "Member 'ABuildingActor::CentroidOffset' has a wrong offset!");
static_assert(offsetof(ABuildingActor, BaseLocToPivotOffset) == 0x0006F8, "Member 'ABuildingActor::BaseLocToPivotOffset' has a wrong offset!");
static_assert(offsetof(ABuildingActor, CustomState) == 0x000708, "Member 'ABuildingActor::CustomState' has a wrong offset!");
static_assert(offsetof(ABuildingActor, bForceReplayRollback) == 0x000718, "Member 'ABuildingActor::bForceReplayRollback' has a wrong offset!");
static_assert(offsetof(ABuildingActor, Team) == 0x000719, "Member 'ABuildingActor::Team' has a wrong offset!");
static_assert(offsetof(ABuildingActor, HotSpotConfig) == 0x000720, "Member 'ABuildingActor::HotSpotConfig' has a wrong offset!");
static_assert(offsetof(ABuildingActor, OnBuildingHealthChanged) == 0x000728, "Member 'ABuildingActor::OnBuildingHealthChanged' has a wrong offset!");

// Class FortniteGame.FortCrackEffect
// 0x00C8 (0x0450 - 0x0388)
class AFortCrackEffect : public AActor
{
public:
	uint8                                         Pad_388[0x20];                                     // 0x0388(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bFadingOut;                                        // 0x03A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A9[0x3];                                      // 0x03A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ABuildingSMActor>        ParentBuilding;                                    // 0x03AC(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bHit : 1;                                          // 0x03B4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3B5[0x3];                                      // 0x03B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CrackHitCount;                                     // 0x03B8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CrackLevel;                                        // 0x03BC(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCrackLevel;                                     // 0x03C0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    StartingLocation;                                  // 0x03C4(0x000C)(Edit, BlueprintVisible, Net, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              StartingNormal;                                    // 0x03D0(0x000C)(Edit, BlueprintVisible, Net, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              HitNormal;                                         // 0x03DC(0x000C)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	EPhysicalSurface                              PhysicalSurfaceType;                               // 0x03E8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E9[0x7];                                      // 0x03E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UPhysicalMaterial>       WoodMaterial;                                      // 0x03F0(0x0020)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UPhysicalMaterial>       StoneMaterial;                                     // 0x0410(0x0020)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UPhysicalMaterial>       MetalMaterial;                                     // 0x0430(0x0020)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void NetFadeOut();
	void NetOnHitCrack();
	void OnBounceAnimationUpdate(const struct FFortBounceData& BounceData);
	void OnFadeOut();
	void OnHitCrack();
	void OnRep_HitNormal();
	void OnRep_PhysicalSurfaceType();
	void OnStartDirectionEffect();

	bool HasStartingPosition() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCrackEffect">();
	}
	static class AFortCrackEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortCrackEffect>();
	}
};
static_assert(alignof(AFortCrackEffect) == 0x000008, "Wrong alignment on AFortCrackEffect");
static_assert(sizeof(AFortCrackEffect) == 0x000450, "Wrong size on AFortCrackEffect");
static_assert(offsetof(AFortCrackEffect, bFadingOut) == 0x0003A8, "Member 'AFortCrackEffect::bFadingOut' has a wrong offset!");
static_assert(offsetof(AFortCrackEffect, ParentBuilding) == 0x0003AC, "Member 'AFortCrackEffect::ParentBuilding' has a wrong offset!");
static_assert(offsetof(AFortCrackEffect, CrackHitCount) == 0x0003B8, "Member 'AFortCrackEffect::CrackHitCount' has a wrong offset!");
static_assert(offsetof(AFortCrackEffect, CrackLevel) == 0x0003BC, "Member 'AFortCrackEffect::CrackLevel' has a wrong offset!");
static_assert(offsetof(AFortCrackEffect, MaxCrackLevel) == 0x0003C0, "Member 'AFortCrackEffect::MaxCrackLevel' has a wrong offset!");
static_assert(offsetof(AFortCrackEffect, StartingLocation) == 0x0003C4, "Member 'AFortCrackEffect::StartingLocation' has a wrong offset!");
static_assert(offsetof(AFortCrackEffect, StartingNormal) == 0x0003D0, "Member 'AFortCrackEffect::StartingNormal' has a wrong offset!");
static_assert(offsetof(AFortCrackEffect, HitNormal) == 0x0003DC, "Member 'AFortCrackEffect::HitNormal' has a wrong offset!");
static_assert(offsetof(AFortCrackEffect, PhysicalSurfaceType) == 0x0003E8, "Member 'AFortCrackEffect::PhysicalSurfaceType' has a wrong offset!");
static_assert(offsetof(AFortCrackEffect, WoodMaterial) == 0x0003F0, "Member 'AFortCrackEffect::WoodMaterial' has a wrong offset!");
static_assert(offsetof(AFortCrackEffect, StoneMaterial) == 0x000410, "Member 'AFortCrackEffect::StoneMaterial' has a wrong offset!");
static_assert(offsetof(AFortCrackEffect, MetalMaterial) == 0x000430, "Member 'AFortCrackEffect::MetalMaterial' has a wrong offset!");

// Class FortniteGame.FortDamageSet
// 0x0200 (0x0230 - 0x0030)
class UFortDamageSet final : public UFortAttributeSet
{
public:
	struct FFortGameplayAttributeData             OutgoingBaseDamage;                                // 0x0030(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FFortGameplayAttributeData             OutgoingBaseEnvironmentalDamage;                   // 0x0050(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FFortGameplayAttributeData             OutgoingBaseImpactDamage;                          // 0x0070(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FFortGameplayAttributeData             OutgoingAbilityDamage;                             // 0x0090(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FFortGameplayAttributeData             OutgoingBaseAbilityDamageMultiplier;               // 0x00B0(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FFortGameplayAttributeData             ZoneCritMultiplier;                                // 0x00D0(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FFortGameplayAttributeData             DiceCritChance;                                    // 0x00F0(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FFortGameplayAttributeData             DiceCritMultiplier;                                // 0x0110(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FFortGameplayAttributeData             KnockbackMagnitude;                                // 0x0130(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FFortGameplayAttributeData             KnockbackZAngle;                                   // 0x0150(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FFortGameplayAttributeData             StunTime;                                          // 0x0170(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FFortGameplayAttributeData             WeaponSkill;                                       // 0x0190(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FFortGameplayAttributeData             CritRating;                                        // 0x01B0(0x0020)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FFortGameplayAttributeData             MaxMeleeComboLevel;                                // 0x01D0(0x0020)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FFortGameplayAttributeData             ShieldDamageScale;                                 // 0x01F0(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FFortGameplayAttributeData             HealthDamageScale;                                 // 0x0210(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, Protected, NativeAccessSpecifierProtected)

public:
	void OnRep_DiceCritChance();
	void OnRep_DiceCritMultiplier();
	void OnRep_HealthDamageScale();
	void OnRep_KnockbackMagnitude();
	void OnRep_KnockbackZAngle();
	void OnRep_OutgoingAbilityDamage();
	void OnRep_OutgoingBaseAbilityDamageMultiplier();
	void OnRep_OutgoingBaseDamage();
	void OnRep_OutgoingBaseEnvironmentalDamage();
	void OnRep_OutgoingBaseImpactDamage();
	void OnRep_ShieldDamageScale();
	void OnRep_StunTime();
	void OnRep_WeaponSkill();
	void OnRep_ZoneCritMultiplier();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDamageSet">();
	}
	static class UFortDamageSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDamageSet>();
	}
};
static_assert(alignof(UFortDamageSet) == 0x000008, "Wrong alignment on UFortDamageSet");
static_assert(sizeof(UFortDamageSet) == 0x000230, "Wrong size on UFortDamageSet");
static_assert(offsetof(UFortDamageSet, OutgoingBaseDamage) == 0x000030, "Member 'UFortDamageSet::OutgoingBaseDamage' has a wrong offset!");
static_assert(offsetof(UFortDamageSet, OutgoingBaseEnvironmentalDamage) == 0x000050, "Member 'UFortDamageSet::OutgoingBaseEnvironmentalDamage' has a wrong offset!");
static_assert(offsetof(UFortDamageSet, OutgoingBaseImpactDamage) == 0x000070, "Member 'UFortDamageSet::OutgoingBaseImpactDamage' has a wrong offset!");
static_assert(offsetof(UFortDamageSet, OutgoingAbilityDamage) == 0x000090, "Member 'UFortDamageSet::OutgoingAbilityDamage' has a wrong offset!");
static_assert(offsetof(UFortDamageSet, OutgoingBaseAbilityDamageMultiplier) == 0x0000B0, "Member 'UFortDamageSet::OutgoingBaseAbilityDamageMultiplier' has a wrong offset!");
static_assert(offsetof(UFortDamageSet, ZoneCritMultiplier) == 0x0000D0, "Member 'UFortDamageSet::ZoneCritMultiplier' has a wrong offset!");
static_assert(offsetof(UFortDamageSet, DiceCritChance) == 0x0000F0, "Member 'UFortDamageSet::DiceCritChance' has a wrong offset!");
static_assert(offsetof(UFortDamageSet, DiceCritMultiplier) == 0x000110, "Member 'UFortDamageSet::DiceCritMultiplier' has a wrong offset!");
static_assert(offsetof(UFortDamageSet, KnockbackMagnitude) == 0x000130, "Member 'UFortDamageSet::KnockbackMagnitude' has a wrong offset!");
static_assert(offsetof(UFortDamageSet, KnockbackZAngle) == 0x000150, "Member 'UFortDamageSet::KnockbackZAngle' has a wrong offset!");
static_assert(offsetof(UFortDamageSet, StunTime) == 0x000170, "Member 'UFortDamageSet::StunTime' has a wrong offset!");
static_assert(offsetof(UFortDamageSet, WeaponSkill) == 0x000190, "Member 'UFortDamageSet::WeaponSkill' has a wrong offset!");
static_assert(offsetof(UFortDamageSet, CritRating) == 0x0001B0, "Member 'UFortDamageSet::CritRating' has a wrong offset!");
static_assert(offsetof(UFortDamageSet, MaxMeleeComboLevel) == 0x0001D0, "Member 'UFortDamageSet::MaxMeleeComboLevel' has a wrong offset!");
static_assert(offsetof(UFortDamageSet, ShieldDamageScale) == 0x0001F0, "Member 'UFortDamageSet::ShieldDamageScale' has a wrong offset!");
static_assert(offsetof(UFortDamageSet, HealthDamageScale) == 0x000210, "Member 'UFortDamageSet::HealthDamageScale' has a wrong offset!");

// Class FortniteGame.FortQueryTest_NavGraphDistance
// 0x0008 (0x01C8 - 0x01C0)
class UFortQueryTest_NavGraphDistance final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           DistanceTo;                                        // 0x01C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_NavGraphDistance">();
	}
	static class UFortQueryTest_NavGraphDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_NavGraphDistance>();
	}
};
static_assert(alignof(UFortQueryTest_NavGraphDistance) == 0x000008, "Wrong alignment on UFortQueryTest_NavGraphDistance");
static_assert(sizeof(UFortQueryTest_NavGraphDistance) == 0x0001C8, "Wrong size on UFortQueryTest_NavGraphDistance");
static_assert(offsetof(UFortQueryTest_NavGraphDistance, DistanceTo) == 0x0001C0, "Member 'UFortQueryTest_NavGraphDistance::DistanceTo' has a wrong offset!");

// Class FortniteGame.FortAttachToActorInterface
// 0x0000 (0x0028 - 0x0028)
class IFortAttachToActorInterface final : public IInterface
{
public:
	class AActor* GetActorAttachedTo() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAttachToActorInterface">();
	}
	static class IFortAttachToActorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortAttachToActorInterface>();
	}
};
static_assert(alignof(IFortAttachToActorInterface) == 0x000008, "Wrong alignment on IFortAttachToActorInterface");
static_assert(sizeof(IFortAttachToActorInterface) == 0x000028, "Wrong size on IFortAttachToActorInterface");

// Class FortniteGame.BuildingSMActor
// 0x0888 (0x0FC0 - 0x0738)
class ABuildingSMActor : public ABuildingActor
{
public:
	uint8                                         Pad_738[0x8];                                      // 0x0738(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBuildingTextureData*                   TextureData[0x4];                                  // 0x0740(0x0008)(Edit, Net, ZeroConstructor, SaveGame, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            StaticMesh;                                        // 0x0760(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTierMeshSets>                  AlternateMeshes;                                   // 0x0768(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         AltMeshIdx;                                        // 0x0778(0x0004)(Net, ZeroConstructor, SaveGame, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortResourceType                             ResourceType;                                      // 0x077C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, RepNotify, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_77D[0x3];                                      // 0x077D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bAllowBuildingCheat : 1;                           // 0x0780(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bMirrored : 1;                                     // 0x0780(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, Net, DisableEditOnTemplate, SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNoCollision : 1;                                  // 0x0780(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNoCameraCollision : 1;                            // 0x0780(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNoPawnCollision : 1;                              // 0x0780(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNoAIPawnCollision : 1;                            // 0x0780(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNoWeaponCollision : 1;                            // 0x0780(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNoRangedWeaponCollision : 1;                      // 0x0780(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNoProjectileCollision : 1;                        // 0x0781(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDoNotBlockInteract : 1;                           // 0x0781(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bBlocksCeilingPlacement : 1;                       // 0x0781(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bBlocksAttachmentPlacement : 1;                    // 0x0781(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportsRepairing : 1;                            // 0x0781(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, Net, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRandomYawOnPlacement : 1;                         // 0x0781(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRandomScaleOnPlacement : 1;                       // 0x0781(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bClearMIDWhenReturningToUndamagedState : 1;        // 0x0781(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_782[0x2];                                      // 0x0782(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              RandomScaleRange;                                  // 0x0784(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFortBounceData                        BounceData;                                        // 0x078C(0x0030)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_7BC[0x4];                                      // 0x07BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   BASEEffectMeshComponent;                           // 0x07C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBuildingNavObstacle>           NavObstacles;                                      // 0x07C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, AdvancedDisplay, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavArea>                   CachedNavAreaHusk;                                 // 0x07D8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavArea>                   CachedNavAreaSmasher;                              // 0x07E0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7E8[0x18];                                     // 0x07E8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class AFortCrackEffect>> WeakSpotEffects;                                   // 0x0800(0x0010)(Net, ZeroConstructor, Transient, RepNotify, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                          bAllowWeakSpots;                                   // 0x0810(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseComplexForWeakSpots;                           // 0x0811(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_812[0x2];                                      // 0x0812(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize100                 ReplicatedDrawScale3D;                             // 0x0814(0x000C)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UMaterialInstanceConstant*              ReplicatedMIC;                                     // 0x0820(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FEditorOnlyBuildingInstanceMaterialParameters EditorOnlyInstanceMaterialParameters;              // 0x0828(0x0030)(Edit, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0858(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     BaseMaterial;                                      // 0x0860(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ELootQuotaLevel                               MaximumQuotaLevelBound;                            // 0x0868(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_869[0x3];                                      // 0x0869(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bCanSpawnAtLowerQuotaLevels : 1;                   // 0x086C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_86D[0x3];                                      // 0x086D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DestructionLootTierGroup;                          // 0x0870(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FChosenQuotaInfo                       DestructionLootTierChosenQuotaInfo;                // 0x0878(0x0010)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   DestructionLootTierKey;                            // 0x0888(0x0008)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   BuildingResourceAmountOverride;                    // 0x0890(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	int32                                         MaxResourcesToSpawn;                               // 0x08A0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8A4[0x4];                                      // 0x08A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InfluenceMapWeight;                                // 0x08A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNeedsWindMaterialParameters;                      // 0x08AC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8AD[0x3];                                      // 0x08AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UCurveLinearColor>       WindSpeedCurve;                                    // 0x08B0(0x0020)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UCurveLinearColor>       WindPannerSpeedCurve;                              // 0x08D0(0x0020)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UMaterialInterface>> IntenseWindMaterials;                              // 0x08F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class USoundBase>              WindAudio;                                         // 0x0900(0x0020)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPropagatesBounceEffects;                          // 0x0920(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_921[0x7];                                      // 0x0921(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        BreakEffect;                                       // 0x0928(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        DeathParticles;                                    // 0x0930(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DeathParticleSocketName;                           // 0x0938(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             DeathSound;                                        // 0x0940(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        ConstructedEffect;                                 // 0x0948(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShieldBuffMaterialParamValue1;                     // 0x0950(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShieldBuffMaterialParamValue2;                     // 0x0954(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AnimatingDistanceFieldSelfShadowBias;              // 0x0958(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNeedsDamageOverlay;                               // 0x095C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_95D[0x3];                                      // 0x095D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRandomDayphaseFX>              RandomDayphaseFXList;                              // 0x0960(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UAudioComponent*                        ConstructionAudioComponent;                        // 0x0970(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMaterialInstanceDynamic*>       AnimatingMIDs;                                     // 0x0978(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   DamageOverlayComponent;                            // 0x0988(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               MIDDamageOverlay;                                  // 0x0990(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageAmountStart;                                 // 0x0998(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastDamageAmount;                                  // 0x099C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHitResult                             LastDamageHit;                                     // 0x09A0(0x0088)(Transient, IsPlainOldData, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A28[0x1C8];                                    // 0x0A28(0x01C8)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BuildingPlacementDistance;                         // 0x0BF0(0x000C)(Edit, BlueprintVisible, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BFC[0x4];                                      // 0x0BFC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBuildingEditModeMetadata*              EditModePatternData;                               // 0x0C00(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnRepairBuildingStarted;                           // 0x0C08(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnRepairBuildingFinished;                          // 0x0C18(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FFortConnectivityComponentData         ConnectivityData;                                  // 0x0C28(0x0018)(SaveGame, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     AnimatingMaterial;                                 // 0x0C40(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     DamagedButNotAnimatingMaterial;                    // 0x0C48(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortDamageVisualsState                       DamageVisualsState;                                // 0x0C50(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C51[0x3];                                      // 0x0C51(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnimatingSubObjects;                               // 0x0C54(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumFrameSubObjects;                                // 0x0C58(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C5C[0x4];                                      // 0x0C5C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UBuildingEditModeSupport>   EditModeSupportClass;                              // 0x0C60(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBuildingEditModeSupport*               EditModeSupport;                                   // 0x0C68(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HealthToAutoBuild;                                 // 0x0C70(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AccumulatedAutoBuildTime;                          // 0x0C74(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsInitiallyBuilding;                              // 0x0C78(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBuildingReplacementType                      BuildingReplacementType;                           // 0x0C79(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBuildingReplacementType                      ReplacementDestructionReason;                      // 0x0C7A(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBuildingAnim                                 CurBuildingAnimType;                               // 0x0C7B(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurAnimSubObjectNum;                               // 0x0C7C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurBuildingAnimStartTime;                          // 0x0C80(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurAnimSubObjectTargetNum;                         // 0x0C84(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMaterialInstanceDynamic*>       BlueprintMIDs;                                     // 0x0C88(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   BlueprintMeshComp;                                 // 0x0C98(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortPlayerStateZone*                   EditingPlayer;                                     // 0x0CA0(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LogicalBuildingIdx;                                // 0x0CA8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         UndermineGroup;                                    // 0x0CAC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EStructuralSupportCheck                       LastStructuralCheck;                               // 0x0CB0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CB1[0x7F];                                     // 0x0CB1(0x007F)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             ConnectivityIcon;                                  // 0x0D30(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                BuildingAttachmentPointOffset;                     // 0x0D38(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BuildingAttachmentRadius;                          // 0x0D44(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBuildingAttachmentSlot                       BuildingAttachmentSlot;                            // 0x0D48(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBuildingAttachmentType                       BuildingAttachmentType;                            // 0x0D49(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D4A[0x6];                                      // 0x0D4A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class ABuildingSMActor*                       ParentActorToAttachTo;                             // 0x0D50(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlacementType                                BuildingPlacementType;                             // 0x0D58(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D59[0x3];                                      // 0x0D59(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayerGridSnapSize;                                // 0x0D5C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ABuildingSMActor*>               AttachedBuildingActors;                            // 0x0D60(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ABuildingSMActor*>               BuildingActorsAttachedTo;                          // 0x0D70(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnTrapPlacementChanged;                            // 0x0D80(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class ABuildingSMActor*>               AttachmentPlacementBlockingActors;                 // 0x0D90(0x0010)(Net, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UBuildingConnectivityComponent*         ConnectivityComponent;                             // 0x0DA0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DA8[0x8];                                      // 0x0DA8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimeline                              RepairAnimTimeline;                                // 0x0DB0(0x00E0)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         bAllowResourceDrop : 1;                            // 0x0E90(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bHideOnDeath : 1;                                  // 0x0E90(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bPlayDestructionEffects : 1;                       // 0x0E90(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bSupportedDirectly : 1;                            // 0x0E90(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bForciblyStructurallySupported : 1;                // 0x0E90(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bRegisterWithStructuralGrid : 1;                   // 0x0E90(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUnderConstruction : 1;                            // 0x0E90(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUnderRepair : 1;                                  // 0x0E90(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCollisionBlockedByPawns : 1;                      // 0x0E91(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         BitPad_E91_1 : 1;                                  // 0x0E91(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bCurrentlyBeingEdited : 1;                         // 0x0E91(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_E92[0x6];                                      // 0x0E92(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class ABuildingSMActor*                       DamagerOwner;                                      // 0x0E98(0x0008)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimeline                              DynamicLODEffectTimeline;                          // 0x0EA0(0x00E0)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class AFortConstructorBASE*                   RelevantBASE;                                      // 0x0F80(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F88[0x18];                                     // 0x0F88(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortConstructorBASE*                   LastRelevantBASE;                                  // 0x0FA0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FA8[0x18];                                     // 0x0FA8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AttachBuildingActorToMe(class ABuildingSMActor* ActorToAttach, bool bForceAttachment);
	void BlueprintOnStructurallyStable();
	void BlueprintOnStructurallyUnstable();
	void DetachBuildingActorFromMe(class ABuildingSMActor* ActorToAttach, bool bBeingDestroyed);
	void EditorOnlyRemoveInstanceMaterialScalarParameter(class FName ParamName);
	void EditorOnlyRemoveInstanceMaterialTextureParameter(class FName ParamName);
	void EditorOnlyRemoveInstanceMaterialVectorParameter(class FName ParamName);
	void EditorOnlySetInstanceMaterialScalarParameter(class FName ParamName, float Value);
	void EditorOnlySetInstanceMaterialTextureParameter(class FName ParamName, class UTexture* Value);
	void EditorOnlySetInstanceMaterialVectorParameter(class FName ParamName, const struct FLinearColor& Value);
	void ForceIntoStructuralGridDuringRuntime();
	void GameplayCue_Abilities_Activation_Generic_BannerWallBuff1(EGameplayCueEvent EventType, const struct FGameplayCueParameters& Parameters);
	void GameplayCue_Abilities_Activation_Generic_BannerWallBuff2(EGameplayCueEvent EventType, const struct FGameplayCueParameters& Parameters);
	class UMaterialInstanceDynamic* GetAnimatingMID(int32 ElementIndex);
	TArray<class ABuildingSMActor*> GetAttachedBuildingActors();
	bool GetIntenseWindMaterialsForPreview(TArray<class UMaterialInterface*>* Materials);
	EBuildingReplacementType GetReplacementDestructionReason();
	void MarkConnectedBuildingsForStructuralIntegrityCheck();
	void MulticastPlayFullHealthEffects();
	void MulticastRequestBuildingAnimation(EBuildingAnim RequestedAnimation);
	void OnAttachToBuilding(class ABuildingSMActor* AttachedToBuilding);
	void OnBounceAnimationUpdate(const struct FFortBounceData& Data);
	void OnDetachFromBuilding(class ABuildingSMActor* AttachedToBuilding, bool bBeingDestroyed);
	void OnDynamicShrinkAndDestroyEffectFinished();
	void OnLODOverrideEffectFinished();
	void OnRep_bCollisionBlockedByPawns();
	void OnRep_BuildingReplacementType();
	void OnRep_bUnderConstruction();
	void OnRep_bUnderRepair();
	void OnRep_EditingPlayer();
	void OnRep_MetaData();
	void OnRep_RelevantBASE();
	void OnRep_ReplicatedDrawScale3D();
	void OnRep_ReplicatedMIC();
	void OnRep_ResourceType(EFortResourceType OldType);
	void OnRep_WeakSpotPositions();
	void OnRepairStarted();
	void RepairBuilding(class AFortPlayerController* RepairingController, int32 ResourcesSpent);
	void UpdateDynamicShrinkAndDestroyEffect(float CurveValue);
	void UpdateLODOverrideEffect(float CurveValue);
	void UpdateRepairMaterialAnim(float CurveValue);

	class UStaticMeshComponent* GetBuildingMeshComponent() const;
	int32 GetLogicalBuildingIndex() const;
	class UCurveLinearColor* GetWindPannerSpeedCurveForPreview() const;
	class UCurveLinearColor* GetWindSpeedCurveForPreview() const;
	bool HasDestructionLoot() const;
	bool IsStructurallySupported() const;
	bool IsSupportedByWorld() const;
	bool WillRegisterWithStructuralGrid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingSMActor">();
	}
	static class ABuildingSMActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingSMActor>();
	}
};
static_assert(alignof(ABuildingSMActor) == 0x000010, "Wrong alignment on ABuildingSMActor");
static_assert(sizeof(ABuildingSMActor) == 0x000FC0, "Wrong size on ABuildingSMActor");
static_assert(offsetof(ABuildingSMActor, TextureData) == 0x000740, "Member 'ABuildingSMActor::TextureData' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, StaticMesh) == 0x000760, "Member 'ABuildingSMActor::StaticMesh' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, AlternateMeshes) == 0x000768, "Member 'ABuildingSMActor::AlternateMeshes' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, AltMeshIdx) == 0x000778, "Member 'ABuildingSMActor::AltMeshIdx' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, ResourceType) == 0x00077C, "Member 'ABuildingSMActor::ResourceType' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, RandomScaleRange) == 0x000784, "Member 'ABuildingSMActor::RandomScaleRange' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, BounceData) == 0x00078C, "Member 'ABuildingSMActor::BounceData' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, BASEEffectMeshComponent) == 0x0007C0, "Member 'ABuildingSMActor::BASEEffectMeshComponent' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, NavObstacles) == 0x0007C8, "Member 'ABuildingSMActor::NavObstacles' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, CachedNavAreaHusk) == 0x0007D8, "Member 'ABuildingSMActor::CachedNavAreaHusk' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, CachedNavAreaSmasher) == 0x0007E0, "Member 'ABuildingSMActor::CachedNavAreaSmasher' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, WeakSpotEffects) == 0x000800, "Member 'ABuildingSMActor::WeakSpotEffects' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, bAllowWeakSpots) == 0x000810, "Member 'ABuildingSMActor::bAllowWeakSpots' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, bUseComplexForWeakSpots) == 0x000811, "Member 'ABuildingSMActor::bUseComplexForWeakSpots' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, ReplicatedDrawScale3D) == 0x000814, "Member 'ABuildingSMActor::ReplicatedDrawScale3D' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, ReplicatedMIC) == 0x000820, "Member 'ABuildingSMActor::ReplicatedMIC' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, EditorOnlyInstanceMaterialParameters) == 0x000828, "Member 'ABuildingSMActor::EditorOnlyInstanceMaterialParameters' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, StaticMeshComponent) == 0x000858, "Member 'ABuildingSMActor::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, BaseMaterial) == 0x000860, "Member 'ABuildingSMActor::BaseMaterial' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, MaximumQuotaLevelBound) == 0x000868, "Member 'ABuildingSMActor::MaximumQuotaLevelBound' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, DestructionLootTierGroup) == 0x000870, "Member 'ABuildingSMActor::DestructionLootTierGroup' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, DestructionLootTierChosenQuotaInfo) == 0x000878, "Member 'ABuildingSMActor::DestructionLootTierChosenQuotaInfo' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, DestructionLootTierKey) == 0x000888, "Member 'ABuildingSMActor::DestructionLootTierKey' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, BuildingResourceAmountOverride) == 0x000890, "Member 'ABuildingSMActor::BuildingResourceAmountOverride' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, MaxResourcesToSpawn) == 0x0008A0, "Member 'ABuildingSMActor::MaxResourcesToSpawn' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, InfluenceMapWeight) == 0x0008A8, "Member 'ABuildingSMActor::InfluenceMapWeight' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, bNeedsWindMaterialParameters) == 0x0008AC, "Member 'ABuildingSMActor::bNeedsWindMaterialParameters' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, WindSpeedCurve) == 0x0008B0, "Member 'ABuildingSMActor::WindSpeedCurve' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, WindPannerSpeedCurve) == 0x0008D0, "Member 'ABuildingSMActor::WindPannerSpeedCurve' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, IntenseWindMaterials) == 0x0008F0, "Member 'ABuildingSMActor::IntenseWindMaterials' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, WindAudio) == 0x000900, "Member 'ABuildingSMActor::WindAudio' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, bPropagatesBounceEffects) == 0x000920, "Member 'ABuildingSMActor::bPropagatesBounceEffects' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, BreakEffect) == 0x000928, "Member 'ABuildingSMActor::BreakEffect' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, DeathParticles) == 0x000930, "Member 'ABuildingSMActor::DeathParticles' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, DeathParticleSocketName) == 0x000938, "Member 'ABuildingSMActor::DeathParticleSocketName' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, DeathSound) == 0x000940, "Member 'ABuildingSMActor::DeathSound' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, ConstructedEffect) == 0x000948, "Member 'ABuildingSMActor::ConstructedEffect' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, ShieldBuffMaterialParamValue1) == 0x000950, "Member 'ABuildingSMActor::ShieldBuffMaterialParamValue1' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, ShieldBuffMaterialParamValue2) == 0x000954, "Member 'ABuildingSMActor::ShieldBuffMaterialParamValue2' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, AnimatingDistanceFieldSelfShadowBias) == 0x000958, "Member 'ABuildingSMActor::AnimatingDistanceFieldSelfShadowBias' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, bNeedsDamageOverlay) == 0x00095C, "Member 'ABuildingSMActor::bNeedsDamageOverlay' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, RandomDayphaseFXList) == 0x000960, "Member 'ABuildingSMActor::RandomDayphaseFXList' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, ConstructionAudioComponent) == 0x000970, "Member 'ABuildingSMActor::ConstructionAudioComponent' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, AnimatingMIDs) == 0x000978, "Member 'ABuildingSMActor::AnimatingMIDs' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, DamageOverlayComponent) == 0x000988, "Member 'ABuildingSMActor::DamageOverlayComponent' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, MIDDamageOverlay) == 0x000990, "Member 'ABuildingSMActor::MIDDamageOverlay' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, DamageAmountStart) == 0x000998, "Member 'ABuildingSMActor::DamageAmountStart' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, LastDamageAmount) == 0x00099C, "Member 'ABuildingSMActor::LastDamageAmount' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, LastDamageHit) == 0x0009A0, "Member 'ABuildingSMActor::LastDamageHit' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, BuildingPlacementDistance) == 0x000BF0, "Member 'ABuildingSMActor::BuildingPlacementDistance' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, EditModePatternData) == 0x000C00, "Member 'ABuildingSMActor::EditModePatternData' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, OnRepairBuildingStarted) == 0x000C08, "Member 'ABuildingSMActor::OnRepairBuildingStarted' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, OnRepairBuildingFinished) == 0x000C18, "Member 'ABuildingSMActor::OnRepairBuildingFinished' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, ConnectivityData) == 0x000C28, "Member 'ABuildingSMActor::ConnectivityData' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, AnimatingMaterial) == 0x000C40, "Member 'ABuildingSMActor::AnimatingMaterial' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, DamagedButNotAnimatingMaterial) == 0x000C48, "Member 'ABuildingSMActor::DamagedButNotAnimatingMaterial' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, DamageVisualsState) == 0x000C50, "Member 'ABuildingSMActor::DamageVisualsState' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, AnimatingSubObjects) == 0x000C54, "Member 'ABuildingSMActor::AnimatingSubObjects' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, NumFrameSubObjects) == 0x000C58, "Member 'ABuildingSMActor::NumFrameSubObjects' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, EditModeSupportClass) == 0x000C60, "Member 'ABuildingSMActor::EditModeSupportClass' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, EditModeSupport) == 0x000C68, "Member 'ABuildingSMActor::EditModeSupport' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, HealthToAutoBuild) == 0x000C70, "Member 'ABuildingSMActor::HealthToAutoBuild' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, AccumulatedAutoBuildTime) == 0x000C74, "Member 'ABuildingSMActor::AccumulatedAutoBuildTime' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, bIsInitiallyBuilding) == 0x000C78, "Member 'ABuildingSMActor::bIsInitiallyBuilding' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, BuildingReplacementType) == 0x000C79, "Member 'ABuildingSMActor::BuildingReplacementType' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, ReplacementDestructionReason) == 0x000C7A, "Member 'ABuildingSMActor::ReplacementDestructionReason' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, CurBuildingAnimType) == 0x000C7B, "Member 'ABuildingSMActor::CurBuildingAnimType' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, CurAnimSubObjectNum) == 0x000C7C, "Member 'ABuildingSMActor::CurAnimSubObjectNum' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, CurBuildingAnimStartTime) == 0x000C80, "Member 'ABuildingSMActor::CurBuildingAnimStartTime' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, CurAnimSubObjectTargetNum) == 0x000C84, "Member 'ABuildingSMActor::CurAnimSubObjectTargetNum' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, BlueprintMIDs) == 0x000C88, "Member 'ABuildingSMActor::BlueprintMIDs' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, BlueprintMeshComp) == 0x000C98, "Member 'ABuildingSMActor::BlueprintMeshComp' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, EditingPlayer) == 0x000CA0, "Member 'ABuildingSMActor::EditingPlayer' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, LogicalBuildingIdx) == 0x000CA8, "Member 'ABuildingSMActor::LogicalBuildingIdx' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, UndermineGroup) == 0x000CAC, "Member 'ABuildingSMActor::UndermineGroup' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, LastStructuralCheck) == 0x000CB0, "Member 'ABuildingSMActor::LastStructuralCheck' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, ConnectivityIcon) == 0x000D30, "Member 'ABuildingSMActor::ConnectivityIcon' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, BuildingAttachmentPointOffset) == 0x000D38, "Member 'ABuildingSMActor::BuildingAttachmentPointOffset' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, BuildingAttachmentRadius) == 0x000D44, "Member 'ABuildingSMActor::BuildingAttachmentRadius' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, BuildingAttachmentSlot) == 0x000D48, "Member 'ABuildingSMActor::BuildingAttachmentSlot' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, BuildingAttachmentType) == 0x000D49, "Member 'ABuildingSMActor::BuildingAttachmentType' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, ParentActorToAttachTo) == 0x000D50, "Member 'ABuildingSMActor::ParentActorToAttachTo' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, BuildingPlacementType) == 0x000D58, "Member 'ABuildingSMActor::BuildingPlacementType' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, PlayerGridSnapSize) == 0x000D5C, "Member 'ABuildingSMActor::PlayerGridSnapSize' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, AttachedBuildingActors) == 0x000D60, "Member 'ABuildingSMActor::AttachedBuildingActors' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, BuildingActorsAttachedTo) == 0x000D70, "Member 'ABuildingSMActor::BuildingActorsAttachedTo' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, OnTrapPlacementChanged) == 0x000D80, "Member 'ABuildingSMActor::OnTrapPlacementChanged' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, AttachmentPlacementBlockingActors) == 0x000D90, "Member 'ABuildingSMActor::AttachmentPlacementBlockingActors' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, ConnectivityComponent) == 0x000DA0, "Member 'ABuildingSMActor::ConnectivityComponent' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, RepairAnimTimeline) == 0x000DB0, "Member 'ABuildingSMActor::RepairAnimTimeline' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, DamagerOwner) == 0x000E98, "Member 'ABuildingSMActor::DamagerOwner' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, DynamicLODEffectTimeline) == 0x000EA0, "Member 'ABuildingSMActor::DynamicLODEffectTimeline' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, RelevantBASE) == 0x000F80, "Member 'ABuildingSMActor::RelevantBASE' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, LastRelevantBASE) == 0x000FA0, "Member 'ABuildingSMActor::LastRelevantBASE' has a wrong offset!");

// Class FortniteGame.FortPlayerController
// 0x1D78 (0x2440 - 0x06C8)
#pragma pack(push, 0x1)
class alignas(0x08) AFortPlayerController : public APlayerController
{
public:
	uint8                                         Pad_6C8[0x10];                                     // 0x06C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bFailedToRespawn : 1;                              // 0x06D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsDisconnecting : 1;                              // 0x06D8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsBeingKicked : 1;                                // 0x06D8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsLateJoining : 1;                                // 0x06D8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHasInitiallySpawned : 1;                          // 0x06D8(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAssignedStartSpawn : 1;                           // 0x06D8(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bReadyToStartMatch : 1;                            // 0x06D8(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bClientPawnIsLoaded : 1;                           // 0x06D8(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_6D9[0x3];                                      // 0x06D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SpawnLoc;                                          // 0x06DC(0x000C)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumPreviousSpawns;                                 // 0x06E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6EC[0x4];                                      // 0x06EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnBlueprintReadyCheckCompleted;                    // 0x06F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_700[0x60];                                     // 0x0700(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AFortAIPawn*>                    ManagedAIs;                                        // 0x0760(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class AFortPlayerPawn*                        MyFortPawn;                                        // 0x0770(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasClientFinishedLoading;                         // 0x0778(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasServerFinishedLoading;                         // 0x0779(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_77A[0x2];                                      // 0x077A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeStartedWaiting;                                // 0x077C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeFinishedNavigationBuild;                       // 0x0780(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                PendingSpectatorLocation;                          // 0x0784(0x000C)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  ActorUnderReticle;                                 // 0x0790(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AFortCrackEffect>        WeakspotUnderReticle;                              // 0x0798(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastActiveTime;                                    // 0x07A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7A4[0x8FC];                                    // 0x07A4(0x08FC)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        LongInteractAudioComponent;                        // 0x10A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InteractDistance;                                  // 0x10A8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InteractHighlightDistance;                         // 0x10AC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InteractTraceExtent;                               // 0x10B0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastInteractTraceTime;                             // 0x10B4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InteractMultiplierForActiveInteraction;            // 0x10B8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InteractMultiplierGamepad;                         // 0x10BC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortInteractContextInfo*               PossibleInteractContextInfo;                       // 0x10C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortInteractContextInfo*               InteractResponse;                                  // 0x10C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10D0[0x5];                                     // 0x10D0(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bWantsToSprint;                                    // 0x10D5(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHoldingSprint;                                    // 0x10D6(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSprintToggleable;                                 // 0x10D7(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSprintCancelsReload;                              // 0x10D8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTapInteractEnabled;                               // 0x10D9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMovementDisabledDueToCancellableAction;           // 0x10DA(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsPlayerActivelyMoving;                           // 0x10DB(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InMovementCancellableAction;                       // 0x10DC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHoldingUse;                                       // 0x10E0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsClientTimingOut;                                // 0x10E1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10E2[0x2];                                     // 0x10E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClientTimeoutBlockInputTime;                       // 0x10E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastMoveForwardTime;                               // 0x10E8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10EC[0x1];                                     // 0x10EC(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAtNameBaseScreen;                                 // 0x10ED(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInventoryToggledByAlt;                            // 0x10EE(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10EF[0x1];                                     // 0x10EF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnSetFirstPersonCamera;                            // 0x10F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1100[0x8];                                     // 0x1100(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UFortCinematicCamera>       CinematicCameraClassOverride;                      // 0x1108(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1110[0x90];                                    // 0x1110(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortIndicatorManager*                  IndicatorManager;                                  // 0x11A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnUiChoiceCompleted;                               // 0x11A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnRegainedFocus;                                   // 0x11B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C8[0x358];                                   // 0x11C8(0x0358)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsInQuickToggleCursorMode;                        // 0x1520(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bGamepadAbilityPending;                            // 0x1521(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bForceAllowCursorMode;                             // 0x1522(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDragDropPending;                                  // 0x1523(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSuppressEventNotifications;                       // 0x1524(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1525[0x57];                                    // 0x1525(0x0057)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastSpotTime;                                      // 0x157C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class AFortMarkActor>>  CurrentMarks;                                      // 0x1580(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_1590[0x50];                                    // 0x1590(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortGameplayAbility*                   PreviewAbility;                                    // 0x15E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAIDirectorDebugInfo                   IntensityGraphInfo;                                // 0x15E8(0x0028)(Net, RepNotify, NativeAccessSpecifierPublic)
	struct FAIDirectorDebugInfo                   PIDValuesGraphInfo;                                // 0x1610(0x0028)(Net, RepNotify, NativeAccessSpecifierPublic)
	struct FAIDirectorDebugInfo                   PIDContributionsGraphInfo;                         // 0x1638(0x0028)(Net, RepNotify, NativeAccessSpecifierPublic)
	class AFortCombatManager*                     CombatManager;                                     // 0x1660(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortAIDirectorDataManager*             AIDirectorDataManager;                             // 0x1668(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortMusicManager*                      MusicManager;                                      // 0x1670(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1678[0x2C8];                                   // 0x1678(0x02C8)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputComponent*                        BuildPreviewModeInputComponent;                    // 0x1940(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABuildingPlayerPrimitivePreview*        BuildPreviewMarker;                                // 0x1948(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1950[0x100];                                   // 0x1950(0x0100)(Fixing Size After Last Property [ Dumper-7 ])
	class ABuildingActor*                         TargetedBuilding;                                  // 0x1A50(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ABuildingSMActor>           ContextualConversionClass;                         // 0x1A58(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class USoundBase>              StartRepairSound;                                  // 0x1A60(0x0020)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class USoundBase>              StartUpgradeSound;                                 // 0x1A80(0x0020)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ABuildingActor*>                 HighlightedPrimaryBuildings;                       // 0x1AA0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class ABuildingActor*>                 HighlightedInteractionBuildings;                   // 0x1AB0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ABuildingActor>          HighlightedPrimaryBuilding;                        // 0x1AC0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UMaterialInterface>      BuildPreviewMarkerParentMaterial;                  // 0x1AC8(0x0020)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               BuildPreviewMarkerMID;                             // 0x1AE8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         BuildPreviewRotationIterations;                    // 0x1AF0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1AF1[0x3];                                     // 0x1AF1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bBuildPreviewMirrored : 1;                         // 0x1AF4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bBuildFree : 1;                                    // 0x1AF4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCraftFree : 1;                                    // 0x1AF4(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1AF5[0x3];                                     // 0x1AF5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EFortCostInfoTypes                            CurrentCostInfoType;                               // 0x1AF8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1AF9[0x7];                                     // 0x1AF9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ABuildingSMActor>           CurrentBuildableClass;                             // 0x1B00(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ABuildingSMActor>           PreviousBuildableClass;                            // 0x1B08(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortResourceLevel                            CurrentResourceLevel;                              // 0x1B10(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortResourceType                             CurrentResourceType;                               // 0x1B11(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B12[0x6];                                     // 0x1B12(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLastBuildableState                    LastBuildableStateData[0xC];                       // 0x1B18(0x0010)(Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1BD8[0x10];                                    // 0x1BD8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFortDamageNumberInfo>          QueuedDamageNumbers;                               // 0x1BE8(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class AFortDamageNumbersActor*                DamageNumbersActor;                                // 0x1BF8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputComponent*                        EditModeInputComponent;                            // 0x1C00(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABuildingSMActor*                       EditBuildingActor;                                 // 0x1C08(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EditModeDistance;                                  // 0x1C10(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LastBuildPreviewGridSnapLoc;                       // 0x1C14(0x000C)(Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               LastBuildPreviewGridSnapRot;                       // 0x1C20(0x000C)(Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                LastBuildPreviewGridSnapCentroid;                  // 0x1C2C(0x000C)(Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputComponent*                        PickerInputComponent;                              // 0x1C38(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortDecoHelper*                        TrapPickerDecoHelper;                              // 0x1C40(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortQuickBars*                         QuickBars;                                         // 0x1C48(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C50[0xE0];                                    // 0x1C50(0x00E0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         PinnedSchematics;                                  // 0x1D30(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D40[0x130];                                   // 0x1D40(0x0130)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bAutoEquipBetterItems : 1;                         // 0x1E70(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1E71[0x7];                                     // 0x1E71(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortInventory*                         WorldInventory;                                    // 0x1E78(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortInventory*                         OutpostInventory;                                  // 0x1E80(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E88[0x15C];                                   // 0x1E88(0x015C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHasInitializedWorldInventory;                     // 0x1FE4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasInitializedHeroInventory;                      // 0x1FE5(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAccountInventoryWasUpdated;                       // 0x1FE6(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSavingGadgetLoadout;                            // 0x1FE7(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FE8[0x118];                                   // 0x1FE8(0x0118)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortClientBotManager*                  BotManager;                                        // 0x2100(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2108[0x8];                                     // 0x2108(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UFortClientBotManager>      ClientBotManagerClass;                             // 0x2110(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2118[0x78];                                    // 0x2118(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDropWeaponsDuringAllMissionStates;                // 0x2190(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2191[0x7F];                                    // 0x2191(0x007F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortRewardReport                      LatestRewardReport;                                // 0x2210(0x0068)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	class UFortRegisteredPlayerInfo*              MyPlayerInfo;                                      // 0x2278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FFortUpdatedObjectiveStat>      UpdatedObjectiveStats;                             // 0x2280(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	bool                                          bHasUnsavedPrimaryMissionProgress;                 // 0x2290(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2291[0x27];                                    // 0x2291(0x0027)(Fixing Size After Last Property [ Dumper-7 ])
	class UStatManager*                           StatManager;                                       // 0x22B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHeartbeatManager*                      HeartbeatManager;                                  // 0x22C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortStatEventManager*                  StatEventManager;                                  // 0x22C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFortPersistentGameplayStatContainer   CachedPersistentGameplayStats;                     // 0x22D0(0x0010)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_22E0[0x10];                                    // 0x22E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UMcpProfileGroup*                       McpProfileGroup;                                   // 0x22F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortMcpProfileAccount*                 MainMcpProfile;                                    // 0x22F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortMcpProfileMetadata*                MetadataProfile;                                   // 0x2300(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bTutorialCompleted : 1;                            // 0x2308(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2309[0x3];                                     // 0x2309(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShouldReceiveCriticalMatchBonus;                  // 0x230C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_230D[0x3];                                     // 0x230D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnServerPlayerChangedBuildMode;                    // 0x2310(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2320[0x4];                                     // 0x2320(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LocationUnderReticle;                              // 0x2324(0x000C)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bInfiniteAmmo : 1;                                 // 0x2330(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNoCoolDown : 1;                                   // 0x2330(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Net, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInfiniteDurability : 1;                           // 0x2330(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Net, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsePickers : 1;                                   // 0x2330(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPickerOpen : 1;                                   // 0x2330(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCheatGhost : 1;                                   // 0x2330(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Net, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCheatFly : 1;                                     // 0x2330(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Net, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_2330_7 : 1;                                 // 0x2330(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         bEnableShotLogging : 1;                            // 0x2331(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsNearActiveEncounters : 1;                       // 0x2331(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Net, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2332[0x2];                                     // 0x2332(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OverriddenBackpackSize;                            // 0x2334(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        AimHelpMode;                                       // 0x2338(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortJumpStaminaCost                          JumpStaminaCost;                                   // 0x233C(0x0001)(Net, ZeroConstructor, Transient, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_233D[0x3];                                     // 0x233D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CameraPrototypeName;                               // 0x2340(0x0008)(Net, ZeroConstructor, Transient, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2348[0x10];                                    // 0x2348(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortHero*                              AthenaMenuHeroDef;                                 // 0x2358(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDamageNumbersOnFatalHit;                      // 0x2360(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2361[0xCF];                                    // 0x2361(0x00CF)(Fixing Size After Last Property [ Dumper-7 ])
	class ABuildingSMActor*                       PendingEnterModeActor;                             // 0x2430(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2438[0x4];                                     // 0x2438(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateSlot(EFortQuickBars InQuickBar, int32 Slot, float ActivateDelay, bool bUpdatePreviousFocusedSlot);
	void AddItemToQuickBars(class UFortItemDefinition* ItemDefinition, EFortQuickBars QuickBarType, int32 SlotIndex);
	void Cheat(const class FString& Msg);
	void CheatAll(const class FString& Msg);
	void ClientAddHeroSpecialization(const class UFortHeroSpecialization* NewSpecialization);
	void ClientAddScoreNumber(int32 Score, EStatCategory ScoreCategory, const struct FVector_NetQuantize& ScoreLocation, bool bDisplayScoreOnPlayer);
	void ClientCancelCrafting();
	void ClientCreateOrJoinChatRoom(const class FString& ChatRoomId);
	void ClientDrawAttentionToUI(const struct FGuid& MissionGuid, const struct FGameplayTagContainer& ObjectiveHandle);
	void ClientExecuteInventoryItem(const struct FGuid& ItemGuid, float Delay, bool bForceExecute);
	void ClientFinishedInteractionInZone();
	void ClientForceCancelBuildingTool();
	void ClientForceProfileQuery();
	void ClientGivePlayerLocalAccountItem(class UFortAccountItemDefinition* ItemDefinition, int32 Count);
	void ClientJoinConsoleSession(const class FString& ConsoleSession);
	void ClientOnGenericPlayerInitialization();
	void ClientOpenChoiceUI(const struct FChoiceData& ChoiceItems);
	void ClientPingMinimap(const struct FVector& WorldLocation, const struct FLinearColor& PingColor);
	void ClientReadyCheckComplete(bool bPassed);
	void ClientReceivedAttributeSources(const struct FGameplayAttribute& Attribute, class UFortAbilitySystemComponent* AbilitySystemComponent, const TArray<struct FAttributeModifierInfo>& Sources);
	void ClientReceivePresetTeamChat(const class FText& ChatText, const struct FUniqueNetIdRepl& SenderID);
	void ClientRegisterWithParty();
	void ClientReportDamagedResourceBuilding(class ABuildingSMActor* BuildingSMActor, EFortResourceType PotentialResourceType, int32 PotentialResourceCount, bool bDestroyed, bool bJustHitWeakspot);
	void ClientRequestReadyCheck(const class FText& QueryText, const class FText& YesText, const class FText& NoText);
	void ClientSendMessage(const class FText& MESSAGE);
	void ClientSetActionMappingEnabled(class FName ActionName, bool bEnabled);
	void ClientSetInviteFlags(const struct FJoinabilitySettings& Settings);
	void ClientSetSpectatorCamera(const struct FVector& CameraLocation, const struct FRotator& CameraRotation);
	void ClientStayWithParty(bool bStayWithParty);
	void ClientStopUIFeedbackEvent(class FName EventName);
	void ClientTriggerUIFeedbackEvent(class FName EventName);
	void ClientUpdateRichPresence(ERichPresenceStateChange RichPresenceChange, bool bImportant);
	void DeployDefender(class ABuildingTrapDefender* DefenderTrap, const class UFortDefenderItem* DefenderItem, const class FName& DefenderSquadId);
	void Emote(const class FName& AssetName);
	void FixupInteractionWidgetsOnUnzoom();
	void ForceUpdateQuickbar(EFortQuickBars QuickbarToRefresh);
	void FortClientPlaySound(class USoundBase* Sound, float VolumeMultiplier, float PitchMultiplier);
	void FortClientPlaySoundAtLocation(class USoundBase* Sound, const struct FVector& Location, float VolumeMultiplier, float PitchMultiplier);
	class AFortAIDirectorDataManager* GetAIDirectorDataManager();
	bool GetAtNameHomeBaseScreen();
	void GivePlayerAmmo(int32 AmmoCount);
	void HandleOutpostInventoryLocalUpdate();
	void HandleWorldInventoryLocalUpdate();
	void LocalOnBlueprintEdit(class ABuildingSMActor* EditedActor);
	void LocalOnUiChoiceCompleted(int32 ChosenItem, int32 MenuIdentifier);
	void LocalPlayForceFeedback(class UForceFeedbackEffect* ForceFeedbackEffect, bool bLooping, class FName Tag);
	void LocalStopForceFeedback(class UForceFeedbackEffect* ForceFeedbackEffect, class FName Tag);
	void OnRep_bHasServerFinishedLoading();
	void OnRep_CheatMovement();
	void OnRep_CombatManager();
	void OnRep_IntensityGraphInfo();
	void OnRep_LatestRewardReport();
	void OnRep_PIDContributionsGraphInfo();
	void OnRep_PIDValuesGraphInfo();
	void OnRep_PinnedSchematics();
	void OnRep_QuickBar();
	void OnRep_UpdatedObjectiveStats();
	void OnRep_UpdatedUnsavedPrimaryMissionProgress();
	void OpenChoiceUI(const struct FChoiceData& ChoiceData);
	void PlaySpatialSound(class USoundBase* Sound, const struct FVector& Location);
	void PostHeroStatCollectionBookProgressMade(int32 LevelReached);
	void PostHeroStatMissionCompleted(int32 DifficultyRating);
	void PostHeroStatSkillPointsEarned(int32 NumSkillPoints);
	void PrintDebugInfo();
	void RemoveItemFromQuickBars(class UFortItemDefinition* ItemDefinition);
	void ResetInputRotationScale();
	void ReturnToMainMenu();
	void SendMessage(const class FText& MESSAGE);
	void ServerAnnouncementStoppedOnClient(const struct FGuid& AnnouncementID);
	void ServerAttemptInteract(class AActor* ReceivingActor, class UPrimitiveComponent* InteractComponent, ETInteractionType InteractType);
	void ServerAttemptPinSchematic(const class FString& ItemId, bool bSave);
	void ServerAttemptUnpinSchematic(const class FString& ItemId, bool bSave);
	void ServerBeginEditingBuildingActor(class ABuildingSMActor* BuildingActorToEdit);
	void ServerBroadcastUIFeedbackEvent(class FName EventName);
	void ServerCheat(const class FString& Msg);
	void ServerCheatAll(const class FString& Msg);
	void ServerClientPawnLoaded(bool bIsPawnLoaded);
	void ServerCraftSchematic(const class FString& ItemId, int32 PostCraftSlot, bool bIsQuickCrafted);
	void ServerCreateAIDirectorDataManager();
	void ServerCreateBuildingActor(const struct FBuildingClassData& BuildingClassData, const struct FVector_NetQuantize10& BuildLoc, const struct FRotator& BuildRot, bool bMirrored);
	void ServerCreateCombatManager();
	void ServerDeployDefender(class ABuildingTrapDefender* DefenderTrap, const class FString& SelectedItemInstanceId, const class FName& DefenderSquadId);
	void ServerDisassembleInventoryItem(const struct FGuid& ItemGuid);
	void ServerDropCarriedObject();
	void ServerEditBuildingActor(class ABuildingSMActor* BuildingActorToEdit, TSubclassOf<class ABuildingSMActor> NewBuildingClass, int32 RotationIterations, bool bMirrored);
	void ServerEmote(const class FName& AssetName);
	void ServerEndEditingBuildingActor(class ABuildingSMActor* BuildingActorToStopEditing);
	void ServerExecuteInventoryItem(const struct FGuid& ItemGuid);
	void ServerExecutePresetTeamChat(const class FText& ChatText, const struct FUniqueNetIdRepl& SenderID);
	void ServerFinishedInteractionInZoneReport(int32 FinishedInteractionState, const TArray<uint64>& FinishedInteractionReport);
	void ServerGiftInventoryItemToOtherPlayer(const struct FGuid& ItemGuid, const struct FUniqueNetIdRepl& PlayerID, int32 Quantity);
	void ServerHandleMissionEvent_StartLeavingZone(class AFortPlayerPawn* PlayerRequestingLeaving);
	void ServerHandleMissionEvent_ToggledCursorMode(class AFortPlayerController* PlayerThatToggledCursorMode, bool bOpened);
	void ServerHandleMissionEvent_ToggledEditMode(class AFortPlayerController* PlayerThatToggledEditMode, class ABuildingSMActor* EditableActor, bool bOpened);
	void ServerItemWillBeDestroyed(const struct FGuid& DestroyedItemGuid, int32 Count);
	void ServerKickPlayer(const struct FUniqueNetIdRepl& PlayerToKick, const class FText& Reason);
	void ServerKillAllAIPawnsAroundPlayer();
	void ServerLoadingScreenDropped();
	void ServerModDurability(const struct FGuid& ItemGuid, float DurabilityMod, bool bForceSet);
	void ServerModifyStat(class FName StatName, int32 Amount, EStatMod ModType, bool bForceStatSave);
	void ServerPingMinimap(const struct FVector& WorldLocation, const struct FLinearColor& PingColor, EFortTeam RequiredTeam);
	void ServerReadyToStartMatch();
	void ServerReleaseInventoryItemKey(EFortQuickBars InQuickBar, int32 Slot);
	void ServerRemoveDefender(class ABuildingTrapDefender* DefenderTrap);
	void ServerRemoveInventoryItem(const struct FGuid& ItemGuid, int32 Count, bool bForceRemoveFromQuickBars);
	void ServerRemoveInventoryStateValue(const struct FGuid& ItemGuid, EFortItemEntryState StateValueType);
	void ServerRepairBuildingActor(class ABuildingSMActor* BuildingActorToRepair);
	void ServerReplyToReadyCheck(bool bReady);
	void ServerReportClientFPS(float ClientAvgFPS, uint8 ClientAvgFrameScore, uint8 ClientMaxFrameScore);
	void ServerRequestAIDebug();
	void ServerRequestAttributeSources(const struct FGameplayAttribute& Attribute, class UFortAbilitySystemComponent* AbilitySystemComponent);
	void ServerRequestGameplayAction(EFortRequestedGameplayAction RequestedAction);
	void ServerReturnToMainMenu();
	void ServerSetAutoEquipBetterItems(bool bAutoEquip);
	void ServerSetClientHasFinishedLoading(bool bInHasFinishedLoading);
	void ServerSetHero(const class FString& NewHeroID);
	void ServerSetInventoryStateValue(const struct FGuid& ItemGuid, const struct FFortItemEntryStateValue& StateValue);
	void ServerSetMarkText(class AFortMarkActor* MarkActor, const class FString& MarkText);
	void ServerSetPartyOwner(const struct FUniqueNetIdRepl& PartyOwnerUniqueId);
	void ServerSetReadyToContinue(bool bReady, EFortGameplayState RequestedState, bool bTryStartTimer);
	void ServerSetTimeOfDay(float TimeOfDay);
	void ServerSetupWeakSpotsOnBuildingActor(class ABuildingSMActor* BuildingActor, const struct FFortCrackEffectData& CrackData);
	void ServerSpawnInventoryDrop(const struct FGuid& ItemGuid, int32 Count);
	void ServerSpawnMark(class AActor* ActorToAttachTo, const struct FVector& AttachOffset, const class FText& PreapprovedText);
	void ServerSpotActor(class AActor* NewlySpottedActor);
	void ServerStartIntensityGraphing();
	void ServerStartPIDContributionsGraphing();
	void ServerStartPIDValueGraphing();
	void ServerSuicide();
	void ServerTeamChatRoomReady(const class FString& ChatRoomId);
	void ServerTeleportToReticle(const struct FVector& TeleportLocation);
	void ServerTouchActiveTime();
	void ServerTriggerCombatEvent(EFortCombatEvents TriggeredEvent, float HeatMultiplier);
	void ServerTriggerCombatEventBatch(const TArray<struct FFortCombatManagerEvent>& Payload);
	void ServerTriggerGenericObjectiveEvent(class AFortObjectiveBase* Objective);
	void ServerUIChoiceCompleted(int32 ChosenItem, int32 MenuIdentifier);
	void ServerUpgradeBuildingActor(class ABuildingActor* BuildingActorToUpgrade, int32 NewUpgradeLevel);
	void SetAtNameHomeBaseScreen(bool AtScreen);
	void SetCinematicModeWithWeapon(bool bInCinematicMode, bool bHidePlayer, bool bHideWeapon, bool bAffectsHUD, bool bAffectsMovement, bool bAffectsTurning);
	void SetCinematicOverrideClass(TSubclassOf<class UFortCinematicCamera> OverrideCameraClass);
	void SetFirstPersonCamera(bool bNewUseFirstPersonCamera);
	void SetInputPitchScale(float InInputPitchScale);
	void SetInputYawScale(float InInputYawScale);
	void SetRotatePawnToCamera(bool bNewRotatePawnToCamera);
	bool StartReadyCheck(const class FText& QueryText, const class FText& YesText, const class FText& NoText, float PercentageToPass);
	void Suicide();
	void SuppressEventNotifications(bool bSuppress);
	void SwapQuickBarFocus(EFortQuickBars InQuickBar);
	void ToggleClientBot();
	void ToggleFullScreenMap();
	void ToggleInventory();
	void ToggleVirtualCursor();

	void DumpHomebaseRatingInfo() const;
	int32 GetAccountLevel() const;
	float GetAccountLevelProgression() const;
	class AActor* GetActorUnderReticle() const;
	class UFortCollectionBookManager* GetCollectionBookManager() const;
	struct FUniqueNetIdRepl GetGameAccountId() const;
	class AFortPlayerPawn* GetPlayerPawn() const;
	class UFortQuestManager* GetQuestManager() const;
	class UFortRegisteredPlayerInfo* GetRegisteredPlayerInfo() const;
	bool GetRotatePawnToCamera() const;
	bool IsActionInputIgnored() const;
	bool IsClientBot() const;
	bool IsClientTimingOut() const;
	bool IsInBuildMode() const;
	bool IsNearActiveEncounters() const;
	bool IsPlayingEmote() const;
	bool IsRequirementsMet(const struct FFortRequirementsInfo& InRequirements) const;
	bool IsUsingFirstPersonCamera() const;
	bool IsUsingGamepad() const;
	class UFortItem* K2_FindExistingItemForDefinition(const class UFortItemDefinition* ItemDefinition, bool bInStorageVault) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerController">();
	}
	static class AFortPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerController>();
	}
};
#pragma pack(pop)
static_assert(alignof(AFortPlayerController) == 0x000008, "Wrong alignment on AFortPlayerController");
static_assert(sizeof(AFortPlayerController) == 0x002440, "Wrong size on AFortPlayerController");
static_assert(offsetof(AFortPlayerController, SpawnLoc) == 0x0006DC, "Member 'AFortPlayerController::SpawnLoc' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, NumPreviousSpawns) == 0x0006E8, "Member 'AFortPlayerController::NumPreviousSpawns' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, OnBlueprintReadyCheckCompleted) == 0x0006F0, "Member 'AFortPlayerController::OnBlueprintReadyCheckCompleted' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, ManagedAIs) == 0x000760, "Member 'AFortPlayerController::ManagedAIs' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, MyFortPawn) == 0x000770, "Member 'AFortPlayerController::MyFortPawn' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, bHasClientFinishedLoading) == 0x000778, "Member 'AFortPlayerController::bHasClientFinishedLoading' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, bHasServerFinishedLoading) == 0x000779, "Member 'AFortPlayerController::bHasServerFinishedLoading' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, TimeStartedWaiting) == 0x00077C, "Member 'AFortPlayerController::TimeStartedWaiting' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, TimeFinishedNavigationBuild) == 0x000780, "Member 'AFortPlayerController::TimeFinishedNavigationBuild' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, PendingSpectatorLocation) == 0x000784, "Member 'AFortPlayerController::PendingSpectatorLocation' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, ActorUnderReticle) == 0x000790, "Member 'AFortPlayerController::ActorUnderReticle' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, WeakspotUnderReticle) == 0x000798, "Member 'AFortPlayerController::WeakspotUnderReticle' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, LastActiveTime) == 0x0007A0, "Member 'AFortPlayerController::LastActiveTime' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, LongInteractAudioComponent) == 0x0010A0, "Member 'AFortPlayerController::LongInteractAudioComponent' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, InteractDistance) == 0x0010A8, "Member 'AFortPlayerController::InteractDistance' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, InteractHighlightDistance) == 0x0010AC, "Member 'AFortPlayerController::InteractHighlightDistance' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, InteractTraceExtent) == 0x0010B0, "Member 'AFortPlayerController::InteractTraceExtent' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, LastInteractTraceTime) == 0x0010B4, "Member 'AFortPlayerController::LastInteractTraceTime' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, InteractMultiplierForActiveInteraction) == 0x0010B8, "Member 'AFortPlayerController::InteractMultiplierForActiveInteraction' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, InteractMultiplierGamepad) == 0x0010BC, "Member 'AFortPlayerController::InteractMultiplierGamepad' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, PossibleInteractContextInfo) == 0x0010C0, "Member 'AFortPlayerController::PossibleInteractContextInfo' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, InteractResponse) == 0x0010C8, "Member 'AFortPlayerController::InteractResponse' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, bWantsToSprint) == 0x0010D5, "Member 'AFortPlayerController::bWantsToSprint' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, bHoldingSprint) == 0x0010D6, "Member 'AFortPlayerController::bHoldingSprint' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, bSprintToggleable) == 0x0010D7, "Member 'AFortPlayerController::bSprintToggleable' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, bSprintCancelsReload) == 0x0010D8, "Member 'AFortPlayerController::bSprintCancelsReload' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, bTapInteractEnabled) == 0x0010D9, "Member 'AFortPlayerController::bTapInteractEnabled' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, bMovementDisabledDueToCancellableAction) == 0x0010DA, "Member 'AFortPlayerController::bMovementDisabledDueToCancellableAction' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, bIsPlayerActivelyMoving) == 0x0010DB, "Member 'AFortPlayerController::bIsPlayerActivelyMoving' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, InMovementCancellableAction) == 0x0010DC, "Member 'AFortPlayerController::InMovementCancellableAction' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, bHoldingUse) == 0x0010E0, "Member 'AFortPlayerController::bHoldingUse' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, bIsClientTimingOut) == 0x0010E1, "Member 'AFortPlayerController::bIsClientTimingOut' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, ClientTimeoutBlockInputTime) == 0x0010E4, "Member 'AFortPlayerController::ClientTimeoutBlockInputTime' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, LastMoveForwardTime) == 0x0010E8, "Member 'AFortPlayerController::LastMoveForwardTime' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, bAtNameBaseScreen) == 0x0010ED, "Member 'AFortPlayerController::bAtNameBaseScreen' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, bInventoryToggledByAlt) == 0x0010EE, "Member 'AFortPlayerController::bInventoryToggledByAlt' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, OnSetFirstPersonCamera) == 0x0010F0, "Member 'AFortPlayerController::OnSetFirstPersonCamera' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, CinematicCameraClassOverride) == 0x001108, "Member 'AFortPlayerController::CinematicCameraClassOverride' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, IndicatorManager) == 0x0011A0, "Member 'AFortPlayerController::IndicatorManager' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, OnUiChoiceCompleted) == 0x0011A8, "Member 'AFortPlayerController::OnUiChoiceCompleted' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, OnRegainedFocus) == 0x0011B8, "Member 'AFortPlayerController::OnRegainedFocus' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, bIsInQuickToggleCursorMode) == 0x001520, "Member 'AFortPlayerController::bIsInQuickToggleCursorMode' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, bGamepadAbilityPending) == 0x001521, "Member 'AFortPlayerController::bGamepadAbilityPending' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, bForceAllowCursorMode) == 0x001522, "Member 'AFortPlayerController::bForceAllowCursorMode' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, bDragDropPending) == 0x001523, "Member 'AFortPlayerController::bDragDropPending' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, bSuppressEventNotifications) == 0x001524, "Member 'AFortPlayerController::bSuppressEventNotifications' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, LastSpotTime) == 0x00157C, "Member 'AFortPlayerController::LastSpotTime' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, CurrentMarks) == 0x001580, "Member 'AFortPlayerController::CurrentMarks' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, PreviewAbility) == 0x0015E0, "Member 'AFortPlayerController::PreviewAbility' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, IntensityGraphInfo) == 0x0015E8, "Member 'AFortPlayerController::IntensityGraphInfo' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, PIDValuesGraphInfo) == 0x001610, "Member 'AFortPlayerController::PIDValuesGraphInfo' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, PIDContributionsGraphInfo) == 0x001638, "Member 'AFortPlayerController::PIDContributionsGraphInfo' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, CombatManager) == 0x001660, "Member 'AFortPlayerController::CombatManager' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, AIDirectorDataManager) == 0x001668, "Member 'AFortPlayerController::AIDirectorDataManager' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, MusicManager) == 0x001670, "Member 'AFortPlayerController::MusicManager' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, BuildPreviewModeInputComponent) == 0x001940, "Member 'AFortPlayerController::BuildPreviewModeInputComponent' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, BuildPreviewMarker) == 0x001948, "Member 'AFortPlayerController::BuildPreviewMarker' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, TargetedBuilding) == 0x001A50, "Member 'AFortPlayerController::TargetedBuilding' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, ContextualConversionClass) == 0x001A58, "Member 'AFortPlayerController::ContextualConversionClass' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, StartRepairSound) == 0x001A60, "Member 'AFortPlayerController::StartRepairSound' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, StartUpgradeSound) == 0x001A80, "Member 'AFortPlayerController::StartUpgradeSound' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, HighlightedPrimaryBuildings) == 0x001AA0, "Member 'AFortPlayerController::HighlightedPrimaryBuildings' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, HighlightedInteractionBuildings) == 0x001AB0, "Member 'AFortPlayerController::HighlightedInteractionBuildings' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, HighlightedPrimaryBuilding) == 0x001AC0, "Member 'AFortPlayerController::HighlightedPrimaryBuilding' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, BuildPreviewMarkerParentMaterial) == 0x001AC8, "Member 'AFortPlayerController::BuildPreviewMarkerParentMaterial' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, BuildPreviewMarkerMID) == 0x001AE8, "Member 'AFortPlayerController::BuildPreviewMarkerMID' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, BuildPreviewRotationIterations) == 0x001AF0, "Member 'AFortPlayerController::BuildPreviewRotationIterations' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, CurrentCostInfoType) == 0x001AF8, "Member 'AFortPlayerController::CurrentCostInfoType' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, CurrentBuildableClass) == 0x001B00, "Member 'AFortPlayerController::CurrentBuildableClass' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, PreviousBuildableClass) == 0x001B08, "Member 'AFortPlayerController::PreviousBuildableClass' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, CurrentResourceLevel) == 0x001B10, "Member 'AFortPlayerController::CurrentResourceLevel' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, CurrentResourceType) == 0x001B11, "Member 'AFortPlayerController::CurrentResourceType' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, LastBuildableStateData) == 0x001B18, "Member 'AFortPlayerController::LastBuildableStateData' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, QueuedDamageNumbers) == 0x001BE8, "Member 'AFortPlayerController::QueuedDamageNumbers' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, DamageNumbersActor) == 0x001BF8, "Member 'AFortPlayerController::DamageNumbersActor' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, EditModeInputComponent) == 0x001C00, "Member 'AFortPlayerController::EditModeInputComponent' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, EditBuildingActor) == 0x001C08, "Member 'AFortPlayerController::EditBuildingActor' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, EditModeDistance) == 0x001C10, "Member 'AFortPlayerController::EditModeDistance' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, LastBuildPreviewGridSnapLoc) == 0x001C14, "Member 'AFortPlayerController::LastBuildPreviewGridSnapLoc' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, LastBuildPreviewGridSnapRot) == 0x001C20, "Member 'AFortPlayerController::LastBuildPreviewGridSnapRot' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, LastBuildPreviewGridSnapCentroid) == 0x001C2C, "Member 'AFortPlayerController::LastBuildPreviewGridSnapCentroid' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, PickerInputComponent) == 0x001C38, "Member 'AFortPlayerController::PickerInputComponent' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, TrapPickerDecoHelper) == 0x001C40, "Member 'AFortPlayerController::TrapPickerDecoHelper' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, QuickBars) == 0x001C48, "Member 'AFortPlayerController::QuickBars' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, PinnedSchematics) == 0x001D30, "Member 'AFortPlayerController::PinnedSchematics' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, WorldInventory) == 0x001E78, "Member 'AFortPlayerController::WorldInventory' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, OutpostInventory) == 0x001E80, "Member 'AFortPlayerController::OutpostInventory' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, bHasInitializedWorldInventory) == 0x001FE4, "Member 'AFortPlayerController::bHasInitializedWorldInventory' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, bHasInitializedHeroInventory) == 0x001FE5, "Member 'AFortPlayerController::bHasInitializedHeroInventory' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, bAccountInventoryWasUpdated) == 0x001FE6, "Member 'AFortPlayerController::bAccountInventoryWasUpdated' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, bIsSavingGadgetLoadout) == 0x001FE7, "Member 'AFortPlayerController::bIsSavingGadgetLoadout' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, BotManager) == 0x002100, "Member 'AFortPlayerController::BotManager' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, ClientBotManagerClass) == 0x002110, "Member 'AFortPlayerController::ClientBotManagerClass' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, bDropWeaponsDuringAllMissionStates) == 0x002190, "Member 'AFortPlayerController::bDropWeaponsDuringAllMissionStates' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, LatestRewardReport) == 0x002210, "Member 'AFortPlayerController::LatestRewardReport' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, MyPlayerInfo) == 0x002278, "Member 'AFortPlayerController::MyPlayerInfo' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, UpdatedObjectiveStats) == 0x002280, "Member 'AFortPlayerController::UpdatedObjectiveStats' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, bHasUnsavedPrimaryMissionProgress) == 0x002290, "Member 'AFortPlayerController::bHasUnsavedPrimaryMissionProgress' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, StatManager) == 0x0022B8, "Member 'AFortPlayerController::StatManager' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, HeartbeatManager) == 0x0022C0, "Member 'AFortPlayerController::HeartbeatManager' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, StatEventManager) == 0x0022C8, "Member 'AFortPlayerController::StatEventManager' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, CachedPersistentGameplayStats) == 0x0022D0, "Member 'AFortPlayerController::CachedPersistentGameplayStats' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, McpProfileGroup) == 0x0022F0, "Member 'AFortPlayerController::McpProfileGroup' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, MainMcpProfile) == 0x0022F8, "Member 'AFortPlayerController::MainMcpProfile' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, MetadataProfile) == 0x002300, "Member 'AFortPlayerController::MetadataProfile' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, bShouldReceiveCriticalMatchBonus) == 0x00230C, "Member 'AFortPlayerController::bShouldReceiveCriticalMatchBonus' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, OnServerPlayerChangedBuildMode) == 0x002310, "Member 'AFortPlayerController::OnServerPlayerChangedBuildMode' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, LocationUnderReticle) == 0x002324, "Member 'AFortPlayerController::LocationUnderReticle' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, OverriddenBackpackSize) == 0x002334, "Member 'AFortPlayerController::OverriddenBackpackSize' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, AimHelpMode) == 0x002338, "Member 'AFortPlayerController::AimHelpMode' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, JumpStaminaCost) == 0x00233C, "Member 'AFortPlayerController::JumpStaminaCost' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, CameraPrototypeName) == 0x002340, "Member 'AFortPlayerController::CameraPrototypeName' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, AthenaMenuHeroDef) == 0x002358, "Member 'AFortPlayerController::AthenaMenuHeroDef' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, bShowDamageNumbersOnFatalHit) == 0x002360, "Member 'AFortPlayerController::bShowDamageNumbersOnFatalHit' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, PendingEnterModeActor) == 0x002430, "Member 'AFortPlayerController::PendingEnterModeActor' has a wrong offset!");

// Class FortniteGame.FortPlayerControllerGameplay
// 0x0090 (0x24D0 - 0x2440)
class AFortPlayerControllerGameplay : public AFortPlayerController
{
public:
	uint8                                         Pad_243C[0x94];                                    // 0x243C(0x0094)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RefreshHUDElementVisibilitiesToSettings();
	void ResetHUDElementVisibilityToSettings(const struct FGameplayTagContainer& HUDElementTags);
	void SetHUDElementVisibility(const struct FGameplayTagContainer& HUDElementTags, bool bHideElements);

	bool AreHUDElementsVisible(const struct FGameplayTagContainer& HUDElementTags) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerControllerGameplay">();
	}
	static class AFortPlayerControllerGameplay* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerControllerGameplay>();
	}
};
static_assert(alignof(AFortPlayerControllerGameplay) == 0x000008, "Wrong alignment on AFortPlayerControllerGameplay");
static_assert(sizeof(AFortPlayerControllerGameplay) == 0x0024D0, "Wrong size on AFortPlayerControllerGameplay");

// Class FortniteGame.FortPlayerControllerZone
// 0x0490 (0x2960 - 0x24D0)
class AFortPlayerControllerZone : public AFortPlayerControllerGameplay
{
public:
	bool                                          bDontChangeReticleColorForEnemy;                   // 0x24D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24D1[0x7];                                     // 0x24D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputComponent*                        DeathInputComponent;                               // 0x24D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFortPlayerDeathReport                 PlayerDeathReport;                                 // 0x24E0(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          bEnterCameraModeOnDeath;                           // 0x2530(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2531[0x38F];                                   // 0x2531(0x038F)(Fixing Size After Last Property [ Dumper-7 ])
	TScriptInterface<class IFortHUDTargetUnderReticleInterface> HUDTargetUnderReticle;                             // 0x28C0(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<struct FUniqueNetIdRepl>               RejoinablePartyMembers;                            // 0x28D0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_28E0[0x80];                                    // 0x28E0(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientOnPawnDied(const struct FFortPlayerDeathReport& DeathReport);
	void ClientOnPawnRevived(class AController* EventInstigator);
	void ClientOnPawnSpawned();
	void ClientOnZoneEndScoreReports(const TArray<struct FFortPlayerScoreReport>& ScoreReports);
	void ClientSendPartyJoinInfoToPlayer(const class FString& JoinInfoStr);
	void PopDeathInputComponent();
	void PushDeathInputComponent();
	void ServerSendLoadoutConfig(int32 LoadoutSeed, const TArray<uint8>& Loadout);
	void ServerSendPartyJoinInfoToPlayer(const struct FUniqueNetIdRepl& RecipientId, const class FString& JoinInfoStr);
	void ServerSetShouldDisablePlayerTeleportingDuringMissionResults();
	void ServerSubmitGameplayVote(int32 VoteDecision);
	void ServerTriggerSetupTeleportCameraEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerControllerZone">();
	}
	static class AFortPlayerControllerZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerControllerZone>();
	}
};
static_assert(alignof(AFortPlayerControllerZone) == 0x000008, "Wrong alignment on AFortPlayerControllerZone");
static_assert(sizeof(AFortPlayerControllerZone) == 0x002960, "Wrong size on AFortPlayerControllerZone");
static_assert(offsetof(AFortPlayerControllerZone, bDontChangeReticleColorForEnemy) == 0x0024D0, "Member 'AFortPlayerControllerZone::bDontChangeReticleColorForEnemy' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerZone, DeathInputComponent) == 0x0024D8, "Member 'AFortPlayerControllerZone::DeathInputComponent' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerZone, PlayerDeathReport) == 0x0024E0, "Member 'AFortPlayerControllerZone::PlayerDeathReport' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerZone, bEnterCameraModeOnDeath) == 0x002530, "Member 'AFortPlayerControllerZone::bEnterCameraModeOnDeath' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerZone, HUDTargetUnderReticle) == 0x0028C0, "Member 'AFortPlayerControllerZone::HUDTargetUnderReticle' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerZone, RejoinablePartyMembers) == 0x0028D0, "Member 'AFortPlayerControllerZone::RejoinablePartyMembers' has a wrong offset!");

// Class FortniteGame.FortPlayerControllerFOB
// 0x0000 (0x2960 - 0x2960)
class AFortPlayerControllerFOB final : public AFortPlayerControllerZone
{
public:
	void ServerAttemptSelectFOBCore(class ABuildingFOBConfigActor* FOBToSelectOn, class UFortFOBCoreDecoItemDefinition* DefToSelect);
	void ServerReloadFOB(class ABuildingFOBConfigActor* FOBToReload);
	void ServerResetFOB(class ABuildingFOBConfigActor* FOBToReset);
	void ServerSaveFOB(class ABuildingFOBConfigActor* FOBToSave);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerControllerFOB">();
	}
	static class AFortPlayerControllerFOB* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerControllerFOB>();
	}
};
static_assert(alignof(AFortPlayerControllerFOB) == 0x000008, "Wrong alignment on AFortPlayerControllerFOB");
static_assert(sizeof(AFortPlayerControllerFOB) == 0x002960, "Wrong size on AFortPlayerControllerFOB");

// Class FortniteGame.FortCameraMode_AthenaVehicle
// 0x0010 (0x0120 - 0x0110)
class UFortCameraMode_AthenaVehicle final : public UFortCameraMode_ThirdPerson
{
public:
	struct FVector                                CameraOriginOffset;                                // 0x0110(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCameraMode_AthenaVehicle">();
	}
	static class UFortCameraMode_AthenaVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCameraMode_AthenaVehicle>();
	}
};
static_assert(alignof(UFortCameraMode_AthenaVehicle) == 0x000008, "Wrong alignment on UFortCameraMode_AthenaVehicle");
static_assert(sizeof(UFortCameraMode_AthenaVehicle) == 0x000120, "Wrong size on UFortCameraMode_AthenaVehicle");
static_assert(offsetof(UFortCameraMode_AthenaVehicle, CameraOriginOffset) == 0x000110, "Member 'UFortCameraMode_AthenaVehicle::CameraOriginOffset' has a wrong offset!");

// Class FortniteGame.FortQueryTest_PerceptionAge
// 0x0010 (0x01D0 - 0x01C0)
class UFortQueryTest_PerceptionAge final : public UEnvQueryTest
{
public:
	ECorePerceptionTypes                          Sense;                                             // 0x01C0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C1[0x7];                                      // 0x01C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UAISense>                   SenseClass;                                        // 0x01C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_PerceptionAge">();
	}
	static class UFortQueryTest_PerceptionAge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_PerceptionAge>();
	}
};
static_assert(alignof(UFortQueryTest_PerceptionAge) == 0x000008, "Wrong alignment on UFortQueryTest_PerceptionAge");
static_assert(sizeof(UFortQueryTest_PerceptionAge) == 0x0001D0, "Wrong size on UFortQueryTest_PerceptionAge");
static_assert(offsetof(UFortQueryTest_PerceptionAge, Sense) == 0x0001C0, "Member 'UFortQueryTest_PerceptionAge::Sense' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_PerceptionAge, SenseClass) == 0x0001C8, "Member 'UFortQueryTest_PerceptionAge::SenseClass' has a wrong offset!");

// Class FortniteGame.BuildingEditModeSupport
// 0x0268 (0x0290 - 0x0028)
class UBuildingEditModeSupport : public UObject
{
public:
	class ABuildingSMActor*                       OwnerBuilding;                                     // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortPlayerController*                  EditingController;                                 // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBuildingEditModeMetadata*              PreviewMetadata;                                   // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBuildingEditModeMetadata*              ScratchpadMetadata;                                // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBuildingEditModeMetadata>  ExpectedMetadataClass;                             // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class ABuildingSMActor>>   PossibleEditClasses;                               // 0x0050(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UStaticMesh>             EditTileMesh;                                      // 0x0060(0x0020)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UStaticMeshComponent*>           EditTileMeshComponents;                            // 0x0080(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UMaterialInterface>      TileMaterialParent;                                // 0x0090(0x0020)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              ActiveTileTexture;                                 // 0x00B0(0x0020)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              InactiveTileTexture;                               // 0x00D0(0x0020)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   LastInteractedComp;                                // 0x00F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   LastHighlightedComp;                               // 0x00F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   PreviewComponent;                                  // 0x0100(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UMaterialInterface>      PreviewMaterial;                                   // 0x0108(0x0020)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FEditModeState                         PreviewEditModeState;                              // 0x0128(0x0010)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UCurveFloat>             SuccessfulPatternMatchCurve;                       // 0x0138(0x0020)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_158[0x8];                                      // 0x0158(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimeline                              SuccessfulMatchInteractTimeline;                   // 0x0160(0x00E0)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         bCanMirrorMetadataToMatch : 1;                     // 0x0240(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanRotateMetadataToMatch : 1;                     // 0x0240(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bEditActionInProgress : 1;                         // 0x0240(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bInitializedTimelines : 1;                         // 0x0240(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_241[0x4F];                                     // 0x0241(0x004F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSuccessfulMatchInteractComplete();
	void OnSuccessfulMatchInteractParamUpdate(float NewInteractParamVal);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingEditModeSupport">();
	}
	static class UBuildingEditModeSupport* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingEditModeSupport>();
	}
};
static_assert(alignof(UBuildingEditModeSupport) == 0x000010, "Wrong alignment on UBuildingEditModeSupport");
static_assert(sizeof(UBuildingEditModeSupport) == 0x000290, "Wrong size on UBuildingEditModeSupport");
static_assert(offsetof(UBuildingEditModeSupport, OwnerBuilding) == 0x000028, "Member 'UBuildingEditModeSupport::OwnerBuilding' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport, EditingController) == 0x000030, "Member 'UBuildingEditModeSupport::EditingController' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport, PreviewMetadata) == 0x000038, "Member 'UBuildingEditModeSupport::PreviewMetadata' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport, ScratchpadMetadata) == 0x000040, "Member 'UBuildingEditModeSupport::ScratchpadMetadata' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport, ExpectedMetadataClass) == 0x000048, "Member 'UBuildingEditModeSupport::ExpectedMetadataClass' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport, PossibleEditClasses) == 0x000050, "Member 'UBuildingEditModeSupport::PossibleEditClasses' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport, EditTileMesh) == 0x000060, "Member 'UBuildingEditModeSupport::EditTileMesh' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport, EditTileMeshComponents) == 0x000080, "Member 'UBuildingEditModeSupport::EditTileMeshComponents' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport, TileMaterialParent) == 0x000090, "Member 'UBuildingEditModeSupport::TileMaterialParent' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport, ActiveTileTexture) == 0x0000B0, "Member 'UBuildingEditModeSupport::ActiveTileTexture' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport, InactiveTileTexture) == 0x0000D0, "Member 'UBuildingEditModeSupport::InactiveTileTexture' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport, LastInteractedComp) == 0x0000F0, "Member 'UBuildingEditModeSupport::LastInteractedComp' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport, LastHighlightedComp) == 0x0000F8, "Member 'UBuildingEditModeSupport::LastHighlightedComp' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport, PreviewComponent) == 0x000100, "Member 'UBuildingEditModeSupport::PreviewComponent' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport, PreviewMaterial) == 0x000108, "Member 'UBuildingEditModeSupport::PreviewMaterial' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport, PreviewEditModeState) == 0x000128, "Member 'UBuildingEditModeSupport::PreviewEditModeState' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport, SuccessfulPatternMatchCurve) == 0x000138, "Member 'UBuildingEditModeSupport::SuccessfulPatternMatchCurve' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport, SuccessfulMatchInteractTimeline) == 0x000160, "Member 'UBuildingEditModeSupport::SuccessfulMatchInteractTimeline' has a wrong offset!");

// Class FortniteGame.FortAIHotSpot_Building
// 0x0088 (0x05C0 - 0x0538)
class AFortAIHotSpot_Building final : public AFortAIHotSpot
{
public:
	class UAIHotSpotConfig*                       ExtraTypeConfig;                                   // 0x0538(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_540[0x80];                                     // 0x0540(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIHotSpot_Building">();
	}
	static class AFortAIHotSpot_Building* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAIHotSpot_Building>();
	}
};
static_assert(alignof(AFortAIHotSpot_Building) == 0x000008, "Wrong alignment on AFortAIHotSpot_Building");
static_assert(sizeof(AFortAIHotSpot_Building) == 0x0005C0, "Wrong size on AFortAIHotSpot_Building");
static_assert(offsetof(AFortAIHotSpot_Building, ExtraTypeConfig) == 0x000538, "Member 'AFortAIHotSpot_Building::ExtraTypeConfig' has a wrong offset!");

// Class FortniteGame.FortAIHotSpot_FakeBuilding
// 0x0000 (0x0538 - 0x0538)
class AFortAIHotSpot_FakeBuilding final : public AFortAIHotSpot
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIHotSpot_FakeBuilding">();
	}
	static class AFortAIHotSpot_FakeBuilding* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAIHotSpot_FakeBuilding>();
	}
};
static_assert(alignof(AFortAIHotSpot_FakeBuilding) == 0x000008, "Wrong alignment on AFortAIHotSpot_FakeBuilding");
static_assert(sizeof(AFortAIHotSpot_FakeBuilding) == 0x000538, "Wrong size on AFortAIHotSpot_FakeBuilding");

// Class FortniteGame.FortPlayerControllerPvP
// 0x0000 (0x2960 - 0x2960)
class AFortPlayerControllerPvP : public AFortPlayerControllerZone
{
public:
	void ClientReceiveKillNotification(class AFortPlayerStateZone* Killer, class AFortPlayerStateZone* Killed);
	void ClientShowGameOverWidget(EFortPvPGameResult GameResult);
	void ServerAttemptSelectFOBCore(class ABuildingFOBConfigActor* FOBToSelectOn, class UFortFOBCoreDecoItemDefinition* DefToSelect);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerControllerPvP">();
	}
	static class AFortPlayerControllerPvP* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerControllerPvP>();
	}
};
static_assert(alignof(AFortPlayerControllerPvP) == 0x000008, "Wrong alignment on AFortPlayerControllerPvP");
static_assert(sizeof(AFortPlayerControllerPvP) == 0x002960, "Wrong size on AFortPlayerControllerPvP");

// Class FortniteGame.FortPlayerControllerPvPBaseDestruction
// 0x0000 (0x2960 - 0x2960)
class AFortPlayerControllerPvPBaseDestruction final : public AFortPlayerControllerPvP
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerControllerPvPBaseDestruction">();
	}
	static class AFortPlayerControllerPvPBaseDestruction* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerControllerPvPBaseDestruction>();
	}
};
static_assert(alignof(AFortPlayerControllerPvPBaseDestruction) == 0x000008, "Wrong alignment on AFortPlayerControllerPvPBaseDestruction");
static_assert(sizeof(AFortPlayerControllerPvPBaseDestruction) == 0x002960, "Wrong size on AFortPlayerControllerPvPBaseDestruction");

// Class FortniteGame.AIHotSpotConfig
// 0x0020 (0x0048 - 0x0028)
class UAIHotSpotConfig final : public UDataAsset
{
public:
	TArray<struct FAIHotSpotSlotConfig>           Slots;                                             // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         bDetectUnreachableSlots : 1;                       // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAIHotSpotSlotGenerator*                SlotGenerator;                                     // 0x0040(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIHotSpotConfig">();
	}
	static class UAIHotSpotConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIHotSpotConfig>();
	}
};
static_assert(alignof(UAIHotSpotConfig) == 0x000008, "Wrong alignment on UAIHotSpotConfig");
static_assert(sizeof(UAIHotSpotConfig) == 0x000048, "Wrong size on UAIHotSpotConfig");
static_assert(offsetof(UAIHotSpotConfig, Slots) == 0x000028, "Member 'UAIHotSpotConfig::Slots' has a wrong offset!");
static_assert(offsetof(UAIHotSpotConfig, SlotGenerator) == 0x000040, "Member 'UAIHotSpotConfig::SlotGenerator' has a wrong offset!");

// Class FortniteGame.FortPlayerStateFrontEnd
// 0x0008 (0x0AD0 - 0x0AC8)
class AFortPlayerStateFrontEnd final : public AFortPlayerState
{
public:
	uint8                                         Pad_AC8[0x8];                                      // 0x0AC8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerStateFrontEnd">();
	}
	static class AFortPlayerStateFrontEnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerStateFrontEnd>();
	}
};
static_assert(alignof(AFortPlayerStateFrontEnd) == 0x000008, "Wrong alignment on AFortPlayerStateFrontEnd");
static_assert(sizeof(AFortPlayerStateFrontEnd) == 0x000AD0, "Wrong size on AFortPlayerStateFrontEnd");

// Class FortniteGame.FortOutpostAnalytics
// 0x0000 (0x0028 - 0x0028)
class UFortOutpostAnalytics final : public UBlueprintFunctionLibrary
{
public:
	static void FireAnalyticsEvent_OutpostAttackWaveCompleted(const class UObject* SourceBp, const class FString& BuildingType, const int32 NumWavesCompleted, const bool Succeeded, const class FString& Direction, const int32 DefenseLeg);
	static void FireAnalyticsEvent_OutpostAttackWaveStarted(const class UObject* SourceBp, const class FString& BuildingType, const int32 NumWavesStarted, const class FString& Direction, const int32 DefenseLeg);
	static void FireAnalyticsEvent_OutpostBuildingActivated(const class UObject* SourceBp, const class FString& BuildingType, const int32 NumMissionsCompleted);
	static void FireAnalyticsEvent_OutpostBuildingDefended(const class UObject* SourceBp, const class FString& BuildingType, const int32 NumMissionsCompleted);
	static void FireAnalyticsEvent_OutpostDefenseEnd(const class UObject* SourceBp, const int32 NumWavesStarted, const int32 NumWavesTotal, bool bSucceeded, bool bAbandoned, const int32 DefenseLeg);
	static void FireAnalyticsEvent_OutpostDefenseStart(const class UObject* SourceBp, const int32 NumWavesTotal, const int32 DefenseLeg);
	static void FireAnalyticsEvent_OutpostLeaveOutpost(const class UObject* SourceBp, const class FString& BuildingType, const int32 NumWavesStarted, const int32 DefenseLeg);
	static void FireAnalyticsEvent_OutpostLoaded(const class UObject* SourceBp, const int32 DefenseLeg);
	static void FireAnalyticsEvent_OutpostSupplyDropPickedUp(const class UObject* SourceBp, const TArray<struct FFortAnalyticsEventAttribute>& Resourcees);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortOutpostAnalytics">();
	}
	static class UFortOutpostAnalytics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortOutpostAnalytics>();
	}
};
static_assert(alignof(UFortOutpostAnalytics) == 0x000008, "Wrong alignment on UFortOutpostAnalytics");
static_assert(sizeof(UFortOutpostAnalytics) == 0x000028, "Wrong size on UFortOutpostAnalytics");

// Class FortniteGame.FortTooltipLibrary
// 0x0000 (0x0028 - 0x0028)
class UFortTooltipLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class FText FormatAttributeBuffs(const struct FFortAttributeInfo& AttributeInfo, float AdditiveBuff, float MultiplicativeBuff);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTooltipLibrary">();
	}
	static class UFortTooltipLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortTooltipLibrary>();
	}
};
static_assert(alignof(UFortTooltipLibrary) == 0x000008, "Wrong alignment on UFortTooltipLibrary");
static_assert(sizeof(UFortTooltipLibrary) == 0x000028, "Wrong size on UFortTooltipLibrary");

// Class FortniteGame.FortAIHotSpotSlotGenerator_FromConfig
// 0x0018 (0x0040 - 0x0028)
class UFortAIHotSpotSlotGenerator_FromConfig final : public UAIHotSpotSlotGenerator
{
public:
	class UAIHotSpotConfig*                       BuildingConfig;                                    // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Offset;                                            // 0x0030(0x000C)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bMirrorX : 1;                                      // 0x003C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bMirrorY : 1;                                      // 0x003C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIHotSpotSlotGenerator_FromConfig">();
	}
	static class UFortAIHotSpotSlotGenerator_FromConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIHotSpotSlotGenerator_FromConfig>();
	}
};
static_assert(alignof(UFortAIHotSpotSlotGenerator_FromConfig) == 0x000008, "Wrong alignment on UFortAIHotSpotSlotGenerator_FromConfig");
static_assert(sizeof(UFortAIHotSpotSlotGenerator_FromConfig) == 0x000040, "Wrong size on UFortAIHotSpotSlotGenerator_FromConfig");
static_assert(offsetof(UFortAIHotSpotSlotGenerator_FromConfig, BuildingConfig) == 0x000028, "Member 'UFortAIHotSpotSlotGenerator_FromConfig::BuildingConfig' has a wrong offset!");
static_assert(offsetof(UFortAIHotSpotSlotGenerator_FromConfig, Offset) == 0x000030, "Member 'UFortAIHotSpotSlotGenerator_FromConfig::Offset' has a wrong offset!");

// Class FortniteGame.FortItem
// 0x00A8 (0x00D0 - 0x0028)
class UFortItem : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnItemChanged;                                     // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x70];                                      // 0x0040(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnItemDestroyed;                                   // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bLoadedFromSave : 1;                               // 0x00C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bTemporaryItemOwningController : 1;                // 0x00C8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class FText GetEvolveRestrictionReasonText(const EItemEvolutionRestrictionReason Reason);
	static class FText GetUpgradeRestrictionReasonText(const EItemUpgradeRestrictionReason Reason);

	void SetOwningControllerForTemporaryItem(class AFortPlayerController* InController);

	bool CanBeDropped() const;
	bool CanBeUnslotted() const;
	bool CanBeUpgraded(TArray<EItemUpgradeRestrictionReason>* OutRestrictionReasons) const;
	bool CanEvolve(TArray<EItemEvolutionRestrictionReason>* OutRestrictionReasons) const;
	bool DoesMatchSearchString(const class FString& SearchString) const;
	TArray<class UFortAlterationItemDefinition*> GetAlterations() const;
	class FText GetAlterationSlotActivationRequirement(int32 SlotIndex) const;
	float GetCoolDownTimeRemaining(class AFortPlayerController* FortPC, float* CooldownDuration) const;
	class FText GetDescription() const;
	class FText GetDisplayName() const;
	float GetDurability() const;
	EFortInventoryFilter GetFilterCategory() const;
	class UFortItemDefinition* GetItemDefinitionBP() const;
	struct FGuid GetItemGuid() const;
	TSoftObjectPtr<class UTexture2D> GetLargePreviewImage() const;
	int32 GetLevel() const;
	int32 GetLoadedAmmo() const;
	int32 GetMaxLevel() const;
	EFortItemTier GetMaxTier() const;
	float GetNormalizedDurability() const;
	int32 GetNumInStack() const;
	class AFortPlayerController* GetOwningController() const;
	bool GetPrimaryCategory(class FText* ItemCategoryText) const;
	EFortRarity GetRarity() const;
	struct FLinearColor GetRarityColor() const;
	struct FLinearColor GetRaritySecondaryColor() const;
	int32 GetRating() const;
	int32 GetRecycleValue() const;
	int32 GetRemainingAmmo() const;
	class UFortItemDefinition* GetSchematicCraftingResultBP() const;
	EFortItemType GetSchematicResultType() const;
	class FText GetSearchTags() const;
	bool GetSecondaryCategory(class FText* ItemCategoryText, struct FSlateBrush* ItemCategoryBrush, EFortBrushSize BrushSize) const;
	TSoftObjectPtr<class UTexture2D> GetSmallPreviewImage() const;
	bool GetTertiaryCategory(class FText* ItemCategoryText, struct FSlateBrush* ItemCategoryBrush, EFortBrushSize BrushSize) const;
	EFortItemTier GetTier() const;
	EFortItemType GetType() const;
	int32 GetUpgradeCost() const;
	class UFortPersistentResourceItemDefinition* GetUpgradeResourceItemDefinition() const;
	bool HasDurability() const;
	bool HasEvolutions() const;
	bool IsActivatable(class AFortPlayerController* FortPC, struct FGameplayTagContainer* FailureReason) const;
	bool IsAlterationSlotActive(int32 SlotIndex) const;
	bool IsEquipable(const class AFortPlayerController* EquippingPC) const;
	bool IsEquipped() const;
	bool IsInStorageVault() const;
	bool IsInventoryOverflowItem() const;
	bool IsSchematic() const;
	bool IsSlotted() const;
	bool IsTemporaryItem() const;
	bool TryGetCategory(EFortItemCategoryOrdinal Ordinal, class FText* OutCategoryDisplayName, bool* OutHasIcon, struct FFortMultiSizeBrush* OutCategoryIconBrush) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortItem">();
	}
	static class UFortItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortItem>();
	}
};
static_assert(alignof(UFortItem) == 0x000008, "Wrong alignment on UFortItem");
static_assert(sizeof(UFortItem) == 0x0000D0, "Wrong size on UFortItem");
static_assert(offsetof(UFortItem, OnItemChanged) == 0x000030, "Member 'UFortItem::OnItemChanged' has a wrong offset!");
static_assert(offsetof(UFortItem, OnItemDestroyed) == 0x0000B0, "Member 'UFortItem::OnItemDestroyed' has a wrong offset!");

// Class FortniteGame.FortAccountItem
// 0x0068 (0x0138 - 0x00D0)
#pragma pack(push, 0x1)
class alignas(0x08) UFortAccountItem : public UFortItem
{
public:
	int32                                         Level;                                             // 0x00D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Xp;                                                // 0x00D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         item_seen;                                         // 0x00D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         favorite;                                          // 0x00DC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         max_level_bonus;                                   // 0x00E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 inventory_overflow_date;                           // 0x00E8(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortAccountItemDefinition*             ItemDefinition;                                    // 0x00F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 InstanceId;                                        // 0x0100(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 TemplateId;                                        // 0x0110(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Quantity;                                          // 0x0120(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsLocalOnlyItem;                                  // 0x0124(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsPendingBeingMarkedAsSeen;                       // 0x0125(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_126[0x12];                                     // 0x0126(0x0012)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MarkItemAsSeenBP();

	bool HasBeenSeenLocally() const;
	bool IsFavorite() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAccountItem">();
	}
	static class UFortAccountItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAccountItem>();
	}
};
#pragma pack(pop)
static_assert(alignof(UFortAccountItem) == 0x000008, "Wrong alignment on UFortAccountItem");
static_assert(sizeof(UFortAccountItem) == 0x000138, "Wrong size on UFortAccountItem");
static_assert(offsetof(UFortAccountItem, Level) == 0x0000D0, "Member 'UFortAccountItem::Level' has a wrong offset!");
static_assert(offsetof(UFortAccountItem, Xp) == 0x0000D4, "Member 'UFortAccountItem::Xp' has a wrong offset!");
static_assert(offsetof(UFortAccountItem, item_seen) == 0x0000D8, "Member 'UFortAccountItem::item_seen' has a wrong offset!");
static_assert(offsetof(UFortAccountItem, favorite) == 0x0000DC, "Member 'UFortAccountItem::favorite' has a wrong offset!");
static_assert(offsetof(UFortAccountItem, max_level_bonus) == 0x0000E0, "Member 'UFortAccountItem::max_level_bonus' has a wrong offset!");
static_assert(offsetof(UFortAccountItem, inventory_overflow_date) == 0x0000E8, "Member 'UFortAccountItem::inventory_overflow_date' has a wrong offset!");
static_assert(offsetof(UFortAccountItem, ItemDefinition) == 0x0000F8, "Member 'UFortAccountItem::ItemDefinition' has a wrong offset!");
static_assert(offsetof(UFortAccountItem, InstanceId) == 0x000100, "Member 'UFortAccountItem::InstanceId' has a wrong offset!");
static_assert(offsetof(UFortAccountItem, TemplateId) == 0x000110, "Member 'UFortAccountItem::TemplateId' has a wrong offset!");
static_assert(offsetof(UFortAccountItem, Quantity) == 0x000120, "Member 'UFortAccountItem::Quantity' has a wrong offset!");
static_assert(offsetof(UFortAccountItem, bIsLocalOnlyItem) == 0x000124, "Member 'UFortAccountItem::bIsLocalOnlyItem' has a wrong offset!");
static_assert(offsetof(UFortAccountItem, bIsPendingBeingMarkedAsSeen) == 0x000125, "Member 'UFortAccountItem::bIsPendingBeingMarkedAsSeen' has a wrong offset!");

// Class FortniteGame.FortQuestItem
// 0x00A8 (0x01E0 - 0x0138)
class UFortQuestItem final : public UFortAccountItem
{
public:
	TArray<class UFortQuestObjectiveInfo*>        Objectives;                                        // 0x0138(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	EFortQuestState                               quest_state;                                       // 0x0148(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          sent_new_notification;                             // 0x0149(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14A[0x6];                                      // 0x014A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              last_state_change_time;                            // 0x0150(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, int32>                      CompletionCounts;                                  // 0x0158(0x0050)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          bSentCompleteNotification;                         // 0x01A8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllObjectivesComplete;                            // 0x01A9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1AA[0x6];                                      // 0x01AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 twitch_broadcaster_channel_id;                     // 0x01B0(0x0010)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentStage;                                      // 0x01C0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C4[0x4];                                      // 0x01C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              expiry_time;                                       // 0x01C8(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFortMissionInstancedConfigData        InstancedConfigData;                               // 0x01D0(0x0010)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	class UFortMissionConfigData* GetMissionConfigData(const struct FGameplayTag& InBucketTag);

	bool CanPinQuest() const;
	bool DoesQuestExpire() const;
	void GetAchievedCount(int32* OutTotalAchievedCount, int32* OutTotalRequiredCount) const;
	struct FDateTime GetBroadcasterGrantWindowEnd() const;
	class UFortQuestObjectiveInfo* GetObjectiveInfo(const struct FDataTableRowHandle& ObjectiveStatHandle) const;
	float GetPercentageComplete() const;
	TArray<struct FFortItemInstanceQuantityPair> GetPreviewAllSelectableRewards() const;
	TArray<struct FFortItemInstanceQuantityPair> GetPreviewRewards() const;
	TArray<struct FFortItemInstanceQuantityPair> GetPreviewSelectableRewards(int32 RewardIndex) const;
	class UFortQuestItemDefinition* GetQuestDefinitionBP() const;
	EFortQuestState GetQuestState() const;
	struct FTimespan GetRemainingExpirationDuration(const struct FTimespan& UtcNowOffset) const;
	class FString GetTwitchBroadcasterChannelId() const;
	bool HasCompletedObjective(const struct FDataTableRowHandle& ObjectiveStatHandle) const;
	bool HasCompletedObjectiveWithName(class FName BackendName) const;
	bool HasCompletedQuest() const;
	bool HasQuestExpired(const struct FTimespan& UtcNowOffset) const;
	bool HasVisibleRewards() const;
	bool IsObjectiveInProgress(const struct FDataTableRowHandle& ObjectiveStatHandle) const;
	bool IsObjectiveWithNameInProgress(class FName BackendName) const;
	bool IsQuestInProgress() const;
	bool IsQuestPinned() const;
	bool IsVisibleToUser(bool bAllowClaimedQuestsToBeVisible) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQuestItem">();
	}
	static class UFortQuestItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQuestItem>();
	}
};
static_assert(alignof(UFortQuestItem) == 0x000008, "Wrong alignment on UFortQuestItem");
static_assert(sizeof(UFortQuestItem) == 0x0001E0, "Wrong size on UFortQuestItem");
static_assert(offsetof(UFortQuestItem, Objectives) == 0x000138, "Member 'UFortQuestItem::Objectives' has a wrong offset!");
static_assert(offsetof(UFortQuestItem, quest_state) == 0x000148, "Member 'UFortQuestItem::quest_state' has a wrong offset!");
static_assert(offsetof(UFortQuestItem, sent_new_notification) == 0x000149, "Member 'UFortQuestItem::sent_new_notification' has a wrong offset!");
static_assert(offsetof(UFortQuestItem, last_state_change_time) == 0x000150, "Member 'UFortQuestItem::last_state_change_time' has a wrong offset!");
static_assert(offsetof(UFortQuestItem, CompletionCounts) == 0x000158, "Member 'UFortQuestItem::CompletionCounts' has a wrong offset!");
static_assert(offsetof(UFortQuestItem, bSentCompleteNotification) == 0x0001A8, "Member 'UFortQuestItem::bSentCompleteNotification' has a wrong offset!");
static_assert(offsetof(UFortQuestItem, bAllObjectivesComplete) == 0x0001A9, "Member 'UFortQuestItem::bAllObjectivesComplete' has a wrong offset!");
static_assert(offsetof(UFortQuestItem, twitch_broadcaster_channel_id) == 0x0001B0, "Member 'UFortQuestItem::twitch_broadcaster_channel_id' has a wrong offset!");
static_assert(offsetof(UFortQuestItem, CurrentStage) == 0x0001C0, "Member 'UFortQuestItem::CurrentStage' has a wrong offset!");
static_assert(offsetof(UFortQuestItem, expiry_time) == 0x0001C8, "Member 'UFortQuestItem::expiry_time' has a wrong offset!");
static_assert(offsetof(UFortQuestItem, InstancedConfigData) == 0x0001D0, "Member 'UFortQuestItem::InstancedConfigData' has a wrong offset!");

// Class FortniteGame.FortAIHotSpotSlotGenerator_RampTrace
// 0x0018 (0x0040 - 0x0028)
class UFortAIHotSpotSlotGenerator_RampTrace final : public UAIHotSpotSlotGenerator
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIHotSpotSlotGenerator_RampTrace">();
	}
	static class UFortAIHotSpotSlotGenerator_RampTrace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIHotSpotSlotGenerator_RampTrace>();
	}
};
static_assert(alignof(UFortAIHotSpotSlotGenerator_RampTrace) == 0x000008, "Wrong alignment on UFortAIHotSpotSlotGenerator_RampTrace");
static_assert(sizeof(UFortAIHotSpotSlotGenerator_RampTrace) == 0x000040, "Wrong size on UFortAIHotSpotSlotGenerator_RampTrace");

// Class FortniteGame.FortNavObstacleComponent
// 0x0008 (0x0128 - 0x0120)
class UFortNavObstacleComponent final : public UNavRelevantComponent
{
public:
	TSubclassOf<class UNavArea>                   ObstacleAreaClass;                                 // 0x0120(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavObstacleComponent">();
	}
	static class UFortNavObstacleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavObstacleComponent>();
	}
};
static_assert(alignof(UFortNavObstacleComponent) == 0x000008, "Wrong alignment on UFortNavObstacleComponent");
static_assert(sizeof(UFortNavObstacleComponent) == 0x000128, "Wrong size on UFortNavObstacleComponent");
static_assert(offsetof(UFortNavObstacleComponent, ObstacleAreaClass) == 0x000120, "Member 'UFortNavObstacleComponent::ObstacleAreaClass' has a wrong offset!");

// Class FortniteGame.FortBehaviorTreeComponent
// 0x0000 (0x0288 - 0x0288)
class UFortBehaviorTreeComponent final : public UBehaviorTreeComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBehaviorTreeComponent">();
	}
	static class UFortBehaviorTreeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBehaviorTreeComponent>();
	}
};
static_assert(alignof(UFortBehaviorTreeComponent) == 0x000008, "Wrong alignment on UFortBehaviorTreeComponent");
static_assert(sizeof(UFortBehaviorTreeComponent) == 0x000288, "Wrong size on UFortBehaviorTreeComponent");

// Class FortniteGame.AutomationPerfMonitorManager
// 0x0088 (0x00B0 - 0x0028)
class UAutomationPerfMonitorManager final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         DesiredStats;                                      // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bRecording;                                        // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0xF];                                       // 0x0041(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeSinceLastRecord;                               // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastGoodFrame;                                     // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x58];                                      // 0x0058(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAutomationPerfMonitorManager* GetPerfMonitorInstance();

	float GetStatAverage(const class FString& StatName);
	bool IsRecordingFTestPerf();
	void StartRecordingFTestPerf(const TArray<class FString>& StatsToRecord);
	void StopRecordingFTestPerf();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AutomationPerfMonitorManager">();
	}
	static class UAutomationPerfMonitorManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAutomationPerfMonitorManager>();
	}
};
static_assert(alignof(UAutomationPerfMonitorManager) == 0x000008, "Wrong alignment on UAutomationPerfMonitorManager");
static_assert(sizeof(UAutomationPerfMonitorManager) == 0x0000B0, "Wrong size on UAutomationPerfMonitorManager");
static_assert(offsetof(UAutomationPerfMonitorManager, DesiredStats) == 0x000030, "Member 'UAutomationPerfMonitorManager::DesiredStats' has a wrong offset!");
static_assert(offsetof(UAutomationPerfMonitorManager, bRecording) == 0x000040, "Member 'UAutomationPerfMonitorManager::bRecording' has a wrong offset!");
static_assert(offsetof(UAutomationPerfMonitorManager, TimeSinceLastRecord) == 0x000050, "Member 'UAutomationPerfMonitorManager::TimeSinceLastRecord' has a wrong offset!");
static_assert(offsetof(UAutomationPerfMonitorManager, LastGoodFrame) == 0x000054, "Member 'UAutomationPerfMonitorManager::LastGoodFrame' has a wrong offset!");

// Class FortniteGame.FortSignificanceManager
// 0x0520 (0x0610 - 0x00F0)
class UFortSignificanceManager final : public USignificanceManager
{
public:
	uint8                                         Pad_F0[0x520];                                     // 0x00F0(0x0520)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortSignificanceManager">();
	}
	static class UFortSignificanceManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortSignificanceManager>();
	}
};
static_assert(alignof(UFortSignificanceManager) == 0x000008, "Wrong alignment on UFortSignificanceManager");
static_assert(sizeof(UFortSignificanceManager) == 0x000610, "Wrong size on UFortSignificanceManager");

// Class FortniteGame.FortMovementSet
// 0x00E0 (0x0110 - 0x0030)
class UFortMovementSet final : public UFortAttributeSet
{
public:
	struct FFortGameplayAttributeData             WalkSpeed;                                         // 0x0030(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             RunSpeed;                                          // 0x0050(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             SprintSpeed;                                       // 0x0070(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             BackwardSpeedMultiplier;                           // 0x0090(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             JumpHeight;                                        // 0x00B0(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             GravityZScale;                                     // 0x00D0(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             SpeedMultiplier;                                   // 0x00F0(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)

public:
	void OnRep_SpeedMultiplier();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMovementSet">();
	}
	static class UFortMovementSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMovementSet>();
	}
};
static_assert(alignof(UFortMovementSet) == 0x000008, "Wrong alignment on UFortMovementSet");
static_assert(sizeof(UFortMovementSet) == 0x000110, "Wrong size on UFortMovementSet");
static_assert(offsetof(UFortMovementSet, WalkSpeed) == 0x000030, "Member 'UFortMovementSet::WalkSpeed' has a wrong offset!");
static_assert(offsetof(UFortMovementSet, RunSpeed) == 0x000050, "Member 'UFortMovementSet::RunSpeed' has a wrong offset!");
static_assert(offsetof(UFortMovementSet, SprintSpeed) == 0x000070, "Member 'UFortMovementSet::SprintSpeed' has a wrong offset!");
static_assert(offsetof(UFortMovementSet, BackwardSpeedMultiplier) == 0x000090, "Member 'UFortMovementSet::BackwardSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UFortMovementSet, JumpHeight) == 0x0000B0, "Member 'UFortMovementSet::JumpHeight' has a wrong offset!");
static_assert(offsetof(UFortMovementSet, GravityZScale) == 0x0000D0, "Member 'UFortMovementSet::GravityZScale' has a wrong offset!");
static_assert(offsetof(UFortMovementSet, SpeedMultiplier) == 0x0000F0, "Member 'UFortMovementSet::SpeedMultiplier' has a wrong offset!");

// Class FortniteGame.FortAbilitySet
// 0x0028 (0x0050 - 0x0028)
class UFortAbilitySet : public UPrimaryDataAsset
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UFortGameplayAbility>> GameplayAbilities;                                 // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<struct FGameplayEffectApplicationInfo> PassiveGameplayEffects;                            // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAbilitySet">();
	}
	static class UFortAbilitySet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAbilitySet>();
	}
};
static_assert(alignof(UFortAbilitySet) == 0x000008, "Wrong alignment on UFortAbilitySet");
static_assert(sizeof(UFortAbilitySet) == 0x000050, "Wrong size on UFortAbilitySet");
static_assert(offsetof(UFortAbilitySet, GameplayAbilities) == 0x000030, "Member 'UFortAbilitySet::GameplayAbilities' has a wrong offset!");
static_assert(offsetof(UFortAbilitySet, PassiveGameplayEffects) == 0x000040, "Member 'UFortAbilitySet::PassiveGameplayEffects' has a wrong offset!");

// Class FortniteGame.FortMetadataItem
// 0x0038 (0x0108 - 0x00D0)
#pragma pack(push, 0x1)
class alignas(0x08) UFortMetadataItem : public UFortItem
{
public:
	int32                                         Level;                                             // 0x00D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 InstanceId;                                        // 0x00D8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 TemplateId;                                        // 0x00E8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Quantity;                                          // 0x00F8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortMetadataItemDefinition*            ItemDefinition;                                    // 0x0100(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMetadataItem">();
	}
	static class UFortMetadataItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMetadataItem>();
	}
};
#pragma pack(pop)
static_assert(alignof(UFortMetadataItem) == 0x000008, "Wrong alignment on UFortMetadataItem");
static_assert(sizeof(UFortMetadataItem) == 0x000108, "Wrong size on UFortMetadataItem");
static_assert(offsetof(UFortMetadataItem, Level) == 0x0000D0, "Member 'UFortMetadataItem::Level' has a wrong offset!");
static_assert(offsetof(UFortMetadataItem, InstanceId) == 0x0000D8, "Member 'UFortMetadataItem::InstanceId' has a wrong offset!");
static_assert(offsetof(UFortMetadataItem, TemplateId) == 0x0000E8, "Member 'UFortMetadataItem::TemplateId' has a wrong offset!");
static_assert(offsetof(UFortMetadataItem, Quantity) == 0x0000F8, "Member 'UFortMetadataItem::Quantity' has a wrong offset!");
static_assert(offsetof(UFortMetadataItem, ItemDefinition) == 0x000100, "Member 'UFortMetadataItem::ItemDefinition' has a wrong offset!");

// Class FortniteGame.FortCloudSaveItem
// 0x0018 (0x0120 - 0x0108)
class UFortCloudSaveItem : public UFortMetadataItem
{
public:
	struct FFortCloudSaveInfo                     cloud_save_info;                                   // 0x0108(0x0018)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCloudSaveItem">();
	}
	static class UFortCloudSaveItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCloudSaveItem>();
	}
};
static_assert(alignof(UFortCloudSaveItem) == 0x000008, "Wrong alignment on UFortCloudSaveItem");
static_assert(sizeof(UFortCloudSaveItem) == 0x000120, "Wrong size on UFortCloudSaveItem");
static_assert(offsetof(UFortCloudSaveItem, cloud_save_info) == 0x000108, "Member 'UFortCloudSaveItem::cloud_save_info' has a wrong offset!");

// Class FortniteGame.FortDamageSourceInterface
// 0x0000 (0x0028 - 0x0028)
class IFortDamageSourceInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDamageSourceInterface">();
	}
	static class IFortDamageSourceInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortDamageSourceInterface>();
	}
};
static_assert(alignof(IFortDamageSourceInterface) == 0x000008, "Wrong alignment on IFortDamageSourceInterface");
static_assert(sizeof(IFortDamageSourceInterface) == 0x000028, "Wrong size on IFortDamageSourceInterface");

// Class FortniteGame.FortNotificationQueue
// 0x0020 (0x0048 - 0x0028)
class UFortNotificationQueue final : public UObject
{
public:
	TArray<struct FFortDialogDescription>         NotificationQueue;                                 // 0x0028(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNotificationQueue">();
	}
	static class UFortNotificationQueue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNotificationQueue>();
	}
};
static_assert(alignof(UFortNotificationQueue) == 0x000008, "Wrong alignment on UFortNotificationQueue");
static_assert(sizeof(UFortNotificationQueue) == 0x000048, "Wrong size on UFortNotificationQueue");
static_assert(offsetof(UFortNotificationQueue, NotificationQueue) == 0x000028, "Member 'UFortNotificationQueue::NotificationQueue' has a wrong offset!");

// Class FortniteGame.FortBlueprintAnalytics
// 0x0000 (0x0028 - 0x0028)
class UFortBlueprintAnalytics final : public UBlueprintFunctionLibrary
{
public:
	static struct FFortAnalyticsEventAttribute ConstructAnalyticsAttribute(const class FString& AttributeName, const class FString& StringValue, const struct FGuid& FGuidValue, const int32 IntValue, const float FloatValue, const bool BoolValue);
	static void FireAnalyticsEvent_Blueprint(const class UObject* SourceBp, const class FString& EventName, const struct FFortAnalyticsEventAttribute& Attribute);
	static void FireAnalyticsEvent_BlueprintArray(const class UObject* SourceBp, const class FString& EventName, const TArray<struct FFortAnalyticsEventAttribute>& Attributes);
	static void FireEvent_BuildLimitProgressDecremented(const class UObject* SourceBp, class AController* Destroyer, class AFortMission* Mission, EFortBuildingType BuildingType, int32 BuildLimitProgress, int32 BuildLimit);
	static void FireEvent_BuildLimitProgressIncremented(const class UObject* SourceBp, class AFortPlayerController* FortPC, class AFortMission* Mission, EFortBuildingType BuildingType, int32 BuildLimitProgress, int32 BuildLimit);
	static void FireEvent_MatchmakingClientEnded(const class UObject* SourceBp, bool bPartyStateIsWorldView, bool bPartyStateIsTheaterView, bool bPartyStateIsReturningToFrontEnd, bool bMatchmakingComplete, bool bLobbyStarted, bool bMatchmakingCancelled);
	static void FireEvent_MatchmakingClientStarted(const class UObject* SourceBp, bool bMatchmakingStarted, bool bClientPartyStateMatchmaking, bool bClientPartyStateChangedPostMatchmaking);
	static void FireEvent_MatchmakingClientStatusTextChanged(const class UObject* SourceBp, bool bMatchmakingIsLocal, bool bUserIsMatchmaking, bool bPartyIsPostMatchmaking, bool bIsStormShieldMission, const class FString& QueueState, EMatchmakingState MatchmakingState);
	static void FireMissionAnalyticsEvent_Blueprint(const class UObject* SourceBp, const class FString& EventName, const struct FFortAnalyticsEventAttribute& Attribute);
	static void FireMissionAnalyticsEvent_BlueprintArray(const class UObject* SourceBp, const class FString& EventName, const TArray<struct FFortAnalyticsEventAttribute>& Attributes);
	static void FireQuestAnalyticsEvent_Blueprint(const class UObject* SourceBp, const class FString& EventName, const class UFortQuestItem* Quest);
	static void FireQuestAnalyticsEvent_BlueprintArray(const class UObject* SourceBp, const class FString& EventName, const class UFortQuestItem* Quest, const TArray<struct FFortAnalyticsEventAttribute>& Attributes);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBlueprintAnalytics">();
	}
	static class UFortBlueprintAnalytics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBlueprintAnalytics>();
	}
};
static_assert(alignof(UFortBlueprintAnalytics) == 0x000008, "Wrong alignment on UFortBlueprintAnalytics");
static_assert(sizeof(UFortBlueprintAnalytics) == 0x000028, "Wrong size on UFortBlueprintAnalytics");

// Class FortniteGame.FortTargetSelectionInterface
// 0x0000 (0x0028 - 0x0028)
class IFortTargetSelectionInterface final : public IInterface
{
public:
	struct FTransform GetTargetingTransform(EFortAbilityTargetingSource Source, class UFortGameplayAbility* SourceAbility) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTargetSelectionInterface">();
	}
	static class IFortTargetSelectionInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortTargetSelectionInterface>();
	}
};
static_assert(alignof(IFortTargetSelectionInterface) == 0x000008, "Wrong alignment on IFortTargetSelectionInterface");
static_assert(sizeof(IFortTargetSelectionInterface) == 0x000028, "Wrong size on IFortTargetSelectionInterface");

// Class FortniteGame.BuildingGameplayActor
// 0x0108 (0x0840 - 0x0738)
class ABuildingGameplayActor : public ABuildingActor
{
public:
	uint8                                         Pad_738[0x10];                                     // 0x0738(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAbilitySet*                        AbilitySet;                                        // 0x0748(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortAbilitySet*                        InherentAbilitySets[0x5];                          // 0x0750(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortDamageSet*                         DamageSet;                                         // 0x0778(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    DamageStatHandle;                                  // 0x0780(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIgnoreInstigatorCollision;                        // 0x0790(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAddOwnerVelocity;                                 // 0x0791(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_792[0x2];                                      // 0x0792(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AbilitySourceLevel;                                // 0x0794(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_798[0x8];                                      // 0x0798(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBuildingGameplayActorAbilityDeliveryInfo DeliverableAbilityInfo;                            // 0x07A0(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         bApplyDefaultEnabledAbilityBucketsOnInit : 1;      // 0x0820(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUseSimpleActorTouchSetupForAbilityBuckets : 1;    // 0x0820(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_821[0x7];                                      // 0x0821(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    RegisteredTouchComponent;                          // 0x0828(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_830[0x8];                                      // 0x0830(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UProjectileMovementComponent*           ProjectileMovementComponent;                       // 0x0838(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void DisableAbilityDeliveryInfo(const struct FGameplayTag& BucketTag);
	void EnableAbilityDeliveryInfo(const struct FGameplayTag& BucketTag);
	void K2_AddGameplayCue(const struct FGameplayTag& GameplayCueTag, const struct FGameplayEffectContextHandle& Context);
	void K2_ExecuteGameplayCue(const struct FGameplayTag& GameplayCueTag, const struct FGameplayEffectContextHandle& Context);
	void K2_ExecuteGameplayCueWithParams(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& GameplayCueParameters);
	void K2_RemoveGameplayCue(const struct FGameplayTag& GameplayCueTag);
	void OnRegisteredTouchComponentBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnRegisteredTouchComponentEndOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void SetAbilitySourceLevel(int32 NewAbilitySourceLevel);
	void SetIgnoreInstigatorCollision(bool bShouldIgnore);
	void SetInitialVelocity(const struct FVector& InitialVelocity);
	void SetTouchComponentForAbilityDeliveryInfo(class UPrimitiveComponent* PrimitiveComponent);

	struct FTransform GetTargetingSourceTransform(EFortAbilityTargetingSource Source) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingGameplayActor">();
	}
	static class ABuildingGameplayActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingGameplayActor>();
	}
};
static_assert(alignof(ABuildingGameplayActor) == 0x000010, "Wrong alignment on ABuildingGameplayActor");
static_assert(sizeof(ABuildingGameplayActor) == 0x000840, "Wrong size on ABuildingGameplayActor");
static_assert(offsetof(ABuildingGameplayActor, AbilitySet) == 0x000748, "Member 'ABuildingGameplayActor::AbilitySet' has a wrong offset!");
static_assert(offsetof(ABuildingGameplayActor, InherentAbilitySets) == 0x000750, "Member 'ABuildingGameplayActor::InherentAbilitySets' has a wrong offset!");
static_assert(offsetof(ABuildingGameplayActor, DamageSet) == 0x000778, "Member 'ABuildingGameplayActor::DamageSet' has a wrong offset!");
static_assert(offsetof(ABuildingGameplayActor, DamageStatHandle) == 0x000780, "Member 'ABuildingGameplayActor::DamageStatHandle' has a wrong offset!");
static_assert(offsetof(ABuildingGameplayActor, bIgnoreInstigatorCollision) == 0x000790, "Member 'ABuildingGameplayActor::bIgnoreInstigatorCollision' has a wrong offset!");
static_assert(offsetof(ABuildingGameplayActor, bAddOwnerVelocity) == 0x000791, "Member 'ABuildingGameplayActor::bAddOwnerVelocity' has a wrong offset!");
static_assert(offsetof(ABuildingGameplayActor, AbilitySourceLevel) == 0x000794, "Member 'ABuildingGameplayActor::AbilitySourceLevel' has a wrong offset!");
static_assert(offsetof(ABuildingGameplayActor, DeliverableAbilityInfo) == 0x0007A0, "Member 'ABuildingGameplayActor::DeliverableAbilityInfo' has a wrong offset!");
static_assert(offsetof(ABuildingGameplayActor, RegisteredTouchComponent) == 0x000828, "Member 'ABuildingGameplayActor::RegisteredTouchComponent' has a wrong offset!");
static_assert(offsetof(ABuildingGameplayActor, ProjectileMovementComponent) == 0x000838, "Member 'ABuildingGameplayActor::ProjectileMovementComponent' has a wrong offset!");

// Class FortniteGame.BuildingCapturePointActor
// 0x00A0 (0x08E0 - 0x0840)
class ABuildingCapturePointActor final : public ABuildingGameplayActor
{
public:
	uint8                                         bUseHUDIndicator : 1;                              // 0x0840(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_841[0x7];                                      // 0x0841(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   HUDStyle;                                          // 0x0848(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                HUDOffset;                                         // 0x0850(0x000C)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bHUDClampToScreenEdge : 1;                         // 0x085C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_85D[0xB];                                      // 0x085D(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       CollisionComponent;                                // 0x0868(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bActivated : 1;                                    // 0x0870(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnInstance, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_871[0x3];                                      // 0x0871(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EContentionRules                              ContentionRules;                                   // 0x0874(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_875[0x3];                                      // 0x0875(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EFortTeam>                             TeamsBarredFromCapture;                            // 0x0878(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         PercentIncreasePerPlayerCaptor;                    // 0x0888(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PercentIncreasePerAICaptor;                        // 0x088C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PercentDecreaseNoCaptor;                           // 0x0890(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bLocked : 1;                                       // 0x0894(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_895[0x3];                                      // 0x0895(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UnlockInterval;                                    // 0x0898(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUnlockRules                                  UnlockRules;                                       // 0x089C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_89D[0x3];                                      // 0x089D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumCapturingPoint;                                 // 0x08A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortTeam                                     TeamCapturingPoint;                                // 0x08A4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortTeam                                     TeamControllingPoint;                              // 0x08A5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortTeam                                     TeamOwningPoint;                                   // 0x08A6(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECaptureState                                 CaptureState;                                      // 0x08A7(0x0001)(Edit, Net, ZeroConstructor, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CapturePercentage;                                 // 0x08A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReplicatedCapturePercentage;                       // 0x08AC(0x0004)(Edit, Net, ZeroConstructor, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnCapturePointStateChanged;                        // 0x08B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnTeamOwningPointChanges;                          // 0x08C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_8D0[0x10];                                     // 0x08D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCapturePointActiveStateChange(bool bInActive);
	void OnCapturePointLockStateChange(bool bInLocked);
	void OnCapturePointStateChange(ECaptureState InState, EFortTeam InTeam);
	void OnEnterCapturePoint(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnLeaveCapturePoint(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnRep_bActivated();
	void OnRep_bLocked();
	void OnRep_CaptureState();
	void OnRep_ReplicatedCapturePercentage();
	void SetActivatedState(bool bInActivated);

	ECaptureState GetCaptureState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingCapturePointActor">();
	}
	static class ABuildingCapturePointActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingCapturePointActor>();
	}
};
static_assert(alignof(ABuildingCapturePointActor) == 0x000010, "Wrong alignment on ABuildingCapturePointActor");
static_assert(sizeof(ABuildingCapturePointActor) == 0x0008E0, "Wrong size on ABuildingCapturePointActor");
static_assert(offsetof(ABuildingCapturePointActor, HUDStyle) == 0x000848, "Member 'ABuildingCapturePointActor::HUDStyle' has a wrong offset!");
static_assert(offsetof(ABuildingCapturePointActor, HUDOffset) == 0x000850, "Member 'ABuildingCapturePointActor::HUDOffset' has a wrong offset!");
static_assert(offsetof(ABuildingCapturePointActor, CollisionComponent) == 0x000868, "Member 'ABuildingCapturePointActor::CollisionComponent' has a wrong offset!");
static_assert(offsetof(ABuildingCapturePointActor, ContentionRules) == 0x000874, "Member 'ABuildingCapturePointActor::ContentionRules' has a wrong offset!");
static_assert(offsetof(ABuildingCapturePointActor, TeamsBarredFromCapture) == 0x000878, "Member 'ABuildingCapturePointActor::TeamsBarredFromCapture' has a wrong offset!");
static_assert(offsetof(ABuildingCapturePointActor, PercentIncreasePerPlayerCaptor) == 0x000888, "Member 'ABuildingCapturePointActor::PercentIncreasePerPlayerCaptor' has a wrong offset!");
static_assert(offsetof(ABuildingCapturePointActor, PercentIncreasePerAICaptor) == 0x00088C, "Member 'ABuildingCapturePointActor::PercentIncreasePerAICaptor' has a wrong offset!");
static_assert(offsetof(ABuildingCapturePointActor, PercentDecreaseNoCaptor) == 0x000890, "Member 'ABuildingCapturePointActor::PercentDecreaseNoCaptor' has a wrong offset!");
static_assert(offsetof(ABuildingCapturePointActor, UnlockInterval) == 0x000898, "Member 'ABuildingCapturePointActor::UnlockInterval' has a wrong offset!");
static_assert(offsetof(ABuildingCapturePointActor, UnlockRules) == 0x00089C, "Member 'ABuildingCapturePointActor::UnlockRules' has a wrong offset!");
static_assert(offsetof(ABuildingCapturePointActor, NumCapturingPoint) == 0x0008A0, "Member 'ABuildingCapturePointActor::NumCapturingPoint' has a wrong offset!");
static_assert(offsetof(ABuildingCapturePointActor, TeamCapturingPoint) == 0x0008A4, "Member 'ABuildingCapturePointActor::TeamCapturingPoint' has a wrong offset!");
static_assert(offsetof(ABuildingCapturePointActor, TeamControllingPoint) == 0x0008A5, "Member 'ABuildingCapturePointActor::TeamControllingPoint' has a wrong offset!");
static_assert(offsetof(ABuildingCapturePointActor, TeamOwningPoint) == 0x0008A6, "Member 'ABuildingCapturePointActor::TeamOwningPoint' has a wrong offset!");
static_assert(offsetof(ABuildingCapturePointActor, CaptureState) == 0x0008A7, "Member 'ABuildingCapturePointActor::CaptureState' has a wrong offset!");
static_assert(offsetof(ABuildingCapturePointActor, CapturePercentage) == 0x0008A8, "Member 'ABuildingCapturePointActor::CapturePercentage' has a wrong offset!");
static_assert(offsetof(ABuildingCapturePointActor, ReplicatedCapturePercentage) == 0x0008AC, "Member 'ABuildingCapturePointActor::ReplicatedCapturePercentage' has a wrong offset!");
static_assert(offsetof(ABuildingCapturePointActor, OnCapturePointStateChanged) == 0x0008B0, "Member 'ABuildingCapturePointActor::OnCapturePointStateChanged' has a wrong offset!");
static_assert(offsetof(ABuildingCapturePointActor, OnTeamOwningPointChanges) == 0x0008C0, "Member 'ABuildingCapturePointActor::OnTeamOwningPointChanges' has a wrong offset!");

// Class FortniteGame.FortItemCategory
// 0x0030 (0x0058 - 0x0028)
class UFortItemCategory final : public UDataAsset
{
public:
	TArray<struct FItemCategoryMappingData>       PrimaryCategories;                                 // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FItemCategory>                  SecondaryCategories;                               // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FItemCategory>                  TertiaryCategories;                                // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortItemCategory">();
	}
	static class UFortItemCategory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortItemCategory>();
	}
};
static_assert(alignof(UFortItemCategory) == 0x000008, "Wrong alignment on UFortItemCategory");
static_assert(sizeof(UFortItemCategory) == 0x000058, "Wrong size on UFortItemCategory");
static_assert(offsetof(UFortItemCategory, PrimaryCategories) == 0x000028, "Member 'UFortItemCategory::PrimaryCategories' has a wrong offset!");
static_assert(offsetof(UFortItemCategory, SecondaryCategories) == 0x000038, "Member 'UFortItemCategory::SecondaryCategories' has a wrong offset!");
static_assert(offsetof(UFortItemCategory, TertiaryCategories) == 0x000048, "Member 'UFortItemCategory::TertiaryCategories' has a wrong offset!");

// Class FortniteGame.FortCarriedObjectHolderInterface
// 0x0000 (0x0028 - 0x0028)
class IFortCarriedObjectHolderInterface final : public IInterface
{
public:
	void OnCarriedObjectAttach(class AActor* AttachedObject);
	void OnCarriedObjectDetach(class AActor* DetachedObject);

	bool CanHoldObject(class AActor* CarriableObject) const;
	class USceneComponent* GetAttachmentComponent(class FName SocketName) const;
	void GetCarriedObjectAttachmentInfo(struct FCarriedObjectAttachmentInfo* OutAttachInfo) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCarriedObjectHolderInterface">();
	}
	static class IFortCarriedObjectHolderInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortCarriedObjectHolderInterface>();
	}
};
static_assert(alignof(IFortCarriedObjectHolderInterface) == 0x000008, "Wrong alignment on IFortCarriedObjectHolderInterface");
static_assert(sizeof(IFortCarriedObjectHolderInterface) == 0x000028, "Wrong size on IFortCarriedObjectHolderInterface");

// Class FortniteGame.BuildingFlagSpawn
// 0x0060 (0x08A0 - 0x0840)
class ABuildingFlagSpawn final : public ABuildingGameplayActor
{
public:
	uint8                                         Pad_840[0x8];                                      // 0x0840(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HUDIndicatorRelativeOffset;                        // 0x0848(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bPickupOnTouch;                                    // 0x0854(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_855[0x3];                                      // 0x0855(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AFortCarriedObject>         CarriedObjectClass;                                // 0x0858(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                RelativeTranslation;                               // 0x0860(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_86C[0x4];                                      // 0x086C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortCarriedObject*                     SpawnedObject;                                     // 0x0870(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpawnDelay;                                        // 0x0878(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_87C[0x24];                                     // 0x087C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCarriedObjectAttachedEvent();
	void OnCarriedObjectDetachedEvent();
	void SpawnCarriedObject();

	bool IsSpawnedObjectAwayFromBase() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingFlagSpawn">();
	}
	static class ABuildingFlagSpawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingFlagSpawn>();
	}
};
static_assert(alignof(ABuildingFlagSpawn) == 0x000010, "Wrong alignment on ABuildingFlagSpawn");
static_assert(sizeof(ABuildingFlagSpawn) == 0x0008A0, "Wrong size on ABuildingFlagSpawn");
static_assert(offsetof(ABuildingFlagSpawn, HUDIndicatorRelativeOffset) == 0x000848, "Member 'ABuildingFlagSpawn::HUDIndicatorRelativeOffset' has a wrong offset!");
static_assert(offsetof(ABuildingFlagSpawn, bPickupOnTouch) == 0x000854, "Member 'ABuildingFlagSpawn::bPickupOnTouch' has a wrong offset!");
static_assert(offsetof(ABuildingFlagSpawn, CarriedObjectClass) == 0x000858, "Member 'ABuildingFlagSpawn::CarriedObjectClass' has a wrong offset!");
static_assert(offsetof(ABuildingFlagSpawn, RelativeTranslation) == 0x000860, "Member 'ABuildingFlagSpawn::RelativeTranslation' has a wrong offset!");
static_assert(offsetof(ABuildingFlagSpawn, SpawnedObject) == 0x000870, "Member 'ABuildingFlagSpawn::SpawnedObject' has a wrong offset!");
static_assert(offsetof(ABuildingFlagSpawn, SpawnDelay) == 0x000878, "Member 'ABuildingFlagSpawn::SpawnDelay' has a wrong offset!");

// Class FortniteGame.FortItemTypeFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UFortItemTypeFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class FText ToText(EFortItemType ItemType, bool UsePlural);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortItemTypeFunctionLibrary">();
	}
	static class UFortItemTypeFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortItemTypeFunctionLibrary>();
	}
};
static_assert(alignof(UFortItemTypeFunctionLibrary) == 0x000008, "Wrong alignment on UFortItemTypeFunctionLibrary");
static_assert(sizeof(UFortItemTypeFunctionLibrary) == 0x000028, "Wrong size on UFortItemTypeFunctionLibrary");

// Class FortniteGame.FortQueryTest_BuildingCriteria
// 0x0300 (0x04D8 - 0x01D8)
class UFortQueryTest_BuildingCriteria final : public UFortQueryTest_GoalBase
{
public:
	struct FAIDataProviderFloatValue              ScoreForGroundSupportedFloor;                      // 0x01D8(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              ScoreForBeingGroundSupported;                      // 0x0208(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              ScoreForTraps;                                     // 0x0238(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              ScoreForWalls;                                     // 0x0268(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              ScoreForNavigableOpening;                          // 0x0298(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FFortAIAssignmentIdentifier            RootAssignmentID;                                  // 0x02C8(0x0030)(Edit, NativeAccessSpecifierPrivate)
	struct FAIDataProviderBoolValue               bPreferCloserToRootAssignment;                     // 0x02F8(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              ScoreForDistanceFromClosestRootAssignmentGoal;     // 0x0328(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              MinDistanceForDistanceScoring;                     // 0x0358(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              MaxDistanceForDistanceScoring;                     // 0x0388(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              MaxHealthScore;                                    // 0x03B8(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderBoolValue               bPreferHigherHealth;                               // 0x03E8(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              ClampMaxHealthValue;                               // 0x0418(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              ClampMinHealthValue;                               // 0x0448(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderBoolValue               bPreferHigherHealthPercentage;                     // 0x0478(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              MaxHealthPercentageScore;                          // 0x04A8(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_BuildingCriteria">();
	}
	static class UFortQueryTest_BuildingCriteria* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_BuildingCriteria>();
	}
};
static_assert(alignof(UFortQueryTest_BuildingCriteria) == 0x000008, "Wrong alignment on UFortQueryTest_BuildingCriteria");
static_assert(sizeof(UFortQueryTest_BuildingCriteria) == 0x0004D8, "Wrong size on UFortQueryTest_BuildingCriteria");
static_assert(offsetof(UFortQueryTest_BuildingCriteria, ScoreForGroundSupportedFloor) == 0x0001D8, "Member 'UFortQueryTest_BuildingCriteria::ScoreForGroundSupportedFloor' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_BuildingCriteria, ScoreForBeingGroundSupported) == 0x000208, "Member 'UFortQueryTest_BuildingCriteria::ScoreForBeingGroundSupported' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_BuildingCriteria, ScoreForTraps) == 0x000238, "Member 'UFortQueryTest_BuildingCriteria::ScoreForTraps' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_BuildingCriteria, ScoreForWalls) == 0x000268, "Member 'UFortQueryTest_BuildingCriteria::ScoreForWalls' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_BuildingCriteria, ScoreForNavigableOpening) == 0x000298, "Member 'UFortQueryTest_BuildingCriteria::ScoreForNavigableOpening' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_BuildingCriteria, RootAssignmentID) == 0x0002C8, "Member 'UFortQueryTest_BuildingCriteria::RootAssignmentID' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_BuildingCriteria, bPreferCloserToRootAssignment) == 0x0002F8, "Member 'UFortQueryTest_BuildingCriteria::bPreferCloserToRootAssignment' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_BuildingCriteria, ScoreForDistanceFromClosestRootAssignmentGoal) == 0x000328, "Member 'UFortQueryTest_BuildingCriteria::ScoreForDistanceFromClosestRootAssignmentGoal' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_BuildingCriteria, MinDistanceForDistanceScoring) == 0x000358, "Member 'UFortQueryTest_BuildingCriteria::MinDistanceForDistanceScoring' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_BuildingCriteria, MaxDistanceForDistanceScoring) == 0x000388, "Member 'UFortQueryTest_BuildingCriteria::MaxDistanceForDistanceScoring' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_BuildingCriteria, MaxHealthScore) == 0x0003B8, "Member 'UFortQueryTest_BuildingCriteria::MaxHealthScore' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_BuildingCriteria, bPreferHigherHealth) == 0x0003E8, "Member 'UFortQueryTest_BuildingCriteria::bPreferHigherHealth' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_BuildingCriteria, ClampMaxHealthValue) == 0x000418, "Member 'UFortQueryTest_BuildingCriteria::ClampMaxHealthValue' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_BuildingCriteria, ClampMinHealthValue) == 0x000448, "Member 'UFortQueryTest_BuildingCriteria::ClampMinHealthValue' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_BuildingCriteria, bPreferHigherHealthPercentage) == 0x000478, "Member 'UFortQueryTest_BuildingCriteria::bPreferHigherHealthPercentage' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_BuildingCriteria, MaxHealthPercentageScore) == 0x0004A8, "Member 'UFortQueryTest_BuildingCriteria::MaxHealthPercentageScore' has a wrong offset!");

// Class FortniteGame.FortAccountItemDefinition
// 0x0050 (0x0270 - 0x0220)
class UFortAccountItemDefinition : public UFortItemDefinition
{
public:
	struct FCurveTableRowHandle                   LevelToXpHandle;                                   // 0x0220(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   LevelToSacrificeXpHandle;                          // 0x0230(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FDataTableRowHandle                    SacrificeRecipe;                                   // 0x0240(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FDataTableRowHandle                    TransmogSacrificeRow;                              // 0x0250(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FDataTableRowHandle>            ConversionRecipes;                                 // 0x0260(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	TArray<struct FFortItemQuantityPair> GetRecyclingRefunds() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAccountItemDefinition">();
	}
	static class UFortAccountItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAccountItemDefinition>();
	}
};
static_assert(alignof(UFortAccountItemDefinition) == 0x000010, "Wrong alignment on UFortAccountItemDefinition");
static_assert(sizeof(UFortAccountItemDefinition) == 0x000270, "Wrong size on UFortAccountItemDefinition");
static_assert(offsetof(UFortAccountItemDefinition, LevelToXpHandle) == 0x000220, "Member 'UFortAccountItemDefinition::LevelToXpHandle' has a wrong offset!");
static_assert(offsetof(UFortAccountItemDefinition, LevelToSacrificeXpHandle) == 0x000230, "Member 'UFortAccountItemDefinition::LevelToSacrificeXpHandle' has a wrong offset!");
static_assert(offsetof(UFortAccountItemDefinition, SacrificeRecipe) == 0x000240, "Member 'UFortAccountItemDefinition::SacrificeRecipe' has a wrong offset!");
static_assert(offsetof(UFortAccountItemDefinition, TransmogSacrificeRow) == 0x000250, "Member 'UFortAccountItemDefinition::TransmogSacrificeRow' has a wrong offset!");
static_assert(offsetof(UFortAccountItemDefinition, ConversionRecipes) == 0x000260, "Member 'UFortAccountItemDefinition::ConversionRecipes' has a wrong offset!");

// Class FortniteGame.FortExpeditionItemDefinition
// 0x0040 (0x02B0 - 0x0270)
class UFortExpeditionItemDefinition final : public UFortAccountItemDefinition
{
public:
	class FString                                 CriteriaRequirementsLootTier;                      // 0x0270(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExpeditionDuration_Minutes;                        // 0x0280(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExpeditionExpirationDuration_Minutes;              // 0x0284(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         BaseTargetPowerRating;                             // 0x0288(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TierFactor;                                        // 0x028C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxTargetPowerClamp;                               // 0x0290(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_294[0x4];                                      // 0x0294(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    ExpeditionRules;                                   // 0x0298(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A8[0x8];                                      // 0x02A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetAllRewards(TArray<class UFortCardPackItemDefinition*>* OutRewards);

	void GetExpeditionCosts(TArray<struct FItemAndCount>* OutExpeditionCosts) const;
	struct FGameplayTagContainer GetRequiredTags() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortExpeditionItemDefinition">();
	}
	static class UFortExpeditionItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortExpeditionItemDefinition>();
	}
};
static_assert(alignof(UFortExpeditionItemDefinition) == 0x000010, "Wrong alignment on UFortExpeditionItemDefinition");
static_assert(sizeof(UFortExpeditionItemDefinition) == 0x0002B0, "Wrong size on UFortExpeditionItemDefinition");
static_assert(offsetof(UFortExpeditionItemDefinition, CriteriaRequirementsLootTier) == 0x000270, "Member 'UFortExpeditionItemDefinition::CriteriaRequirementsLootTier' has a wrong offset!");
static_assert(offsetof(UFortExpeditionItemDefinition, ExpeditionDuration_Minutes) == 0x000280, "Member 'UFortExpeditionItemDefinition::ExpeditionDuration_Minutes' has a wrong offset!");
static_assert(offsetof(UFortExpeditionItemDefinition, ExpeditionExpirationDuration_Minutes) == 0x000284, "Member 'UFortExpeditionItemDefinition::ExpeditionExpirationDuration_Minutes' has a wrong offset!");
static_assert(offsetof(UFortExpeditionItemDefinition, BaseTargetPowerRating) == 0x000288, "Member 'UFortExpeditionItemDefinition::BaseTargetPowerRating' has a wrong offset!");
static_assert(offsetof(UFortExpeditionItemDefinition, TierFactor) == 0x00028C, "Member 'UFortExpeditionItemDefinition::TierFactor' has a wrong offset!");
static_assert(offsetof(UFortExpeditionItemDefinition, MaxTargetPowerClamp) == 0x000290, "Member 'UFortExpeditionItemDefinition::MaxTargetPowerClamp' has a wrong offset!");
static_assert(offsetof(UFortExpeditionItemDefinition, ExpeditionRules) == 0x000298, "Member 'UFortExpeditionItemDefinition::ExpeditionRules' has a wrong offset!");

// Class FortniteGame.FortGenericRecord
// 0x00A8 (0x00D0 - 0x0028)
class UFortGenericRecord : public UObject
{
public:
	uint8                                         Pad_28[0xA8];                                      // 0x0028(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGenericRecord">();
	}
	static class UFortGenericRecord* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGenericRecord>();
	}
};
static_assert(alignof(UFortGenericRecord) == 0x000008, "Wrong alignment on UFortGenericRecord");
static_assert(sizeof(UFortGenericRecord) == 0x0000D0, "Wrong size on UFortGenericRecord");

// Class FortniteGame.FortConsumableAccountItemDefinition
// 0x0010 (0x0280 - 0x0270)
#pragma pack(push, 0x1)
class alignas(0x10) UFortConsumableAccountItemDefinition : public UFortAccountItemDefinition
{
public:
	bool                                          bCanActivateOnSelf;                                // 0x0270(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanActivateOnOthers;                              // 0x0271(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAutomaticallyConsumed;                          // 0x0272(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_273[0x5];                                      // 0x0273(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortConsumableAccountItemDefinition">();
	}
	static class UFortConsumableAccountItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortConsumableAccountItemDefinition>();
	}
};
#pragma pack(pop)
static_assert(alignof(UFortConsumableAccountItemDefinition) == 0x000010, "Wrong alignment on UFortConsumableAccountItemDefinition");
static_assert(sizeof(UFortConsumableAccountItemDefinition) == 0x000280, "Wrong size on UFortConsumableAccountItemDefinition");
static_assert(offsetof(UFortConsumableAccountItemDefinition, bCanActivateOnSelf) == 0x000270, "Member 'UFortConsumableAccountItemDefinition::bCanActivateOnSelf' has a wrong offset!");
static_assert(offsetof(UFortConsumableAccountItemDefinition, bCanActivateOnOthers) == 0x000271, "Member 'UFortConsumableAccountItemDefinition::bCanActivateOnOthers' has a wrong offset!");
static_assert(offsetof(UFortConsumableAccountItemDefinition, bIsAutomaticallyConsumed) == 0x000272, "Member 'UFortConsumableAccountItemDefinition::bIsAutomaticallyConsumed' has a wrong offset!");

// Class FortniteGame.FortAccountBuffCreditItemDefinition
// 0x0020 (0x02A0 - 0x0280)
class UFortAccountBuffCreditItemDefinition final : public UFortConsumableAccountItemDefinition
{
public:
	TSoftObjectPtr<class UFortAccountBuffItemDefinition> BuffToGrant;                                       // 0x0278(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinutesOfBuffTimeToGrant;                          // 0x0298(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29C[0x4];                                      // 0x029C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAccountBuffCreditItemDefinition">();
	}
	static class UFortAccountBuffCreditItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAccountBuffCreditItemDefinition>();
	}
};
static_assert(alignof(UFortAccountBuffCreditItemDefinition) == 0x000010, "Wrong alignment on UFortAccountBuffCreditItemDefinition");
static_assert(sizeof(UFortAccountBuffCreditItemDefinition) == 0x0002A0, "Wrong size on UFortAccountBuffCreditItemDefinition");
static_assert(offsetof(UFortAccountBuffCreditItemDefinition, BuffToGrant) == 0x000278, "Member 'UFortAccountBuffCreditItemDefinition::BuffToGrant' has a wrong offset!");
static_assert(offsetof(UFortAccountBuffCreditItemDefinition, MinutesOfBuffTimeToGrant) == 0x000298, "Member 'UFortAccountBuffCreditItemDefinition::MinutesOfBuffTimeToGrant' has a wrong offset!");

// Class FortniteGame.FortTooltipInterface
// 0x0000 (0x0028 - 0x0028)
class IFortTooltipInterface final : public IInterface
{
public:
	class UFortTooltipDisplayStatsList* GetDisplayStats() const;
	TSubclassOf<class UFortTooltip> GetTooltip() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTooltipInterface">();
	}
	static class IFortTooltipInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortTooltipInterface>();
	}
};
static_assert(alignof(IFortTooltipInterface) == 0x000008, "Wrong alignment on IFortTooltipInterface");
static_assert(sizeof(IFortTooltipInterface) == 0x000028, "Wrong size on IFortTooltipInterface");

// Class FortniteGame.FortOutpostFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UFortOutpostFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ActivateCraftingTable(class AFortPlayerControllerOutpost* FortPC);
	static bool CanActivateCraftingTable(class AFortPlayerControllerOutpost* FortPC);
	static int32 CountOverflowFromAddingItem(class AFortPlayerControllerOutpost* Player, class UFortWorldItem* Item, int32 Count);
	static void DeactivateCraftingTable(class AFortPlayerControllerOutpost* FortPC);
	static bool DeployOutpostBuildingTagOnPlacementTag(class UObject* WorldContextObject, const struct FGameplayTag& BuildingTag, const struct FGameplayTag& PlacementTag);
	static void FabricateItem(class AFortPlayerControllerOutpost* FortPC, class UFortWorldItemDefinition* ItemDef);
	static void FabricatorAbortDisintegration(class AFortPlayerControllerOutpost* FortPC);
	static int32 FabricatorCanDisintegrateItem(class AFortPlayerControllerOutpost* FortPC, class UFortWorldItem* Item, int32 Count);
	static void FabricatorDisintegrateItem(class AFortPlayerControllerOutpost* FortPC, class UFortWorldItem* Item, int32 Count);
	static bool FabricatorIsDisintegrating(class AFortPlayerControllerOutpost* FortPC);
	static void GetCraftingTableActivationCost(class AFortPlayerControllerOutpost* FortPC, TArray<struct FFortItemQuantityPair>* OutWorldItems);
	static int32 GetCraftingTableActivationItemCount(class AFortPlayerControllerOutpost* FortPC);
	static int32 GetFabricatorDisintegrationDurationInSeconds(class AFortPlayerControllerOutpost* FortPC);
	static int32 GetFabricatorDisintegrationMinutesRemaining(class AFortPlayerControllerOutpost* FortPC);
	static int32 GetFabricatorDisintegrationSecondsRemaining(class AFortPlayerControllerOutpost* FortPC);
	static struct FDateTime GetFabricatorDisintegrationStartTime(class AFortPlayerControllerOutpost* FortPC);
	static int32 GetFabricatorIncomingGooAmount(class AFortPlayerControllerOutpost* FortPC);
	static int32 GetFabricatorIncomingGooAmountProgress(class AFortPlayerControllerOutpost* FortPC);
	static int32 GetFabricatorItemDisintegrationDurationInSeconds(class UFortWorldItem* Item, int32 Count);
	static int32 GetFabricatorMaxGooCapacity(class AFortPlayerControllerOutpost* FortPC);
	static TArray<class UFortItem*> GetFabricatorPlayerItems(class AFortPlayerControllerOutpost* FortPC, EFortInventoryFilter InventoryFilter, const class FString& SearchFilter);
	static TArray<class UFortItem*> GetFabricatorRecipes(class AFortPlayerControllerOutpost* FortPC, EFortInventoryFilter InventoryFilter, const class FString& SearchFilter);
	static int32 GetFabricatorStoredGooAmount(class AFortPlayerControllerOutpost* FortPC);
	static int32 GetGooFromDisintegrationOfItem(const class UFortWorldItem* Item);
	static int32 GetGooRequiredToFabricateItem(const class UFortWorldItem* Item);
	static int32 GetNumberOfCraftingTableItemsRemaining(class AFortPlayerControllerOutpost* FortPC);
	static class UFortOutpostItemDefinition* GetOutpostBuildingItemDefinition(class UObject* WorldContextObject, EOutpostBuildings Building);
	static struct FGameplayTag GetOutpostBuildingTagFromPlacementTag(class UObject* WorldContextObject, const struct FGameplayTag& PlacementTag);
	static class AFortPlayerControllerOutpost* GetOutpostOwner(class UObject* WorldContextObject);
	static class UFortMissionConfigData* GetOutpostQuestMissionConfigData(class UObject* WorldContextObject, const struct FGameplayTag& ConfigTag);
	static struct FGameplayTag GetPlacementTagFromOutpostBuildingTag(class UObject* WorldContextObject, const struct FGameplayTag& BuildingTag);
	static int32 GetStorageVaultCapacity(class AFortPlayerControllerOutpost* Player);
	static int32 GetStorageVaultNumItems(class AFortPlayerControllerOutpost* Player);
	static TArray<class UFortItem*> GetStorageVaultPlayerItems(class AFortPlayerControllerOutpost* Player, EFortInventoryFilter InventoryFilter, const class FString& SearchFilter);
	static TArray<class UFortItem*> GetStorageVaultStoredItems(class AFortPlayerControllerOutpost* Player, EFortInventoryFilter InventoryFilter, const class FString& SearchFilter);
	static bool IsCraftingTableActive(class AFortPlayerControllerOutpost* FortPC);
	static void SetCriticalMissionJoinability(class UObject* WorldContextObject, bool bJoinable);
	static void SetOutpostDefenseActive(class UObject* WorldContextObject, bool bActive);
	static void SetOutpostGameDifficultyRow(class UObject* WorldContextObject, const struct FDataTableRowHandle& GameDifficultyInfo);
	static void StorageVaultStoreItem(class AFortPlayerControllerOutpost* Player, class UFortWorldItem* Item, int32 Count);
	static void StorageVaultWithdrawItem(class AFortPlayerControllerOutpost* Player, class UFortWorldItem* Item, int32 Count);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortOutpostFunctionLibrary">();
	}
	static class UFortOutpostFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortOutpostFunctionLibrary>();
	}
};
static_assert(alignof(UFortOutpostFunctionLibrary) == 0x000008, "Wrong alignment on UFortOutpostFunctionLibrary");
static_assert(sizeof(UFortOutpostFunctionLibrary) == 0x000028, "Wrong size on UFortOutpostFunctionLibrary");

// Class FortniteGame.FortTooltipContext
// 0x0040 (0x0068 - 0x0028)
class UFortTooltipContext : public UObject
{
public:
	class UAbilitySystemComponent*                SourceAbilitySystem;                               // 0x0028(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilitySystemComponent*                DestAbilitySystem;                                 // 0x0030(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TreatAsLevel;                                      // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  TagContainer;                                      // 0x0040(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UObject*                                ComparisonObject;                                  // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UFortTooltipContext* SpawnTooltipContext();
	static class UFortTooltipContext* SpawnTooltipContextWithNetID(class UObject* WorldContextObject, const struct FUniqueNetIdRepl& UniqueId);
	static class UFortTooltipContext* SpawnTooltipContextWithSource(class APlayerController* SourcePlayerController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTooltipContext">();
	}
	static class UFortTooltipContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortTooltipContext>();
	}
};
static_assert(alignof(UFortTooltipContext) == 0x000008, "Wrong alignment on UFortTooltipContext");
static_assert(sizeof(UFortTooltipContext) == 0x000068, "Wrong size on UFortTooltipContext");
static_assert(offsetof(UFortTooltipContext, SourceAbilitySystem) == 0x000028, "Member 'UFortTooltipContext::SourceAbilitySystem' has a wrong offset!");
static_assert(offsetof(UFortTooltipContext, DestAbilitySystem) == 0x000030, "Member 'UFortTooltipContext::DestAbilitySystem' has a wrong offset!");
static_assert(offsetof(UFortTooltipContext, TreatAsLevel) == 0x000038, "Member 'UFortTooltipContext::TreatAsLevel' has a wrong offset!");
static_assert(offsetof(UFortTooltipContext, TagContainer) == 0x000040, "Member 'UFortTooltipContext::TagContainer' has a wrong offset!");
static_assert(offsetof(UFortTooltipContext, ComparisonObject) == 0x000060, "Member 'UFortTooltipContext::ComparisonObject' has a wrong offset!");

// Class FortniteGame.FortTooltipMap
// 0x0060 (0x0088 - 0x0028)
class UFortTooltipMap final : public UDataAsset
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFortTooltipMapEntry>           Mapping;                                           // 0x0078(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTooltipMap">();
	}
	static class UFortTooltipMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortTooltipMap>();
	}
};
static_assert(alignof(UFortTooltipMap) == 0x000008, "Wrong alignment on UFortTooltipMap");
static_assert(sizeof(UFortTooltipMap) == 0x000088, "Wrong size on UFortTooltipMap");
static_assert(offsetof(UFortTooltipMap, Mapping) == 0x000078, "Member 'UFortTooltipMap::Mapping' has a wrong offset!");

// Class FortniteGame.FortBTDecorator_IsTakerAirborne
// 0x0000 (0x0068 - 0x0068)
class UFortBTDecorator_IsTakerAirborne final : public UBTDecorator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTDecorator_IsTakerAirborne">();
	}
	static class UFortBTDecorator_IsTakerAirborne* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTDecorator_IsTakerAirborne>();
	}
};
static_assert(alignof(UFortBTDecorator_IsTakerAirborne) == 0x000008, "Wrong alignment on UFortBTDecorator_IsTakerAirborne");
static_assert(sizeof(UFortBTDecorator_IsTakerAirborne) == 0x000068, "Wrong size on UFortBTDecorator_IsTakerAirborne");

// Class FortniteGame.FortStaticMeshLinkComponent
// 0x0020 (0x0140 - 0x0120)
class UFortStaticMeshLinkComponent final : public UNavRelevantComponent
{
public:
	uint8                                         Pad_120[0x20];                                     // 0x0120(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortStaticMeshLinkComponent">();
	}
	static class UFortStaticMeshLinkComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortStaticMeshLinkComponent>();
	}
};
static_assert(alignof(UFortStaticMeshLinkComponent) == 0x000008, "Wrong alignment on UFortStaticMeshLinkComponent");
static_assert(sizeof(UFortStaticMeshLinkComponent) == 0x000140, "Wrong size on UFortStaticMeshLinkComponent");

// Class FortniteGame.FortTooltipManager
// 0x0058 (0x0080 - 0x0028)
class UFortTooltipManager final : public UObject
{
public:
	TMap<class UClass*, class UFortTooltip*>      Tooltips;                                          // 0x0028(0x0050)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class AActor*                                 DamageRecieverProxy;                               // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTooltipManager">();
	}
	static class UFortTooltipManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortTooltipManager>();
	}
};
static_assert(alignof(UFortTooltipManager) == 0x000008, "Wrong alignment on UFortTooltipManager");
static_assert(sizeof(UFortTooltipManager) == 0x000080, "Wrong size on UFortTooltipManager");
static_assert(offsetof(UFortTooltipManager, Tooltips) == 0x000028, "Member 'UFortTooltipManager::Tooltips' has a wrong offset!");
static_assert(offsetof(UFortTooltipManager, DamageRecieverProxy) == 0x000078, "Member 'UFortTooltipManager::DamageRecieverProxy' has a wrong offset!");

// Class FortniteGame.FortTooltip
// 0x0068 (0x0090 - 0x0028)
class UFortTooltip : public UObject
{
public:
	class FText                                   Description;                                       // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x50];                                      // 0x0040(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetLocalizationFloat(const class FString& Name_0, float Value);
	void SetLocalizationInt(const class FString& Name_0, int32 Value);
	void SetLocalizationText(const class FString& Name_0, const class FText& Value);

	bool BP_GetNumericValue(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, float* OutVal) const;
	bool BP_GetTextForToken(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, class FText* OutText) const;
	bool BP_GetTokenizedDescriptionText(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, TArray<class FText>* OutDescription) const;
	bool BP_GetValueData(const class UObject* ObjectToDescribe, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, struct FFortTooltipValueData* OutData) const;
	bool GetNumericValue(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, float* OutVal) const;
	bool GetTextForToken(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, class FText* OutText) const;
	bool GetTokenizedDescriptionText(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, TArray<class FText>* OutDescription) const;
	bool GetValueData(const class UObject* ObjectToDescribe, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, struct FFortTooltipValueData* OutData) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTooltip">();
	}
	static class UFortTooltip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortTooltip>();
	}
};
static_assert(alignof(UFortTooltip) == 0x000008, "Wrong alignment on UFortTooltip");
static_assert(sizeof(UFortTooltip) == 0x000090, "Wrong size on UFortTooltip");
static_assert(offsetof(UFortTooltip, Description) == 0x000028, "Member 'UFortTooltip::Description' has a wrong offset!");

// Class FortniteGame.FortMissionState
// 0x0030 (0x03B8 - 0x0388)
class AFortMissionState : public AActor
{
public:
	uint8                                         Pad_388[0x8];                                      // 0x0388(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnUpdateUI;                                        // 0x0390(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMissionUIEvent;                                  // 0x03A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bAlreadySetTimerOnce;                              // 0x03B0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAlreadyCalledOnAllPlayersLoadedIn;                // 0x03B1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B2[0x2];                                      // 0x03B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimerForOnAllPlayersLoadedIn;                      // 0x03B4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnAllPlayersLoadedIn();
	void OnAllPlayersLoadedInWrapper();
	void OnMatchStarted();
	void OnWorldReady();
	void SendMissionUIEvent(const struct FGameplayTagContainer& EventTags);
	void SetTimerForOnAllPlayersLoadedIn(float Timer);
	void UpdateUI();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMissionState">();
	}
	static class AFortMissionState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortMissionState>();
	}
};
static_assert(alignof(AFortMissionState) == 0x000008, "Wrong alignment on AFortMissionState");
static_assert(sizeof(AFortMissionState) == 0x0003B8, "Wrong size on AFortMissionState");
static_assert(offsetof(AFortMissionState, OnUpdateUI) == 0x000390, "Member 'AFortMissionState::OnUpdateUI' has a wrong offset!");
static_assert(offsetof(AFortMissionState, OnMissionUIEvent) == 0x0003A0, "Member 'AFortMissionState::OnMissionUIEvent' has a wrong offset!");
static_assert(offsetof(AFortMissionState, bAlreadySetTimerOnce) == 0x0003B0, "Member 'AFortMissionState::bAlreadySetTimerOnce' has a wrong offset!");
static_assert(offsetof(AFortMissionState, bAlreadyCalledOnAllPlayersLoadedIn) == 0x0003B1, "Member 'AFortMissionState::bAlreadyCalledOnAllPlayersLoadedIn' has a wrong offset!");
static_assert(offsetof(AFortMissionState, TimerForOnAllPlayersLoadedIn) == 0x0003B4, "Member 'AFortMissionState::TimerForOnAllPlayersLoadedIn' has a wrong offset!");

// Class FortniteGame.FortMission
// 0x0320 (0x06D8 - 0x03B8)
class AFortMission : public AFortMissionState
{
public:
	uint8                                         Pad_3B8[0x10];                                     // 0x03B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortMissionInfo*                       MissionInfo;                                       // 0x03C8(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UClass*>                         MissionEnemyClasses;                               // 0x03D0(0x0010)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UFortBotMissionLogic>       BotLogicClass;                                     // 0x03E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortBotMissionLogic*                   BotLogic;                                          // 0x03E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortMissionGenerator*                  MissionGenerator;                                  // 0x03F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMissionGenerationCategory                    MissionCategory;                                   // 0x03F8(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F9[0x3];                                      // 0x03F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UIIndex;                                           // 0x03FC(0x0004)(Net, ZeroConstructor, SaveGame, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUniqueNetIdRepl                       QuestOwnerAccount;                                 // 0x0400(0x0018)(Net, SaveGame, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFortMissionEventName>          MissionEventNames;                                 // 0x0418(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, AssetRegistrySearchable, AdvancedDisplay, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnObjectivesUpdated;                               // 0x0428(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FFortMissionPlacementActorPreferredTagInfo> PlacementActorPreferredTagData;                    // 0x0438(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bLoadedFromRecord;                                 // 0x0448(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFiredParTimeEvent;                                // 0x0449(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_44A[0x2];                                      // 0x044A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MissionActivationTime;                             // 0x044C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFortMissionFocusDisplayData           CurrentFocusData;                                  // 0x0450(0x0020)(Net, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	bool                                          bSilentDestroyNextFrame;                           // 0x0470(0x0001)(Net, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_471[0x7];                                      // 0x0471(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AFortObjectiveBase*>             ActiveObjectives;                                  // 0x0478(0x0010)(Net, ZeroConstructor, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	TArray<struct FUniqueNetIdRepl>               ParticipatingAccounts;                             // 0x0488(0x0010)(Net, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FUniqueNetIdRepl>               ParticipatingButDisconnectedAccounts;              // 0x0498(0x0010)(Net, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	EFortMissionStatus                            MissionStatus;                                     // 0x04A8(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, SaveGame, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A9[0x7];                                      // 0x04A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  MissionCompletionTags;                             // 0x04B0(0x0020)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsMissionVisible;                                 // 0x04D0(0x0001)(Net, ZeroConstructor, SaveGame, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortMissionAudibility                        MissionAudibility;                                 // 0x04D1(0x0001)(Net, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D2[0x2];                                      // 0x04D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentObjectiveBlockIndex;                        // 0x04D4(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsMissionVisibleOverride;                         // 0x04D8(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D9[0x3];                                      // 0x04D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  MissionGuid;                                       // 0x04DC(0x0010)(Net, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         StartingDay;                                       // 0x04EC(0x0004)(Net, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortMissionTimerComponent*             TimerComponent;                                    // 0x04F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4F8[0x4];                                      // 0x04F8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ChosenRewardIdx;                                   // 0x04FC(0x0004)(Net, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFortBadgeCountArray                   PotentialBadgesArray;                              // 0x0500(0x00C0)(Net, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C0[0xB8];                                     // 0x05C0(0x00B8)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortGeneratedDifficultyOptions        GeneratedMissionOptions;                           // 0x0678(0x0040)(Protected, NativeAccessSpecifierProtected)
	struct FFortMissionInstancedConfigData        ConfigData;                                        // 0x06B8(0x0010)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6C8[0x10];                                     // 0x06C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static TArray<class AActor*> SpawnAtPlacementActorsAsArray(class AFortMission* Mission, bool* bSucceeded);

	void AddCompletionTag(const struct FGameplayTag& NewCompletionTag);
	void AddCompletionTags(const struct FGameplayTagContainer& NewCompletionTagContainer);
	void AddGoalsToAssignment(class UFortAIAssignment* Assignment, const TArray<struct FFortAIGoalInfo>& GoalInfos);
	void AddGoalsToEncounterAssignment(const struct FFortAIAssignmentIdentifier& AssignmentIdentifier, const class UFortAIEncounterInfo*& Encounter, const TArray<struct FFortAIGoalInfo>& GoalInfos);
	void AddGoalToAssignment(class UFortAIAssignment* Assignment, const struct FFortAIGoalInfo& GoalInfo);
	void AddGoalToEncounterAssignment(const struct FFortAIAssignmentIdentifier& AssignmentIdentifier, const class UFortAIEncounterInfo*& Encounter, const struct FFortAIGoalInfo& GoalInfo);
	bool AddParticipantAccount(class AFortPlayerController* PlayerController);
	void AttemptMissionSave(const class FString& OptionalSaveName);
	void BlueprintCustomHandleMissionEvent(const struct FGuid& MissionGuid_0, const struct FGameplayTagContainer& ObjectiveHandle, class UFortMissionEventParams* Params_0, bool DO_NOT_USE_THIS_OR_VARIABLES_BELOW, class UObject* EventFocus, const class UDataAsset* EventContent, class AActor* EventInstigator, int32 GenericInt, float GenericFloat, const class FText& GenericText, const struct FGameplayTagContainer& GameplayTags, const struct FFortMissionEvent& MissionEvent);
	void BlueprintOnActivated();
	void BlueprintOnMissionEnd(EFortMissionStatus Status);
	void BlueprintOnStartPlaying();
	void BlueprintPostMissionLoad();
	struct FFortMissionWeightedReward ChooseRandomReward();
	EAssignmentCreationResult CreateEncounterAssignment(const struct FGameplayTagContainer& AssignmentTags, const class UFortAIEncounterInfo*& Encounter, class UFortAIAssignmentSettings* AssignmentSettings, TSubclassOf<class UFortAIGoalProvider> GoalProvider, struct FFortAIAssignmentIdentifier* AssignmentIdentifier);
	class UFortAIEncounterSequence* CreateEncounterSequence(const struct FGameplayTagContainer& SequenceTags);
	void FindGoalLocationsForEncounterAssignment(const struct FFortAIAssignmentIdentifier& AssignmentIdentifier, const class UFortAIEncounterInfo*& Encounter, TArray<struct FVector>* OutGoalLocations);
	void FocusThisMission(const class FText& FocusDisplayText, float FocusPercentage);
	class UFortMissionConfigData* GetConfigData(const struct FGameplayTag& InBucketTag);
	void GetRewardItemsByTag(const struct FGameplayTag& RewardTag, TArray<class UFortWorldItemDefinition*>* OutRewardItems);
	void GrantRewardsByTag(const struct FGameplayTag& RewardTag, EFortRewardType RewardType);
	bool InitializeActorsForMission(class AFortMission* Mission, TArray<class AActor*>* OutActorsInitialized);
	bool InitializeActorsForMissionMatchingItemIdentifyingQuery(class AFortMission* Mission, const struct FGameplayTagQuery& TagQuery, TArray<class AActor*>* OutActorsInitialized);
	void OnRep_ActiveObjectives();
	void OnRep_bIsMissionVisible();
	void OnRep_CurrentFocusDisplayData();
	void OnRep_MissionStatus();
	void OnRep_PotentialBadgesArray();
	void OnRep_QuestOwnerAccount();
	void OnRep_UIIndex();
	void OnWaveCompleted(int32 Tier, int32 Wave, EFortCompletionResult Result);
	void ProvideAllPotentialBadges(const TArray<struct FGameplayTag>& BadgeTags);
	void RecordResourceActorSpawn(class AActor* SpawnedActor);
	void RemoveGoalFromEncounterAssignment(const struct FFortAIAssignmentIdentifier& AssignmentIdentifier, const class UFortAIEncounterInfo*& Encounter, const struct FFortAIGoalInfo& GoalInfo);
	void RemoveGoalsFromEncounterAssignment(const struct FFortAIAssignmentIdentifier& AssignmentIdentifier, const class UFortAIEncounterInfo*& Encounter, const TArray<struct FFortAIGoalInfo>& GoalInfos);
	bool RemoveParticipantAccount(struct FUniqueNetIdRepl* AbandoningPlayerId);
	void SendBotLogicMessage(const class FString& EventName);
	void SetToSilentDestroy();
	void SetUiVisibility(bool bInIsMissionVisible);
	class UFortAIEncounterInfo* StartMissionAIEncounter(TSubclassOf<class UFortAIEncounterInfo> EncounterTemplate, const TArray<class AActor*>& TargetActors, class UFortAIAssignmentSettings* AssignmentSettings, const struct FEncounterEnvironmentQueryInfo& EnvironmentQueryInfo, class AActor* QueryActor, const struct FGameplayTagContainer& InjectedTags, const struct FFortEncounterSettings& EncounterSettings, int32 ActivationDelay);
	class UFortAIEncounterInfo* StartMissionAIEncounterFromGeneratedProfile(int32 GeneratedEncounterProfileIndex, const TArray<class AActor*>& TargetActors, class UFortAIAssignmentSettings* AssignmentSettings, const struct FEncounterEnvironmentQueryInfo& EnvironmentQueryInfo, class AActor* QueryActor, const struct FGameplayTagContainer& InjectedTags, const struct FFortEncounterSettings& EncounterSettings, int32 ActivationDelay, bool bUseAssignments);
	void StopEncounterSequence(class UFortAIEncounterSequence* SequenceToStop);
	void StopMissionAIEncounter(class UFortAIEncounterInfo* EncounterToStop);

	bool BlueprintCanPlayerParticipate(class AFortPlayerController* PlayerController) const;
	bool GetActorsSpawnedMatchingQuery(const struct FGameplayTagQuery& TagQuery, TArray<class AActor*>* SpawnedActors) const;
	int32 GetAdditionalMissionCompletionMissionPoints(EFortMissionStatus CompletionStatus) const;
	bool GetAdditionalMissionSuccessBadges(TArray<class UFortWorldItemDefinition*>* SuccessItems) const;
	TArray<class AFortObjectiveBase*> GetAllObjectives() const;
	int32 GetBuildingDamageLootTier(class AFortPlayerController* PlayerController) const;
	int32 GetCurrentBluGloRewards() const;
	class FText GetCurrentFocusDisplayText() const;
	float GetCurrentFocusPercentage() const;
	int32 GetDaysRemainingBeforeOverPar() const;
	float GetExpectedCompletionTime() const;
	struct FGuid GetMissionGuid() const;
	class FText GetMissionName() const;
	class AFortObjectiveBase* GetObjectiveByHandle(const struct FGameplayTagContainer& ObjectiveHandle) const;
	TArray<struct FGameplayTagContainer> GetObjectiveHandlesWithTag(const struct FGameplayTag& ObjectiveTag, int32 MaxNumberOfObjectives) const;
	EFortObjectiveStatus GetObjectiveStatusByHandle(const struct FGameplayTagContainer& ObjectiveHandle) const;
	TArray<class AFortPlayerController*> GetParticipatingMissionControllers() const;
	int32 GetPawnDamageLootTier(class AFortPlayerController* PlayerController) const;
	bool GetSpawnLocationActorsMatchingQuery(const struct FGameplayTagQuery& TagQuery, TArray<class AActor*>* SpawnLocationActors) const;
	bool GetSpawnLocationsMatchingQuery(const struct FGameplayTagQuery& TagQuery, TArray<struct FVector>* SpawnLocations) const;
	bool HasMissionPar() const;
	bool IsPlayerParticipating(class AFortPlayerController* PlayerController) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMission">();
	}
	static class AFortMission* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortMission>();
	}
};
static_assert(alignof(AFortMission) == 0x000008, "Wrong alignment on AFortMission");
static_assert(sizeof(AFortMission) == 0x0006D8, "Wrong size on AFortMission");
static_assert(offsetof(AFortMission, MissionInfo) == 0x0003C8, "Member 'AFortMission::MissionInfo' has a wrong offset!");
static_assert(offsetof(AFortMission, MissionEnemyClasses) == 0x0003D0, "Member 'AFortMission::MissionEnemyClasses' has a wrong offset!");
static_assert(offsetof(AFortMission, BotLogicClass) == 0x0003E0, "Member 'AFortMission::BotLogicClass' has a wrong offset!");
static_assert(offsetof(AFortMission, BotLogic) == 0x0003E8, "Member 'AFortMission::BotLogic' has a wrong offset!");
static_assert(offsetof(AFortMission, MissionGenerator) == 0x0003F0, "Member 'AFortMission::MissionGenerator' has a wrong offset!");
static_assert(offsetof(AFortMission, MissionCategory) == 0x0003F8, "Member 'AFortMission::MissionCategory' has a wrong offset!");
static_assert(offsetof(AFortMission, UIIndex) == 0x0003FC, "Member 'AFortMission::UIIndex' has a wrong offset!");
static_assert(offsetof(AFortMission, QuestOwnerAccount) == 0x000400, "Member 'AFortMission::QuestOwnerAccount' has a wrong offset!");
static_assert(offsetof(AFortMission, MissionEventNames) == 0x000418, "Member 'AFortMission::MissionEventNames' has a wrong offset!");
static_assert(offsetof(AFortMission, OnObjectivesUpdated) == 0x000428, "Member 'AFortMission::OnObjectivesUpdated' has a wrong offset!");
static_assert(offsetof(AFortMission, PlacementActorPreferredTagData) == 0x000438, "Member 'AFortMission::PlacementActorPreferredTagData' has a wrong offset!");
static_assert(offsetof(AFortMission, bLoadedFromRecord) == 0x000448, "Member 'AFortMission::bLoadedFromRecord' has a wrong offset!");
static_assert(offsetof(AFortMission, bFiredParTimeEvent) == 0x000449, "Member 'AFortMission::bFiredParTimeEvent' has a wrong offset!");
static_assert(offsetof(AFortMission, MissionActivationTime) == 0x00044C, "Member 'AFortMission::MissionActivationTime' has a wrong offset!");
static_assert(offsetof(AFortMission, CurrentFocusData) == 0x000450, "Member 'AFortMission::CurrentFocusData' has a wrong offset!");
static_assert(offsetof(AFortMission, bSilentDestroyNextFrame) == 0x000470, "Member 'AFortMission::bSilentDestroyNextFrame' has a wrong offset!");
static_assert(offsetof(AFortMission, ActiveObjectives) == 0x000478, "Member 'AFortMission::ActiveObjectives' has a wrong offset!");
static_assert(offsetof(AFortMission, ParticipatingAccounts) == 0x000488, "Member 'AFortMission::ParticipatingAccounts' has a wrong offset!");
static_assert(offsetof(AFortMission, ParticipatingButDisconnectedAccounts) == 0x000498, "Member 'AFortMission::ParticipatingButDisconnectedAccounts' has a wrong offset!");
static_assert(offsetof(AFortMission, MissionStatus) == 0x0004A8, "Member 'AFortMission::MissionStatus' has a wrong offset!");
static_assert(offsetof(AFortMission, MissionCompletionTags) == 0x0004B0, "Member 'AFortMission::MissionCompletionTags' has a wrong offset!");
static_assert(offsetof(AFortMission, bIsMissionVisible) == 0x0004D0, "Member 'AFortMission::bIsMissionVisible' has a wrong offset!");
static_assert(offsetof(AFortMission, MissionAudibility) == 0x0004D1, "Member 'AFortMission::MissionAudibility' has a wrong offset!");
static_assert(offsetof(AFortMission, CurrentObjectiveBlockIndex) == 0x0004D4, "Member 'AFortMission::CurrentObjectiveBlockIndex' has a wrong offset!");
static_assert(offsetof(AFortMission, bIsMissionVisibleOverride) == 0x0004D8, "Member 'AFortMission::bIsMissionVisibleOverride' has a wrong offset!");
static_assert(offsetof(AFortMission, MissionGuid) == 0x0004DC, "Member 'AFortMission::MissionGuid' has a wrong offset!");
static_assert(offsetof(AFortMission, StartingDay) == 0x0004EC, "Member 'AFortMission::StartingDay' has a wrong offset!");
static_assert(offsetof(AFortMission, TimerComponent) == 0x0004F0, "Member 'AFortMission::TimerComponent' has a wrong offset!");
static_assert(offsetof(AFortMission, ChosenRewardIdx) == 0x0004FC, "Member 'AFortMission::ChosenRewardIdx' has a wrong offset!");
static_assert(offsetof(AFortMission, PotentialBadgesArray) == 0x000500, "Member 'AFortMission::PotentialBadgesArray' has a wrong offset!");
static_assert(offsetof(AFortMission, GeneratedMissionOptions) == 0x000678, "Member 'AFortMission::GeneratedMissionOptions' has a wrong offset!");
static_assert(offsetof(AFortMission, ConfigData) == 0x0006B8, "Member 'AFortMission::ConfigData' has a wrong offset!");

// Class FortniteGame.FortPvPMission
// 0x0010 (0x06E8 - 0x06D8)
class AFortPvPMission : public AFortMission
{
public:
	class AFortPlayerStatePvP*                    WinningPlayerState;                                // 0x06D8(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFortTeamInfo*                          WinningTeam;                                       // 0x06E0(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPvPMission">();
	}
	static class AFortPvPMission* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPvPMission>();
	}
};
static_assert(alignof(AFortPvPMission) == 0x000008, "Wrong alignment on AFortPvPMission");
static_assert(sizeof(AFortPvPMission) == 0x0006E8, "Wrong size on AFortPvPMission");
static_assert(offsetof(AFortPvPMission, WinningPlayerState) == 0x0006D8, "Member 'AFortPvPMission::WinningPlayerState' has a wrong offset!");
static_assert(offsetof(AFortPvPMission, WinningTeam) == 0x0006E0, "Member 'AFortPvPMission::WinningTeam' has a wrong offset!");

// Class FortniteGame.FortPvPMission_3PtDomination
// 0x0028 (0x0710 - 0x06E8)
class AFortPvPMission_3PtDomination final : public AFortPvPMission
{
public:
	TArray<class ABuildingCapturePointActor*>     CapturePoints;                                     // 0x06E8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 TeamScores;                                        // 0x06F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	int32                                         ScoreToWin;                                        // 0x0708(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_70C[0x4];                                      // 0x070C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CapturePointSetterHackTimer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPvPMission_3PtDomination">();
	}
	static class AFortPvPMission_3PtDomination* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPvPMission_3PtDomination>();
	}
};
static_assert(alignof(AFortPvPMission_3PtDomination) == 0x000008, "Wrong alignment on AFortPvPMission_3PtDomination");
static_assert(sizeof(AFortPvPMission_3PtDomination) == 0x000710, "Wrong size on AFortPvPMission_3PtDomination");
static_assert(offsetof(AFortPvPMission_3PtDomination, CapturePoints) == 0x0006E8, "Member 'AFortPvPMission_3PtDomination::CapturePoints' has a wrong offset!");
static_assert(offsetof(AFortPvPMission_3PtDomination, TeamScores) == 0x0006F8, "Member 'AFortPvPMission_3PtDomination::TeamScores' has a wrong offset!");
static_assert(offsetof(AFortPvPMission_3PtDomination, ScoreToWin) == 0x000708, "Member 'AFortPvPMission_3PtDomination::ScoreToWin' has a wrong offset!");

// Class FortniteGame.FortTooltipDisplayStatsList
// 0x0010 (0x0038 - 0x0028)
class UFortTooltipDisplayStatsList final : public UDataAsset
{
public:
	TArray<struct FFortTooltipDisplayStatsCategory> TooltipCategories;                                 // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTooltipDisplayStatsList">();
	}
	static class UFortTooltipDisplayStatsList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortTooltipDisplayStatsList>();
	}
};
static_assert(alignof(UFortTooltipDisplayStatsList) == 0x000008, "Wrong alignment on UFortTooltipDisplayStatsList");
static_assert(sizeof(UFortTooltipDisplayStatsList) == 0x000038, "Wrong size on UFortTooltipDisplayStatsList");
static_assert(offsetof(UFortTooltipDisplayStatsList, TooltipCategories) == 0x000028, "Member 'UFortTooltipDisplayStatsList::TooltipCategories' has a wrong offset!");

// Class FortniteGame.FortTooltipDisplayStatsLookupTable
// 0x0060 (0x0088 - 0x0028)
class UFortTooltipDisplayStatsLookupTable final : public UDataAsset
{
public:
	TArray<struct FFortTooltipDisplayInfo>        TooltipDisplayStats;                               // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTooltipDisplayStatsLookupTable">();
	}
	static class UFortTooltipDisplayStatsLookupTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortTooltipDisplayStatsLookupTable>();
	}
};
static_assert(alignof(UFortTooltipDisplayStatsLookupTable) == 0x000008, "Wrong alignment on UFortTooltipDisplayStatsLookupTable");
static_assert(sizeof(UFortTooltipDisplayStatsLookupTable) == 0x000088, "Wrong size on UFortTooltipDisplayStatsLookupTable");
static_assert(offsetof(UFortTooltipDisplayStatsLookupTable, TooltipDisplayStats) == 0x000028, "Member 'UFortTooltipDisplayStatsLookupTable::TooltipDisplayStats' has a wrong offset!");

// Class FortniteGame.FortItemIconDefinition
// 0x0120 (0x0148 - 0x0028)
class UFortItemIconDefinition final : public UDataAsset
{
public:
	struct FSlateBrush                            Brush;                                             // 0x0028(0x0090)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            LargeBrush;                                        // 0x00B8(0x0090)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortItemIconDefinition">();
	}
	static class UFortItemIconDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortItemIconDefinition>();
	}
};
static_assert(alignof(UFortItemIconDefinition) == 0x000008, "Wrong alignment on UFortItemIconDefinition");
static_assert(sizeof(UFortItemIconDefinition) == 0x000148, "Wrong size on UFortItemIconDefinition");
static_assert(offsetof(UFortItemIconDefinition, Brush) == 0x000028, "Member 'UFortItemIconDefinition::Brush' has a wrong offset!");
static_assert(offsetof(UFortItemIconDefinition, LargeBrush) == 0x0000B8, "Member 'UFortItemIconDefinition::LargeBrush' has a wrong offset!");

// Class FortniteGame.FortBTDecorator_QueryGameplayAbility
// 0x0070 (0x00D8 - 0x0068)
class UFortBTDecorator_QueryGameplayAbility : public UBTDecorator
{
public:
	struct FGameplayTagContainer                  GameplayAbilityTag;                                // 0x0068(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 Target;                                            // 0x0088(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  ActiveAbilityTagsToSkipTesting;                    // 0x00B0(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	bool                                          bUseTarget;                                        // 0x00D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTDecorator_QueryGameplayAbility">();
	}
	static class UFortBTDecorator_QueryGameplayAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTDecorator_QueryGameplayAbility>();
	}
};
static_assert(alignof(UFortBTDecorator_QueryGameplayAbility) == 0x000008, "Wrong alignment on UFortBTDecorator_QueryGameplayAbility");
static_assert(sizeof(UFortBTDecorator_QueryGameplayAbility) == 0x0000D8, "Wrong size on UFortBTDecorator_QueryGameplayAbility");
static_assert(offsetof(UFortBTDecorator_QueryGameplayAbility, GameplayAbilityTag) == 0x000068, "Member 'UFortBTDecorator_QueryGameplayAbility::GameplayAbilityTag' has a wrong offset!");
static_assert(offsetof(UFortBTDecorator_QueryGameplayAbility, Target) == 0x000088, "Member 'UFortBTDecorator_QueryGameplayAbility::Target' has a wrong offset!");
static_assert(offsetof(UFortBTDecorator_QueryGameplayAbility, ActiveAbilityTagsToSkipTesting) == 0x0000B0, "Member 'UFortBTDecorator_QueryGameplayAbility::ActiveAbilityTagsToSkipTesting' has a wrong offset!");
static_assert(offsetof(UFortBTDecorator_QueryGameplayAbility, bUseTarget) == 0x0000D0, "Member 'UFortBTDecorator_QueryGameplayAbility::bUseTarget' has a wrong offset!");

// Class FortniteGame.FortBTDecorator_GameplayAbility_IsWithinMaxTargetSelectionRange
// 0x0000 (0x00D8 - 0x00D8)
class UFortBTDecorator_GameplayAbility_IsWithinMaxTargetSelectionRange final : public UFortBTDecorator_QueryGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTDecorator_GameplayAbility_IsWithinMaxTargetSelectionRange">();
	}
	static class UFortBTDecorator_GameplayAbility_IsWithinMaxTargetSelectionRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTDecorator_GameplayAbility_IsWithinMaxTargetSelectionRange>();
	}
};
static_assert(alignof(UFortBTDecorator_GameplayAbility_IsWithinMaxTargetSelectionRange) == 0x000008, "Wrong alignment on UFortBTDecorator_GameplayAbility_IsWithinMaxTargetSelectionRange");
static_assert(sizeof(UFortBTDecorator_GameplayAbility_IsWithinMaxTargetSelectionRange) == 0x0000D8, "Wrong size on UFortBTDecorator_GameplayAbility_IsWithinMaxTargetSelectionRange");

// Class FortniteGame.FortQueryTest_GoalDiscouragement
// 0x0030 (0x0208 - 0x01D8)
class UFortQueryTest_GoalDiscouragement final : public UFortQueryTest_GoalBase
{
public:
	struct FAIDataProviderBoolValue               DisableDiscouragementWhenUndermining;              // 0x01D8(0x0030)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_GoalDiscouragement">();
	}
	static class UFortQueryTest_GoalDiscouragement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_GoalDiscouragement>();
	}
};
static_assert(alignof(UFortQueryTest_GoalDiscouragement) == 0x000008, "Wrong alignment on UFortQueryTest_GoalDiscouragement");
static_assert(sizeof(UFortQueryTest_GoalDiscouragement) == 0x000208, "Wrong size on UFortQueryTest_GoalDiscouragement");
static_assert(offsetof(UFortQueryTest_GoalDiscouragement, DisableDiscouragementWhenUndermining) == 0x0001D8, "Member 'UFortQueryTest_GoalDiscouragement::DisableDiscouragementWhenUndermining' has a wrong offset!");

// Class FortniteGame.FortPickupEffect
// 0x0040 (0x03C8 - 0x0388)
class AFortPickupEffect : public AActor
{
public:
	class UStaticMesh*                            StaticMesh;                                        // 0x0388(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          SkeletalMesh;                                      // 0x0390(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortWorldItemDefinition*               ItemDefinition;                                    // 0x0398(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoNotShowSpawnParticles;                          // 0x03A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A1[0x3];                                      // 0x03A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PickupColor;                                       // 0x03A4(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BackpackWorldPosition;                             // 0x03B0(0x0010)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOwnedByALocalPlayer : 1;                          // 0x03C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOwnedByPlayer : 1;                                // 0x03C0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3C1[0x7];                                      // 0x03C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAboutToEnterBackpack(class AFortPawn* PickupTarget);
	void OnAttached();
	void OnPickedUp();
	void OnTossed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPickupEffect">();
	}
	static class AFortPickupEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPickupEffect>();
	}
};
static_assert(alignof(AFortPickupEffect) == 0x000008, "Wrong alignment on AFortPickupEffect");
static_assert(sizeof(AFortPickupEffect) == 0x0003C8, "Wrong size on AFortPickupEffect");
static_assert(offsetof(AFortPickupEffect, StaticMesh) == 0x000388, "Member 'AFortPickupEffect::StaticMesh' has a wrong offset!");
static_assert(offsetof(AFortPickupEffect, SkeletalMesh) == 0x000390, "Member 'AFortPickupEffect::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(AFortPickupEffect, ItemDefinition) == 0x000398, "Member 'AFortPickupEffect::ItemDefinition' has a wrong offset!");
static_assert(offsetof(AFortPickupEffect, bDoNotShowSpawnParticles) == 0x0003A0, "Member 'AFortPickupEffect::bDoNotShowSpawnParticles' has a wrong offset!");
static_assert(offsetof(AFortPickupEffect, PickupColor) == 0x0003A4, "Member 'AFortPickupEffect::PickupColor' has a wrong offset!");
static_assert(offsetof(AFortPickupEffect, BackpackWorldPosition) == 0x0003B0, "Member 'AFortPickupEffect::BackpackWorldPosition' has a wrong offset!");

// Class FortniteGame.FortBTDecorator_GameplayAbility_CanActivate
// 0x0000 (0x00D8 - 0x00D8)
class UFortBTDecorator_GameplayAbility_CanActivate final : public UFortBTDecorator_QueryGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTDecorator_GameplayAbility_CanActivate">();
	}
	static class UFortBTDecorator_GameplayAbility_CanActivate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTDecorator_GameplayAbility_CanActivate>();
	}
};
static_assert(alignof(UFortBTDecorator_GameplayAbility_CanActivate) == 0x000008, "Wrong alignment on UFortBTDecorator_GameplayAbility_CanActivate");
static_assert(sizeof(UFortBTDecorator_GameplayAbility_CanActivate) == 0x0000D8, "Wrong size on UFortBTDecorator_GameplayAbility_CanActivate");

// Class FortniteGame.FortQueryTest_GoalDistanceRanges
// 0x0028 (0x0200 - 0x01D8)
class UFortQueryTest_GoalDistanceRanges final : public UFortQueryTest_GoalBase
{
public:
	EDistanceMode                                 DistanceMode;                                      // 0x01D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D9[0x7];                                      // 0x01D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UEnvQueryContext>           DistanceTo;                                        // 0x01E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EEnvTestDistance                              ScreeningTestMode;                                 // 0x01E8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EEnvTestDistance                              TestMode;                                          // 0x01E9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1EA[0x6];                                      // 0x01EA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGoalDistanceData>              GoalDistanceDataRanges;                            // 0x01F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_GoalDistanceRanges">();
	}
	static class UFortQueryTest_GoalDistanceRanges* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_GoalDistanceRanges>();
	}
};
static_assert(alignof(UFortQueryTest_GoalDistanceRanges) == 0x000008, "Wrong alignment on UFortQueryTest_GoalDistanceRanges");
static_assert(sizeof(UFortQueryTest_GoalDistanceRanges) == 0x000200, "Wrong size on UFortQueryTest_GoalDistanceRanges");
static_assert(offsetof(UFortQueryTest_GoalDistanceRanges, DistanceMode) == 0x0001D8, "Member 'UFortQueryTest_GoalDistanceRanges::DistanceMode' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalDistanceRanges, DistanceTo) == 0x0001E0, "Member 'UFortQueryTest_GoalDistanceRanges::DistanceTo' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalDistanceRanges, ScreeningTestMode) == 0x0001E8, "Member 'UFortQueryTest_GoalDistanceRanges::ScreeningTestMode' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalDistanceRanges, TestMode) == 0x0001E9, "Member 'UFortQueryTest_GoalDistanceRanges::TestMode' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalDistanceRanges, GoalDistanceDataRanges) == 0x0001F0, "Member 'UFortQueryTest_GoalDistanceRanges::GoalDistanceDataRanges' has a wrong offset!");

// Class FortniteGame.FortQuickBars
// 0x0328 (0x06B0 - 0x0388)
class AFortQuickBars final : public AActor
{
public:
	struct FQuickBar                              PrimaryQuickBar;                                   // 0x0388(0x0090)(Net, RepNotify, NativeAccessSpecifierPrivate)
	struct FQuickBar                              SecondaryQuickBar;                                 // 0x0418(0x0090)(Net, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4A8[0x1C8];                                    // 0x04A8(0x01C8)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UFortWorldItem*>                 CachedFloorTraps;                                  // 0x0670(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UFortWorldItem*>                 CachedWallTraps;                                   // 0x0680(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UFortWorldItem*>                 CachedCeilingTraps;                                // 0x0690(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6A0[0x10];                                     // 0x06A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableSlot(EFortQuickBars InQuickBar, int32 SlotIndex);
	void Empty(EFortQuickBars InQuickBar);
	void EmptySlot(EFortQuickBars InQuickBar, int32 SlotIndex);
	void EnableSlot(EFortQuickBars InQuickBar, int32 SlotIndex);
	void OnRep_PrimaryQuickBar();
	void OnRep_SecondaryQuickBar();
	void ServerActivateSlotInternal(EFortQuickBars InQuickBar, int32 Slot, float ActivateDelay, bool bUpdatePreviousFocusedSlot);
	void ServerAddItemInternal(const struct FGuid& Item, EFortQuickBars InQuickBar, int32 Slot);
	void ServerRemoveItemInternal(const struct FGuid& Item, bool bFindReplacement, bool bForce);
	void ServerSwapItemsInternal(EFortQuickBars QuickBarA, int32 SlotIndexA, EFortQuickBars QuickBarB, int32 SlotIndexB);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQuickBars">();
	}
	static class AFortQuickBars* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortQuickBars>();
	}
};
static_assert(alignof(AFortQuickBars) == 0x000008, "Wrong alignment on AFortQuickBars");
static_assert(sizeof(AFortQuickBars) == 0x0006B0, "Wrong size on AFortQuickBars");
static_assert(offsetof(AFortQuickBars, PrimaryQuickBar) == 0x000388, "Member 'AFortQuickBars::PrimaryQuickBar' has a wrong offset!");
static_assert(offsetof(AFortQuickBars, SecondaryQuickBar) == 0x000418, "Member 'AFortQuickBars::SecondaryQuickBar' has a wrong offset!");
static_assert(offsetof(AFortQuickBars, CachedFloorTraps) == 0x000670, "Member 'AFortQuickBars::CachedFloorTraps' has a wrong offset!");
static_assert(offsetof(AFortQuickBars, CachedWallTraps) == 0x000680, "Member 'AFortQuickBars::CachedWallTraps' has a wrong offset!");
static_assert(offsetof(AFortQuickBars, CachedCeilingTraps) == 0x000690, "Member 'AFortQuickBars::CachedCeilingTraps' has a wrong offset!");

// Class FortniteGame.FortQueryContext_AllGoals
// 0x0000 (0x0028 - 0x0028)
class UFortQueryContext_AllGoals final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_AllGoals">();
	}
	static class UFortQueryContext_AllGoals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_AllGoals>();
	}
};
static_assert(alignof(UFortQueryContext_AllGoals) == 0x000008, "Wrong alignment on UFortQueryContext_AllGoals");
static_assert(sizeof(UFortQueryContext_AllGoals) == 0x000028, "Wrong size on UFortQueryContext_AllGoals");

// Class FortniteGame.FortBTDecorator_DistanceBetween
// 0x0068 (0x00D0 - 0x0068)
class UFortBTDecorator_DistanceBetween final : public UBTDecorator
{
public:
	EArithmeticKeyOperation                       Operator;                                          // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 BlackboardKeyA;                                    // 0x0070(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 BlackboardKeyB;                                    // 0x0098(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         SpecifiedDistance;                                 // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseSelf : 1;                                      // 0x00C4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCalculateAs2D : 1;                                // 0x00C4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C5[0x3];                                       // 0x00C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceCalculationUpdateRate;                     // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTDecorator_DistanceBetween">();
	}
	static class UFortBTDecorator_DistanceBetween* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTDecorator_DistanceBetween>();
	}
};
static_assert(alignof(UFortBTDecorator_DistanceBetween) == 0x000008, "Wrong alignment on UFortBTDecorator_DistanceBetween");
static_assert(sizeof(UFortBTDecorator_DistanceBetween) == 0x0000D0, "Wrong size on UFortBTDecorator_DistanceBetween");
static_assert(offsetof(UFortBTDecorator_DistanceBetween, Operator) == 0x000068, "Member 'UFortBTDecorator_DistanceBetween::Operator' has a wrong offset!");
static_assert(offsetof(UFortBTDecorator_DistanceBetween, BlackboardKeyA) == 0x000070, "Member 'UFortBTDecorator_DistanceBetween::BlackboardKeyA' has a wrong offset!");
static_assert(offsetof(UFortBTDecorator_DistanceBetween, BlackboardKeyB) == 0x000098, "Member 'UFortBTDecorator_DistanceBetween::BlackboardKeyB' has a wrong offset!");
static_assert(offsetof(UFortBTDecorator_DistanceBetween, SpecifiedDistance) == 0x0000C0, "Member 'UFortBTDecorator_DistanceBetween::SpecifiedDistance' has a wrong offset!");
static_assert(offsetof(UFortBTDecorator_DistanceBetween, DistanceCalculationUpdateRate) == 0x0000C8, "Member 'UFortBTDecorator_DistanceBetween::DistanceCalculationUpdateRate' has a wrong offset!");

// Class FortniteGame.FortMetadataItemDefinition
// 0x0000 (0x0220 - 0x0220)
class UFortMetadataItemDefinition : public UFortItemDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMetadataItemDefinition">();
	}
	static class UFortMetadataItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMetadataItemDefinition>();
	}
};
static_assert(alignof(UFortMetadataItemDefinition) == 0x000010, "Wrong alignment on UFortMetadataItemDefinition");
static_assert(sizeof(UFortMetadataItemDefinition) == 0x000220, "Wrong size on UFortMetadataItemDefinition");

// Class FortniteGame.FortCloudSaveItemDefinition
// 0x0010 (0x0230 - 0x0220)
#pragma pack(push, 0x1)
class alignas(0x10) UFortCloudSaveItemDefinition : public UFortMetadataItemDefinition
{
public:
	int32                                         ContentVersion;                                    // 0x0220(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_224[0x4];                                      // 0x0224(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCloudSaveItemDefinition">();
	}
	static class UFortCloudSaveItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCloudSaveItemDefinition>();
	}
};
#pragma pack(pop)
static_assert(alignof(UFortCloudSaveItemDefinition) == 0x000010, "Wrong alignment on UFortCloudSaveItemDefinition");
static_assert(sizeof(UFortCloudSaveItemDefinition) == 0x000230, "Wrong size on UFortCloudSaveItemDefinition");
static_assert(offsetof(UFortCloudSaveItemDefinition, ContentVersion) == 0x000220, "Member 'UFortCloudSaveItemDefinition::ContentVersion' has a wrong offset!");

// Class FortniteGame.FortQueryContext_EncounterFallbackTarget
// 0x0000 (0x0028 - 0x0028)
class UFortQueryContext_EncounterFallbackTarget final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_EncounterFallbackTarget">();
	}
	static class UFortQueryContext_EncounterFallbackTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_EncounterFallbackTarget>();
	}
};
static_assert(alignof(UFortQueryContext_EncounterFallbackTarget) == 0x000008, "Wrong alignment on UFortQueryContext_EncounterFallbackTarget");
static_assert(sizeof(UFortQueryContext_EncounterFallbackTarget) == 0x000028, "Wrong size on UFortQueryContext_EncounterFallbackTarget");

// Class FortniteGame.FortBTDecorator_GameplayAbility_IsOnCooldown
// 0x0000 (0x00D8 - 0x00D8)
class UFortBTDecorator_GameplayAbility_IsOnCooldown final : public UFortBTDecorator_QueryGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTDecorator_GameplayAbility_IsOnCooldown">();
	}
	static class UFortBTDecorator_GameplayAbility_IsOnCooldown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTDecorator_GameplayAbility_IsOnCooldown>();
	}
};
static_assert(alignof(UFortBTDecorator_GameplayAbility_IsOnCooldown) == 0x000008, "Wrong alignment on UFortBTDecorator_GameplayAbility_IsOnCooldown");
static_assert(sizeof(UFortBTDecorator_GameplayAbility_IsOnCooldown) == 0x0000D8, "Wrong size on UFortBTDecorator_GameplayAbility_IsOnCooldown");

// Class FortniteGame.FortWorldRecord
// 0x0148 (0x0218 - 0x00D0)
class UFortWorldRecord final : public UFortGenericRecord
{
public:
	struct FFortCloudSaveInfo                     CloudInfo;                                         // 0x00D0(0x0018)(Transient, NativeAccessSpecifierPublic)
	int32                                         CurrentZoneIndex;                                  // 0x00E8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFortPlayerRecord>              SavedPlayers;                                      // 0x00F0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	struct FFortZoneInstanceDetails               ZoneInstanceInfo;                                  // 0x0100(0x0108)(Transient, NativeAccessSpecifierPublic)
	class FString                                 WUID;                                              // 0x0208(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortWorldRecord">();
	}
	static class UFortWorldRecord* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortWorldRecord>();
	}
};
static_assert(alignof(UFortWorldRecord) == 0x000008, "Wrong alignment on UFortWorldRecord");
static_assert(sizeof(UFortWorldRecord) == 0x000218, "Wrong size on UFortWorldRecord");
static_assert(offsetof(UFortWorldRecord, CloudInfo) == 0x0000D0, "Member 'UFortWorldRecord::CloudInfo' has a wrong offset!");
static_assert(offsetof(UFortWorldRecord, CurrentZoneIndex) == 0x0000E8, "Member 'UFortWorldRecord::CurrentZoneIndex' has a wrong offset!");
static_assert(offsetof(UFortWorldRecord, SavedPlayers) == 0x0000F0, "Member 'UFortWorldRecord::SavedPlayers' has a wrong offset!");
static_assert(offsetof(UFortWorldRecord, ZoneInstanceInfo) == 0x000100, "Member 'UFortWorldRecord::ZoneInstanceInfo' has a wrong offset!");
static_assert(offsetof(UFortWorldRecord, WUID) == 0x000208, "Member 'UFortWorldRecord::WUID' has a wrong offset!");

// Class FortniteGame.FortZoneRecord
// 0x01D0 (0x02A0 - 0x00D0)
class UFortZoneRecord final : public UFortGenericRecord
{
public:
	int32                                         WorldSaveCount;                                    // 0x00D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ZoneIndex;                                         // 0x00D4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PersistentLevelName;                               // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFortLevelRecord>               SavedLevels;                                       // 0x00E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         NumSavedLevels;                                    // 0x00F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ZoneTileSeed;                                      // 0x00F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x190];                                     // 0x00F8(0x0190)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FStatManagerPeriodRecord>       PlayerMapStatManagerPeriods;                       // 0x0288(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         CloudSaveItemDefContentVersion;                    // 0x0298(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedsFullActorSave;                               // 0x029C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29D[0x3];                                      // 0x029D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortZoneRecord">();
	}
	static class UFortZoneRecord* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortZoneRecord>();
	}
};
static_assert(alignof(UFortZoneRecord) == 0x000008, "Wrong alignment on UFortZoneRecord");
static_assert(sizeof(UFortZoneRecord) == 0x0002A0, "Wrong size on UFortZoneRecord");
static_assert(offsetof(UFortZoneRecord, WorldSaveCount) == 0x0000D0, "Member 'UFortZoneRecord::WorldSaveCount' has a wrong offset!");
static_assert(offsetof(UFortZoneRecord, ZoneIndex) == 0x0000D4, "Member 'UFortZoneRecord::ZoneIndex' has a wrong offset!");
static_assert(offsetof(UFortZoneRecord, PersistentLevelName) == 0x0000D8, "Member 'UFortZoneRecord::PersistentLevelName' has a wrong offset!");
static_assert(offsetof(UFortZoneRecord, SavedLevels) == 0x0000E0, "Member 'UFortZoneRecord::SavedLevels' has a wrong offset!");
static_assert(offsetof(UFortZoneRecord, NumSavedLevels) == 0x0000F0, "Member 'UFortZoneRecord::NumSavedLevels' has a wrong offset!");
static_assert(offsetof(UFortZoneRecord, ZoneTileSeed) == 0x0000F4, "Member 'UFortZoneRecord::ZoneTileSeed' has a wrong offset!");
static_assert(offsetof(UFortZoneRecord, PlayerMapStatManagerPeriods) == 0x000288, "Member 'UFortZoneRecord::PlayerMapStatManagerPeriods' has a wrong offset!");
static_assert(offsetof(UFortZoneRecord, CloudSaveItemDefContentVersion) == 0x000298, "Member 'UFortZoneRecord::CloudSaveItemDefContentVersion' has a wrong offset!");
static_assert(offsetof(UFortZoneRecord, bNeedsFullActorSave) == 0x00029C, "Member 'UFortZoneRecord::bNeedsFullActorSave' has a wrong offset!");

// Class FortniteGame.FortBuildingInstructions
// 0x00B0 (0x00D8 - 0x0028)
class UFortBuildingInstructions final : public UDataAsset
{
public:
	TSoftObjectPtr<class UWorld>                  TemplateMap;                                       // 0x0028(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, SaveGame, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFortBuildingInstruction>       Instructions;                                      // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, SaveGame, NativeAccessSpecifierPublic)
	struct FBoxSphereBounds                       Bounds;                                            // 0x0058(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, SaveGame, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         NumOfPiecesToSpawnAtOnce;                          // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeBetweenSpawns;                                 // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MapName;                                           // 0x0080(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_90[0x48];                                      // 0x0090(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBuildingInstructions">();
	}
	static class UFortBuildingInstructions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBuildingInstructions>();
	}
};
static_assert(alignof(UFortBuildingInstructions) == 0x000008, "Wrong alignment on UFortBuildingInstructions");
static_assert(sizeof(UFortBuildingInstructions) == 0x0000D8, "Wrong size on UFortBuildingInstructions");
static_assert(offsetof(UFortBuildingInstructions, TemplateMap) == 0x000028, "Member 'UFortBuildingInstructions::TemplateMap' has a wrong offset!");
static_assert(offsetof(UFortBuildingInstructions, Instructions) == 0x000048, "Member 'UFortBuildingInstructions::Instructions' has a wrong offset!");
static_assert(offsetof(UFortBuildingInstructions, Bounds) == 0x000058, "Member 'UFortBuildingInstructions::Bounds' has a wrong offset!");
static_assert(offsetof(UFortBuildingInstructions, NumOfPiecesToSpawnAtOnce) == 0x000074, "Member 'UFortBuildingInstructions::NumOfPiecesToSpawnAtOnce' has a wrong offset!");
static_assert(offsetof(UFortBuildingInstructions, TimeBetweenSpawns) == 0x000078, "Member 'UFortBuildingInstructions::TimeBetweenSpawns' has a wrong offset!");
static_assert(offsetof(UFortBuildingInstructions, MapName) == 0x000080, "Member 'UFortBuildingInstructions::MapName' has a wrong offset!");

// Class FortniteGame.BuildingFOBCoreSpawnPad
// 0x0000 (0x0840 - 0x0840)
class ABuildingFOBCoreSpawnPad final : public ABuildingGameplayActor
{
public:
	struct FTransform GetCoreSpawnTransform() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingFOBCoreSpawnPad">();
	}
	static class ABuildingFOBCoreSpawnPad* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingFOBCoreSpawnPad>();
	}
};
static_assert(alignof(ABuildingFOBCoreSpawnPad) == 0x000010, "Wrong alignment on ABuildingFOBCoreSpawnPad");
static_assert(sizeof(ABuildingFOBCoreSpawnPad) == 0x000840, "Wrong size on ABuildingFOBCoreSpawnPad");

// Class FortniteGame.FortPickup
// 0x0200 (0x0588 - 0x0388)
class AFortPickup : public AActor
{
public:
	uint8                                         Pad_388[0x8];                                      // 0x0388(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUsePickupWidget;                                  // 0x0390(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_391[0x7];                                      // 0x0391(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnPickup;                                          // 0x0398(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPickupAttempted;                                 // 0x03A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FFortItemEntry                         PrimaryPickupItemEntry;                            // 0x03B8(0x00A8)(Net, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortItemEntry>                 MultiItemPickupEntries;                            // 0x0460(0x0010)(Net, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FFortPickupLocationData                PickupLocationData;                                // 0x0470(0x0060)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	int32                                         OptionalOwnerID;                                   // 0x04D0(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  OptionalMissionGuid;                               // 0x04D4(0x0010)(Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4E4[0x4];                                      // 0x04E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortItem*                              PrimaryPickupDummyItem;                            // 0x04E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AFortPickupEffect>       PickupEffectBlueprint;                             // 0x04F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      TouchCapsule;                                      // 0x04F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProjectileMovementComponent*           MovementComponent;                                 // 0x0500(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPickedUp;                                         // 0x0508(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTossed;                                           // 0x0509(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSplitOnPickup;                                    // 0x050A(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTossedFromContainer;                              // 0x050B(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastLandedSoundPlayTime;                           // 0x050C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortPawn*                              PawnWhoDroppedPickup;                              // 0x0510(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortSimpleMiniMapIndicator*            MiniMapIndicator;                                  // 0x0518(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortSlateHUDIndicator*                 HUDLabel;                                          // 0x0520(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_528[0x60];                                     // 0x0528(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FText GetDisplayName();
	bool GetInteractErrorText(class FText* InteractErrorText);
	bool GetInteractText(class FText* InteractText);
	void OnRep_bPickedUp();
	void OnRep_PickupLocationData();
	void OnRep_PickupOwnerData();
	void OnRep_PrimaryPickupItemEntry();
	void OnRep_TossedFromContainer();
	void TossPickup(const struct FVector& FinalLocation, class AFortPawn* ItemOwner, int32 OverrideMaxStackCount);

	bool PickedUp() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPickup">();
	}
	static class AFortPickup* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPickup>();
	}
};
static_assert(alignof(AFortPickup) == 0x000008, "Wrong alignment on AFortPickup");
static_assert(sizeof(AFortPickup) == 0x000588, "Wrong size on AFortPickup");
static_assert(offsetof(AFortPickup, bUsePickupWidget) == 0x000390, "Member 'AFortPickup::bUsePickupWidget' has a wrong offset!");
static_assert(offsetof(AFortPickup, OnPickup) == 0x000398, "Member 'AFortPickup::OnPickup' has a wrong offset!");
static_assert(offsetof(AFortPickup, OnPickupAttempted) == 0x0003A8, "Member 'AFortPickup::OnPickupAttempted' has a wrong offset!");
static_assert(offsetof(AFortPickup, PrimaryPickupItemEntry) == 0x0003B8, "Member 'AFortPickup::PrimaryPickupItemEntry' has a wrong offset!");
static_assert(offsetof(AFortPickup, MultiItemPickupEntries) == 0x000460, "Member 'AFortPickup::MultiItemPickupEntries' has a wrong offset!");
static_assert(offsetof(AFortPickup, PickupLocationData) == 0x000470, "Member 'AFortPickup::PickupLocationData' has a wrong offset!");
static_assert(offsetof(AFortPickup, OptionalOwnerID) == 0x0004D0, "Member 'AFortPickup::OptionalOwnerID' has a wrong offset!");
static_assert(offsetof(AFortPickup, OptionalMissionGuid) == 0x0004D4, "Member 'AFortPickup::OptionalMissionGuid' has a wrong offset!");
static_assert(offsetof(AFortPickup, PrimaryPickupDummyItem) == 0x0004E8, "Member 'AFortPickup::PrimaryPickupDummyItem' has a wrong offset!");
static_assert(offsetof(AFortPickup, PickupEffectBlueprint) == 0x0004F0, "Member 'AFortPickup::PickupEffectBlueprint' has a wrong offset!");
static_assert(offsetof(AFortPickup, TouchCapsule) == 0x0004F8, "Member 'AFortPickup::TouchCapsule' has a wrong offset!");
static_assert(offsetof(AFortPickup, MovementComponent) == 0x000500, "Member 'AFortPickup::MovementComponent' has a wrong offset!");
static_assert(offsetof(AFortPickup, bPickedUp) == 0x000508, "Member 'AFortPickup::bPickedUp' has a wrong offset!");
static_assert(offsetof(AFortPickup, bTossed) == 0x000509, "Member 'AFortPickup::bTossed' has a wrong offset!");
static_assert(offsetof(AFortPickup, bSplitOnPickup) == 0x00050A, "Member 'AFortPickup::bSplitOnPickup' has a wrong offset!");
static_assert(offsetof(AFortPickup, bTossedFromContainer) == 0x00050B, "Member 'AFortPickup::bTossedFromContainer' has a wrong offset!");
static_assert(offsetof(AFortPickup, LastLandedSoundPlayTime) == 0x00050C, "Member 'AFortPickup::LastLandedSoundPlayTime' has a wrong offset!");
static_assert(offsetof(AFortPickup, PawnWhoDroppedPickup) == 0x000510, "Member 'AFortPickup::PawnWhoDroppedPickup' has a wrong offset!");
static_assert(offsetof(AFortPickup, MiniMapIndicator) == 0x000518, "Member 'AFortPickup::MiniMapIndicator' has a wrong offset!");
static_assert(offsetof(AFortPickup, HUDLabel) == 0x000520, "Member 'AFortPickup::HUDLabel' has a wrong offset!");

// Class FortniteGame.FortPickupAthena
// 0x0000 (0x0588 - 0x0588)
class AFortPickupAthena final : public AFortPickup
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPickupAthena">();
	}
	static class AFortPickupAthena* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPickupAthena>();
	}
};
static_assert(alignof(AFortPickupAthena) == 0x000008, "Wrong alignment on AFortPickupAthena");
static_assert(sizeof(AFortPickupAthena) == 0x000588, "Wrong size on AFortPickupAthena");

// Class FortniteGame.BuildingFOBConfigActor
// 0x02F0 (0x0B30 - 0x0840)
class ABuildingFOBConfigActor final : public ABuildingGameplayActor
{
public:
	UMulticastDelegateProperty_                   OnIOOperationComplete;                             // 0x0840(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FString                                 ExplicitSaveFile;                                  // 0x0850(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFortBuildingInstructions> FallbackBuildingInstructions;                      // 0x0860(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 CoreSaveFileUniqueContext;                         // 0x0880(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   CreationModeSpawnPadClass;                         // 0x0890(0x0020)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  SpawnPadPlacementActorRequiredTags;                // 0x08B0(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UObjectLibrary>          FOBCoreLibrary;                                    // 0x08D0(0x0020)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bLoadFirstCoreInCreationMode : 1;                  // 0x08F0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_8F1[0x7];                                      // 0x08F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFOBCoreChoiceArray                    FOBCoreChoices;                                    // 0x08F8(0x00C0)(Net, Transient, Protected, NativeAccessSpecifierProtected)
	class UFortFOBCoreDecoItemDefinition*         SelectedCoreItemDef;                               // 0x09B8(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABuildingFOBCoreActor*                  SelectedCore;                                      // 0x09C0(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABuildingFOBCoreSpawnPad*               CoreSpawnPad;                                      // 0x09C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFOBSaveFileBuildingInstructionsHandler* SaveFileInstructionsHandler;                       // 0x09D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FUniqueNetIdRepl                       OwnerNetID;                                        // 0x09D8(0x0018)(Net, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFOBMode                                      FOBMode;                                           // 0x09F0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFOBIOStatus                                  IOStatus;                                          // 0x09F1(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9F2[0x2];                                      // 0x09F2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bEnumeratedUserFilesSuccessfully : 1;              // 0x09F4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCoreBasedDeploymentModeFinalizationRequested : 1; // 0x09F4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bInitialized : 1;                                  // 0x09F4(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bFinalized : 1;                                    // 0x09F4(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Net, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDummyDeployment : 1;                              // 0x09F4(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_9F5[0xE3];                                     // 0x09F5(0x00E3)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnAllBuildingsSpawned;                             // 0x0AD8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class UBoxComponent*                          ContainmentBoxComponent;                           // 0x0AE8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBox                                   ContainmentBoxStructuralGridBox;                   // 0x0AF0(0x001C)(Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_B0C[0x4];                                      // 0x0B0C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  SpawnLocationTags;                                 // 0x0B10(0x0020)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	bool AttemptSelectFOBCore(class UFortFOBCoreDecoItemDefinition* DefToSelect);
	void OnCoreInitialized(class ABuildingFOBCoreActor* InitializedCore);
	void OnFinalizationFXMulticast();
	void OnFinalizationPlayFX();
	void OnFinalized();
	void OnFOBModeSet(EFOBMode ModeThatWasSet);
	void OnIOOperationCompleteMulticast(EFOBIOStatus IOOperation, bool bSuccess, class UFortFOBCoreDecoItemDefinition* SelectedCoreDef);
	void OnRep_bFinalized();
	void OnRep_FOBMode();
	bool ReloadFOB();

	bool CanPerformIOOperation() const;
	bool CanReloadFOB() const;
	bool CanSaveFOB() const;
	TArray<struct FFOBCoreChoice> GetAllCoreChoices() const;
	EFOBMode GetFOBMode() const;
	class UFortFOBCoreDecoItemDefinition* GetSelectedFOBCoreItemDefinition() const;
	bool IsBuildingActorWithinFOB(class ABuildingActor* ActorToCheck) const;
	bool IsFinalized() const;
	bool IsInitialized() const;
	bool IsPlayerControllerFOBOwner(const class AFortPlayerController* FortPC) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingFOBConfigActor">();
	}
	static class ABuildingFOBConfigActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingFOBConfigActor>();
	}
};
static_assert(alignof(ABuildingFOBConfigActor) == 0x000010, "Wrong alignment on ABuildingFOBConfigActor");
static_assert(sizeof(ABuildingFOBConfigActor) == 0x000B30, "Wrong size on ABuildingFOBConfigActor");
static_assert(offsetof(ABuildingFOBConfigActor, OnIOOperationComplete) == 0x000840, "Member 'ABuildingFOBConfigActor::OnIOOperationComplete' has a wrong offset!");
static_assert(offsetof(ABuildingFOBConfigActor, ExplicitSaveFile) == 0x000850, "Member 'ABuildingFOBConfigActor::ExplicitSaveFile' has a wrong offset!");
static_assert(offsetof(ABuildingFOBConfigActor, FallbackBuildingInstructions) == 0x000860, "Member 'ABuildingFOBConfigActor::FallbackBuildingInstructions' has a wrong offset!");
static_assert(offsetof(ABuildingFOBConfigActor, CoreSaveFileUniqueContext) == 0x000880, "Member 'ABuildingFOBConfigActor::CoreSaveFileUniqueContext' has a wrong offset!");
static_assert(offsetof(ABuildingFOBConfigActor, CreationModeSpawnPadClass) == 0x000890, "Member 'ABuildingFOBConfigActor::CreationModeSpawnPadClass' has a wrong offset!");
static_assert(offsetof(ABuildingFOBConfigActor, SpawnPadPlacementActorRequiredTags) == 0x0008B0, "Member 'ABuildingFOBConfigActor::SpawnPadPlacementActorRequiredTags' has a wrong offset!");
static_assert(offsetof(ABuildingFOBConfigActor, FOBCoreLibrary) == 0x0008D0, "Member 'ABuildingFOBConfigActor::FOBCoreLibrary' has a wrong offset!");
static_assert(offsetof(ABuildingFOBConfigActor, FOBCoreChoices) == 0x0008F8, "Member 'ABuildingFOBConfigActor::FOBCoreChoices' has a wrong offset!");
static_assert(offsetof(ABuildingFOBConfigActor, SelectedCoreItemDef) == 0x0009B8, "Member 'ABuildingFOBConfigActor::SelectedCoreItemDef' has a wrong offset!");
static_assert(offsetof(ABuildingFOBConfigActor, SelectedCore) == 0x0009C0, "Member 'ABuildingFOBConfigActor::SelectedCore' has a wrong offset!");
static_assert(offsetof(ABuildingFOBConfigActor, CoreSpawnPad) == 0x0009C8, "Member 'ABuildingFOBConfigActor::CoreSpawnPad' has a wrong offset!");
static_assert(offsetof(ABuildingFOBConfigActor, SaveFileInstructionsHandler) == 0x0009D0, "Member 'ABuildingFOBConfigActor::SaveFileInstructionsHandler' has a wrong offset!");
static_assert(offsetof(ABuildingFOBConfigActor, OwnerNetID) == 0x0009D8, "Member 'ABuildingFOBConfigActor::OwnerNetID' has a wrong offset!");
static_assert(offsetof(ABuildingFOBConfigActor, FOBMode) == 0x0009F0, "Member 'ABuildingFOBConfigActor::FOBMode' has a wrong offset!");
static_assert(offsetof(ABuildingFOBConfigActor, IOStatus) == 0x0009F1, "Member 'ABuildingFOBConfigActor::IOStatus' has a wrong offset!");
static_assert(offsetof(ABuildingFOBConfigActor, OnAllBuildingsSpawned) == 0x000AD8, "Member 'ABuildingFOBConfigActor::OnAllBuildingsSpawned' has a wrong offset!");
static_assert(offsetof(ABuildingFOBConfigActor, ContainmentBoxComponent) == 0x000AE8, "Member 'ABuildingFOBConfigActor::ContainmentBoxComponent' has a wrong offset!");
static_assert(offsetof(ABuildingFOBConfigActor, ContainmentBoxStructuralGridBox) == 0x000AF0, "Member 'ABuildingFOBConfigActor::ContainmentBoxStructuralGridBox' has a wrong offset!");
static_assert(offsetof(ABuildingFOBConfigActor, SpawnLocationTags) == 0x000B10, "Member 'ABuildingFOBConfigActor::SpawnLocationTags' has a wrong offset!");

// Class FortniteGame.BuildingFOBCoreActor
// 0x0110 (0x0950 - 0x0840)
class ABuildingFOBCoreActor final : public ABuildingGameplayActor
{
public:
	TSoftObjectPtr<class UParticleSystem>         SimpleDeathParticles;                              // 0x0840(0x0020)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class USoundBase>              SimpleDeathSound;                                  // 0x0860(0x0020)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          SimpleBoundsBoxComponent;                          // 0x0880(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          TouchBoxComponent;                                 // 0x0888(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ContainmentVolumeTouchBoxOffsetExtents;            // 0x0890(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bRegisterAsGlobalGameplayEventListener : 1;        // 0x089C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bConformTouchBoxToFOBContainmentBox : 1;           // 0x089C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bActive : 1;                                       // 0x089C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Net, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bTargetable : 1;                                   // 0x089C(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bVulnerable : 1;                                   // 0x089C(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_89D[0x3];                                      // 0x089D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnFOBCoreTargetableChanged;                        // 0x08A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnFOBCoreVulnerableChanged;                        // 0x08B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	struct FUniqueNetIdRepl                       OwnerNetID;                                        // 0x08C0(0x0018)(Net, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortFOBCoreDecoItemDefinition*         SpawnedFromItemDef;                                // 0x08D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABuildingFOBCoreSpawnPad*               SpawnedFromSpawnPad;                               // 0x08E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBox                                   FOBBounds;                                         // 0x08E8(0x001C)(Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FBox                                   FOBStructuralBounds;                               // 0x0904(0x001C)(Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnFOBCoreDamaged;                                  // 0x0920(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnFOBCoreOutOfHealth;                              // 0x0930(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         bShowTargetableHUDIndicator : 1;                   // 0x0940(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_941[0xF];                                      // 0x0941(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MarkTargetable();
	void MarkVulnerable();
	void OnActiveStatusChanged(bool bNewActiveStatus);
	void OnRep_bActive();
	void OnRep_bTargetable();
	void OnRep_bVulnerable();
	void OnTargetableStatusChanged(bool bNewTargetableStatus);
	void OnVulnerableStatusChanged(bool bNewTargetableStatus);

	void GetFOBBoundsBoxOverlappedActors(TArray<class ABuildingSMActor*>* OverlappedActors, bool bSortByDistanceFromCore) const;
	bool GetFOBBoundsCenterAndExtents(struct FVector* OutCenter, struct FVector* OutExtents) const;
	struct FTransform GetSimpleDeathFXTransform() const;
	bool IsActive() const;
	bool IsActorWithinFOBBounds(class AActor* Actor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingFOBCoreActor">();
	}
	static class ABuildingFOBCoreActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingFOBCoreActor>();
	}
};
static_assert(alignof(ABuildingFOBCoreActor) == 0x000010, "Wrong alignment on ABuildingFOBCoreActor");
static_assert(sizeof(ABuildingFOBCoreActor) == 0x000950, "Wrong size on ABuildingFOBCoreActor");
static_assert(offsetof(ABuildingFOBCoreActor, SimpleDeathParticles) == 0x000840, "Member 'ABuildingFOBCoreActor::SimpleDeathParticles' has a wrong offset!");
static_assert(offsetof(ABuildingFOBCoreActor, SimpleDeathSound) == 0x000860, "Member 'ABuildingFOBCoreActor::SimpleDeathSound' has a wrong offset!");
static_assert(offsetof(ABuildingFOBCoreActor, SimpleBoundsBoxComponent) == 0x000880, "Member 'ABuildingFOBCoreActor::SimpleBoundsBoxComponent' has a wrong offset!");
static_assert(offsetof(ABuildingFOBCoreActor, TouchBoxComponent) == 0x000888, "Member 'ABuildingFOBCoreActor::TouchBoxComponent' has a wrong offset!");
static_assert(offsetof(ABuildingFOBCoreActor, ContainmentVolumeTouchBoxOffsetExtents) == 0x000890, "Member 'ABuildingFOBCoreActor::ContainmentVolumeTouchBoxOffsetExtents' has a wrong offset!");
static_assert(offsetof(ABuildingFOBCoreActor, OnFOBCoreTargetableChanged) == 0x0008A0, "Member 'ABuildingFOBCoreActor::OnFOBCoreTargetableChanged' has a wrong offset!");
static_assert(offsetof(ABuildingFOBCoreActor, OnFOBCoreVulnerableChanged) == 0x0008B0, "Member 'ABuildingFOBCoreActor::OnFOBCoreVulnerableChanged' has a wrong offset!");
static_assert(offsetof(ABuildingFOBCoreActor, OwnerNetID) == 0x0008C0, "Member 'ABuildingFOBCoreActor::OwnerNetID' has a wrong offset!");
static_assert(offsetof(ABuildingFOBCoreActor, SpawnedFromItemDef) == 0x0008D8, "Member 'ABuildingFOBCoreActor::SpawnedFromItemDef' has a wrong offset!");
static_assert(offsetof(ABuildingFOBCoreActor, SpawnedFromSpawnPad) == 0x0008E0, "Member 'ABuildingFOBCoreActor::SpawnedFromSpawnPad' has a wrong offset!");
static_assert(offsetof(ABuildingFOBCoreActor, FOBBounds) == 0x0008E8, "Member 'ABuildingFOBCoreActor::FOBBounds' has a wrong offset!");
static_assert(offsetof(ABuildingFOBCoreActor, FOBStructuralBounds) == 0x000904, "Member 'ABuildingFOBCoreActor::FOBStructuralBounds' has a wrong offset!");
static_assert(offsetof(ABuildingFOBCoreActor, OnFOBCoreDamaged) == 0x000920, "Member 'ABuildingFOBCoreActor::OnFOBCoreDamaged' has a wrong offset!");
static_assert(offsetof(ABuildingFOBCoreActor, OnFOBCoreOutOfHealth) == 0x000930, "Member 'ABuildingFOBCoreActor::OnFOBCoreOutOfHealth' has a wrong offset!");

// Class FortniteGame.FortQueryContext_EncounterTargetObjective
// 0x0000 (0x0028 - 0x0028)
class UFortQueryContext_EncounterTargetObjective final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_EncounterTargetObjective">();
	}
	static class UFortQueryContext_EncounterTargetObjective* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_EncounterTargetObjective>();
	}
};
static_assert(alignof(UFortQueryContext_EncounterTargetObjective) == 0x000008, "Wrong alignment on UFortQueryContext_EncounterTargetObjective");
static_assert(sizeof(UFortQueryContext_EncounterTargetObjective) == 0x000028, "Wrong size on UFortQueryContext_EncounterTargetObjective");

// Class FortniteGame.FortBTDecorator_GameplayAbility_CompareDistance
// 0x0010 (0x00E8 - 0x00D8)
class UFortBTDecorator_GameplayAbility_CompareDistance final : public UFortBTDecorator_QueryGameplayAbility
{
public:
	TArray<struct FDistanceToTargetComparison>    DistanceComparisons;                               // 0x00D8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTDecorator_GameplayAbility_CompareDistance">();
	}
	static class UFortBTDecorator_GameplayAbility_CompareDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTDecorator_GameplayAbility_CompareDistance>();
	}
};
static_assert(alignof(UFortBTDecorator_GameplayAbility_CompareDistance) == 0x000008, "Wrong alignment on UFortBTDecorator_GameplayAbility_CompareDistance");
static_assert(sizeof(UFortBTDecorator_GameplayAbility_CompareDistance) == 0x0000E8, "Wrong size on UFortBTDecorator_GameplayAbility_CompareDistance");
static_assert(offsetof(UFortBTDecorator_GameplayAbility_CompareDistance, DistanceComparisons) == 0x0000D8, "Member 'UFortBTDecorator_GameplayAbility_CompareDistance::DistanceComparisons' has a wrong offset!");

// Class FortniteGame.BuildingItemCollectorActor
// 0x00C0 (0x0900 - 0x0840)
class ABuildingItemCollectorActor final : public ABuildingGameplayActor
{
public:
	uint8                                         Pad_840[0x70];                                     // 0x0840(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	EFortItemCollectorBehavior                    ItemCollectorBehavior;                             // 0x08B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortItemCollectorState                       ItemCollectorState;                                // 0x08B1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortTeam                                     ControllingTeam;                                   // 0x08B2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8B3[0x5];                                      // 0x08B3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortWorldItemDefinition*               ItemToDeposit;                                     // 0x08B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            MaxDepositCurve;                                   // 0x08C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 TeamDepositAmounts;                                // 0x08C8(0x0010)(Edit, Net, ZeroConstructor, EditConst, RepNotify, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 TeamDepositGoals;                                  // 0x08D8(0x0010)(Edit, Net, ZeroConstructor, EditConst, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_8E8[0x18];                                     // 0x08E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetNumberOfTeamCaptures(EFortTeam InTeam);
	int32 GetTeamDepositAmount(EFortTeam InTeam);
	int32 GetTeamDepositGoal(EFortTeam InTeam);
	int32 GetTeamReachedGoalCount(EFortTeam InTeam);
	void OnItemCollectorStateChanged(EFortItemCollectorState InItemCollectorState);
	void OnRep_ControllingTeam();
	void OnRep_ItemCollectorState();
	void OnRep_TeamDepositAmounts();
	void OnRep_TeamDepositGoals();
	void OnTeamReachedDepositGoal(EFortTeam InControllingTeam);
	void SetItemCollectorState(EFortItemCollectorState InItemCollectorState);
	void UpdateTeamDepositValues(const TArray<int32>& DepositAmounts, const TArray<int32>& DepositGoals);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingItemCollectorActor">();
	}
	static class ABuildingItemCollectorActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingItemCollectorActor>();
	}
};
static_assert(alignof(ABuildingItemCollectorActor) == 0x000010, "Wrong alignment on ABuildingItemCollectorActor");
static_assert(sizeof(ABuildingItemCollectorActor) == 0x000900, "Wrong size on ABuildingItemCollectorActor");
static_assert(offsetof(ABuildingItemCollectorActor, ItemCollectorBehavior) == 0x0008B0, "Member 'ABuildingItemCollectorActor::ItemCollectorBehavior' has a wrong offset!");
static_assert(offsetof(ABuildingItemCollectorActor, ItemCollectorState) == 0x0008B1, "Member 'ABuildingItemCollectorActor::ItemCollectorState' has a wrong offset!");
static_assert(offsetof(ABuildingItemCollectorActor, ControllingTeam) == 0x0008B2, "Member 'ABuildingItemCollectorActor::ControllingTeam' has a wrong offset!");
static_assert(offsetof(ABuildingItemCollectorActor, ItemToDeposit) == 0x0008B8, "Member 'ABuildingItemCollectorActor::ItemToDeposit' has a wrong offset!");
static_assert(offsetof(ABuildingItemCollectorActor, MaxDepositCurve) == 0x0008C0, "Member 'ABuildingItemCollectorActor::MaxDepositCurve' has a wrong offset!");
static_assert(offsetof(ABuildingItemCollectorActor, TeamDepositAmounts) == 0x0008C8, "Member 'ABuildingItemCollectorActor::TeamDepositAmounts' has a wrong offset!");
static_assert(offsetof(ABuildingItemCollectorActor, TeamDepositGoals) == 0x0008D8, "Member 'ABuildingItemCollectorActor::TeamDepositGoals' has a wrong offset!");

// Class FortniteGame.DecoyActor
// 0x0010 (0x0850 - 0x0840)
class ADecoyActor final : public ABuildingGameplayActor
{
public:
	float                                         GoalOverrideRadius;                                // 0x0840(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_844[0xC];                                      // 0x0844(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DecoyActor">();
	}
	static class ADecoyActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADecoyActor>();
	}
};
static_assert(alignof(ADecoyActor) == 0x000010, "Wrong alignment on ADecoyActor");
static_assert(sizeof(ADecoyActor) == 0x000850, "Wrong size on ADecoyActor");
static_assert(offsetof(ADecoyActor, GoalOverrideRadius) == 0x000840, "Member 'ADecoyActor::GoalOverrideRadius' has a wrong offset!");

// Class FortniteGame.FortQueryContext_GoalProviderRootAssignmentGoals
// 0x0000 (0x0028 - 0x0028)
class UFortQueryContext_GoalProviderRootAssignmentGoals final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_GoalProviderRootAssignmentGoals">();
	}
	static class UFortQueryContext_GoalProviderRootAssignmentGoals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_GoalProviderRootAssignmentGoals>();
	}
};
static_assert(alignof(UFortQueryContext_GoalProviderRootAssignmentGoals) == 0x000008, "Wrong alignment on UFortQueryContext_GoalProviderRootAssignmentGoals");
static_assert(sizeof(UFortQueryContext_GoalProviderRootAssignmentGoals) == 0x000028, "Wrong size on UFortQueryContext_GoalProviderRootAssignmentGoals");

// Class FortniteGame.FortBTService_ContextOverride
// 0x0000 (0x0070 - 0x0070)
class UFortBTService_ContextOverride : public UBTService
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTService_ContextOverride">();
	}
	static class UFortBTService_ContextOverride* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTService_ContextOverride>();
	}
};
static_assert(alignof(UFortBTService_ContextOverride) == 0x000008, "Wrong alignment on UFortBTService_ContextOverride");
static_assert(sizeof(UFortBTService_ContextOverride) == 0x000070, "Wrong size on UFortBTService_ContextOverride");

// Class FortniteGame.FortBTContext_SuppressGoalUpdate
// 0x0008 (0x0078 - 0x0070)
class UFortBTContext_SuppressGoalUpdate final : public UFortBTService_ContextOverride
{
public:
	bool                                          bUnregisterFromGoalManager;                        // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTContext_SuppressGoalUpdate">();
	}
	static class UFortBTContext_SuppressGoalUpdate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTContext_SuppressGoalUpdate>();
	}
};
static_assert(alignof(UFortBTContext_SuppressGoalUpdate) == 0x000008, "Wrong alignment on UFortBTContext_SuppressGoalUpdate");
static_assert(sizeof(UFortBTContext_SuppressGoalUpdate) == 0x000078, "Wrong size on UFortBTContext_SuppressGoalUpdate");
static_assert(offsetof(UFortBTContext_SuppressGoalUpdate, bUnregisterFromGoalManager) == 0x000070, "Member 'UFortBTContext_SuppressGoalUpdate::bUnregisterFromGoalManager' has a wrong offset!");

// Class FortniteGame.DeployableBaseCore
// 0x0050 (0x0890 - 0x0840)
class ADeployableBaseCore final : public ABuildingGameplayActor
{
public:
	class ADeployableBasePlot*                    Plot;                                              // 0x0840(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UParticleSystem>         SimpleDeathParticles;                              // 0x0848(0x0020)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class USoundBase>              SimpleDeathSound;                                  // 0x0868(0x0020)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bRegisterAsGlobalGameplayEventListener : 1;        // 0x0888(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_889[0x7];                                      // 0x0889(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FTransform GetSimpleDeathFXTransform() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeployableBaseCore">();
	}
	static class ADeployableBaseCore* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADeployableBaseCore>();
	}
};
static_assert(alignof(ADeployableBaseCore) == 0x000010, "Wrong alignment on ADeployableBaseCore");
static_assert(sizeof(ADeployableBaseCore) == 0x000890, "Wrong size on ADeployableBaseCore");
static_assert(offsetof(ADeployableBaseCore, Plot) == 0x000840, "Member 'ADeployableBaseCore::Plot' has a wrong offset!");
static_assert(offsetof(ADeployableBaseCore, SimpleDeathParticles) == 0x000848, "Member 'ADeployableBaseCore::SimpleDeathParticles' has a wrong offset!");
static_assert(offsetof(ADeployableBaseCore, SimpleDeathSound) == 0x000868, "Member 'ADeployableBaseCore::SimpleDeathSound' has a wrong offset!");

// Class FortniteGame.FortInventoryOwnerInterface
// 0x0000 (0x0028 - 0x0028)
class IFortInventoryOwnerInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortInventoryOwnerInterface">();
	}
	static class IFortInventoryOwnerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortInventoryOwnerInterface>();
	}
};
static_assert(alignof(IFortInventoryOwnerInterface) == 0x000008, "Wrong alignment on IFortInventoryOwnerInterface");
static_assert(sizeof(IFortInventoryOwnerInterface) == 0x000028, "Wrong size on IFortInventoryOwnerInterface");

// Class FortniteGame.FortSafeZoneIndicator
// 0x01F0 (0x0578 - 0x0388)
class AFortSafeZoneIndicator final : public AActor
{
public:
	class UFortMiniMapComponent*                  MinimapComp;                                       // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0390(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastRadius;                                        // 0x0394(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NextRadius;                                        // 0x0398(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 LastCenter;                                        // 0x039C(0x000C)(BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 NextCenter;                                        // 0x03A8(0x000C)(BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, NativeAccessSpecifierPublic)
	float                                         SafeZoneStartShrinkTime;                           // 0x03B4(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SafeZoneFinishShrinkTime;                          // 0x03B8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3BC[0x4];                                      // 0x03BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            MiniMapIconBrush;                                  // 0x03C0(0x0090)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateBrush                            FarOffMiniMapIconBrush;                            // 0x0450(0x0090)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateBrush                            FullScreenMapIconBrush;                            // 0x04E0(0x0090)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_570[0x8];                                      // 0x0570(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetSafeZoneShrinkSpeed();
	void OnSafeZoneStateChange(EFortSafeZoneState NewState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortSafeZoneIndicator">();
	}
	static class AFortSafeZoneIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortSafeZoneIndicator>();
	}
};
static_assert(alignof(AFortSafeZoneIndicator) == 0x000008, "Wrong alignment on AFortSafeZoneIndicator");
static_assert(sizeof(AFortSafeZoneIndicator) == 0x000578, "Wrong size on AFortSafeZoneIndicator");
static_assert(offsetof(AFortSafeZoneIndicator, MinimapComp) == 0x000388, "Member 'AFortSafeZoneIndicator::MinimapComp' has a wrong offset!");
static_assert(offsetof(AFortSafeZoneIndicator, Radius) == 0x000390, "Member 'AFortSafeZoneIndicator::Radius' has a wrong offset!");
static_assert(offsetof(AFortSafeZoneIndicator, LastRadius) == 0x000394, "Member 'AFortSafeZoneIndicator::LastRadius' has a wrong offset!");
static_assert(offsetof(AFortSafeZoneIndicator, NextRadius) == 0x000398, "Member 'AFortSafeZoneIndicator::NextRadius' has a wrong offset!");
static_assert(offsetof(AFortSafeZoneIndicator, LastCenter) == 0x00039C, "Member 'AFortSafeZoneIndicator::LastCenter' has a wrong offset!");
static_assert(offsetof(AFortSafeZoneIndicator, NextCenter) == 0x0003A8, "Member 'AFortSafeZoneIndicator::NextCenter' has a wrong offset!");
static_assert(offsetof(AFortSafeZoneIndicator, SafeZoneStartShrinkTime) == 0x0003B4, "Member 'AFortSafeZoneIndicator::SafeZoneStartShrinkTime' has a wrong offset!");
static_assert(offsetof(AFortSafeZoneIndicator, SafeZoneFinishShrinkTime) == 0x0003B8, "Member 'AFortSafeZoneIndicator::SafeZoneFinishShrinkTime' has a wrong offset!");
static_assert(offsetof(AFortSafeZoneIndicator, MiniMapIconBrush) == 0x0003C0, "Member 'AFortSafeZoneIndicator::MiniMapIconBrush' has a wrong offset!");
static_assert(offsetof(AFortSafeZoneIndicator, FarOffMiniMapIconBrush) == 0x000450, "Member 'AFortSafeZoneIndicator::FarOffMiniMapIconBrush' has a wrong offset!");
static_assert(offsetof(AFortSafeZoneIndicator, FullScreenMapIconBrush) == 0x0004E0, "Member 'AFortSafeZoneIndicator::FullScreenMapIconBrush' has a wrong offset!");

// Class FortniteGame.FortQueryTest_InfluenceScore
// 0x0000 (0x01C0 - 0x01C0)
class UFortQueryTest_InfluenceScore final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_InfluenceScore">();
	}
	static class UFortQueryTest_InfluenceScore* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_InfluenceScore>();
	}
};
static_assert(alignof(UFortQueryTest_InfluenceScore) == 0x000008, "Wrong alignment on UFortQueryTest_InfluenceScore");
static_assert(sizeof(UFortQueryTest_InfluenceScore) == 0x0001C0, "Wrong size on UFortQueryTest_InfluenceScore");

// Class FortniteGame.FortInventoryInterface
// 0x0000 (0x0028 - 0x0028)
class IFortInventoryInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortInventoryInterface">();
	}
	static class IFortInventoryInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortInventoryInterface>();
	}
};
static_assert(alignof(IFortInventoryInterface) == 0x000008, "Wrong alignment on IFortInventoryInterface");
static_assert(sizeof(IFortInventoryInterface) == 0x000028, "Wrong size on IFortInventoryInterface");

// Class FortniteGame.FortInventory
// 0x0200 (0x0588 - 0x0388)
class AFortInventory final : public AActor
{
public:
	uint8                                         Pad_388[0x8];                                      // 0x0388(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EFortInventoryType                            InventoryType;                                     // 0x0390(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEnforcesMaxNumStackRules;                         // 0x0391(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_392[0x6];                                      // 0x0392(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAttribute                     InventoryMaxSizeAttribute;                         // 0x0398(0x0020)(Net, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortAccountItemDefinition*             InventoryMaxSizeToken;                             // 0x03B8(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFortItemList                          Inventory;                                         // 0x03C0(0x0170)(Net, SaveGame, RepNotify, NativeAccessSpecifierPrivate)
	bool                                          bRequiresLocalUpdate;                              // 0x0530(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRequiresSaving;                                   // 0x0531(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsShuttingDown;                                   // 0x0532(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_533[0x15];                                     // 0x0533(0x0015)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UFortWorldItem*>                 PendingInstances;                                  // 0x0548(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UFortItem*>                      RecentlyAdded;                                     // 0x0558(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UFortItem*>                      RecentlyRemoved;                                   // 0x0568(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UFortItem*>                      RecentlyChanged;                                   // 0x0578(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void HandleInventoryAttributeChange();
	void HandleInventoryLocalUpdate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortInventory">();
	}
	static class AFortInventory* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortInventory>();
	}
};
static_assert(alignof(AFortInventory) == 0x000008, "Wrong alignment on AFortInventory");
static_assert(sizeof(AFortInventory) == 0x000588, "Wrong size on AFortInventory");
static_assert(offsetof(AFortInventory, InventoryType) == 0x000390, "Member 'AFortInventory::InventoryType' has a wrong offset!");
static_assert(offsetof(AFortInventory, bEnforcesMaxNumStackRules) == 0x000391, "Member 'AFortInventory::bEnforcesMaxNumStackRules' has a wrong offset!");
static_assert(offsetof(AFortInventory, InventoryMaxSizeAttribute) == 0x000398, "Member 'AFortInventory::InventoryMaxSizeAttribute' has a wrong offset!");
static_assert(offsetof(AFortInventory, InventoryMaxSizeToken) == 0x0003B8, "Member 'AFortInventory::InventoryMaxSizeToken' has a wrong offset!");
static_assert(offsetof(AFortInventory, Inventory) == 0x0003C0, "Member 'AFortInventory::Inventory' has a wrong offset!");
static_assert(offsetof(AFortInventory, bRequiresLocalUpdate) == 0x000530, "Member 'AFortInventory::bRequiresLocalUpdate' has a wrong offset!");
static_assert(offsetof(AFortInventory, bRequiresSaving) == 0x000531, "Member 'AFortInventory::bRequiresSaving' has a wrong offset!");
static_assert(offsetof(AFortInventory, bIsShuttingDown) == 0x000532, "Member 'AFortInventory::bIsShuttingDown' has a wrong offset!");
static_assert(offsetof(AFortInventory, PendingInstances) == 0x000548, "Member 'AFortInventory::PendingInstances' has a wrong offset!");
static_assert(offsetof(AFortInventory, RecentlyAdded) == 0x000558, "Member 'AFortInventory::RecentlyAdded' has a wrong offset!");
static_assert(offsetof(AFortInventory, RecentlyRemoved) == 0x000568, "Member 'AFortInventory::RecentlyRemoved' has a wrong offset!");
static_assert(offsetof(AFortInventory, RecentlyChanged) == 0x000578, "Member 'AFortInventory::RecentlyChanged' has a wrong offset!");

// Class FortniteGame.FortPlayerCameraBase
// 0x05B0 (0x1F80 - 0x19D0)
#pragma pack(push, 0x1)
class alignas(0x10) AFortPlayerCameraBase : public APlayerCameraManager
{
public:
	TArray<struct FActiveFortCamera>              CameraBlendStack;                                  // 0x19C8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortCameraInstanceEntry>       CameraInstances;                                   // 0x19D8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortCameraMode>            Base3PClass;                                       // 0x19E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UFortCameraMode>            Targeting3PClass;                                  // 0x19F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UFortCameraMode>            OverrideCameraClass;                               // 0x19F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UFortCinematicCamera>       CinematicCameraClass;                              // 0x1A00(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UFortCameraMode>            DBNOCameraClass;                                   // 0x1A08(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UFortCameraMode>            DeathCameraClass;                                  // 0x1A10(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UFortCameraMode>            SkydiveGlideCameraClass;                           // 0x1A18(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UFortCameraMode>            SkydiveDiveCameraClass;                            // 0x1A20(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UFortCameraMode>            SkydiveParachuteCameraClass;                       // 0x1A28(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFortCameraPrototype>           CameraPrototypes;                                  // 0x1A30(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class APostProcessVolume*                     ZoomPostProcessVolume;                             // 0x1A40(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A48[0x530];                                   // 0x1A48(0x0530)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerCameraBase">();
	}
	static class AFortPlayerCameraBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerCameraBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(AFortPlayerCameraBase) == 0x000010, "Wrong alignment on AFortPlayerCameraBase");
static_assert(sizeof(AFortPlayerCameraBase) == 0x001F80, "Wrong size on AFortPlayerCameraBase");
static_assert(offsetof(AFortPlayerCameraBase, CameraBlendStack) == 0x0019C8, "Member 'AFortPlayerCameraBase::CameraBlendStack' has a wrong offset!");
static_assert(offsetof(AFortPlayerCameraBase, CameraInstances) == 0x0019D8, "Member 'AFortPlayerCameraBase::CameraInstances' has a wrong offset!");
static_assert(offsetof(AFortPlayerCameraBase, Base3PClass) == 0x0019E8, "Member 'AFortPlayerCameraBase::Base3PClass' has a wrong offset!");
static_assert(offsetof(AFortPlayerCameraBase, Targeting3PClass) == 0x0019F0, "Member 'AFortPlayerCameraBase::Targeting3PClass' has a wrong offset!");
static_assert(offsetof(AFortPlayerCameraBase, OverrideCameraClass) == 0x0019F8, "Member 'AFortPlayerCameraBase::OverrideCameraClass' has a wrong offset!");
static_assert(offsetof(AFortPlayerCameraBase, CinematicCameraClass) == 0x001A00, "Member 'AFortPlayerCameraBase::CinematicCameraClass' has a wrong offset!");
static_assert(offsetof(AFortPlayerCameraBase, DBNOCameraClass) == 0x001A08, "Member 'AFortPlayerCameraBase::DBNOCameraClass' has a wrong offset!");
static_assert(offsetof(AFortPlayerCameraBase, DeathCameraClass) == 0x001A10, "Member 'AFortPlayerCameraBase::DeathCameraClass' has a wrong offset!");
static_assert(offsetof(AFortPlayerCameraBase, SkydiveGlideCameraClass) == 0x001A18, "Member 'AFortPlayerCameraBase::SkydiveGlideCameraClass' has a wrong offset!");
static_assert(offsetof(AFortPlayerCameraBase, SkydiveDiveCameraClass) == 0x001A20, "Member 'AFortPlayerCameraBase::SkydiveDiveCameraClass' has a wrong offset!");
static_assert(offsetof(AFortPlayerCameraBase, SkydiveParachuteCameraClass) == 0x001A28, "Member 'AFortPlayerCameraBase::SkydiveParachuteCameraClass' has a wrong offset!");
static_assert(offsetof(AFortPlayerCameraBase, CameraPrototypes) == 0x001A30, "Member 'AFortPlayerCameraBase::CameraPrototypes' has a wrong offset!");
static_assert(offsetof(AFortPlayerCameraBase, ZoomPostProcessVolume) == 0x001A40, "Member 'AFortPlayerCameraBase::ZoomPostProcessVolume' has a wrong offset!");

// Class FortniteGame.DeployableBasePlot
// 0x02C0 (0x0B00 - 0x0840)
class ADeployableBasePlot final : public ABuildingGameplayActor
{
public:
	uint8                                         Pad_840[0x8];                                      // 0x0840(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUniqueNetIdRepl                       OccupantNetID;                                     // 0x0848(0x0018)(Net, Transient, RepNotify, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFortCloudSaveInfo                     OccupantNextCloudSaveInfo;                         // 0x0860(0x0018)(Transient, Protected, NativeAccessSpecifierProtected)
	class UFortDeployableBaseRecord*              OccupantDeployableBaseRecord;                      // 0x0878(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          BuildableSpaceComponent;                           // 0x0880(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          SavableSpaceComponent;                             // 0x0888(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          EntirePlotSpaceComponent;                          // 0x0890(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        SpawnOffsetComponent;                              // 0x0898(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          BuildableAreasArray[0x3];                          // 0x08A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   DeployableBaseCoreClass;                           // 0x08B8(0x0020)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ADeployableBaseCore*                    DeployableBaseCore;                                // 0x08D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bDirty : 1;                                        // 0x08E0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDirtiedSinceLastWriteToBuffer : 1;                // 0x08E0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCloudFileSavedSinceLastCloudItemUpdate : 1;       // 0x08E0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_8E1[0x3];                                      // 0x08E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EDeployableBaseBuildingState                  CurrentBuildingState;                              // 0x08E4(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDeployableBaseBuildingState                  GoalBuildingState;                                 // 0x08E5(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8E6[0x4A];                                     // 0x08E6(0x004A)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnOccupantIdChanged;                               // 0x0930(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnDeployableBaseCoreCreated;                       // 0x0940(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnDeployableBaseCoreDestroyed;                     // 0x0950(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnDeployableBasePlotSpacesChanged;                 // 0x0960(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TArray<class AFortDeployableBasePickup*>      OutstandingAssociatedPickups;                      // 0x0970(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class AFortInventory*                         PlotInventory;                                     // 0x0980(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_988[0x78];                                     // 0x0988(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DeferredActorIdxToResumeAt;                        // 0x0A00(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumActorsFromRecordDestroyed;                      // 0x0A04(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FIntVector                             BuildableSpaceExpansionVector;                     // 0x0A08(0x000C)(Net, Transient, RepNotify, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxActorsToCreatePerBuildingCall;                  // 0x0A14(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxActorsToDestroyPerDestroyCall;                  // 0x0A18(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DelayBetweenActorRecordBuilding;                   // 0x0A1C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DelayBetweenActorRecordDestroying;                 // 0x0A20(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A24[0x4];                                      // 0x0A24(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortPlayerStart*                       PlayerStart;                                       // 0x0A28(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            ConstructionTimeEffect;                            // 0x0A30(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FDeferredActorData>             DeferredConstructionActors;                        // 0x0A38(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A48[0x8];                                      // 0x0A48(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBox                                   BuildableAreasStructuralSupportBoxesArray[0x3];    // 0x0A50(0x001C)(Net, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AA4[0x5C];                                     // 0x0AA4(0x005C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AFortPlayerStart* GetPlayerStart();
	void HandleBuildingStateTransition(EDeployableBaseBuildingState InPreviousState, EDeployableBaseBuildingState InCurrentState);
	void OnBuildingStateTransition(EDeployableBaseBuildingState InPreviousState, EDeployableBaseBuildingState InCurrentState);
	void OnCurrentBuildingStateSet(EDeployableBaseBuildingState InCurrentBuildingState);
	void OnRep_BuildableSpaceExpansionVector();
	void OnRep_CurrentBuildingState();
	void OnRep_OccupantNetID();

	int32 GetNumOfItemsInPlot() const;
	const struct FUniqueNetIdRepl GetOccupantNetID() const;
	bool IsBuildingActorWithinBuildableSpace(const class ABuildingActor* ActorToCheck, const struct FVector& GridLocation) const;
	bool IsOccupant(const struct FUniqueNetIdRepl& UserId) const;
	bool IsOccupied() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeployableBasePlot">();
	}
	static class ADeployableBasePlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADeployableBasePlot>();
	}
};
static_assert(alignof(ADeployableBasePlot) == 0x000010, "Wrong alignment on ADeployableBasePlot");
static_assert(sizeof(ADeployableBasePlot) == 0x000B00, "Wrong size on ADeployableBasePlot");
static_assert(offsetof(ADeployableBasePlot, OccupantNetID) == 0x000848, "Member 'ADeployableBasePlot::OccupantNetID' has a wrong offset!");
static_assert(offsetof(ADeployableBasePlot, OccupantNextCloudSaveInfo) == 0x000860, "Member 'ADeployableBasePlot::OccupantNextCloudSaveInfo' has a wrong offset!");
static_assert(offsetof(ADeployableBasePlot, OccupantDeployableBaseRecord) == 0x000878, "Member 'ADeployableBasePlot::OccupantDeployableBaseRecord' has a wrong offset!");
static_assert(offsetof(ADeployableBasePlot, BuildableSpaceComponent) == 0x000880, "Member 'ADeployableBasePlot::BuildableSpaceComponent' has a wrong offset!");
static_assert(offsetof(ADeployableBasePlot, SavableSpaceComponent) == 0x000888, "Member 'ADeployableBasePlot::SavableSpaceComponent' has a wrong offset!");
static_assert(offsetof(ADeployableBasePlot, EntirePlotSpaceComponent) == 0x000890, "Member 'ADeployableBasePlot::EntirePlotSpaceComponent' has a wrong offset!");
static_assert(offsetof(ADeployableBasePlot, SpawnOffsetComponent) == 0x000898, "Member 'ADeployableBasePlot::SpawnOffsetComponent' has a wrong offset!");
static_assert(offsetof(ADeployableBasePlot, BuildableAreasArray) == 0x0008A0, "Member 'ADeployableBasePlot::BuildableAreasArray' has a wrong offset!");
static_assert(offsetof(ADeployableBasePlot, DeployableBaseCoreClass) == 0x0008B8, "Member 'ADeployableBasePlot::DeployableBaseCoreClass' has a wrong offset!");
static_assert(offsetof(ADeployableBasePlot, DeployableBaseCore) == 0x0008D8, "Member 'ADeployableBasePlot::DeployableBaseCore' has a wrong offset!");
static_assert(offsetof(ADeployableBasePlot, CurrentBuildingState) == 0x0008E4, "Member 'ADeployableBasePlot::CurrentBuildingState' has a wrong offset!");
static_assert(offsetof(ADeployableBasePlot, GoalBuildingState) == 0x0008E5, "Member 'ADeployableBasePlot::GoalBuildingState' has a wrong offset!");
static_assert(offsetof(ADeployableBasePlot, OnOccupantIdChanged) == 0x000930, "Member 'ADeployableBasePlot::OnOccupantIdChanged' has a wrong offset!");
static_assert(offsetof(ADeployableBasePlot, OnDeployableBaseCoreCreated) == 0x000940, "Member 'ADeployableBasePlot::OnDeployableBaseCoreCreated' has a wrong offset!");
static_assert(offsetof(ADeployableBasePlot, OnDeployableBaseCoreDestroyed) == 0x000950, "Member 'ADeployableBasePlot::OnDeployableBaseCoreDestroyed' has a wrong offset!");
static_assert(offsetof(ADeployableBasePlot, OnDeployableBasePlotSpacesChanged) == 0x000960, "Member 'ADeployableBasePlot::OnDeployableBasePlotSpacesChanged' has a wrong offset!");
static_assert(offsetof(ADeployableBasePlot, OutstandingAssociatedPickups) == 0x000970, "Member 'ADeployableBasePlot::OutstandingAssociatedPickups' has a wrong offset!");
static_assert(offsetof(ADeployableBasePlot, PlotInventory) == 0x000980, "Member 'ADeployableBasePlot::PlotInventory' has a wrong offset!");
static_assert(offsetof(ADeployableBasePlot, DeferredActorIdxToResumeAt) == 0x000A00, "Member 'ADeployableBasePlot::DeferredActorIdxToResumeAt' has a wrong offset!");
static_assert(offsetof(ADeployableBasePlot, NumActorsFromRecordDestroyed) == 0x000A04, "Member 'ADeployableBasePlot::NumActorsFromRecordDestroyed' has a wrong offset!");
static_assert(offsetof(ADeployableBasePlot, BuildableSpaceExpansionVector) == 0x000A08, "Member 'ADeployableBasePlot::BuildableSpaceExpansionVector' has a wrong offset!");
static_assert(offsetof(ADeployableBasePlot, MaxActorsToCreatePerBuildingCall) == 0x000A14, "Member 'ADeployableBasePlot::MaxActorsToCreatePerBuildingCall' has a wrong offset!");
static_assert(offsetof(ADeployableBasePlot, MaxActorsToDestroyPerDestroyCall) == 0x000A18, "Member 'ADeployableBasePlot::MaxActorsToDestroyPerDestroyCall' has a wrong offset!");
static_assert(offsetof(ADeployableBasePlot, DelayBetweenActorRecordBuilding) == 0x000A1C, "Member 'ADeployableBasePlot::DelayBetweenActorRecordBuilding' has a wrong offset!");
static_assert(offsetof(ADeployableBasePlot, DelayBetweenActorRecordDestroying) == 0x000A20, "Member 'ADeployableBasePlot::DelayBetweenActorRecordDestroying' has a wrong offset!");
static_assert(offsetof(ADeployableBasePlot, PlayerStart) == 0x000A28, "Member 'ADeployableBasePlot::PlayerStart' has a wrong offset!");
static_assert(offsetof(ADeployableBasePlot, ConstructionTimeEffect) == 0x000A30, "Member 'ADeployableBasePlot::ConstructionTimeEffect' has a wrong offset!");
static_assert(offsetof(ADeployableBasePlot, DeferredConstructionActors) == 0x000A38, "Member 'ADeployableBasePlot::DeferredConstructionActors' has a wrong offset!");
static_assert(offsetof(ADeployableBasePlot, BuildableAreasStructuralSupportBoxesArray) == 0x000A50, "Member 'ADeployableBasePlot::BuildableAreasStructuralSupportBoxesArray' has a wrong offset!");

// Class FortniteGame.FortAthenaSupplyDrop
// 0x0010 (0x0850 - 0x0840)
class AFortAthenaSupplyDrop final : public ABuildingGameplayActor
{
public:
	struct FCollisionProfileName                  GroundCollsionProfile;                             // 0x0840(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_848[0x8];                                      // 0x0848(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GroundTrace(const struct FVector& TraceStart, const struct FVector& TraceEnd, struct FHitResult* OutHit) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaSupplyDrop">();
	}
	static class AFortAthenaSupplyDrop* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAthenaSupplyDrop>();
	}
};
static_assert(alignof(AFortAthenaSupplyDrop) == 0x000010, "Wrong alignment on AFortAthenaSupplyDrop");
static_assert(sizeof(AFortAthenaSupplyDrop) == 0x000850, "Wrong size on AFortAthenaSupplyDrop");
static_assert(offsetof(AFortAthenaSupplyDrop, GroundCollsionProfile) == 0x000840, "Member 'AFortAthenaSupplyDrop::GroundCollsionProfile' has a wrong offset!");

// Class FortniteGame.FortQueryTest_Random
// 0x0008 (0x01C8 - 0x01C0)
class UFortQueryTest_Random final : public UEnvQueryTest
{
public:
	uint8                                         bUseRandomSeedForAI : 1;                           // 0x01C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseRandomSeedForOthers : 1;                       // 0x01C0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1C1[0x7];                                      // 0x01C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_Random">();
	}
	static class UFortQueryTest_Random* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_Random>();
	}
};
static_assert(alignof(UFortQueryTest_Random) == 0x000008, "Wrong alignment on UFortQueryTest_Random");
static_assert(sizeof(UFortQueryTest_Random) == 0x0001C8, "Wrong size on UFortQueryTest_Random");

// Class FortniteGame.FortBTContext_MoveUrgency
// 0x0008 (0x0078 - 0x0070)
class UFortBTContext_MoveUrgency final : public UFortBTService_ContextOverride
{
public:
	EFortMovementUrgency                          MoveUrgency;                                       // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTContext_MoveUrgency">();
	}
	static class UFortBTContext_MoveUrgency* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTContext_MoveUrgency>();
	}
};
static_assert(alignof(UFortBTContext_MoveUrgency) == 0x000008, "Wrong alignment on UFortBTContext_MoveUrgency");
static_assert(sizeof(UFortBTContext_MoveUrgency) == 0x000078, "Wrong size on UFortBTContext_MoveUrgency");
static_assert(offsetof(UFortBTContext_MoveUrgency, MoveUrgency) == 0x000070, "Member 'UFortBTContext_MoveUrgency::MoveUrgency' has a wrong offset!");

// Class FortniteGame.SBAGrantedBuildingGameplayActor
// 0x0010 (0x0850 - 0x0840)
class ASBAGrantedBuildingGameplayActor final : public ABuildingGameplayActor
{
public:
	struct FTeamStrategicBuildingHandle           OwningSBAHandle;                                   // 0x0840(0x0004)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_844[0xC];                                      // 0x0844(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AStrategicBuildingActor* GetOwnerStrategicBuildingActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SBAGrantedBuildingGameplayActor">();
	}
	static class ASBAGrantedBuildingGameplayActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASBAGrantedBuildingGameplayActor>();
	}
};
static_assert(alignof(ASBAGrantedBuildingGameplayActor) == 0x000010, "Wrong alignment on ASBAGrantedBuildingGameplayActor");
static_assert(sizeof(ASBAGrantedBuildingGameplayActor) == 0x000850, "Wrong size on ASBAGrantedBuildingGameplayActor");
static_assert(offsetof(ASBAGrantedBuildingGameplayActor, OwningSBAHandle) == 0x000840, "Member 'ASBAGrantedBuildingGameplayActor::OwningSBAHandle' has a wrong offset!");

// Class FortniteGame.FortIndicator
// 0x0028 (0x0050 - 0x0028)
class UFortIndicator : public UObject
{
public:
	struct FVector                                RelativeLocation;                                  // 0x0028(0x000C)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x0034(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnParentActorEndPlay(class AActor* Actor, EEndPlayReason EndPlayReason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortIndicator">();
	}
	static class UFortIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortIndicator>();
	}
};
static_assert(alignof(UFortIndicator) == 0x000008, "Wrong alignment on UFortIndicator");
static_assert(sizeof(UFortIndicator) == 0x000050, "Wrong size on UFortIndicator");
static_assert(offsetof(UFortIndicator, RelativeLocation) == 0x000028, "Member 'UFortIndicator::RelativeLocation' has a wrong offset!");
static_assert(offsetof(UFortIndicator, MaxDistance) == 0x000034, "Member 'UFortIndicator::MaxDistance' has a wrong offset!");

// Class FortniteGame.FortReplaySpectatorCameraComponent
// 0x0070 (0x0840 - 0x07D0)
#pragma pack(push, 0x1)
class alignas(0x10) UFortReplaySpectatorCameraComponent : public UCameraComponent
{
public:
	class AFortReplaySpectator*                   SpectatorController;                               // 0x07D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D8[0xC];                                      // 0x07D8(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	EFocusMethod                                  FocusMethod;                                       // 0x07E4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7E5[0x3];                                      // 0x07E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ManualFocusDistance;                               // 0x07E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AutoFocusInterpSpeed;                              // 0x07EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraApertureFStop;                               // 0x07F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7F4[0x4];                                      // 0x07F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           ScreenFringeFOVCurve;                              // 0x07F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ZoomRate;                                          // 0x0800(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FOVInterpSpeed;                                    // 0x0804(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxFOV;                                            // 0x0808(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinFOV;                                            // 0x080C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_810[0x28];                                     // 0x0810(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortReplaySpectatorCameraComponent">();
	}
	static class UFortReplaySpectatorCameraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortReplaySpectatorCameraComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UFortReplaySpectatorCameraComponent) == 0x000010, "Wrong alignment on UFortReplaySpectatorCameraComponent");
static_assert(sizeof(UFortReplaySpectatorCameraComponent) == 0x000840, "Wrong size on UFortReplaySpectatorCameraComponent");
static_assert(offsetof(UFortReplaySpectatorCameraComponent, SpectatorController) == 0x0007D0, "Member 'UFortReplaySpectatorCameraComponent::SpectatorController' has a wrong offset!");
static_assert(offsetof(UFortReplaySpectatorCameraComponent, FocusMethod) == 0x0007E4, "Member 'UFortReplaySpectatorCameraComponent::FocusMethod' has a wrong offset!");
static_assert(offsetof(UFortReplaySpectatorCameraComponent, ManualFocusDistance) == 0x0007E8, "Member 'UFortReplaySpectatorCameraComponent::ManualFocusDistance' has a wrong offset!");
static_assert(offsetof(UFortReplaySpectatorCameraComponent, AutoFocusInterpSpeed) == 0x0007EC, "Member 'UFortReplaySpectatorCameraComponent::AutoFocusInterpSpeed' has a wrong offset!");
static_assert(offsetof(UFortReplaySpectatorCameraComponent, CameraApertureFStop) == 0x0007F0, "Member 'UFortReplaySpectatorCameraComponent::CameraApertureFStop' has a wrong offset!");
static_assert(offsetof(UFortReplaySpectatorCameraComponent, ScreenFringeFOVCurve) == 0x0007F8, "Member 'UFortReplaySpectatorCameraComponent::ScreenFringeFOVCurve' has a wrong offset!");
static_assert(offsetof(UFortReplaySpectatorCameraComponent, ZoomRate) == 0x000800, "Member 'UFortReplaySpectatorCameraComponent::ZoomRate' has a wrong offset!");
static_assert(offsetof(UFortReplaySpectatorCameraComponent, FOVInterpSpeed) == 0x000804, "Member 'UFortReplaySpectatorCameraComponent::FOVInterpSpeed' has a wrong offset!");
static_assert(offsetof(UFortReplaySpectatorCameraComponent, MaxFOV) == 0x000808, "Member 'UFortReplaySpectatorCameraComponent::MaxFOV' has a wrong offset!");
static_assert(offsetof(UFortReplaySpectatorCameraComponent, MinFOV) == 0x00080C, "Member 'UFortReplaySpectatorCameraComponent::MinFOV' has a wrong offset!");

// Class FortniteGame.FortQuestCategory
// 0x0060 (0x0088 - 0x0028)
class UFortQuestCategory final : public UObject
{
public:
	class FText                                   Name_0;                                            // 0x0028(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<class UFortQuestItem*>                 CurrentQuests;                                     // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bExpanded;                                         // 0x0050(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortCategoryTableRow                  CategoryInfo;                                      // 0x0058(0x0028)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool HasUnseenQuests() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQuestCategory">();
	}
	static class UFortQuestCategory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQuestCategory>();
	}
};
static_assert(alignof(UFortQuestCategory) == 0x000008, "Wrong alignment on UFortQuestCategory");
static_assert(sizeof(UFortQuestCategory) == 0x000088, "Wrong size on UFortQuestCategory");
static_assert(offsetof(UFortQuestCategory, Name_0) == 0x000028, "Member 'UFortQuestCategory::Name_0' has a wrong offset!");
static_assert(offsetof(UFortQuestCategory, CurrentQuests) == 0x000040, "Member 'UFortQuestCategory::CurrentQuests' has a wrong offset!");
static_assert(offsetof(UFortQuestCategory, bExpanded) == 0x000050, "Member 'UFortQuestCategory::bExpanded' has a wrong offset!");
static_assert(offsetof(UFortQuestCategory, CategoryInfo) == 0x000058, "Member 'UFortQuestCategory::CategoryInfo' has a wrong offset!");

// Class FortniteGame.FortVisibilityComponent
// 0x0020 (0x0110 - 0x00F0)
class UFortVisibilityComponent : public UActorComponent
{
public:
	uint8                                         bRegisterWithVisibilityManager : 1;                // 0x00F0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bObserver : 1;                                     // 0x00F0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDistanceCheck2D : 1;                              // 0x00F0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCheckFacing : 1;                                  // 0x00F0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCheckLOS : 1;                                     // 0x00F0(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bRevealWithMap : 1;                                // 0x00F0(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EFortVisibilityBehavior                       VisibilityBehavior;                                // 0x00F4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F5[0x3];                                       // 0x00F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnVisibilityChangedEvent;                          // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	float                                         Radius;                                            // 0x0108(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortVisibilityComponent">();
	}
	static class UFortVisibilityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortVisibilityComponent>();
	}
};
static_assert(alignof(UFortVisibilityComponent) == 0x000008, "Wrong alignment on UFortVisibilityComponent");
static_assert(sizeof(UFortVisibilityComponent) == 0x000110, "Wrong size on UFortVisibilityComponent");
static_assert(offsetof(UFortVisibilityComponent, VisibilityBehavior) == 0x0000F4, "Member 'UFortVisibilityComponent::VisibilityBehavior' has a wrong offset!");
static_assert(offsetof(UFortVisibilityComponent, OnVisibilityChangedEvent) == 0x0000F8, "Member 'UFortVisibilityComponent::OnVisibilityChangedEvent' has a wrong offset!");
static_assert(offsetof(UFortVisibilityComponent, Radius) == 0x000108, "Member 'UFortVisibilityComponent::Radius' has a wrong offset!");

// Class FortniteGame.FortMiniMapIndicator
// 0x02C8 (0x0318 - 0x0050)
#pragma pack(push, 0x1)
class alignas(0x08) UFortMiniMapIndicator : public UFortIndicator
{
public:
	uint8                                         Pad_50[0x2C1];                                     // 0x0050(0x02C1)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bForceHidden;                                      // 0x0311(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_312[0x6];                                      // 0x0312(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMiniMapIndicator">();
	}
	static class UFortMiniMapIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMiniMapIndicator>();
	}
};
#pragma pack(pop)
static_assert(alignof(UFortMiniMapIndicator) == 0x000008, "Wrong alignment on UFortMiniMapIndicator");
static_assert(sizeof(UFortMiniMapIndicator) == 0x000318, "Wrong size on UFortMiniMapIndicator");
static_assert(offsetof(UFortMiniMapIndicator, bForceHidden) == 0x000311, "Member 'UFortMiniMapIndicator::bForceHidden' has a wrong offset!");

// Class FortniteGame.FortGameplayAbility
// 0x04B8 (0x0A40 - 0x0588)
class UFortGameplayAbility : public UGameplayAbility
{
public:
	uint8                                         Pad_588[0x10];                                     // 0x0588(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	EFortGameplayAbilityActivation                ActivationType;                                    // 0x0598(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_599[0x7];                                      // 0x0599(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortGameplayEffectContainer           EffectContainers[0x5];                             // 0x05A0(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FFortGameplayEffectContainer>   GameplayEffectContainers;                          // 0x0848(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  OwnerPreviewImageOverrideTags;                     // 0x0858(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSubclassOf<class AFortProjectileBase>        ProjectileClass;                                   // 0x0878(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    DamageStatHandle;                                  // 0x0880(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FFortAbilityCost>               AbilityCosts;                                      // 0x0890(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         bShowWidgetForCosts : 1;                           // 0x08A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bStartWithCooldown : 1;                            // 0x08A0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPersistOnDeath : 1;                               // 0x08A0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bStopsAIBehaviorLogic : 1;                         // 0x08A0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bStopsAIMovement : 1;                              // 0x08A0(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bStopsRVOAvoidance : 1;                            // 0x08A0(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bForceNormalAILOD : 1;                             // 0x08A0(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_8A1[0x3];                                      // 0x08A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EFortAILODLevel                               MinimumRequiredAILODLevel;                         // 0x08A4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8A5[0x3];                                      // 0x08A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         BitPad_8A8_0 : 3;                                  // 0x08A8(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bRelevantForAIDespawning : 1;                      // 0x08A8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseAIFireLocationAndRotation : 1;                 // 0x08A8(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_8A9[0x3];                                      // 0x08A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EFortAIWeaponUsage                            AIWeaponUsage;                                     // 0x08AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8AD[0x3];                                      // 0x08AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           WeaponTestApplicationTag;                          // 0x08B0(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bVerifyFireOffsetIsNotObstructedByWorldGeometry : 1; // 0x08B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanHitBallisticTestsOnlyTestIndesructiblesWhileFalling : 1; // 0x08B8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_8B9[0x3];                                      // 0x08B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                FireOffset;                                        // 0x08BC(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActivationNoiseRange;                              // 0x08C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactNoiseRange;                                  // 0x08CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActivationNoiseLoudness;                           // 0x08D0(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactNoiseLoudness;                               // 0x08D4(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ProhibitedTargetTags;                              // 0x08D8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_8F8[0x1];                                      // 0x08F8(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bLeadPawnTargets;                                  // 0x08F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8FA[0x2];                                      // 0x08FA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DesiredThrowAngle;                                 // 0x08FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxYawAngleToFire;                                 // 0x0900(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClampMaxYawAngleToFire;                           // 0x0904(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseTargetActorLocation;                           // 0x0905(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_906[0x2];                                      // 0x0906(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialAccuracyMax;                                // 0x0908(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialAccuracyMin;                                // 0x090C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetAccuracyMax;                                 // 0x0910(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetAccuracyMin;                                 // 0x0914(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinAccuracyDistance;                               // 0x0918(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAccuracyDistance;                               // 0x091C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccuracyDistanceMultiplier;                        // 0x0920(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumUsesToReachTargetAccuracy;                      // 0x0924(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UseCount;                                          // 0x0928(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_92C[0x4];                                      // 0x092C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFortGameplayAbilityBehaviorDistanceData> GameplayAbilityBehaviorDistanceData;               // 0x0930(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_940[0x20];                                     // 0x0940(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortGameplayAbilityMontageInfo        MontageInfo;                                       // 0x0960(0x0060)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x09C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x09D8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_9F0[0x8];                                      // 0x09F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             SmallPreviewImageOverride;                         // 0x09F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A00[0x8];                                      // 0x0A00(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UFortTooltip>               Tooltip;                                           // 0x0A08(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortTooltipDisplayStatsList*           StatList;                                          // 0x0A10(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A18[0x28];                                     // 0x0A18(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void CalculateProjectileTrajectorySpline(TArray<struct FVector>* OutSplinePoints, TArray<struct FVector>* OutSplineTangents, const class AActor* Instigator, const struct FVector& InitialLocation, const struct FVector& InitialVelocity, float Gravity, float Friction, float Bounciness, float TimeStep, float TraceExtent);

	const TArray<struct FActiveGameplayEffectHandle> ApplyGameplayEffectContainer(const struct FGameplayAbilityTargetDataHandle& TargetData, const struct FGameplayTag& ApplicationTag, int32 GameplayEffectLevel);
	struct FFortGameplayEffectContainer BP_GetGameplayEffectContainer(const struct FGameplayTag& ApplicationTag);
	void ClearAIFocalPoint(bool bUseAttackingPriority);
	void EquipAbilityWeapon(class UFortWeaponItemDefinition* WeaponDefinition, int32 ItemLevel);
	struct FVector GetAimLocationNearestPawn(class AFortPawn* Instigator);
	void K2_AbilityCompleted();
	void K2_TriggerFromAnimation(const struct FGameplayTag& ApplicationTag);
	struct FFortGameplayEffectContainerSpec MakeGameplayEffectContainerSpec(const struct FGameplayTag& ApplicationTag, int32 GameplayEffectLevel);
	void OnAbilityInputReleased();
	void SetAIFocalPoint(class AActor* FocusTarget, const struct FVector& FocalPoint, bool bUseAttackingPriority);
	bool SetupPreviewImageOverride();

	struct FVector ApplyAccuracyToTargetLocation(const struct FVector& SourceLocation, const struct FVector& TargetLocation, float inDesiredThrowAngle) const;
	bool DoesTargetHaveProhibitedTagsForAI(const class AActor* Target) const;
	bool DoesTargetHaveTags(const class AActor* Target, const struct FGameplayTagContainer& Tags) const;
	class UFortAbilitySystemComponent* GetActivatingAbilityComponent() const;
	class AFortPawn* GetActivatingPawn() const;
	class AActor* GetAIAbilityTarget() const;
	void GetCurrentAbilitySourceLevel(float* OutSourceLevel) const;
	class UFortWorldItemDefinition* GetCurrentSourceItemDefinition() const;
	class AFortWeapon* GetCurrentSourceWeapon() const;
	struct FTransform GetCustomAbilitySourceTransform() const;
	class UFortTooltipDisplayStatsList* GetDisplayStats() const;
	struct FVector GetFireLocation() const;
	struct FRotator GetFireRotation(bool bApplyLeading, bool bApplyInaccuracy, bool bApplyClampedMaxYawAngleToFire) const;
	void GetProjectileInitialValues(float* outProjectileSpeed, struct FRotator* outSpawnDirection, float* outProjectileGravity, class AActor** HomingTarget, bool bApplyInaccuracy, bool bApplyClampedMaxYawAngleToFire, bool bApplyLeading) const;
	TSubclassOf<class UFortTooltip> GetTooltip() const;
	bool IsTargetOutsideOfMaxYawRotation() const;
	bool K2_ShouldUseDecoTool(const struct FGameplayAbilityActorInfo& ActorInfo) const;
	void QueryGameplayEffectContainerTargetExecutionModifiers(const struct FGameplayAbilityTargetDataHandle& TargetData, const class UFortAbilitySystemComponent* SrcAbilitySystem, const struct FGameplayTag& ApplicationTag, int32 GameplayEffectLevel, const class UObject* SourceObject, const TArray<struct FGameplayEffectExecutionScopedModifierInfo>& InScopedMods, const TArray<struct FActiveGameplayEffectHandle>& InIgnoreHandles, TArray<struct FGameplayModifierEvaluatedData>* OutOutputModifiers) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameplayAbility">();
	}
	static class UFortGameplayAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGameplayAbility>();
	}
};
static_assert(alignof(UFortGameplayAbility) == 0x000008, "Wrong alignment on UFortGameplayAbility");
static_assert(sizeof(UFortGameplayAbility) == 0x000A40, "Wrong size on UFortGameplayAbility");
static_assert(offsetof(UFortGameplayAbility, ActivationType) == 0x000598, "Member 'UFortGameplayAbility::ActivationType' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, EffectContainers) == 0x0005A0, "Member 'UFortGameplayAbility::EffectContainers' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, GameplayEffectContainers) == 0x000848, "Member 'UFortGameplayAbility::GameplayEffectContainers' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, OwnerPreviewImageOverrideTags) == 0x000858, "Member 'UFortGameplayAbility::OwnerPreviewImageOverrideTags' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, ProjectileClass) == 0x000878, "Member 'UFortGameplayAbility::ProjectileClass' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, DamageStatHandle) == 0x000880, "Member 'UFortGameplayAbility::DamageStatHandle' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, AbilityCosts) == 0x000890, "Member 'UFortGameplayAbility::AbilityCosts' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, MinimumRequiredAILODLevel) == 0x0008A4, "Member 'UFortGameplayAbility::MinimumRequiredAILODLevel' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, AIWeaponUsage) == 0x0008AC, "Member 'UFortGameplayAbility::AIWeaponUsage' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, WeaponTestApplicationTag) == 0x0008B0, "Member 'UFortGameplayAbility::WeaponTestApplicationTag' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, FireOffset) == 0x0008BC, "Member 'UFortGameplayAbility::FireOffset' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, ActivationNoiseRange) == 0x0008C8, "Member 'UFortGameplayAbility::ActivationNoiseRange' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, ImpactNoiseRange) == 0x0008CC, "Member 'UFortGameplayAbility::ImpactNoiseRange' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, ActivationNoiseLoudness) == 0x0008D0, "Member 'UFortGameplayAbility::ActivationNoiseLoudness' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, ImpactNoiseLoudness) == 0x0008D4, "Member 'UFortGameplayAbility::ImpactNoiseLoudness' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, ProhibitedTargetTags) == 0x0008D8, "Member 'UFortGameplayAbility::ProhibitedTargetTags' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, bLeadPawnTargets) == 0x0008F9, "Member 'UFortGameplayAbility::bLeadPawnTargets' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, DesiredThrowAngle) == 0x0008FC, "Member 'UFortGameplayAbility::DesiredThrowAngle' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, MaxYawAngleToFire) == 0x000900, "Member 'UFortGameplayAbility::MaxYawAngleToFire' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, bClampMaxYawAngleToFire) == 0x000904, "Member 'UFortGameplayAbility::bClampMaxYawAngleToFire' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, bUseTargetActorLocation) == 0x000905, "Member 'UFortGameplayAbility::bUseTargetActorLocation' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, InitialAccuracyMax) == 0x000908, "Member 'UFortGameplayAbility::InitialAccuracyMax' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, InitialAccuracyMin) == 0x00090C, "Member 'UFortGameplayAbility::InitialAccuracyMin' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, TargetAccuracyMax) == 0x000910, "Member 'UFortGameplayAbility::TargetAccuracyMax' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, TargetAccuracyMin) == 0x000914, "Member 'UFortGameplayAbility::TargetAccuracyMin' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, MinAccuracyDistance) == 0x000918, "Member 'UFortGameplayAbility::MinAccuracyDistance' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, MaxAccuracyDistance) == 0x00091C, "Member 'UFortGameplayAbility::MaxAccuracyDistance' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, AccuracyDistanceMultiplier) == 0x000920, "Member 'UFortGameplayAbility::AccuracyDistanceMultiplier' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, NumUsesToReachTargetAccuracy) == 0x000924, "Member 'UFortGameplayAbility::NumUsesToReachTargetAccuracy' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, UseCount) == 0x000928, "Member 'UFortGameplayAbility::UseCount' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, GameplayAbilityBehaviorDistanceData) == 0x000930, "Member 'UFortGameplayAbility::GameplayAbilityBehaviorDistanceData' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, MontageInfo) == 0x000960, "Member 'UFortGameplayAbility::MontageInfo' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, DisplayName) == 0x0009C0, "Member 'UFortGameplayAbility::DisplayName' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, Description) == 0x0009D8, "Member 'UFortGameplayAbility::Description' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, SmallPreviewImageOverride) == 0x0009F8, "Member 'UFortGameplayAbility::SmallPreviewImageOverride' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, Tooltip) == 0x000A08, "Member 'UFortGameplayAbility::Tooltip' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, StatList) == 0x000A10, "Member 'UFortGameplayAbility::StatList' has a wrong offset!");

// Class FortniteGame.FortAlterableItem
// 0x0030 (0x0168 - 0x0138)
#pragma pack(push, 0x1)
class alignas(0x08) UFortAlterableItem : public UFortAccountItem
{
public:
	TArray<struct FFortAlterationSlots>           alteration_slots;                                  // 0x0138(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FString>                         alterations;                                       // 0x0148(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UFortAlterationItemDefinition*>  AlterationInstances;                               // 0x0158(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	int32 GetNumberOfSlotsForAlterationType(EFortAlteration AlterationType) const;
	int32 GetRating() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAlterableItem">();
	}
	static class UFortAlterableItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAlterableItem>();
	}
};
#pragma pack(pop)
static_assert(alignof(UFortAlterableItem) == 0x000008, "Wrong alignment on UFortAlterableItem");
static_assert(sizeof(UFortAlterableItem) == 0x000168, "Wrong size on UFortAlterableItem");
static_assert(offsetof(UFortAlterableItem, alteration_slots) == 0x000138, "Member 'UFortAlterableItem::alteration_slots' has a wrong offset!");
static_assert(offsetof(UFortAlterableItem, alterations) == 0x000148, "Member 'UFortAlterableItem::alterations' has a wrong offset!");
static_assert(offsetof(UFortAlterableItem, AlterationInstances) == 0x000158, "Member 'UFortAlterableItem::AlterationInstances' has a wrong offset!");

// Class FortniteGame.FortSchematicItem
// 0x0068 (0x01D0 - 0x0168)
class UFortSchematicItem final : public UFortAlterableItem
{
public:
	bool                                          bGrantedByAbility;                                 // 0x0168(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_169[0x3];                                      // 0x0169(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RequiredTeamLevel;                                 // 0x016C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_170[0x60];                                     // 0x0170(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetRequiredTeamLevelToCraft() const;
	int32 GetSchematicQuantityProduced() const;
	void GetSchematicRequirements(TArray<struct FSchematicRequirement>* Requirements) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortSchematicItem">();
	}
	static class UFortSchematicItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortSchematicItem>();
	}
};
static_assert(alignof(UFortSchematicItem) == 0x000008, "Wrong alignment on UFortSchematicItem");
static_assert(sizeof(UFortSchematicItem) == 0x0001D0, "Wrong size on UFortSchematicItem");
static_assert(offsetof(UFortSchematicItem, bGrantedByAbility) == 0x000168, "Member 'UFortSchematicItem::bGrantedByAbility' has a wrong offset!");
static_assert(offsetof(UFortSchematicItem, RequiredTeamLevel) == 0x00016C, "Member 'UFortSchematicItem::RequiredTeamLevel' has a wrong offset!");

// Class FortniteGame.FortItemTooltip
// 0x0000 (0x0090 - 0x0090)
class UFortItemTooltip : public UFortTooltip
{
public:
	bool GetNumericValue(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, float* OutVal) const;
	bool GetTextForToken(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, class FText* OutText) const;
	bool GetTokenizedDescriptionText(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, TArray<class FText>* OutDescription) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortItemTooltip">();
	}
	static class UFortItemTooltip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortItemTooltip>();
	}
};
static_assert(alignof(UFortItemTooltip) == 0x000008, "Wrong alignment on UFortItemTooltip");
static_assert(sizeof(UFortItemTooltip) == 0x000090, "Wrong size on UFortItemTooltip");

// Class FortniteGame.FortAIPerceptionComponent
// 0x0008 (0x01D0 - 0x01C8)
class UFortAIPerceptionComponent final : public UAIPerceptionComponent
{
public:
	float                                         LosingSightRadiusBump;                             // 0x01C8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CC[0x4];                                      // 0x01CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIPerceptionComponent">();
	}
	static class UFortAIPerceptionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIPerceptionComponent>();
	}
};
static_assert(alignof(UFortAIPerceptionComponent) == 0x000008, "Wrong alignment on UFortAIPerceptionComponent");
static_assert(sizeof(UFortAIPerceptionComponent) == 0x0001D0, "Wrong size on UFortAIPerceptionComponent");
static_assert(offsetof(UFortAIPerceptionComponent, LosingSightRadiusBump) == 0x0001C8, "Member 'UFortAIPerceptionComponent::LosingSightRadiusBump' has a wrong offset!");

// Class FortniteGame.StrategicBuildingActor
// 0x0140 (0x0980 - 0x0840)
#pragma pack(push, 0x1)
class alignas(0x10) AStrategicBuildingActor : public ABuildingGameplayActor
{
public:
	float                                         HealthBarVisibilityDistance;                       // 0x0840(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HealthBarVisibilityDistanceSquared;                // 0x0844(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          TouchBoxComponent;                                 // 0x0848(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortStrategicBuildingCategory                StrategicBuildingCategory;                         // 0x0850(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_851[0x7];                                      // 0x0851(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UFortAbilitySet*>                PermanentInherentAbilitySets;                      // 0x0858(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FStrategicBuildingLevelInformation> LevelInfo;                                         // 0x0868(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditFixedSize, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         ProximityPulseInterval;                            // 0x0878(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_87C[0x4];                                      // 0x087C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UFortGameplayAbility>       DeathPenaltyAbility;                               // 0x0880(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        DeathParticles;                                    // 0x0888(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             DeathSound;                                        // 0x0890(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortGadgetItemDefinition*              SpawnedFromItemDefinition;                         // 0x0898(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTeamStrategicBuildingHandle           SBAHandle;                                         // 0x08A0(0x0004)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FStrategicBuildingActiveConstructionInfo ConstructionProgress;                              // 0x08A4(0x0010)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_8B4[0x4];                                      // 0x08B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FStrategicBuildingLevelActiveCriteriaProgress> LevelProgress;                                     // 0x08B8(0x0010)(Net, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortAbilitySetHandle>          StrategicBuildingAbilitySets;                      // 0x08C8(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortAbilitySetHandle>          PersistentlyAppliedAbilitySets;                    // 0x08D8(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         DeferredTouchActorsToProcess;                      // 0x08E8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_8F8[0x58];                                     // 0x08F8(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bIsActive : 1;                                     // 0x0950(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bHasGEsToApplyOnTouch : 1;                         // 0x0950(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bHasGEsToApplyOnPulseTimer : 1;                    // 0x0950(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_951[0x7];                                      // 0x0951(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortVisibilityComponent*               VisibilityComponent;                               // 0x0958(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             MiniMapIcon;                                       // 0x0960(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_968[0x10];                                     // 0x0968(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyProximityPulseEffects();
	bool AttemptIncrementLevelUnlockProgress(int32 InLevel, float InProgressDelta);
	void GiveItemFromStrategicBuildingToPlayer(class AFortPlayerController* PlayerController, const class UFortWorldItemDefinition* ItemDefinition, int32 NumberToGive);
	void OnActiveStatusChanged(bool bNewActiveStatus);
	void OnConstructionEndedPlayEffects(int32 ConstructionLevel);
	void OnConstructionStartedPlayEffects(float ServerStartTime, float ServerEndTime, float CurrentServerTime, float ElapsedPct, int32 ConstructionLvl);
	void OnConstructionTickPlayEffects(float DeltaTime, float ElapsedPct, int32 ConstructionLvl);
	void OnRep_bIsActive();
	void OnRep_ConstructionProgress();
	void ProcessDeferredTouchActors();
	void SetupIndicators();
	void SetupVisibilityComponent();

	float GetCurrentLevelUnlockProgress(int32 InLevel) const;
	struct FVector GetDeathEffectsLocation() const;
	struct FRotator GetDeathEffectsRotation() const;
	struct FVector GetDeathEffectsScale() const;
	float GetMaxLevelUnlockProgress(int32 InLevel) const;
	bool IsActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StrategicBuildingActor">();
	}
	static class AStrategicBuildingActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStrategicBuildingActor>();
	}
};
#pragma pack(pop)
static_assert(alignof(AStrategicBuildingActor) == 0x000010, "Wrong alignment on AStrategicBuildingActor");
static_assert(sizeof(AStrategicBuildingActor) == 0x000980, "Wrong size on AStrategicBuildingActor");
static_assert(offsetof(AStrategicBuildingActor, HealthBarVisibilityDistance) == 0x000840, "Member 'AStrategicBuildingActor::HealthBarVisibilityDistance' has a wrong offset!");
static_assert(offsetof(AStrategicBuildingActor, HealthBarVisibilityDistanceSquared) == 0x000844, "Member 'AStrategicBuildingActor::HealthBarVisibilityDistanceSquared' has a wrong offset!");
static_assert(offsetof(AStrategicBuildingActor, TouchBoxComponent) == 0x000848, "Member 'AStrategicBuildingActor::TouchBoxComponent' has a wrong offset!");
static_assert(offsetof(AStrategicBuildingActor, StrategicBuildingCategory) == 0x000850, "Member 'AStrategicBuildingActor::StrategicBuildingCategory' has a wrong offset!");
static_assert(offsetof(AStrategicBuildingActor, PermanentInherentAbilitySets) == 0x000858, "Member 'AStrategicBuildingActor::PermanentInherentAbilitySets' has a wrong offset!");
static_assert(offsetof(AStrategicBuildingActor, LevelInfo) == 0x000868, "Member 'AStrategicBuildingActor::LevelInfo' has a wrong offset!");
static_assert(offsetof(AStrategicBuildingActor, ProximityPulseInterval) == 0x000878, "Member 'AStrategicBuildingActor::ProximityPulseInterval' has a wrong offset!");
static_assert(offsetof(AStrategicBuildingActor, DeathPenaltyAbility) == 0x000880, "Member 'AStrategicBuildingActor::DeathPenaltyAbility' has a wrong offset!");
static_assert(offsetof(AStrategicBuildingActor, DeathParticles) == 0x000888, "Member 'AStrategicBuildingActor::DeathParticles' has a wrong offset!");
static_assert(offsetof(AStrategicBuildingActor, DeathSound) == 0x000890, "Member 'AStrategicBuildingActor::DeathSound' has a wrong offset!");
static_assert(offsetof(AStrategicBuildingActor, SpawnedFromItemDefinition) == 0x000898, "Member 'AStrategicBuildingActor::SpawnedFromItemDefinition' has a wrong offset!");
static_assert(offsetof(AStrategicBuildingActor, SBAHandle) == 0x0008A0, "Member 'AStrategicBuildingActor::SBAHandle' has a wrong offset!");
static_assert(offsetof(AStrategicBuildingActor, ConstructionProgress) == 0x0008A4, "Member 'AStrategicBuildingActor::ConstructionProgress' has a wrong offset!");
static_assert(offsetof(AStrategicBuildingActor, LevelProgress) == 0x0008B8, "Member 'AStrategicBuildingActor::LevelProgress' has a wrong offset!");
static_assert(offsetof(AStrategicBuildingActor, StrategicBuildingAbilitySets) == 0x0008C8, "Member 'AStrategicBuildingActor::StrategicBuildingAbilitySets' has a wrong offset!");
static_assert(offsetof(AStrategicBuildingActor, PersistentlyAppliedAbilitySets) == 0x0008D8, "Member 'AStrategicBuildingActor::PersistentlyAppliedAbilitySets' has a wrong offset!");
static_assert(offsetof(AStrategicBuildingActor, DeferredTouchActorsToProcess) == 0x0008E8, "Member 'AStrategicBuildingActor::DeferredTouchActorsToProcess' has a wrong offset!");
static_assert(offsetof(AStrategicBuildingActor, VisibilityComponent) == 0x000958, "Member 'AStrategicBuildingActor::VisibilityComponent' has a wrong offset!");
static_assert(offsetof(AStrategicBuildingActor, MiniMapIcon) == 0x000960, "Member 'AStrategicBuildingActor::MiniMapIcon' has a wrong offset!");

// Class FortniteGame.FortPvPBaseCornerstone
// 0x0030 (0x09B0 - 0x0980)
class AFortPvPBaseCornerstone final : public AStrategicBuildingActor
{
public:
	uint8                                         bInvincible : 1;                                   // 0x0978(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_979[0x7];                                      // 0x0979(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnCornerstoneDamaged;                              // 0x0980(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnCornerstoneOutOfHealth;                          // 0x0990(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_9A0[0x10];                                     // 0x09A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInvincibilityChanged(bool bIsInvincible);
	void OnRep_bInvincible();
	void SetInvincibility(bool bInInvincible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPvPBaseCornerstone">();
	}
	static class AFortPvPBaseCornerstone* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPvPBaseCornerstone>();
	}
};
static_assert(alignof(AFortPvPBaseCornerstone) == 0x000010, "Wrong alignment on AFortPvPBaseCornerstone");
static_assert(sizeof(AFortPvPBaseCornerstone) == 0x0009B0, "Wrong size on AFortPvPBaseCornerstone");
static_assert(offsetof(AFortPvPBaseCornerstone, OnCornerstoneDamaged) == 0x000980, "Member 'AFortPvPBaseCornerstone::OnCornerstoneDamaged' has a wrong offset!");
static_assert(offsetof(AFortPvPBaseCornerstone, OnCornerstoneOutOfHealth) == 0x000990, "Member 'AFortPvPBaseCornerstone::OnCornerstoneOutOfHealth' has a wrong offset!");

// Class FortniteGame.FortWeapon
// 0x0700 (0x0A88 - 0x0388)
class AFortWeapon : public AActor
{
public:
	uint8                                         Pad_388[0x18];                                     // 0x0388(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsEquippingWeapon;                                // 0x03A0(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsReloadingWeapon;                                // 0x03A1(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsChargingWeapon;                                 // 0x03A2(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A3[0x5];                                      // 0x03A3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnLocalAmmoChanged;                                // 0x03A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B8[0x8];                                      // 0x03B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnReticleColorChanged;                             // 0x03C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UFortWeaponItemDefinition*              WeaponData;                                        // 0x03D0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFortGameplayAbilityBehaviorDistanceData> GameplayAbilityBehaviorDistanceData;               // 0x03D8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	bool                                          bShouldDrawNativeReticle;                          // 0x03E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E9[0x7];                                      // 0x03E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             ReticleImage;                                      // 0x03F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 ReticleDefaultColor;                               // 0x03F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 ReticleEnemyColor;                                 // 0x03FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 ReticleBuildingColor;                              // 0x0400(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_404[0x4];                                      // 0x0404(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             HitNotifyReticleImage;                             // 0x0408(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HitNotifyDisplayDuration;                          // 0x0410(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_414[0x4];                                      // 0x0414(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             ReticleCenterImage;                                // 0x0418(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             MuzzleBlockedReticleImage;                         // 0x0420(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReticleDefaultPrimaryStrikeAngle;                  // 0x0428(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReticleDefaultSecondaryStrikeAngle;                // 0x042C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UFortCameraMode>            CameraBase3PClass;                                 // 0x0430(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UFortCameraMode>            CameraTargeting3PClass;                            // 0x0438(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UFortCameraMode>            CameraBase1PClass;                                 // 0x0440(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UFortCameraMode>            CameraTargeting1PClass;                            // 0x0448(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             DestroyedSound;                                    // 0x0450(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             OutOfAmmoSound;                                    // 0x0458(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             ReloadSounds[0x3];                                 // 0x0460(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             PrimaryFireSound[0x3];                             // 0x0478(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             PrimaryFireStopSound[0x3];                         // 0x0490(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             SecondaryFireSound[0x3];                           // 0x04A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             SecondaryFireStopSound[0x3];                       // 0x04C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PrimaryFireSoundFadeOutTime;                       // 0x04D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4DC[0x4];                                      // 0x04DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             ImpactPhysicalSurfaceSounds[0x3F];                 // 0x04E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        ImpactPhysicalSurfaceEffects[0x3F];                // 0x06D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCameraShake>               ImpactCameraShake;                                 // 0x08D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UForceFeedbackEffect*                   PrimaryForceFeedbackEffect;                        // 0x08D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UForceFeedbackEffect*                   SecondaryForceFeedbackEffect;                      // 0x08E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UForceFeedbackEffect*                   PrimaryImpactForceFeedbackEffect;                  // 0x08E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UForceFeedbackEffect*                   SecondaryImpactForceFeedbackEffect;                // 0x08F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        FireAudioChannels[0x3];                            // 0x08F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 WeaponMesh;                                        // 0x0910(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMaterialInterface*>             DefaultWeaponMaterials;                            // 0x0918(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	int32                                         FireAudioChannelWantsToPlay[0x3];                  // 0x0928(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUsingSecondaryFireAudio;                          // 0x0934(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_935[0x3];                                      // 0x0935(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 CurrentReticleColor;                               // 0x0938(0x0004)(Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                CurrentDamageStartLocation;                        // 0x093C(0x000C)(Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                CurrentAdjustedAimDirection;                       // 0x0948(0x000C)(Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastFireTime;                                      // 0x0954(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsPlayingFireFX;                                  // 0x0958(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_959[0x3];                                      // 0x0959(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimerIntervalAdjustment;                           // 0x095C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InputQueueTimePercent;                             // 0x0960(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowTargeting;                                   // 0x0964(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsTargeting;                                      // 0x0965(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_966[0x2];                                      // 0x0966(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastTargetingTransitionTime;                       // 0x0968(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                TargetSourceOffset;                                // 0x096C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                TargetSourceOffsetWhileCrouched;                   // 0x0978(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                TargetSourceOffsetWhileTargeting;                  // 0x0984(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTraceThroughPawns;                                // 0x0990(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_991[0x3];                                      // 0x0991(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TraceThroughPawnsLimit;                            // 0x0994(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastReloadTime;                                    // 0x0998(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastSuccessfulReloadTime;                          // 0x099C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentReloadDuration;                             // 0x09A0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  ItemEntryGuid;                                     // 0x09A4(0x0010)(Net, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         WeaponLevel;                                       // 0x09B4(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AmmoCount;                                         // 0x09B8(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9BC[0x4];                                      // 0x09BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BurstFireCounter;                                  // 0x09C0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ChargeTime;                                        // 0x09C4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentShotLogIndex;                               // 0x09C8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9CC[0x4];                                      // 0x09CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint32>                                ShotLogFlags;                                      // 0x09D0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         bInitializedWeaponItem : 1;                        // 0x09E0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         BitPad_9E0_1 : 1;                                  // 0x09E0(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bUpdateLocalAmmoCount : 1;                         // 0x09E0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bPendingDestroyDueToDurabilityOrStackCount : 1;    // 0x09E0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_9E1[0x3];                                      // 0x09E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int16                                         ChargeStatusPack;                                  // 0x09E4(0x0002)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9E6[0xA];                                      // 0x09E6(0x000A)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortGameplayAbility*                   ActiveAbility;                                     // 0x09F0(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayAbilitySpecHandle             PrimaryAbilitySpecHandle;                          // 0x09F8(0x0004)(Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayAbilitySpecHandle             SecondaryAbilitySpecHandle;                        // 0x09FC(0x0004)(Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayAbilitySpecHandle             ReloadAbilitySpecHandle;                           // 0x0A00(0x0004)(Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A04[0x4];                                      // 0x0A04(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayAbilitySpecHandle>     EquippedAbilityHandles;                            // 0x0A08(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortAbilitySetHandle>          EquippedAbilitySetHandles;                         // 0x0A18(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UFortAlterationItemDefinition*>  AppliedAlterations;                                // 0x0A28(0x0010)(Net, ZeroConstructor, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	class AFortFXManager*                         CachedFXManager;                                   // 0x0A38(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortSignificanceManager*               CachedSignificanceManager;                         // 0x0A40(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MuzzleSocketName;                                  // 0x0A48(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MuzzleFalloffSocketName;                           // 0x0A50(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A58[0x8];                                      // 0x0A58(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           EquipAnimation;                                    // 0x0A60(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           ReloadAnimation;                                   // 0x0A68(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           WeaponEquipMontage;                                // 0x0A70(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           WeaponReloadMontage;                               // 0x0A78(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortWeaponCoreAnimation                      WeaponCoreAnimation;                               // 0x0A80(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A81[0x7];                                      // 0x0A81(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientGivenTo(class APawn* P);
	void ClientReportShotFlags(uint32 ShotFlags, int32 ShotIndex);
	struct FColor DetermineReticleColor();
	void GameplayCue_Impact(EGameplayCueEvent EventType, const struct FGameplayCueParameters& Parameters);
	void GameplayCue_Weapons_Activation(EGameplayCueEvent EventType, const struct FGameplayCueParameters& Parameters);
	float GetMeleeAttackPlayRate();
	void K2_OnUnEquip();
	void OnAmmoCountChanged();
	void OnChargeDown();
	void OnChargeUp();
	void OnEndCharge();
	void OnEquippedWeaponDestory();
	void OnEquippedWeaponDestroyWrapper();
	void OnInitAlteration(class UFortAlterationItemDefinition* NewAlteration);
	void OnInitCosmeticAlterations(const struct FFortCosmeticModification& CosmeticMod, class UMaterialInstanceDynamic* DynamicMaterialInstance);
	void OnOutOfAmmoFire();
	void OnPawnMontageBlendingOut(class UAnimMontage* PawnMontage, bool bInterrupted);
	void OnPawnMontageStarted(class UAnimMontage* PawnMontage);
	void OnPlayImpactFX(const struct FHitResult& HitResult, EPhysicalSurface ImpactPhysicalSurface, class UParticleSystemComponent* SpawnedPSC);
	void OnPlayReloadFX(EFortReloadFXState ReloadStage);
	void OnPlayWeaponFireFX(bool bPersistentFire, bool bSecondaryFire);
	void OnReachedMaxCharge();
	void OnReachedMinCharge();
	void OnRep_AmmoCount();
	void OnRep_ChargeStatusPack();
	void OnRep_ReplicatedAppliedAlterations();
	void OnRep_ReplicatedWeaponData();
	void OnSetTargeting(bool bNewIsTargeting);
	void OnStartCharge();
	void OnStopWeaponFireFX();
	void OnWeaponAttached();
	void OnWeaponVisibilityChanged(bool bVisible);
	void PlayForceFeedback(bool bSecondaryFire, bool bPersistentFire, bool bImpact);
	void PlayNativeImpactFX(const struct FHitResult& HitResult, const struct FGameplayCueParameters& GameplayCueParameters);
	void PlayReloadFX(EFortReloadFXState ReloadStage);
	void PlayWeaponFireFX(bool bSecondaryFire);
	void Reload();
	void ResetTempWeaponMaterialOverride();
	void ServerResetShotReport();
	void ServerSetChargeState(uint8 NewState);
	void SetShouldDrawNativeReticle(bool bInShouldDrawReticle);
	void SetWeaponVisibility(bool bDesiredVisibility, bool bForceUpdate);
	void StopForceFeedback();
	void StopWeaponFireFX();
	void UseWeaponDurability(float DurabilityScale);

	TArray<class UFortAlterationItemDefinition*> GetAlterations() const;
	int32 GetBulletsPerClip() const;
	float GetChargePercent() const;
	EFortWeaponCoreAnimation GetCoreAnimation() const;
	float GetCurrentMaxChargePercent() const;
	struct FVector GetDamageStartLocation(struct FVector* AimDir) const;
	int32 GetLocalMagazineAmmoCount() const;
	int32 GetLocalRemainingAmmo() const;
	int32 GetMagazineAmmoCount() const;
	struct FVector GetMuzzleLocation() const;
	struct FTransform GetMuzzleSocketTransform() const;
	float GetRange() const;
	float GetReloadProgress() const;
	float GetReloadTime() const;
	int32 GetRemainingAmmo() const;
	struct FColor GetReticleColor() const;
	bool IsProjectileWeapon() const;
	bool IsReloading() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortWeapon">();
	}
	static class AFortWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortWeapon>();
	}
};
static_assert(alignof(AFortWeapon) == 0x000008, "Wrong alignment on AFortWeapon");
static_assert(sizeof(AFortWeapon) == 0x000A88, "Wrong size on AFortWeapon");
static_assert(offsetof(AFortWeapon, bIsEquippingWeapon) == 0x0003A0, "Member 'AFortWeapon::bIsEquippingWeapon' has a wrong offset!");
static_assert(offsetof(AFortWeapon, bIsReloadingWeapon) == 0x0003A1, "Member 'AFortWeapon::bIsReloadingWeapon' has a wrong offset!");
static_assert(offsetof(AFortWeapon, bIsChargingWeapon) == 0x0003A2, "Member 'AFortWeapon::bIsChargingWeapon' has a wrong offset!");
static_assert(offsetof(AFortWeapon, OnLocalAmmoChanged) == 0x0003A8, "Member 'AFortWeapon::OnLocalAmmoChanged' has a wrong offset!");
static_assert(offsetof(AFortWeapon, OnReticleColorChanged) == 0x0003C0, "Member 'AFortWeapon::OnReticleColorChanged' has a wrong offset!");
static_assert(offsetof(AFortWeapon, WeaponData) == 0x0003D0, "Member 'AFortWeapon::WeaponData' has a wrong offset!");
static_assert(offsetof(AFortWeapon, GameplayAbilityBehaviorDistanceData) == 0x0003D8, "Member 'AFortWeapon::GameplayAbilityBehaviorDistanceData' has a wrong offset!");
static_assert(offsetof(AFortWeapon, bShouldDrawNativeReticle) == 0x0003E8, "Member 'AFortWeapon::bShouldDrawNativeReticle' has a wrong offset!");
static_assert(offsetof(AFortWeapon, ReticleImage) == 0x0003F0, "Member 'AFortWeapon::ReticleImage' has a wrong offset!");
static_assert(offsetof(AFortWeapon, ReticleDefaultColor) == 0x0003F8, "Member 'AFortWeapon::ReticleDefaultColor' has a wrong offset!");
static_assert(offsetof(AFortWeapon, ReticleEnemyColor) == 0x0003FC, "Member 'AFortWeapon::ReticleEnemyColor' has a wrong offset!");
static_assert(offsetof(AFortWeapon, ReticleBuildingColor) == 0x000400, "Member 'AFortWeapon::ReticleBuildingColor' has a wrong offset!");
static_assert(offsetof(AFortWeapon, HitNotifyReticleImage) == 0x000408, "Member 'AFortWeapon::HitNotifyReticleImage' has a wrong offset!");
static_assert(offsetof(AFortWeapon, HitNotifyDisplayDuration) == 0x000410, "Member 'AFortWeapon::HitNotifyDisplayDuration' has a wrong offset!");
static_assert(offsetof(AFortWeapon, ReticleCenterImage) == 0x000418, "Member 'AFortWeapon::ReticleCenterImage' has a wrong offset!");
static_assert(offsetof(AFortWeapon, MuzzleBlockedReticleImage) == 0x000420, "Member 'AFortWeapon::MuzzleBlockedReticleImage' has a wrong offset!");
static_assert(offsetof(AFortWeapon, ReticleDefaultPrimaryStrikeAngle) == 0x000428, "Member 'AFortWeapon::ReticleDefaultPrimaryStrikeAngle' has a wrong offset!");
static_assert(offsetof(AFortWeapon, ReticleDefaultSecondaryStrikeAngle) == 0x00042C, "Member 'AFortWeapon::ReticleDefaultSecondaryStrikeAngle' has a wrong offset!");
static_assert(offsetof(AFortWeapon, CameraBase3PClass) == 0x000430, "Member 'AFortWeapon::CameraBase3PClass' has a wrong offset!");
static_assert(offsetof(AFortWeapon, CameraTargeting3PClass) == 0x000438, "Member 'AFortWeapon::CameraTargeting3PClass' has a wrong offset!");
static_assert(offsetof(AFortWeapon, CameraBase1PClass) == 0x000440, "Member 'AFortWeapon::CameraBase1PClass' has a wrong offset!");
static_assert(offsetof(AFortWeapon, CameraTargeting1PClass) == 0x000448, "Member 'AFortWeapon::CameraTargeting1PClass' has a wrong offset!");
static_assert(offsetof(AFortWeapon, DestroyedSound) == 0x000450, "Member 'AFortWeapon::DestroyedSound' has a wrong offset!");
static_assert(offsetof(AFortWeapon, OutOfAmmoSound) == 0x000458, "Member 'AFortWeapon::OutOfAmmoSound' has a wrong offset!");
static_assert(offsetof(AFortWeapon, ReloadSounds) == 0x000460, "Member 'AFortWeapon::ReloadSounds' has a wrong offset!");
static_assert(offsetof(AFortWeapon, PrimaryFireSound) == 0x000478, "Member 'AFortWeapon::PrimaryFireSound' has a wrong offset!");
static_assert(offsetof(AFortWeapon, PrimaryFireStopSound) == 0x000490, "Member 'AFortWeapon::PrimaryFireStopSound' has a wrong offset!");
static_assert(offsetof(AFortWeapon, SecondaryFireSound) == 0x0004A8, "Member 'AFortWeapon::SecondaryFireSound' has a wrong offset!");
static_assert(offsetof(AFortWeapon, SecondaryFireStopSound) == 0x0004C0, "Member 'AFortWeapon::SecondaryFireStopSound' has a wrong offset!");
static_assert(offsetof(AFortWeapon, PrimaryFireSoundFadeOutTime) == 0x0004D8, "Member 'AFortWeapon::PrimaryFireSoundFadeOutTime' has a wrong offset!");
static_assert(offsetof(AFortWeapon, ImpactPhysicalSurfaceSounds) == 0x0004E0, "Member 'AFortWeapon::ImpactPhysicalSurfaceSounds' has a wrong offset!");
static_assert(offsetof(AFortWeapon, ImpactPhysicalSurfaceEffects) == 0x0006D8, "Member 'AFortWeapon::ImpactPhysicalSurfaceEffects' has a wrong offset!");
static_assert(offsetof(AFortWeapon, ImpactCameraShake) == 0x0008D0, "Member 'AFortWeapon::ImpactCameraShake' has a wrong offset!");
static_assert(offsetof(AFortWeapon, PrimaryForceFeedbackEffect) == 0x0008D8, "Member 'AFortWeapon::PrimaryForceFeedbackEffect' has a wrong offset!");
static_assert(offsetof(AFortWeapon, SecondaryForceFeedbackEffect) == 0x0008E0, "Member 'AFortWeapon::SecondaryForceFeedbackEffect' has a wrong offset!");
static_assert(offsetof(AFortWeapon, PrimaryImpactForceFeedbackEffect) == 0x0008E8, "Member 'AFortWeapon::PrimaryImpactForceFeedbackEffect' has a wrong offset!");
static_assert(offsetof(AFortWeapon, SecondaryImpactForceFeedbackEffect) == 0x0008F0, "Member 'AFortWeapon::SecondaryImpactForceFeedbackEffect' has a wrong offset!");
static_assert(offsetof(AFortWeapon, FireAudioChannels) == 0x0008F8, "Member 'AFortWeapon::FireAudioChannels' has a wrong offset!");
static_assert(offsetof(AFortWeapon, WeaponMesh) == 0x000910, "Member 'AFortWeapon::WeaponMesh' has a wrong offset!");
static_assert(offsetof(AFortWeapon, DefaultWeaponMaterials) == 0x000918, "Member 'AFortWeapon::DefaultWeaponMaterials' has a wrong offset!");
static_assert(offsetof(AFortWeapon, FireAudioChannelWantsToPlay) == 0x000928, "Member 'AFortWeapon::FireAudioChannelWantsToPlay' has a wrong offset!");
static_assert(offsetof(AFortWeapon, bUsingSecondaryFireAudio) == 0x000934, "Member 'AFortWeapon::bUsingSecondaryFireAudio' has a wrong offset!");
static_assert(offsetof(AFortWeapon, CurrentReticleColor) == 0x000938, "Member 'AFortWeapon::CurrentReticleColor' has a wrong offset!");
static_assert(offsetof(AFortWeapon, CurrentDamageStartLocation) == 0x00093C, "Member 'AFortWeapon::CurrentDamageStartLocation' has a wrong offset!");
static_assert(offsetof(AFortWeapon, CurrentAdjustedAimDirection) == 0x000948, "Member 'AFortWeapon::CurrentAdjustedAimDirection' has a wrong offset!");
static_assert(offsetof(AFortWeapon, LastFireTime) == 0x000954, "Member 'AFortWeapon::LastFireTime' has a wrong offset!");
static_assert(offsetof(AFortWeapon, bIsPlayingFireFX) == 0x000958, "Member 'AFortWeapon::bIsPlayingFireFX' has a wrong offset!");
static_assert(offsetof(AFortWeapon, TimerIntervalAdjustment) == 0x00095C, "Member 'AFortWeapon::TimerIntervalAdjustment' has a wrong offset!");
static_assert(offsetof(AFortWeapon, InputQueueTimePercent) == 0x000960, "Member 'AFortWeapon::InputQueueTimePercent' has a wrong offset!");
static_assert(offsetof(AFortWeapon, bAllowTargeting) == 0x000964, "Member 'AFortWeapon::bAllowTargeting' has a wrong offset!");
static_assert(offsetof(AFortWeapon, bIsTargeting) == 0x000965, "Member 'AFortWeapon::bIsTargeting' has a wrong offset!");
static_assert(offsetof(AFortWeapon, LastTargetingTransitionTime) == 0x000968, "Member 'AFortWeapon::LastTargetingTransitionTime' has a wrong offset!");
static_assert(offsetof(AFortWeapon, TargetSourceOffset) == 0x00096C, "Member 'AFortWeapon::TargetSourceOffset' has a wrong offset!");
static_assert(offsetof(AFortWeapon, TargetSourceOffsetWhileCrouched) == 0x000978, "Member 'AFortWeapon::TargetSourceOffsetWhileCrouched' has a wrong offset!");
static_assert(offsetof(AFortWeapon, TargetSourceOffsetWhileTargeting) == 0x000984, "Member 'AFortWeapon::TargetSourceOffsetWhileTargeting' has a wrong offset!");
static_assert(offsetof(AFortWeapon, bTraceThroughPawns) == 0x000990, "Member 'AFortWeapon::bTraceThroughPawns' has a wrong offset!");
static_assert(offsetof(AFortWeapon, TraceThroughPawnsLimit) == 0x000994, "Member 'AFortWeapon::TraceThroughPawnsLimit' has a wrong offset!");
static_assert(offsetof(AFortWeapon, LastReloadTime) == 0x000998, "Member 'AFortWeapon::LastReloadTime' has a wrong offset!");
static_assert(offsetof(AFortWeapon, LastSuccessfulReloadTime) == 0x00099C, "Member 'AFortWeapon::LastSuccessfulReloadTime' has a wrong offset!");
static_assert(offsetof(AFortWeapon, CurrentReloadDuration) == 0x0009A0, "Member 'AFortWeapon::CurrentReloadDuration' has a wrong offset!");
static_assert(offsetof(AFortWeapon, ItemEntryGuid) == 0x0009A4, "Member 'AFortWeapon::ItemEntryGuid' has a wrong offset!");
static_assert(offsetof(AFortWeapon, WeaponLevel) == 0x0009B4, "Member 'AFortWeapon::WeaponLevel' has a wrong offset!");
static_assert(offsetof(AFortWeapon, AmmoCount) == 0x0009B8, "Member 'AFortWeapon::AmmoCount' has a wrong offset!");
static_assert(offsetof(AFortWeapon, BurstFireCounter) == 0x0009C0, "Member 'AFortWeapon::BurstFireCounter' has a wrong offset!");
static_assert(offsetof(AFortWeapon, ChargeTime) == 0x0009C4, "Member 'AFortWeapon::ChargeTime' has a wrong offset!");
static_assert(offsetof(AFortWeapon, CurrentShotLogIndex) == 0x0009C8, "Member 'AFortWeapon::CurrentShotLogIndex' has a wrong offset!");
static_assert(offsetof(AFortWeapon, ShotLogFlags) == 0x0009D0, "Member 'AFortWeapon::ShotLogFlags' has a wrong offset!");
static_assert(offsetof(AFortWeapon, ChargeStatusPack) == 0x0009E4, "Member 'AFortWeapon::ChargeStatusPack' has a wrong offset!");
static_assert(offsetof(AFortWeapon, ActiveAbility) == 0x0009F0, "Member 'AFortWeapon::ActiveAbility' has a wrong offset!");
static_assert(offsetof(AFortWeapon, PrimaryAbilitySpecHandle) == 0x0009F8, "Member 'AFortWeapon::PrimaryAbilitySpecHandle' has a wrong offset!");
static_assert(offsetof(AFortWeapon, SecondaryAbilitySpecHandle) == 0x0009FC, "Member 'AFortWeapon::SecondaryAbilitySpecHandle' has a wrong offset!");
static_assert(offsetof(AFortWeapon, ReloadAbilitySpecHandle) == 0x000A00, "Member 'AFortWeapon::ReloadAbilitySpecHandle' has a wrong offset!");
static_assert(offsetof(AFortWeapon, EquippedAbilityHandles) == 0x000A08, "Member 'AFortWeapon::EquippedAbilityHandles' has a wrong offset!");
static_assert(offsetof(AFortWeapon, EquippedAbilitySetHandles) == 0x000A18, "Member 'AFortWeapon::EquippedAbilitySetHandles' has a wrong offset!");
static_assert(offsetof(AFortWeapon, AppliedAlterations) == 0x000A28, "Member 'AFortWeapon::AppliedAlterations' has a wrong offset!");
static_assert(offsetof(AFortWeapon, CachedFXManager) == 0x000A38, "Member 'AFortWeapon::CachedFXManager' has a wrong offset!");
static_assert(offsetof(AFortWeapon, CachedSignificanceManager) == 0x000A40, "Member 'AFortWeapon::CachedSignificanceManager' has a wrong offset!");
static_assert(offsetof(AFortWeapon, MuzzleSocketName) == 0x000A48, "Member 'AFortWeapon::MuzzleSocketName' has a wrong offset!");
static_assert(offsetof(AFortWeapon, MuzzleFalloffSocketName) == 0x000A50, "Member 'AFortWeapon::MuzzleFalloffSocketName' has a wrong offset!");
static_assert(offsetof(AFortWeapon, EquipAnimation) == 0x000A60, "Member 'AFortWeapon::EquipAnimation' has a wrong offset!");
static_assert(offsetof(AFortWeapon, ReloadAnimation) == 0x000A68, "Member 'AFortWeapon::ReloadAnimation' has a wrong offset!");
static_assert(offsetof(AFortWeapon, WeaponEquipMontage) == 0x000A70, "Member 'AFortWeapon::WeaponEquipMontage' has a wrong offset!");
static_assert(offsetof(AFortWeapon, WeaponReloadMontage) == 0x000A78, "Member 'AFortWeapon::WeaponReloadMontage' has a wrong offset!");
static_assert(offsetof(AFortWeapon, WeaponCoreAnimation) == 0x000A80, "Member 'AFortWeapon::WeaponCoreAnimation' has a wrong offset!");

// Class FortniteGame.FortAIGoalProvider
// 0x0020 (0x0048 - 0x0028)
class UFortAIGoalProvider : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWorld*                                 World;                                             // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortAIAssignment*                      AssignmentOwner;                                   // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortAIEncounterInfo*                   EncounterInfo;                                     // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool InitializeGoalProvider(class UWorld* ContextWorld, class UFortAIAssignment* Assignment);
	void UpdateGoals();

	class UFortAIEncounterInfo* GetEncounterInfo() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIGoalProvider">();
	}
	static class UFortAIGoalProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIGoalProvider>();
	}
};
static_assert(alignof(UFortAIGoalProvider) == 0x000008, "Wrong alignment on UFortAIGoalProvider");
static_assert(sizeof(UFortAIGoalProvider) == 0x000048, "Wrong size on UFortAIGoalProvider");
static_assert(offsetof(UFortAIGoalProvider, World) == 0x000030, "Member 'UFortAIGoalProvider::World' has a wrong offset!");
static_assert(offsetof(UFortAIGoalProvider, AssignmentOwner) == 0x000038, "Member 'UFortAIGoalProvider::AssignmentOwner' has a wrong offset!");
static_assert(offsetof(UFortAIGoalProvider, EncounterInfo) == 0x000040, "Member 'UFortAIGoalProvider::EncounterInfo' has a wrong offset!");

// Class FortniteGame.BuildingRift
// 0x00A0 (0x07D8 - 0x0738)
#pragma pack(push, 0x1)
class alignas(0x08) ABuildingRift : public ABuildingActor
{
public:
	float                                         DistToTarget;                                      // 0x0738(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_73C[0x4];                                      // 0x073C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnDelay;                                        // 0x0740(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_744[0x4];                                      // 0x0744(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UEnvQuery*                              EnvironmentQuery;                                  // 0x0748(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FEnvNamedValue>                 QueryParams;                                       // 0x0750(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         QueryRadius;                                       // 0x0760(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_764[0x4];                                      // 0x0764(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        FreeSpawnSlots;                                    // 0x0768(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortSpawnSlotData>             UsedSpawnSlots;                                    // 0x0778(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_788[0x10];                                     // 0x0788(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bRiftIsVisible;                                    // 0x0798(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRiftIsActive;                                     // 0x0799(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsReadyToSpawnAI;                                 // 0x079A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasBadRiftSlots;                                  // 0x079B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_79C[0x3C];                                     // 0x079C(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastRiftSpawningAI();
	void OnActivated();
	void OnDeactivated();
	void OnFinishedEncounterSpawn(class AFortAIPawn* SpawnedAI);
	void OnPlaced();
	void OnRemoved();
	void OnRep_RiftIsActive();
	void OnRep_RiftIsVisible();
	void OnSpawnAI();
	void OnStartedEncounterSpawn(class AFortAIPawn* SpawnedAI);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingRift">();
	}
	static class ABuildingRift* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingRift>();
	}
};
#pragma pack(pop)
static_assert(alignof(ABuildingRift) == 0x000008, "Wrong alignment on ABuildingRift");
static_assert(sizeof(ABuildingRift) == 0x0007D8, "Wrong size on ABuildingRift");
static_assert(offsetof(ABuildingRift, DistToTarget) == 0x000738, "Member 'ABuildingRift::DistToTarget' has a wrong offset!");
static_assert(offsetof(ABuildingRift, SpawnDelay) == 0x000740, "Member 'ABuildingRift::SpawnDelay' has a wrong offset!");
static_assert(offsetof(ABuildingRift, EnvironmentQuery) == 0x000748, "Member 'ABuildingRift::EnvironmentQuery' has a wrong offset!");
static_assert(offsetof(ABuildingRift, QueryParams) == 0x000750, "Member 'ABuildingRift::QueryParams' has a wrong offset!");
static_assert(offsetof(ABuildingRift, QueryRadius) == 0x000760, "Member 'ABuildingRift::QueryRadius' has a wrong offset!");
static_assert(offsetof(ABuildingRift, FreeSpawnSlots) == 0x000768, "Member 'ABuildingRift::FreeSpawnSlots' has a wrong offset!");
static_assert(offsetof(ABuildingRift, UsedSpawnSlots) == 0x000778, "Member 'ABuildingRift::UsedSpawnSlots' has a wrong offset!");
static_assert(offsetof(ABuildingRift, bRiftIsVisible) == 0x000798, "Member 'ABuildingRift::bRiftIsVisible' has a wrong offset!");
static_assert(offsetof(ABuildingRift, bRiftIsActive) == 0x000799, "Member 'ABuildingRift::bRiftIsActive' has a wrong offset!");
static_assert(offsetof(ABuildingRift, bIsReadyToSpawnAI) == 0x00079A, "Member 'ABuildingRift::bIsReadyToSpawnAI' has a wrong offset!");
static_assert(offsetof(ABuildingRift, bHasBadRiftSlots) == 0x00079B, "Member 'ABuildingRift::bHasBadRiftSlots' has a wrong offset!");

// Class FortniteGame.FortTakerRift
// 0x0028 (0x0800 - 0x07D8)
class AFortTakerRift final : public ABuildingRift
{
public:
	TSoftObjectPtr<class UParticleSystem>         TakerRiftParticle;                                 // 0x07D8(0x0020)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystemComponent*               TakerRiftParticleComponent;                        // 0x07F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTakerRift">();
	}
	static class AFortTakerRift* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortTakerRift>();
	}
};
static_assert(alignof(AFortTakerRift) == 0x000008, "Wrong alignment on AFortTakerRift");
static_assert(sizeof(AFortTakerRift) == 0x000800, "Wrong size on AFortTakerRift");
static_assert(offsetof(AFortTakerRift, TakerRiftParticle) == 0x0007D8, "Member 'AFortTakerRift::TakerRiftParticle' has a wrong offset!");
static_assert(offsetof(AFortTakerRift, TakerRiftParticleComponent) == 0x0007F8, "Member 'AFortTakerRift::TakerRiftParticleComponent' has a wrong offset!");

// Class FortniteGame.FortCharacterType
// 0x0000 (0x0270 - 0x0270)
class UFortCharacterType : public UFortAccountItemDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCharacterType">();
	}
	static class UFortCharacterType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCharacterType>();
	}
};
static_assert(alignof(UFortCharacterType) == 0x000010, "Wrong alignment on UFortCharacterType");
static_assert(sizeof(UFortCharacterType) == 0x000270, "Wrong size on UFortCharacterType");

// Class FortniteGame.FortDefenderItemDefinition
// 0x0060 (0x02D0 - 0x0270)
class UFortDefenderItemDefinition final : public UFortCharacterType
{
public:
	TArray<struct FGameplayEffectApplicationInfo> CombinedStatGEs;                                   // 0x0270(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FFortAlterationSlots>           DefenderAlterationSlots;                           // 0x0280(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   AppearanceOverrideName;                            // 0x0290(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFortAttributeInitializationKey        AttributeInitKey;                                  // 0x0298(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   PawnClass;                                         // 0x02A8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C8[0x8];                                      // 0x02C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDefenderItemDefinition">();
	}
	static class UFortDefenderItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDefenderItemDefinition>();
	}
};
static_assert(alignof(UFortDefenderItemDefinition) == 0x000010, "Wrong alignment on UFortDefenderItemDefinition");
static_assert(sizeof(UFortDefenderItemDefinition) == 0x0002D0, "Wrong size on UFortDefenderItemDefinition");
static_assert(offsetof(UFortDefenderItemDefinition, CombinedStatGEs) == 0x000270, "Member 'UFortDefenderItemDefinition::CombinedStatGEs' has a wrong offset!");
static_assert(offsetof(UFortDefenderItemDefinition, DefenderAlterationSlots) == 0x000280, "Member 'UFortDefenderItemDefinition::DefenderAlterationSlots' has a wrong offset!");
static_assert(offsetof(UFortDefenderItemDefinition, AppearanceOverrideName) == 0x000290, "Member 'UFortDefenderItemDefinition::AppearanceOverrideName' has a wrong offset!");
static_assert(offsetof(UFortDefenderItemDefinition, AttributeInitKey) == 0x000298, "Member 'UFortDefenderItemDefinition::AttributeInitKey' has a wrong offset!");
static_assert(offsetof(UFortDefenderItemDefinition, PawnClass) == 0x0002A8, "Member 'UFortDefenderItemDefinition::PawnClass' has a wrong offset!");

// Class FortniteGame.FortAISpawnerInterface
// 0x0000 (0x0028 - 0x0028)
class IFortAISpawnerInterface final : public IInterface
{
public:
	bool IsReadyToReceiveNewSpawnGroup();
	bool OnReceiveSpawnGroup();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAISpawnerInterface">();
	}
	static class IFortAISpawnerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortAISpawnerInterface>();
	}
};
static_assert(alignof(IFortAISpawnerInterface) == 0x000008, "Wrong alignment on IFortAISpawnerInterface");
static_assert(sizeof(IFortAISpawnerInterface) == 0x000028, "Wrong size on IFortAISpawnerInterface");

// Class FortniteGame.FortWorldItemTooltip
// 0x0000 (0x0090 - 0x0090)
class UFortWorldItemTooltip : public UFortItemTooltip
{
public:
	bool GetNumericValue(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, float* OutVal) const;
	bool GetTextForToken(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, class FText* OutText) const;
	bool GetTokenizedDescriptionText(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, TArray<class FText>* OutDescription) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortWorldItemTooltip">();
	}
	static class UFortWorldItemTooltip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortWorldItemTooltip>();
	}
};
static_assert(alignof(UFortWorldItemTooltip) == 0x000008, "Wrong alignment on UFortWorldItemTooltip");
static_assert(sizeof(UFortWorldItemTooltip) == 0x000090, "Wrong size on UFortWorldItemTooltip");

// Class FortniteGame.FortWeaponTooltip
// 0x0088 (0x0118 - 0x0090)
class UFortWeaponTooltip : public UFortWorldItemTooltip
{
public:
	class UFortWorldItem*                         CachedWeapon;                                      // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_98[0x80];                                      // 0x0098(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetNumericValue(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, float* OutVal) const;
	bool GetTextForToken(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, class FText* OutText) const;
	bool GetTokenizedDescriptionText(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, TArray<class FText>* OutDescription) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortWeaponTooltip">();
	}
	static class UFortWeaponTooltip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortWeaponTooltip>();
	}
};
static_assert(alignof(UFortWeaponTooltip) == 0x000008, "Wrong alignment on UFortWeaponTooltip");
static_assert(sizeof(UFortWeaponTooltip) == 0x000118, "Wrong size on UFortWeaponTooltip");
static_assert(offsetof(UFortWeaponTooltip, CachedWeapon) == 0x000090, "Member 'UFortWeaponTooltip::CachedWeapon' has a wrong offset!");

// Class FortniteGame.FortWeaponRangedTooltip
// 0x0000 (0x0118 - 0x0118)
class UFortWeaponRangedTooltip final : public UFortWeaponTooltip
{
public:
	bool GetNumericValue(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, float* OutVal) const;
	bool GetTextForToken(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, class FText* OutText) const;
	bool GetTokenizedDescriptionText(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, TArray<class FText>* OutDescription) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortWeaponRangedTooltip">();
	}
	static class UFortWeaponRangedTooltip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortWeaponRangedTooltip>();
	}
};
static_assert(alignof(UFortWeaponRangedTooltip) == 0x000008, "Wrong alignment on UFortWeaponRangedTooltip");
static_assert(sizeof(UFortWeaponRangedTooltip) == 0x000118, "Wrong size on UFortWeaponRangedTooltip");

// Class FortniteGame.BuildingAutoNav
// 0x0010 (0x0FD0 - 0x0FC0)
#pragma pack(push, 0x1)
class alignas(0x10) ABuildingAutoNav : public ABuildingSMActor
{
public:
	uint8                                         bAutoAssignNavProperties : 1;                      // 0x0FC0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_FC1[0x7];                                      // 0x0FC1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingAutoNav">();
	}
	static class ABuildingAutoNav* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingAutoNav>();
	}
};
#pragma pack(pop)
static_assert(alignof(ABuildingAutoNav) == 0x000010, "Wrong alignment on ABuildingAutoNav");
static_assert(sizeof(ABuildingAutoNav) == 0x000FD0, "Wrong size on ABuildingAutoNav");

// Class FortniteGame.BuildingContainer
// 0x0100 (0x10D0 - 0x0FD0)
#pragma pack(push, 0x1)
class alignas(0x10) ABuildingContainer : public ABuildingAutoNav
{
public:
	class USoundCue*                              SearchingSoundCueLoop;                             // 0x0FC8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              LootRepeatSoundCue;                                // 0x0FD0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              OnDamageSoundCue;                                  // 0x0FD8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              OnDeathSoundCue;                                   // 0x0FE0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            SearchedMesh;                                      // 0x0FE8(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             SearchedMaterialOverrides;                         // 0x0FF0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	float                                         SearchBounceRadiusOverride;                        // 0x1000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1004[0x4];                                     // 0x1004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SearchLootTierGroup;                               // 0x1008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FChosenQuotaInfo                       SearchLootTierChosenQuotaInfo;                     // 0x1010(0x0010)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   ContainerLootTierKey;                              // 0x1020(0x0008)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ReplicatedLootTier;                                // 0x1028(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              NumItemsToDropRange;                               // 0x102C(0x0008)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1034[0x4];                                     // 0x1034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortWorldItemDefinition*               LootTestingData;                                   // 0x1038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LootNoiseRange;                                    // 0x1040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LootNoiseLoudness;                                 // 0x1044(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LootSpawnLocation;                                 // 0x1048(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LootFinalLocation;                                 // 0x1054(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LootTossDirection_Athena;                          // 0x1060(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         LootTossSpeed_Athena;                              // 0x106C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LootTossConeHalfAngle_Athena;                      // 0x1070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortRarity                                   HighestRarity;                                     // 0x1074(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1075[0x3];                                     // 0x1075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bAlwaysShowContainer : 1;                          // 0x1078(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAlwaysMaintainLoot : 1;                           // 0x1078(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDestroyContainerOnSearch : 1;                     // 0x1078(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAlreadySearched : 1;                              // 0x1078(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, Net, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bBuriedTreasure : 1;                               // 0x1078(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bHasRaisedTreasure : 1;                            // 0x1078(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bStartAlreadySearched_Athena : 1;                  // 0x1078(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bRegenerateLoot : 1;                               // 0x1078(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1079[0x3];                                     // 0x1079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LootedWeaponsDurabilityModifier;                   // 0x107C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeUntilLootRegenerates;                          // 0x1080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFortSearchBounceData                  SearchBounceData;                                  // 0x1084(0x0010)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bUseLocationForDrop;                               // 0x1094(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1095[0x3];                                     // 0x1095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCurveTableRowHandle                   SearchSpeed;                                       // 0x1098(0x0010)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_10A8[0x10];                                    // 0x10A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            CurrentInteractBounceCurve;                        // 0x10B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            CurrentInteractBounceNormalCurve;                  // 0x10C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10C8[0x4];                                     // 0x10C8(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BounceContainer();
	int32 GetLootTier();
	void OnBeginSearch();
	void OnLoot();
	void OnLootRepeat();
	void OnLootReset();
	void OnRaiseTreasure();
	void OnRep_bAlreadySearched();
	void OnSearchInterrupted();
	void OnSetSearched();
	void RaiseTreasure();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingContainer">();
	}
	static class ABuildingContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingContainer>();
	}
};
#pragma pack(pop)
static_assert(alignof(ABuildingContainer) == 0x000010, "Wrong alignment on ABuildingContainer");
static_assert(sizeof(ABuildingContainer) == 0x0010D0, "Wrong size on ABuildingContainer");
static_assert(offsetof(ABuildingContainer, SearchingSoundCueLoop) == 0x000FC8, "Member 'ABuildingContainer::SearchingSoundCueLoop' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, LootRepeatSoundCue) == 0x000FD0, "Member 'ABuildingContainer::LootRepeatSoundCue' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, OnDamageSoundCue) == 0x000FD8, "Member 'ABuildingContainer::OnDamageSoundCue' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, OnDeathSoundCue) == 0x000FE0, "Member 'ABuildingContainer::OnDeathSoundCue' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, SearchedMesh) == 0x000FE8, "Member 'ABuildingContainer::SearchedMesh' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, SearchedMaterialOverrides) == 0x000FF0, "Member 'ABuildingContainer::SearchedMaterialOverrides' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, SearchBounceRadiusOverride) == 0x001000, "Member 'ABuildingContainer::SearchBounceRadiusOverride' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, SearchLootTierGroup) == 0x001008, "Member 'ABuildingContainer::SearchLootTierGroup' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, SearchLootTierChosenQuotaInfo) == 0x001010, "Member 'ABuildingContainer::SearchLootTierChosenQuotaInfo' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, ContainerLootTierKey) == 0x001020, "Member 'ABuildingContainer::ContainerLootTierKey' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, ReplicatedLootTier) == 0x001028, "Member 'ABuildingContainer::ReplicatedLootTier' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, NumItemsToDropRange) == 0x00102C, "Member 'ABuildingContainer::NumItemsToDropRange' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, LootTestingData) == 0x001038, "Member 'ABuildingContainer::LootTestingData' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, LootNoiseRange) == 0x001040, "Member 'ABuildingContainer::LootNoiseRange' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, LootNoiseLoudness) == 0x001044, "Member 'ABuildingContainer::LootNoiseLoudness' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, LootSpawnLocation) == 0x001048, "Member 'ABuildingContainer::LootSpawnLocation' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, LootFinalLocation) == 0x001054, "Member 'ABuildingContainer::LootFinalLocation' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, LootTossDirection_Athena) == 0x001060, "Member 'ABuildingContainer::LootTossDirection_Athena' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, LootTossSpeed_Athena) == 0x00106C, "Member 'ABuildingContainer::LootTossSpeed_Athena' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, LootTossConeHalfAngle_Athena) == 0x001070, "Member 'ABuildingContainer::LootTossConeHalfAngle_Athena' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, HighestRarity) == 0x001074, "Member 'ABuildingContainer::HighestRarity' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, LootedWeaponsDurabilityModifier) == 0x00107C, "Member 'ABuildingContainer::LootedWeaponsDurabilityModifier' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, TimeUntilLootRegenerates) == 0x001080, "Member 'ABuildingContainer::TimeUntilLootRegenerates' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, SearchBounceData) == 0x001084, "Member 'ABuildingContainer::SearchBounceData' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, bUseLocationForDrop) == 0x001094, "Member 'ABuildingContainer::bUseLocationForDrop' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, SearchSpeed) == 0x001098, "Member 'ABuildingContainer::SearchSpeed' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, CurrentInteractBounceCurve) == 0x0010B8, "Member 'ABuildingContainer::CurrentInteractBounceCurve' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, CurrentInteractBounceNormalCurve) == 0x0010C0, "Member 'ABuildingContainer::CurrentInteractBounceNormalCurve' has a wrong offset!");

// Class FortniteGame.FortGameplayAbilityTooltip
// 0x0088 (0x0118 - 0x0090)
class UFortGameplayAbilityTooltip : public UFortTooltip
{
public:
	struct FGameplayAbilitySpec                   CachedSpec;                                        // 0x0090(0x0078)(Transient, NativeAccessSpecifierPrivate)
	class UGameplayAbility*                       CachedAbilityInstance;                             // 0x0108(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortTooltipContext*                    CachedContext;                                     // 0x0110(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool GetApplicationTag(const class UGameplayAbility* AbilityInstance, struct FGameplayTag* OutTag) const;
	bool GetNumericValue(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, float* OutVal) const;
	bool GetTextForToken(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, class FText* OutText) const;
	bool GetTextForTokenFromAbilityInstance(const class UGameplayAbility* AbilityInstance, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, class FText* OutText) const;
	bool GetTextForTokenFromAbilityInstanceInternal(const class UGameplayAbility* AbilityInstance, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, class FText* OutText) const;
	bool GetTextForTokenFromAbilitySpec(const struct FGameplayAbilitySpec& Spec, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, class FText* OutText) const;
	bool GetTextForTokenFromAbilitySpecInternal(const struct FGameplayAbilitySpec& Spec, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, class FText* OutText) const;
	bool GetTokenizedDescriptionText(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, TArray<class FText>* OutDescription) const;
	void InitializeAbilityInstance(const class UGameplayAbility* AbilityInstance, const class UFortTooltipContext* Context) const;
	void InitializeAbilityInstanceInternal(const class UGameplayAbility* AbilityInstance, const class UFortTooltipContext* Context) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameplayAbilityTooltip">();
	}
	static class UFortGameplayAbilityTooltip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGameplayAbilityTooltip>();
	}
};
static_assert(alignof(UFortGameplayAbilityTooltip) == 0x000008, "Wrong alignment on UFortGameplayAbilityTooltip");
static_assert(sizeof(UFortGameplayAbilityTooltip) == 0x000118, "Wrong size on UFortGameplayAbilityTooltip");
static_assert(offsetof(UFortGameplayAbilityTooltip, CachedSpec) == 0x000090, "Member 'UFortGameplayAbilityTooltip::CachedSpec' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbilityTooltip, CachedAbilityInstance) == 0x000108, "Member 'UFortGameplayAbilityTooltip::CachedAbilityInstance' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbilityTooltip, CachedContext) == 0x000110, "Member 'UFortGameplayAbilityTooltip::CachedContext' has a wrong offset!");

// Class FortniteGame.FortAIObjectiveInterface
// 0x0000 (0x0028 - 0x0028)
class IFortAIObjectiveInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIObjectiveInterface">();
	}
	static class IFortAIObjectiveInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortAIObjectiveInterface>();
	}
};
static_assert(alignof(IFortAIObjectiveInterface) == 0x000008, "Wrong alignment on IFortAIObjectiveInterface");
static_assert(sizeof(IFortAIObjectiveInterface) == 0x000028, "Wrong size on IFortAIObjectiveInterface");

// Class FortniteGame.KeepItemContainer
// 0x0070 (0x1140 - 0x10D0)
class AKeepItemContainer : public ABuildingContainer
{
public:
	int32                                         HostUpgradeLevel;                                  // 0x10CC(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class AFortPlayerState>> SearchedBy;                                        // 0x10D0(0x0010)(Net, ZeroConstructor, RepNotify, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	EKeepContainerType                            ContainerType;                                     // 0x10E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseDefaultLootLogic;                              // 0x10E1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bResetThisWhenKeepResets;                          // 0x10E2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10E3[0x5];                                     // 0x10E3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ContainerNameKey;                                  // 0x10E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             ContainerDataTable;                                // 0x10F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowChoiceUI;                                     // 0x10F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10F9[0x7];                                     // 0x10F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EFortItemType>                         ItemsInChoiceUI;                                   // 0x1100(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1110[0x10];                                    // 0x1110(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	EFortRarity                                   BestAvailableRarity;                               // 0x1120(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1121[0x3];                                     // 0x1121(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxItems;                                          // 0x1124(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1128[0x18];                                    // 0x1128(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FName GetContainerNameAndLevelKey();
	void InitializeContainer(int32 InitUpgradeLevel);
	void OnRep_HostUpgradeLevel();
	void OnRep_SearchedBy();
	void ResetContainer(class AFortPlayerController* FortPC);
	void RestoreLoot();

	int32 GetLootTierOverride() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KeepItemContainer">();
	}
	static class AKeepItemContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKeepItemContainer>();
	}
};
static_assert(alignof(AKeepItemContainer) == 0x000010, "Wrong alignment on AKeepItemContainer");
static_assert(sizeof(AKeepItemContainer) == 0x001140, "Wrong size on AKeepItemContainer");
static_assert(offsetof(AKeepItemContainer, HostUpgradeLevel) == 0x0010CC, "Member 'AKeepItemContainer::HostUpgradeLevel' has a wrong offset!");
static_assert(offsetof(AKeepItemContainer, SearchedBy) == 0x0010D0, "Member 'AKeepItemContainer::SearchedBy' has a wrong offset!");
static_assert(offsetof(AKeepItemContainer, ContainerType) == 0x0010E0, "Member 'AKeepItemContainer::ContainerType' has a wrong offset!");
static_assert(offsetof(AKeepItemContainer, bUseDefaultLootLogic) == 0x0010E1, "Member 'AKeepItemContainer::bUseDefaultLootLogic' has a wrong offset!");
static_assert(offsetof(AKeepItemContainer, bResetThisWhenKeepResets) == 0x0010E2, "Member 'AKeepItemContainer::bResetThisWhenKeepResets' has a wrong offset!");
static_assert(offsetof(AKeepItemContainer, ContainerNameKey) == 0x0010E8, "Member 'AKeepItemContainer::ContainerNameKey' has a wrong offset!");
static_assert(offsetof(AKeepItemContainer, ContainerDataTable) == 0x0010F0, "Member 'AKeepItemContainer::ContainerDataTable' has a wrong offset!");
static_assert(offsetof(AKeepItemContainer, bShowChoiceUI) == 0x0010F8, "Member 'AKeepItemContainer::bShowChoiceUI' has a wrong offset!");
static_assert(offsetof(AKeepItemContainer, ItemsInChoiceUI) == 0x001100, "Member 'AKeepItemContainer::ItemsInChoiceUI' has a wrong offset!");
static_assert(offsetof(AKeepItemContainer, BestAvailableRarity) == 0x001120, "Member 'AKeepItemContainer::BestAvailableRarity' has a wrong offset!");
static_assert(offsetof(AKeepItemContainer, MaxItems) == 0x001124, "Member 'AKeepItemContainer::MaxItems' has a wrong offset!");

// Class FortniteGame.KeepItemCoreContainer
// 0x0000 (0x1140 - 0x1140)
class AKeepItemCoreContainer final : public AKeepItemContainer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KeepItemCoreContainer">();
	}
	static class AKeepItemCoreContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKeepItemCoreContainer>();
	}
};
static_assert(alignof(AKeepItemCoreContainer) == 0x000010, "Wrong alignment on AKeepItemCoreContainer");
static_assert(sizeof(AKeepItemCoreContainer) == 0x001140, "Wrong size on AKeepItemCoreContainer");

// Class FortniteGame.FortCodeTokenItemDefinition
// 0x0030 (0x02A0 - 0x0270)
class UFortCodeTokenItemDefinition final : public UFortAccountItemDefinition
{
public:
	class FString                                 RedemptionCodeRule;                                // 0x0270(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RedemptionCodeGroup;                               // 0x0280(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<ECodeTokenPlatform>                    AllowedPlatforms;                                  // 0x0290(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCodeTokenItemDefinition">();
	}
	static class UFortCodeTokenItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCodeTokenItemDefinition>();
	}
};
static_assert(alignof(UFortCodeTokenItemDefinition) == 0x000010, "Wrong alignment on UFortCodeTokenItemDefinition");
static_assert(sizeof(UFortCodeTokenItemDefinition) == 0x0002A0, "Wrong size on UFortCodeTokenItemDefinition");
static_assert(offsetof(UFortCodeTokenItemDefinition, RedemptionCodeRule) == 0x000270, "Member 'UFortCodeTokenItemDefinition::RedemptionCodeRule' has a wrong offset!");
static_assert(offsetof(UFortCodeTokenItemDefinition, RedemptionCodeGroup) == 0x000280, "Member 'UFortCodeTokenItemDefinition::RedemptionCodeGroup' has a wrong offset!");
static_assert(offsetof(UFortCodeTokenItemDefinition, AllowedPlatforms) == 0x000290, "Member 'UFortCodeTokenItemDefinition::AllowedPlatforms' has a wrong offset!");

// Class FortniteGame.FortActorIndicatorInterface
// 0x0000 (0x0028 - 0x0028)
class IFortActorIndicatorInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortActorIndicatorInterface">();
	}
	static class IFortActorIndicatorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortActorIndicatorInterface>();
	}
};
static_assert(alignof(IFortActorIndicatorInterface) == 0x000008, "Wrong alignment on IFortActorIndicatorInterface");
static_assert(sizeof(IFortActorIndicatorInterface) == 0x000028, "Wrong size on IFortActorIndicatorInterface");

// Class FortniteGame.BuildingCorner
// 0x0010 (0x0FE0 - 0x0FD0)
class ABuildingCorner : public ABuildingAutoNav
{
public:
	class ABuildingSMActor*                       PrimaryWall;                                       // 0x0FC8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABuildingSMActor*                       SecondaryWall;                                     // 0x0FD0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FD8[0x8];                                      // 0x0FD8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingCorner">();
	}
	static class ABuildingCorner* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingCorner>();
	}
};
static_assert(alignof(ABuildingCorner) == 0x000010, "Wrong alignment on ABuildingCorner");
static_assert(sizeof(ABuildingCorner) == 0x000FE0, "Wrong size on ABuildingCorner");
static_assert(offsetof(ABuildingCorner, PrimaryWall) == 0x000FC8, "Member 'ABuildingCorner::PrimaryWall' has a wrong offset!");
static_assert(offsetof(ABuildingCorner, SecondaryWall) == 0x000FD0, "Member 'ABuildingCorner::SecondaryWall' has a wrong offset!");

// Class FortniteGame.BuildingPropCorner
// 0x0000 (0x0FE0 - 0x0FE0)
class ABuildingPropCorner final : public ABuildingCorner
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingPropCorner">();
	}
	static class ABuildingPropCorner* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingPropCorner>();
	}
};
static_assert(alignof(ABuildingPropCorner) == 0x000010, "Wrong alignment on ABuildingPropCorner");
static_assert(sizeof(ABuildingPropCorner) == 0x000FE0, "Wrong size on ABuildingPropCorner");

// Class FortniteGame.FortWeaponRanged
// 0x0218 (0x0CA0 - 0x0A88)
class AFortWeaponRanged : public AFortWeapon
{
public:
	TSubclassOf<class AFortTracerBase>            TracerTemplate;                                    // 0x0A88(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentNumBullets;                                 // 0x0A90(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ScopeTargetingMuzzleOffset;                        // 0x0A94(0x000C)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                CurrentMuzzleBlockedLocation;                      // 0x0AA0(0x000C)(Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               MaxTargetingAimAdjustment;                         // 0x0AAC(0x000C)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         ProjectilePitchOffset;                             // 0x0AB8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bShouldDisplayAmmoCounter : 1;                     // 0x0ABC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bShouldAimFromMuzzleAtCloseRange : 1;              // 0x0ABC(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bMaintainAimLocationDuringTargeting : 1;           // 0x0ABC(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUseScopeTargeting : 1;                            // 0x0ABC(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bPersistentFireFX : 1;                             // 0x0ABC(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUseBeamParticles : 1;                             // 0x0ABC(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUseImpactFXForProjectiles : 1;                    // 0x0ABC(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUseImpactFXForProjectileOverlaps : 1;             // 0x0ABC(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUseImpactDecals : 1;                              // 0x0ABD(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUsePersistentBeam : 1;                            // 0x0ABD(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_ABE[0x2];                                      // 0x0ABE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortEffectDistanceQuality             BeamSignificance;                                  // 0x0AC0(0x0018)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FFortEffectDistanceQuality             ImpactSignificance;                                // 0x0AD8(0x0018)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FFortEffectDistanceQuality             DecalSignificance;                                 // 0x0AF0(0x0018)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         ScopeImpactEffectDistanceOffset;                   // 0x0B08(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B0C[0x4];                                      // 0x0B0C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        BeamParticleSystem;                                // 0x0B10(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BeamSourceSocketName;                              // 0x0B18(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                DecalSizeMin;                                      // 0x0B20(0x000C)(Edit, BlueprintVisible, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                DecalSizeMax;                                      // 0x0B2C(0x000C)(Edit, BlueprintVisible, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DecalLifespanMin;                                  // 0x0B38(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DecalLifespanMax;                                  // 0x0B3C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           DecalColorStart;                                   // 0x0B40(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           DecalColorEnd;                                     // 0x0B50(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     DecalMaterial;                                     // 0x0B60(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             DecalTexture;                                      // 0x0B68(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<EPhysicalSurface>                      SurfaceAcceptingDecals;                            // 0x0B70(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_B80[0x4];                                      // 0x0B80(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ShellReloadCounter;                                // 0x0B84(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B88[0x4];                                      // 0x0B88(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               TargetingRotAdjustmentTotal;                       // 0x0B8C(0x000C)(Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         LastTargetingRotAdjustmentWeight;                  // 0x0B98(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B9C[0xDC];                                     // 0x0B9C(0x00DC)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           FireAnimation;                                     // 0x0C78(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           FireDownsightsAnimation;                           // 0x0C80(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           WeaponFireMontage;                                 // 0x0C88(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           WeaponFireDownsightsMontage;                       // 0x0C90(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               BeamPSC;                                           // 0x0C98(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void DeactivateBeamFX();
	void InitializeBeamFX(class UParticleSystemComponent* InBeamPSC);
	bool ShouldSpawnBulletShellFX();

	float GetTimeToNextFire() const;
	bool IsUsingFirstPersonCamera() const;
	bool IsUsingScope() const;
	bool IsUsingScopeOrFirstPersonCamera() const;
	bool ShouldDisplayAmmoCounter() const;
	bool UseScopeTargeting() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortWeaponRanged">();
	}
	static class AFortWeaponRanged* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortWeaponRanged>();
	}
};
static_assert(alignof(AFortWeaponRanged) == 0x000008, "Wrong alignment on AFortWeaponRanged");
static_assert(sizeof(AFortWeaponRanged) == 0x000CA0, "Wrong size on AFortWeaponRanged");
static_assert(offsetof(AFortWeaponRanged, TracerTemplate) == 0x000A88, "Member 'AFortWeaponRanged::TracerTemplate' has a wrong offset!");
static_assert(offsetof(AFortWeaponRanged, CurrentNumBullets) == 0x000A90, "Member 'AFortWeaponRanged::CurrentNumBullets' has a wrong offset!");
static_assert(offsetof(AFortWeaponRanged, ScopeTargetingMuzzleOffset) == 0x000A94, "Member 'AFortWeaponRanged::ScopeTargetingMuzzleOffset' has a wrong offset!");
static_assert(offsetof(AFortWeaponRanged, CurrentMuzzleBlockedLocation) == 0x000AA0, "Member 'AFortWeaponRanged::CurrentMuzzleBlockedLocation' has a wrong offset!");
static_assert(offsetof(AFortWeaponRanged, MaxTargetingAimAdjustment) == 0x000AAC, "Member 'AFortWeaponRanged::MaxTargetingAimAdjustment' has a wrong offset!");
static_assert(offsetof(AFortWeaponRanged, ProjectilePitchOffset) == 0x000AB8, "Member 'AFortWeaponRanged::ProjectilePitchOffset' has a wrong offset!");
static_assert(offsetof(AFortWeaponRanged, BeamSignificance) == 0x000AC0, "Member 'AFortWeaponRanged::BeamSignificance' has a wrong offset!");
static_assert(offsetof(AFortWeaponRanged, ImpactSignificance) == 0x000AD8, "Member 'AFortWeaponRanged::ImpactSignificance' has a wrong offset!");
static_assert(offsetof(AFortWeaponRanged, DecalSignificance) == 0x000AF0, "Member 'AFortWeaponRanged::DecalSignificance' has a wrong offset!");
static_assert(offsetof(AFortWeaponRanged, ScopeImpactEffectDistanceOffset) == 0x000B08, "Member 'AFortWeaponRanged::ScopeImpactEffectDistanceOffset' has a wrong offset!");
static_assert(offsetof(AFortWeaponRanged, BeamParticleSystem) == 0x000B10, "Member 'AFortWeaponRanged::BeamParticleSystem' has a wrong offset!");
static_assert(offsetof(AFortWeaponRanged, BeamSourceSocketName) == 0x000B18, "Member 'AFortWeaponRanged::BeamSourceSocketName' has a wrong offset!");
static_assert(offsetof(AFortWeaponRanged, DecalSizeMin) == 0x000B20, "Member 'AFortWeaponRanged::DecalSizeMin' has a wrong offset!");
static_assert(offsetof(AFortWeaponRanged, DecalSizeMax) == 0x000B2C, "Member 'AFortWeaponRanged::DecalSizeMax' has a wrong offset!");
static_assert(offsetof(AFortWeaponRanged, DecalLifespanMin) == 0x000B38, "Member 'AFortWeaponRanged::DecalLifespanMin' has a wrong offset!");
static_assert(offsetof(AFortWeaponRanged, DecalLifespanMax) == 0x000B3C, "Member 'AFortWeaponRanged::DecalLifespanMax' has a wrong offset!");
static_assert(offsetof(AFortWeaponRanged, DecalColorStart) == 0x000B40, "Member 'AFortWeaponRanged::DecalColorStart' has a wrong offset!");
static_assert(offsetof(AFortWeaponRanged, DecalColorEnd) == 0x000B50, "Member 'AFortWeaponRanged::DecalColorEnd' has a wrong offset!");
static_assert(offsetof(AFortWeaponRanged, DecalMaterial) == 0x000B60, "Member 'AFortWeaponRanged::DecalMaterial' has a wrong offset!");
static_assert(offsetof(AFortWeaponRanged, DecalTexture) == 0x000B68, "Member 'AFortWeaponRanged::DecalTexture' has a wrong offset!");
static_assert(offsetof(AFortWeaponRanged, SurfaceAcceptingDecals) == 0x000B70, "Member 'AFortWeaponRanged::SurfaceAcceptingDecals' has a wrong offset!");
static_assert(offsetof(AFortWeaponRanged, ShellReloadCounter) == 0x000B84, "Member 'AFortWeaponRanged::ShellReloadCounter' has a wrong offset!");
static_assert(offsetof(AFortWeaponRanged, TargetingRotAdjustmentTotal) == 0x000B8C, "Member 'AFortWeaponRanged::TargetingRotAdjustmentTotal' has a wrong offset!");
static_assert(offsetof(AFortWeaponRanged, LastTargetingRotAdjustmentWeight) == 0x000B98, "Member 'AFortWeaponRanged::LastTargetingRotAdjustmentWeight' has a wrong offset!");
static_assert(offsetof(AFortWeaponRanged, FireAnimation) == 0x000C78, "Member 'AFortWeaponRanged::FireAnimation' has a wrong offset!");
static_assert(offsetof(AFortWeaponRanged, FireDownsightsAnimation) == 0x000C80, "Member 'AFortWeaponRanged::FireDownsightsAnimation' has a wrong offset!");
static_assert(offsetof(AFortWeaponRanged, WeaponFireMontage) == 0x000C88, "Member 'AFortWeaponRanged::WeaponFireMontage' has a wrong offset!");
static_assert(offsetof(AFortWeaponRanged, WeaponFireDownsightsMontage) == 0x000C90, "Member 'AFortWeaponRanged::WeaponFireDownsightsMontage' has a wrong offset!");
static_assert(offsetof(AFortWeaponRanged, BeamPSC) == 0x000C98, "Member 'AFortWeaponRanged::BeamPSC' has a wrong offset!");

// Class FortniteGame.FortSpottableActorInterface
// 0x0000 (0x0028 - 0x0028)
class IFortSpottableActorInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortSpottableActorInterface">();
	}
	static class IFortSpottableActorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortSpottableActorInterface>();
	}
};
static_assert(alignof(IFortSpottableActorInterface) == 0x000008, "Wrong alignment on IFortSpottableActorInterface");
static_assert(sizeof(IFortSpottableActorInterface) == 0x000028, "Wrong size on IFortSpottableActorInterface");

// Class FortniteGame.BuildingDeco
// 0x0000 (0x0FD0 - 0x0FD0)
class ABuildingDeco final : public ABuildingAutoNav
{
public:
	bool                                          bCastShadow;                                       // 0x0FC8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC9[0x7];                                      // 0x0FC9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingDeco">();
	}
	static class ABuildingDeco* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingDeco>();
	}
};
static_assert(alignof(ABuildingDeco) == 0x000010, "Wrong alignment on ABuildingDeco");
static_assert(sizeof(ABuildingDeco) == 0x000FD0, "Wrong size on ABuildingDeco");
static_assert(offsetof(ABuildingDeco, bCastShadow) == 0x000FC8, "Member 'ABuildingDeco::bCastShadow' has a wrong offset!");

// Class FortniteGame.BuildingPillar
// 0x0000 (0x0FD0 - 0x0FD0)
class ABuildingPillar : public ABuildingAutoNav
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingPillar">();
	}
	static class ABuildingPillar* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingPillar>();
	}
};
static_assert(alignof(ABuildingPillar) == 0x000010, "Wrong alignment on ABuildingPillar");
static_assert(sizeof(ABuildingPillar) == 0x000FD0, "Wrong size on ABuildingPillar");

// Class FortniteGame.FortCurrencyItem
// 0x0008 (0x0140 - 0x0138)
class UFortCurrencyItem final : public UFortAccountItem
{
public:
	uint8                                         Pad_138[0x8];                                      // 0x0138(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCurrencyItem">();
	}
	static class UFortCurrencyItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCurrencyItem>();
	}
};
static_assert(alignof(UFortCurrencyItem) == 0x000008, "Wrong alignment on UFortCurrencyItem");
static_assert(sizeof(UFortCurrencyItem) == 0x000140, "Wrong size on UFortCurrencyItem");

// Class FortniteGame.FortAIAssignmentSettings
// 0x0060 (0x0088 - 0x0028)
class UFortAIAssignmentSettings final : public UDataAsset
{
public:
	TArray<struct FGoalSelectionQueryInfo>        GoalSelectionQueryInfos;                           // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          bGoalLocationsAlwaysKnown;                         // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsEnemyAssignment;                                // 0x0039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  RequiredTags;                                      // 0x0040(0x0020)(Edit, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  ProhibitedTags;                                    // 0x0060(0x0020)(Edit, NativeAccessSpecifierPrivate)
	float                                         MaxAIAllowedForAssignment;                         // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxAIAllowedPerGoal;                               // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIAssignmentSettings">();
	}
	static class UFortAIAssignmentSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIAssignmentSettings>();
	}
};
static_assert(alignof(UFortAIAssignmentSettings) == 0x000008, "Wrong alignment on UFortAIAssignmentSettings");
static_assert(sizeof(UFortAIAssignmentSettings) == 0x000088, "Wrong size on UFortAIAssignmentSettings");
static_assert(offsetof(UFortAIAssignmentSettings, GoalSelectionQueryInfos) == 0x000028, "Member 'UFortAIAssignmentSettings::GoalSelectionQueryInfos' has a wrong offset!");
static_assert(offsetof(UFortAIAssignmentSettings, bGoalLocationsAlwaysKnown) == 0x000038, "Member 'UFortAIAssignmentSettings::bGoalLocationsAlwaysKnown' has a wrong offset!");
static_assert(offsetof(UFortAIAssignmentSettings, bIsEnemyAssignment) == 0x000039, "Member 'UFortAIAssignmentSettings::bIsEnemyAssignment' has a wrong offset!");
static_assert(offsetof(UFortAIAssignmentSettings, RequiredTags) == 0x000040, "Member 'UFortAIAssignmentSettings::RequiredTags' has a wrong offset!");
static_assert(offsetof(UFortAIAssignmentSettings, ProhibitedTags) == 0x000060, "Member 'UFortAIAssignmentSettings::ProhibitedTags' has a wrong offset!");
static_assert(offsetof(UFortAIAssignmentSettings, MaxAIAllowedForAssignment) == 0x000080, "Member 'UFortAIAssignmentSettings::MaxAIAllowedForAssignment' has a wrong offset!");
static_assert(offsetof(UFortAIAssignmentSettings, MaxAIAllowedPerGoal) == 0x000084, "Member 'UFortAIAssignmentSettings::MaxAIAllowedPerGoal' has a wrong offset!");

// Class FortniteGame.FortUIBaseClass
// 0x0068 (0x04D8 - 0x0470)
class AFortUIBaseClass : public AHUD
{
public:
	uint8                                         Pad_470[0x68];                                     // 0x0470(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortUIBaseClass">();
	}
	static class AFortUIBaseClass* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortUIBaseClass>();
	}
};
static_assert(alignof(AFortUIBaseClass) == 0x000008, "Wrong alignment on AFortUIBaseClass");
static_assert(sizeof(AFortUIBaseClass) == 0x0004D8, "Wrong size on AFortUIBaseClass");

// Class FortniteGame.FortUIZone
// 0x03E8 (0x08C0 - 0x04D8)
class AFortUIZone : public AFortUIBaseClass
{
public:
	struct FFontRenderInfo                        TextRenderInfo;                                    // 0x04D8(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	class UReporterGraph*                         CombatGraph;                                       // 0x0500(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReporterGraph*                         FactorGraph;                                       // 0x0508(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReporterGraph*                         IntensityGraph;                                    // 0x0510(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReporterGraph*                         PIDValuesGraph;                                    // 0x0518(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReporterGraph*                         PIDContributionsGraph;                             // 0x0520(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReporterGraph*                         UtilitiesGraph;                                    // 0x0528(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_530[0x70];                                     // 0x0530(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	EFortContextualReticleTypes                   CurrentContextualReticleIconType;                  // 0x05A0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A1[0x3];                                      // 0x05A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 CurrentContextualReticleColor;                     // 0x05A4(0x0004)(Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              ContextualReticleIcons[0x8];                       // 0x05A8(0x0020)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6A8[0x200];                                    // 0x06A8(0x0200)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UFortSpottedActorIndicator*>     SpottedActorIndicators;                            // 0x08A8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_8B8[0x8];                                      // 0x08B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ToggleTargetInfo();
	void ToggleTargetInfoAI();
	void ToggleTargetInfoLock(bool bTraceComplex);
	void ToggleTargetInfoPaths();
	void ToggleTargetInfoSensing();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortUIZone">();
	}
	static class AFortUIZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortUIZone>();
	}
};
static_assert(alignof(AFortUIZone) == 0x000008, "Wrong alignment on AFortUIZone");
static_assert(sizeof(AFortUIZone) == 0x0008C0, "Wrong size on AFortUIZone");
static_assert(offsetof(AFortUIZone, TextRenderInfo) == 0x0004D8, "Member 'AFortUIZone::TextRenderInfo' has a wrong offset!");
static_assert(offsetof(AFortUIZone, CombatGraph) == 0x000500, "Member 'AFortUIZone::CombatGraph' has a wrong offset!");
static_assert(offsetof(AFortUIZone, FactorGraph) == 0x000508, "Member 'AFortUIZone::FactorGraph' has a wrong offset!");
static_assert(offsetof(AFortUIZone, IntensityGraph) == 0x000510, "Member 'AFortUIZone::IntensityGraph' has a wrong offset!");
static_assert(offsetof(AFortUIZone, PIDValuesGraph) == 0x000518, "Member 'AFortUIZone::PIDValuesGraph' has a wrong offset!");
static_assert(offsetof(AFortUIZone, PIDContributionsGraph) == 0x000520, "Member 'AFortUIZone::PIDContributionsGraph' has a wrong offset!");
static_assert(offsetof(AFortUIZone, UtilitiesGraph) == 0x000528, "Member 'AFortUIZone::UtilitiesGraph' has a wrong offset!");
static_assert(offsetof(AFortUIZone, CurrentContextualReticleIconType) == 0x0005A0, "Member 'AFortUIZone::CurrentContextualReticleIconType' has a wrong offset!");
static_assert(offsetof(AFortUIZone, CurrentContextualReticleColor) == 0x0005A4, "Member 'AFortUIZone::CurrentContextualReticleColor' has a wrong offset!");
static_assert(offsetof(AFortUIZone, ContextualReticleIcons) == 0x0005A8, "Member 'AFortUIZone::ContextualReticleIcons' has a wrong offset!");
static_assert(offsetof(AFortUIZone, SpottedActorIndicators) == 0x0008A8, "Member 'AFortUIZone::SpottedActorIndicators' has a wrong offset!");

// Class FortniteGame.FortUIPvP
// 0x0000 (0x08C0 - 0x08C0)
class AFortUIPvP : public AFortUIZone
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortUIPvP">();
	}
	static class AFortUIPvP* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortUIPvP>();
	}
};
static_assert(alignof(AFortUIPvP) == 0x000008, "Wrong alignment on AFortUIPvP");
static_assert(sizeof(AFortUIPvP) == 0x0008C0, "Wrong size on AFortUIPvP");

// Class FortniteGame.BuildingProp
// 0x0000 (0x0FD0 - 0x0FD0)
#pragma pack(push, 0x1)
class alignas(0x10) ABuildingProp : public ABuildingAutoNav
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingProp">();
	}
	static class ABuildingProp* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingProp>();
	}
};
#pragma pack(pop)
static_assert(alignof(ABuildingProp) == 0x000010, "Wrong alignment on ABuildingProp");
static_assert(sizeof(ABuildingProp) == 0x000FD0, "Wrong size on ABuildingProp");

// Class FortniteGame.BuildingPropAtlas
// 0x0140 (0x1110 - 0x0FD0)
class ABuildingPropAtlas final : public ABuildingProp
{
public:
	class UPrimitiveComponent*                    Ring1Comp;                                         // 0x0FC8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPrimitiveComponent*                    Ring2Comp;                                         // 0x0FD0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPrimitiveComponent*                    Ring3Comp;                                         // 0x0FD8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               RingTransitionMID;                                 // 0x0FE0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        PortalAudioComp;                                   // 0x0FE8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FF0[0x120];                                    // 0x0FF0(0x0120)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeAudio(class UAudioComponent* InPortalLoopingComp);
	void InitializeRings(class UPrimitiveComponent* InRing1Comp, class UPrimitiveComponent* InRing2Comp, class UPrimitiveComponent* InRing3Comp);
	void OnRingSpinningLoop();
	void PlayRingDamage(float DurationMin, float DurationMax, float MagnitudeMin, float MagnitudeMax);
	void PlayRingsIdleLoop(float AnimDuration, float Ring1ZOffset);
	void PlayRingSpinning(const struct FRotator& Ring1RateMin, const struct FRotator& Ring1RateMax, const struct FRotator& Ring2Rate, const struct FRotator& Ring3Rate);
	void PlayRingsReset(float AnimDuration);
	void RestoreRingsHierarchy();
	void SetupAnimationSpeed(float InActivationTime, float InTotalDefenseTime, float InAnimSpeedStart, float InAnimSpeedEnd);
	void SetupAnimationTransition(class UMaterialInstanceDynamic* Mid, class FName ParamName, float InTransitionTime);
	void StopRingSpinning();

	float GetDefenseAnimSpeed() const;
	float GetDefenseProgress() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingPropAtlas">();
	}
	static class ABuildingPropAtlas* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingPropAtlas>();
	}
};
static_assert(alignof(ABuildingPropAtlas) == 0x000010, "Wrong alignment on ABuildingPropAtlas");
static_assert(sizeof(ABuildingPropAtlas) == 0x001110, "Wrong size on ABuildingPropAtlas");
static_assert(offsetof(ABuildingPropAtlas, Ring1Comp) == 0x000FC8, "Member 'ABuildingPropAtlas::Ring1Comp' has a wrong offset!");
static_assert(offsetof(ABuildingPropAtlas, Ring2Comp) == 0x000FD0, "Member 'ABuildingPropAtlas::Ring2Comp' has a wrong offset!");
static_assert(offsetof(ABuildingPropAtlas, Ring3Comp) == 0x000FD8, "Member 'ABuildingPropAtlas::Ring3Comp' has a wrong offset!");
static_assert(offsetof(ABuildingPropAtlas, RingTransitionMID) == 0x000FE0, "Member 'ABuildingPropAtlas::RingTransitionMID' has a wrong offset!");
static_assert(offsetof(ABuildingPropAtlas, PortalAudioComp) == 0x000FE8, "Member 'ABuildingPropAtlas::PortalAudioComp' has a wrong offset!");

// Class FortniteGame.FortItemDefinitionTooltip
// 0x0000 (0x0090 - 0x0090)
class UFortItemDefinitionTooltip : public UFortTooltip
{
public:
	bool GetTextForToken(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, class FText* OutText) const;
	bool GetTokenizedDescriptionText(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, TArray<class FText>* OutDescription) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortItemDefinitionTooltip">();
	}
	static class UFortItemDefinitionTooltip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortItemDefinitionTooltip>();
	}
};
static_assert(alignof(UFortItemDefinitionTooltip) == 0x000008, "Wrong alignment on UFortItemDefinitionTooltip");
static_assert(sizeof(UFortItemDefinitionTooltip) == 0x000090, "Wrong size on UFortItemDefinitionTooltip");

// Class FortniteGame.FortWorldItemDefinitionTooltip
// 0x0000 (0x0090 - 0x0090)
class UFortWorldItemDefinitionTooltip : public UFortItemDefinitionTooltip
{
public:
	bool GetTextForToken(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, class FText* OutText) const;
	bool GetTokenizedDescriptionText(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, TArray<class FText>* OutDescription) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortWorldItemDefinitionTooltip">();
	}
	static class UFortWorldItemDefinitionTooltip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortWorldItemDefinitionTooltip>();
	}
};
static_assert(alignof(UFortWorldItemDefinitionTooltip) == 0x000008, "Wrong alignment on UFortWorldItemDefinitionTooltip");
static_assert(sizeof(UFortWorldItemDefinitionTooltip) == 0x000090, "Wrong size on UFortWorldItemDefinitionTooltip");

// Class FortniteGame.FortWeaponItemDefinitionTooltip
// 0x0000 (0x0090 - 0x0090)
class UFortWeaponItemDefinitionTooltip : public UFortWorldItemDefinitionTooltip
{
public:
	bool GetNumericValue(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, float* OutVal) const;
	bool GetTextForToken(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, class FText* OutText) const;
	bool GetTokenizedDescriptionText(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, TArray<class FText>* OutDescription) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortWeaponItemDefinitionTooltip">();
	}
	static class UFortWeaponItemDefinitionTooltip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortWeaponItemDefinitionTooltip>();
	}
};
static_assert(alignof(UFortWeaponItemDefinitionTooltip) == 0x000008, "Wrong alignment on UFortWeaponItemDefinitionTooltip");
static_assert(sizeof(UFortWeaponItemDefinitionTooltip) == 0x000090, "Wrong size on UFortWeaponItemDefinitionTooltip");

// Class FortniteGame.FortWeaponMeleeItemDefinitionTooltip
// 0x0000 (0x0090 - 0x0090)
class UFortWeaponMeleeItemDefinitionTooltip final : public UFortWeaponItemDefinitionTooltip
{
public:
	bool GetNumericValue(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, float* OutVal) const;
	bool GetTextForToken(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, class FText* OutText) const;
	bool GetTokenizedDescriptionText(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, TArray<class FText>* OutDescription) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortWeaponMeleeItemDefinitionTooltip">();
	}
	static class UFortWeaponMeleeItemDefinitionTooltip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortWeaponMeleeItemDefinitionTooltip>();
	}
};
static_assert(alignof(UFortWeaponMeleeItemDefinitionTooltip) == 0x000008, "Wrong alignment on UFortWeaponMeleeItemDefinitionTooltip");
static_assert(sizeof(UFortWeaponMeleeItemDefinitionTooltip) == 0x000090, "Wrong size on UFortWeaponMeleeItemDefinitionTooltip");

// Class FortniteGame.FortAbilityTestObserver
// 0x0030 (0x03B8 - 0x0388)
class AFortAbilityTestObserver final : public AActor
{
public:
	uint8                                         Pad_388[0x30];                                     // 0x0388(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StartObserving(class APawn* Pawn);
	void StopObserving();

	bool WasAbilityActivated(class UGameplayAbility* Ability) const;
	bool WasAbilityTagActivated(const struct FGameplayTag& AbilityTag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAbilityTestObserver">();
	}
	static class AFortAbilityTestObserver* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAbilityTestObserver>();
	}
};
static_assert(alignof(AFortAbilityTestObserver) == 0x000008, "Wrong alignment on AFortAbilityTestObserver");
static_assert(sizeof(AFortAbilityTestObserver) == 0x0003B8, "Wrong size on AFortAbilityTestObserver");

// Class FortniteGame.BuildingPropWall
// 0x0010 (0x0FE0 - 0x0FD0)
class ABuildingPropWall final : public ABuildingProp
{
public:
	struct FBuildingActorNavArea                  AreaPatternOverride;                               // 0x0FC8(0x0004)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EBuildingWallArea                             AreaShapeType;                                     // 0x0FCC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FCD[0x13];                                     // 0x0FCD(0x0013)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingPropWall">();
	}
	static class ABuildingPropWall* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingPropWall>();
	}
};
static_assert(alignof(ABuildingPropWall) == 0x000010, "Wrong alignment on ABuildingPropWall");
static_assert(sizeof(ABuildingPropWall) == 0x000FE0, "Wrong size on ABuildingPropWall");
static_assert(offsetof(ABuildingPropWall, AreaPatternOverride) == 0x000FC8, "Member 'ABuildingPropWall::AreaPatternOverride' has a wrong offset!");
static_assert(offsetof(ABuildingPropWall, AreaShapeType) == 0x000FCC, "Member 'ABuildingPropWall::AreaShapeType' has a wrong offset!");

// Class FortniteGame.FortLobbyBeaconHost
// 0x0018 (0x03F8 - 0x03E0)
class AFortLobbyBeaconHost : public ALobbyBeaconHost
{
public:
	uint8                                         bAllowReservationsToProceedToLobby : 1;            // 0x03E0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bWorldRecordLoaded : 1;                            // 0x03E0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_3E1[0x3];                                      // 0x03E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LastReservationCountForPermissionTimeoutChange;    // 0x03E4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LobbyPermissionTimeout;                            // 0x03E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3EC[0xC];                                      // 0x03EC(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortLobbyBeaconHost">();
	}
	static class AFortLobbyBeaconHost* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortLobbyBeaconHost>();
	}
};
static_assert(alignof(AFortLobbyBeaconHost) == 0x000008, "Wrong alignment on AFortLobbyBeaconHost");
static_assert(sizeof(AFortLobbyBeaconHost) == 0x0003F8, "Wrong size on AFortLobbyBeaconHost");
static_assert(offsetof(AFortLobbyBeaconHost, LastReservationCountForPermissionTimeoutChange) == 0x0003E4, "Member 'AFortLobbyBeaconHost::LastReservationCountForPermissionTimeoutChange' has a wrong offset!");
static_assert(offsetof(AFortLobbyBeaconHost, LobbyPermissionTimeout) == 0x0003E8, "Member 'AFortLobbyBeaconHost::LobbyPermissionTimeout' has a wrong offset!");

// Class FortniteGame.FortLobbyBeaconHostPvE
// 0x0000 (0x03F8 - 0x03F8)
class AFortLobbyBeaconHostPvE : public AFortLobbyBeaconHost
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortLobbyBeaconHostPvE">();
	}
	static class AFortLobbyBeaconHostPvE* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortLobbyBeaconHostPvE>();
	}
};
static_assert(alignof(AFortLobbyBeaconHostPvE) == 0x000008, "Wrong alignment on AFortLobbyBeaconHostPvE");
static_assert(sizeof(AFortLobbyBeaconHostPvE) == 0x0003F8, "Wrong size on AFortLobbyBeaconHostPvE");

// Class FortniteGame.FortLobbyBeaconHostOutpost
// 0x0000 (0x03F8 - 0x03F8)
class AFortLobbyBeaconHostOutpost final : public AFortLobbyBeaconHostPvE
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortLobbyBeaconHostOutpost">();
	}
	static class AFortLobbyBeaconHostOutpost* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortLobbyBeaconHostOutpost>();
	}
};
static_assert(alignof(AFortLobbyBeaconHostOutpost) == 0x000008, "Wrong alignment on AFortLobbyBeaconHostOutpost");
static_assert(sizeof(AFortLobbyBeaconHostOutpost) == 0x0003F8, "Wrong size on AFortLobbyBeaconHostOutpost");

// Class FortniteGame.FortAlterationItemDefinition
// 0x0940 (0x0BB0 - 0x0270)
class UFortAlterationItemDefinition final : public UFortAccountItemDefinition
{
public:
	EFortAlteration                               AlterationType;                                    // 0x0270(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_271[0x7];                                      // 0x0271(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortCosmeticModification              DefaultCosmetic;                                   // 0x0278(0x08F8)(Edit, NativeAccessSpecifierPrivate)
	TArray<struct FFortConditionalCosmeticModification> ConditionalCosmetics;                              // 0x0B70(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FFortConditionalIncludeTags>    AdditionalGameplayTags;                            // 0x0B80(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UFortAbilitySet>         AlterationAbilitySet;                              // 0x0B90(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAlterationItemDefinition">();
	}
	static class UFortAlterationItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAlterationItemDefinition>();
	}
};
static_assert(alignof(UFortAlterationItemDefinition) == 0x000010, "Wrong alignment on UFortAlterationItemDefinition");
static_assert(sizeof(UFortAlterationItemDefinition) == 0x000BB0, "Wrong size on UFortAlterationItemDefinition");
static_assert(offsetof(UFortAlterationItemDefinition, AlterationType) == 0x000270, "Member 'UFortAlterationItemDefinition::AlterationType' has a wrong offset!");
static_assert(offsetof(UFortAlterationItemDefinition, DefaultCosmetic) == 0x000278, "Member 'UFortAlterationItemDefinition::DefaultCosmetic' has a wrong offset!");
static_assert(offsetof(UFortAlterationItemDefinition, ConditionalCosmetics) == 0x000B70, "Member 'UFortAlterationItemDefinition::ConditionalCosmetics' has a wrong offset!");
static_assert(offsetof(UFortAlterationItemDefinition, AdditionalGameplayTags) == 0x000B80, "Member 'UFortAlterationItemDefinition::AdditionalGameplayTags' has a wrong offset!");
static_assert(offsetof(UFortAlterationItemDefinition, AlterationAbilitySet) == 0x000B90, "Member 'UFortAlterationItemDefinition::AlterationAbilitySet' has a wrong offset!");

// Class FortniteGame.FortAlterationFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UFortAlterationFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UParticleSystem* GetAlterationImpactPhysicalSurfaceEffects(EPhysicalSurface HitSurface, const struct FFortCosmeticModification& CosmeticMod);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAlterationFunctionLibrary">();
	}
	static class UFortAlterationFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAlterationFunctionLibrary>();
	}
};
static_assert(alignof(UFortAlterationFunctionLibrary) == 0x000008, "Wrong alignment on UFortAlterationFunctionLibrary");
static_assert(sizeof(UFortAlterationFunctionLibrary) == 0x000028, "Wrong size on UFortAlterationFunctionLibrary");

// Class FortniteGame.FortWeaponItemDefinition
// 0x0210 (0x0630 - 0x0420)
#pragma pack(push, 0x1)
class alignas(0x10) UFortWeaponItemDefinition : public UFortWorldItemDefinition
{
public:
	TSoftClassPtr<class UClass>                   WeaponActorClass;                                  // 0x0420(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class USkeletalMesh>           WeaponMeshOverride;                                // 0x0440(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDataTableRowHandle                    WeaponStatHandle;                                  // 0x0460(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFortAlterationItemDefinition> BaseAlteration;                                    // 0x0470(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFortAlterationItemDefinition> BaseCosmeticAlteration;                            // 0x0490(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   PrimaryFireAbility;                                // 0x04B0(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   SecondaryFireAbility;                              // 0x04D0(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   ReloadAbility;                                     // 0x04F0(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftClassPtr<class UClass>>           EquippedAbilities;                                 // 0x0510(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFortWorldItemDefinition> AmmoData;                                          // 0x0520(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LowAmmoPercentage;                                 // 0x0540(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DegradedPercentage;                                // 0x0544(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortWeaponTriggerType                        TriggerType;                                       // 0x0548(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowTargetingDuringReload;                       // 0x0549(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_54A[0x6];                                      // 0x054A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              ReticleImage;                                      // 0x0550(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<float>                                 ReticleCornerAngles;                               // 0x0570(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              HitNotifyImage;                                    // 0x0580(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              MuzzleBlockedImage;                                // 0x05A0(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<float>                                 HitNotifyCornerAngles;                             // 0x05C0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              ReticleCenterImage;                                // 0x05D0(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              ReticleCenterImageOffset;                          // 0x05F0(0x0008)(Edit, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bReticleCornerOutsideSpreadRadius;                 // 0x05F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F9[0x3];                                      // 0x05F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitNotifyDuration;                                 // 0x05FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UCurveFloat>             HitNotifyOpacityCurve;                             // 0x0600(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bValidForLastEquipped;                             // 0x0620(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortDisplayTier                              DisplayTier;                                       // 0x0621(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_622[0x6];                                      // 0x0622(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class FText GetDisplayTierAsText(const EFortDisplayTier DisplayTier_0);

	class UFortAlterationItemDefinition* GetBaseAlteration() const;
	class UFortAlterationItemDefinition* GetBaseCosmeticAlteration() const;
	float GetDegradedPercentage() const;
	EFortDisplayTier GetDisplayTier() const;
	TArray<TSubclassOf<class UFortGameplayAbility>> GetEquippedAbilities() const;
	float GetHitNotifyDuration() const;
	class UTexture2D* GetHitNotifyImage() const;
	class UCurveFloat* GetHitNotifyOpacityCurve() const;
	float GetLowAmmoPercentage() const;
	class UTexture2D* GetMuzzleBlockedImage() const;
	TSubclassOf<class UFortGameplayAbility> GetPrimaryFireAbility() const;
	TSubclassOf<class UFortGameplayAbility> GetReloadAbility() const;
	class UTexture2D* GetReticleCenterImage() const;
	struct FVector2D GetReticleCenterImageOffset() const;
	TArray<float> GetReticleCornerAngles() const;
	class UTexture2D* GetReticleImage() const;
	TSubclassOf<class UFortGameplayAbility> GetSecondaryFireAbility() const;
	class FText GetShortDisplayName() const;
	EFortWeaponTriggerType GetTriggerType() const;
	TSubclassOf<class AFortWeapon> GetWeaponActorClass() const;
	class USkeletalMesh* GetWeaponMeshOverride() const;
	struct FDataTableRowHandle GetWeaponStatHandle() const;
	bool ShouldAllowTargetingDuringReload() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortWeaponItemDefinition">();
	}
	static class UFortWeaponItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortWeaponItemDefinition>();
	}
};
#pragma pack(pop)
static_assert(alignof(UFortWeaponItemDefinition) == 0x000010, "Wrong alignment on UFortWeaponItemDefinition");
static_assert(sizeof(UFortWeaponItemDefinition) == 0x000630, "Wrong size on UFortWeaponItemDefinition");
static_assert(offsetof(UFortWeaponItemDefinition, WeaponActorClass) == 0x000420, "Member 'UFortWeaponItemDefinition::WeaponActorClass' has a wrong offset!");
static_assert(offsetof(UFortWeaponItemDefinition, WeaponMeshOverride) == 0x000440, "Member 'UFortWeaponItemDefinition::WeaponMeshOverride' has a wrong offset!");
static_assert(offsetof(UFortWeaponItemDefinition, WeaponStatHandle) == 0x000460, "Member 'UFortWeaponItemDefinition::WeaponStatHandle' has a wrong offset!");
static_assert(offsetof(UFortWeaponItemDefinition, BaseAlteration) == 0x000470, "Member 'UFortWeaponItemDefinition::BaseAlteration' has a wrong offset!");
static_assert(offsetof(UFortWeaponItemDefinition, BaseCosmeticAlteration) == 0x000490, "Member 'UFortWeaponItemDefinition::BaseCosmeticAlteration' has a wrong offset!");
static_assert(offsetof(UFortWeaponItemDefinition, PrimaryFireAbility) == 0x0004B0, "Member 'UFortWeaponItemDefinition::PrimaryFireAbility' has a wrong offset!");
static_assert(offsetof(UFortWeaponItemDefinition, SecondaryFireAbility) == 0x0004D0, "Member 'UFortWeaponItemDefinition::SecondaryFireAbility' has a wrong offset!");
static_assert(offsetof(UFortWeaponItemDefinition, ReloadAbility) == 0x0004F0, "Member 'UFortWeaponItemDefinition::ReloadAbility' has a wrong offset!");
static_assert(offsetof(UFortWeaponItemDefinition, EquippedAbilities) == 0x000510, "Member 'UFortWeaponItemDefinition::EquippedAbilities' has a wrong offset!");
static_assert(offsetof(UFortWeaponItemDefinition, AmmoData) == 0x000520, "Member 'UFortWeaponItemDefinition::AmmoData' has a wrong offset!");
static_assert(offsetof(UFortWeaponItemDefinition, LowAmmoPercentage) == 0x000540, "Member 'UFortWeaponItemDefinition::LowAmmoPercentage' has a wrong offset!");
static_assert(offsetof(UFortWeaponItemDefinition, DegradedPercentage) == 0x000544, "Member 'UFortWeaponItemDefinition::DegradedPercentage' has a wrong offset!");
static_assert(offsetof(UFortWeaponItemDefinition, TriggerType) == 0x000548, "Member 'UFortWeaponItemDefinition::TriggerType' has a wrong offset!");
static_assert(offsetof(UFortWeaponItemDefinition, bAllowTargetingDuringReload) == 0x000549, "Member 'UFortWeaponItemDefinition::bAllowTargetingDuringReload' has a wrong offset!");
static_assert(offsetof(UFortWeaponItemDefinition, ReticleImage) == 0x000550, "Member 'UFortWeaponItemDefinition::ReticleImage' has a wrong offset!");
static_assert(offsetof(UFortWeaponItemDefinition, ReticleCornerAngles) == 0x000570, "Member 'UFortWeaponItemDefinition::ReticleCornerAngles' has a wrong offset!");
static_assert(offsetof(UFortWeaponItemDefinition, HitNotifyImage) == 0x000580, "Member 'UFortWeaponItemDefinition::HitNotifyImage' has a wrong offset!");
static_assert(offsetof(UFortWeaponItemDefinition, MuzzleBlockedImage) == 0x0005A0, "Member 'UFortWeaponItemDefinition::MuzzleBlockedImage' has a wrong offset!");
static_assert(offsetof(UFortWeaponItemDefinition, HitNotifyCornerAngles) == 0x0005C0, "Member 'UFortWeaponItemDefinition::HitNotifyCornerAngles' has a wrong offset!");
static_assert(offsetof(UFortWeaponItemDefinition, ReticleCenterImage) == 0x0005D0, "Member 'UFortWeaponItemDefinition::ReticleCenterImage' has a wrong offset!");
static_assert(offsetof(UFortWeaponItemDefinition, ReticleCenterImageOffset) == 0x0005F0, "Member 'UFortWeaponItemDefinition::ReticleCenterImageOffset' has a wrong offset!");
static_assert(offsetof(UFortWeaponItemDefinition, bReticleCornerOutsideSpreadRadius) == 0x0005F8, "Member 'UFortWeaponItemDefinition::bReticleCornerOutsideSpreadRadius' has a wrong offset!");
static_assert(offsetof(UFortWeaponItemDefinition, HitNotifyDuration) == 0x0005FC, "Member 'UFortWeaponItemDefinition::HitNotifyDuration' has a wrong offset!");
static_assert(offsetof(UFortWeaponItemDefinition, HitNotifyOpacityCurve) == 0x000600, "Member 'UFortWeaponItemDefinition::HitNotifyOpacityCurve' has a wrong offset!");
static_assert(offsetof(UFortWeaponItemDefinition, bValidForLastEquipped) == 0x000620, "Member 'UFortWeaponItemDefinition::bValidForLastEquipped' has a wrong offset!");
static_assert(offsetof(UFortWeaponItemDefinition, DisplayTier) == 0x000621, "Member 'UFortWeaponItemDefinition::DisplayTier' has a wrong offset!");

// Class FortniteGame.FortConstructorBASE
// 0x0390 (0x1360 - 0x0FD0)
class AFortConstructorBASE final : public ABuildingProp
{
public:
	uint8                                         Pad_FC8[0x8];                                      // 0x0FC8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBASEGameplayEffect>            BASEBuildingApplicationEffects;                    // 0x0FD0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FBASEGameplayEffect>            BASEFriendlyApplicationEffects;                    // 0x0FE0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FBASEGameplayEffect>            BASEFriendlyApplicationTrapEffects;                // 0x0FF0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FBASEGameplayEffect>            BASEEnemyApplicationEffects;                       // 0x1000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InBASETag;                                         // 0x1010(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NodesToAffect;                                     // 0x1018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BaseLevel;                                         // 0x101C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPatternBASEEffect>             BASEEffectPatterns;                                // 0x1020(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FFortBaseWeaponStats                   DamageStats;                                       // 0x1030(0x0120)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UFortDamageSet*                         DamageAttributeSet;                                // 0x1150(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1158[0x208];                                   // 0x1158(0x0208)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class ABuildingSMActor*> GetBuildingActorsInBase();
	void OnBaseCollisionTouched(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnBaseCollisionUnTouched(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnBasePawnDestroyed(class AFortPawn* Pawn);
	void OnBasePawnDied(class AFortPawn* Pawn);
	void OnPawnAddedToBase(class AFortPawn* Pawn);
	void OnPawnRemovedFromBase(class AFortPawn* Pawn);
	void OnPlaced(class UAbilitySystemComponent* InstigatorAbilitySystemComponent);
	void StartBuildingActorVisuals(class ABuildingSMActor* BuildingActor, class UStaticMeshComponent* EffectMeshComp);
	void StopBuildingActorVisuals(class ABuildingSMActor* BuildingActor, class UStaticMeshComponent* EffectMeshComp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortConstructorBASE">();
	}
	static class AFortConstructorBASE* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortConstructorBASE>();
	}
};
static_assert(alignof(AFortConstructorBASE) == 0x000010, "Wrong alignment on AFortConstructorBASE");
static_assert(sizeof(AFortConstructorBASE) == 0x001360, "Wrong size on AFortConstructorBASE");
static_assert(offsetof(AFortConstructorBASE, BASEBuildingApplicationEffects) == 0x000FD0, "Member 'AFortConstructorBASE::BASEBuildingApplicationEffects' has a wrong offset!");
static_assert(offsetof(AFortConstructorBASE, BASEFriendlyApplicationEffects) == 0x000FE0, "Member 'AFortConstructorBASE::BASEFriendlyApplicationEffects' has a wrong offset!");
static_assert(offsetof(AFortConstructorBASE, BASEFriendlyApplicationTrapEffects) == 0x000FF0, "Member 'AFortConstructorBASE::BASEFriendlyApplicationTrapEffects' has a wrong offset!");
static_assert(offsetof(AFortConstructorBASE, BASEEnemyApplicationEffects) == 0x001000, "Member 'AFortConstructorBASE::BASEEnemyApplicationEffects' has a wrong offset!");
static_assert(offsetof(AFortConstructorBASE, InBASETag) == 0x001010, "Member 'AFortConstructorBASE::InBASETag' has a wrong offset!");
static_assert(offsetof(AFortConstructorBASE, NodesToAffect) == 0x001018, "Member 'AFortConstructorBASE::NodesToAffect' has a wrong offset!");
static_assert(offsetof(AFortConstructorBASE, BaseLevel) == 0x00101C, "Member 'AFortConstructorBASE::BaseLevel' has a wrong offset!");
static_assert(offsetof(AFortConstructorBASE, BASEEffectPatterns) == 0x001020, "Member 'AFortConstructorBASE::BASEEffectPatterns' has a wrong offset!");
static_assert(offsetof(AFortConstructorBASE, DamageStats) == 0x001030, "Member 'AFortConstructorBASE::DamageStats' has a wrong offset!");
static_assert(offsetof(AFortConstructorBASE, DamageAttributeSet) == 0x001150, "Member 'AFortConstructorBASE::DamageAttributeSet' has a wrong offset!");

// Class FortniteGame.FortLobbyBeaconPlayerState
// 0x01D0 (0x0690 - 0x04C0)
class AFortLobbyBeaconPlayerState : public ALobbyBeaconPlayerState
{
public:
	class FName                                   ConsoleOSSName;                                    // 0x04C0(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUniqueNetIdRepl                       ConsoleUniqueNetId;                                // 0x04C8(0x0018)(Net, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortTeam                                     TeamAffiliation;                                   // 0x04E0(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E1[0x3];                                      // 0x04E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentCharXP;                                     // 0x04E4(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MatchmakingLevel;                                  // 0x04E8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4EC[0x4];                                      // 0x04EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 HeroId;                                            // 0x04F0(0x0010)(Net, ZeroConstructor, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortHeroType*                          HeroType;                                          // 0x0500(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HeroSquadId;                                       // 0x0508(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_510[0x8];                                      // 0x0510(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LobbyTimeRemaining;                                // 0x0518(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51C[0x4];                                      // 0x051C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         HomeBaseVersion;                                   // 0x0520(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         SelectedGadgets;                                   // 0x0528(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	EFortCustomGender                             CharacterGender;                                   // 0x0538(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_539[0x157];                                    // 0x0539(0x0157)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_CharacterGender();
	void OnRep_CharXP();
	void OnRep_ConsoleOSSName();
	void OnRep_ConsoleUniqueNetId();
	void OnRep_Gadgets();
	void OnRep_HeroId();
	void OnRep_HeroSquadId();
	void OnRep_HeroType();
	void OnRep_HomeBaseVersion();
	void OnRep_LobbyTimeRemaining();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortLobbyBeaconPlayerState">();
	}
	static class AFortLobbyBeaconPlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortLobbyBeaconPlayerState>();
	}
};
static_assert(alignof(AFortLobbyBeaconPlayerState) == 0x000008, "Wrong alignment on AFortLobbyBeaconPlayerState");
static_assert(sizeof(AFortLobbyBeaconPlayerState) == 0x000690, "Wrong size on AFortLobbyBeaconPlayerState");
static_assert(offsetof(AFortLobbyBeaconPlayerState, ConsoleOSSName) == 0x0004C0, "Member 'AFortLobbyBeaconPlayerState::ConsoleOSSName' has a wrong offset!");
static_assert(offsetof(AFortLobbyBeaconPlayerState, ConsoleUniqueNetId) == 0x0004C8, "Member 'AFortLobbyBeaconPlayerState::ConsoleUniqueNetId' has a wrong offset!");
static_assert(offsetof(AFortLobbyBeaconPlayerState, TeamAffiliation) == 0x0004E0, "Member 'AFortLobbyBeaconPlayerState::TeamAffiliation' has a wrong offset!");
static_assert(offsetof(AFortLobbyBeaconPlayerState, CurrentCharXP) == 0x0004E4, "Member 'AFortLobbyBeaconPlayerState::CurrentCharXP' has a wrong offset!");
static_assert(offsetof(AFortLobbyBeaconPlayerState, MatchmakingLevel) == 0x0004E8, "Member 'AFortLobbyBeaconPlayerState::MatchmakingLevel' has a wrong offset!");
static_assert(offsetof(AFortLobbyBeaconPlayerState, HeroId) == 0x0004F0, "Member 'AFortLobbyBeaconPlayerState::HeroId' has a wrong offset!");
static_assert(offsetof(AFortLobbyBeaconPlayerState, HeroType) == 0x000500, "Member 'AFortLobbyBeaconPlayerState::HeroType' has a wrong offset!");
static_assert(offsetof(AFortLobbyBeaconPlayerState, HeroSquadId) == 0x000508, "Member 'AFortLobbyBeaconPlayerState::HeroSquadId' has a wrong offset!");
static_assert(offsetof(AFortLobbyBeaconPlayerState, LobbyTimeRemaining) == 0x000518, "Member 'AFortLobbyBeaconPlayerState::LobbyTimeRemaining' has a wrong offset!");
static_assert(offsetof(AFortLobbyBeaconPlayerState, HomeBaseVersion) == 0x000520, "Member 'AFortLobbyBeaconPlayerState::HomeBaseVersion' has a wrong offset!");
static_assert(offsetof(AFortLobbyBeaconPlayerState, SelectedGadgets) == 0x000528, "Member 'AFortLobbyBeaconPlayerState::SelectedGadgets' has a wrong offset!");
static_assert(offsetof(AFortLobbyBeaconPlayerState, CharacterGender) == 0x000538, "Member 'AFortLobbyBeaconPlayerState::CharacterGender' has a wrong offset!");

// Class FortniteGame.FortDecoTool
// 0x0048 (0x0AD0 - 0x0A88)
class AFortDecoTool : public AFortWeapon
{
public:
	bool                                          bButtonDown;                                       // 0x0A88(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A89[0x7];                                      // 0x0A89(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortItemDefinition*                    ItemDefinition;                                    // 0x0A90(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortDecoHelper*                        DecoHelper;                                        // 0x0A98(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 CarriedActor;                                      // 0x0AA0(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlaceCarriedActor;                                // 0x0AA8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AA9[0x7];                                      // 0x0AA9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UParticleSystem>         SpawnEffect;                                       // 0x0AB0(0x0020)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ClientDestroyDecoPreview();
	void OnCarriedActorDestroyed(class AActor* DestroyedActor);
	void OnRep_CarriedActor(class AActor* OldCarriedActor);
	void OnRep_ItemDefinition();
	void ServerSpawnDeco(const struct FVector& Location, const struct FRotator& Rotation, class ABuildingSMActor* AttachedActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDecoTool">();
	}
	static class AFortDecoTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortDecoTool>();
	}
};
static_assert(alignof(AFortDecoTool) == 0x000008, "Wrong alignment on AFortDecoTool");
static_assert(sizeof(AFortDecoTool) == 0x000AD0, "Wrong size on AFortDecoTool");
static_assert(offsetof(AFortDecoTool, bButtonDown) == 0x000A88, "Member 'AFortDecoTool::bButtonDown' has a wrong offset!");
static_assert(offsetof(AFortDecoTool, ItemDefinition) == 0x000A90, "Member 'AFortDecoTool::ItemDefinition' has a wrong offset!");
static_assert(offsetof(AFortDecoTool, DecoHelper) == 0x000A98, "Member 'AFortDecoTool::DecoHelper' has a wrong offset!");
static_assert(offsetof(AFortDecoTool, CarriedActor) == 0x000AA0, "Member 'AFortDecoTool::CarriedActor' has a wrong offset!");
static_assert(offsetof(AFortDecoTool, bPlaceCarriedActor) == 0x000AA8, "Member 'AFortDecoTool::bPlaceCarriedActor' has a wrong offset!");
static_assert(offsetof(AFortDecoTool, SpawnEffect) == 0x000AB0, "Member 'AFortDecoTool::SpawnEffect' has a wrong offset!");

// Class FortniteGame.FortAbilityDecoTool
// 0x0028 (0x0AF8 - 0x0AD0)
class AFortAbilityDecoTool : public AFortDecoTool
{
public:
	struct FAbilityToolSpawnParameters            CachedSpawnParameters;                             // 0x0AD0(0x0028)(Transient, NoDestructor, NativeAccessSpecifierPrivate)

public:
	class ABuildingActor* AbilitySpawnDeco(const struct FAbilityToolSpawnParameters& SpawnParameters);
	struct FGameplayAbilitySpecHandle GetPlacementAbilityHandle();
	class UFortGameplayAbility* GetPlacementAbilityInstance();

	void GetSpawnParameters(struct FAbilityToolSpawnParameters* OutSpawnParamters) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAbilityDecoTool">();
	}
	static class AFortAbilityDecoTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAbilityDecoTool>();
	}
};
static_assert(alignof(AFortAbilityDecoTool) == 0x000008, "Wrong alignment on AFortAbilityDecoTool");
static_assert(sizeof(AFortAbilityDecoTool) == 0x000AF8, "Wrong size on AFortAbilityDecoTool");
static_assert(offsetof(AFortAbilityDecoTool, CachedSpawnParameters) == 0x000AD0, "Member 'AFortAbilityDecoTool::CachedSpawnParameters' has a wrong offset!");

// Class FortniteGame.FortHealthRegenInterface
// 0x0000 (0x0028 - 0x0028)
class IFortHealthRegenInterface final : public IInterface
{
public:
	class UGameplayEffect* GetHealthRegenDelayGameplayEffect() const;
	class UGameplayEffect* GetHealthRegenGameplayEffect() const;
	TSubclassOf<class UGameplayEffect> GetHealthRegenGameplayEffectClass() const;
	class UGameplayEffect* GetShieldRegenDelayGameplayEffect() const;
	class UGameplayEffect* GetShieldRegenGameplayEffect() const;
	TSubclassOf<class UGameplayEffect> GetShieldRegenGameplayEffectClass() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortHealthRegenInterface">();
	}
	static class IFortHealthRegenInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortHealthRegenInterface>();
	}
};
static_assert(alignof(IFortHealthRegenInterface) == 0x000008, "Wrong alignment on IFortHealthRegenInterface");
static_assert(sizeof(IFortHealthRegenInterface) == 0x000028, "Wrong size on IFortHealthRegenInterface");

// Class FortniteGame.FortOutpostBuilding
// 0x0000 (0x0FD0 - 0x0FD0)
class AFortOutpostBuilding final : public ABuildingProp
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortOutpostBuilding">();
	}
	static class AFortOutpostBuilding* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortOutpostBuilding>();
	}
};
static_assert(alignof(AFortOutpostBuilding) == 0x000010, "Wrong alignment on AFortOutpostBuilding");
static_assert(sizeof(AFortOutpostBuilding) == 0x000FD0, "Wrong size on AFortOutpostBuilding");

// Class FortniteGame.FortTrack
// 0x0190 (0x1160 - 0x0FD0)
class AFortTrack final : public ABuildingProp
{
public:
	UMulticastDelegateProperty_                   OnTrackGraphChanged;                               // 0x0FC8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FText                                   ToggleSwitchText;                                  // 0x0FD8(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         ToggleInteractTime;                                // 0x0FF0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FF4[0x4];                                      // 0x0FF4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            TrackPieceMeshesByType[0x5];                       // 0x0FF8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseFloorMesh;                                     // 0x1020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1021[0x7];                                     // 0x1021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            TrackFloorMeshesByVerticality[0x3];                // 0x1028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTrackConnectorMeshConfig>      ConnectorMeshConfigs;                              // 0x1040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class AFortTrack*                             NeighborsByDirection[0x4];                         // 0x1050(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SwitchState;                                       // 0x1070(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConfigurationIdx;                                  // 0x1074(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCollisionResponseContainer            FloorCollisionResponseContainer;                   // 0x1078(0x0020)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackMeshComp;                                     // 0x1098(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   TrackFloorMeshComp;                                // 0x10A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   ConnectorMeshCompsByDirection[0x4];                // 0x10A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          PlacementCollision1;                               // 0x10C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          PlacementCollision2;                               // 0x10D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USplineComponent*                       SplineComp1;                                       // 0x10D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USplineComponent*                       SplineComp2;                                       // 0x10E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        SwitchCompBase;                                    // 0x10E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPrimitiveComponent*                    SwitchComp;                                        // 0x10F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10F8[0x68];                                    // 0x10F8(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetOutgoingNeighborFromSpline(class USplineComponent* InSpline, bool InReverseDirection, class AFortTrack** OutNeighbor);
	float GetPathDistanceToTrack(class AFortTrack* TargetTrack, class USplineComponent* InCurrentSpline, float CurrentDistanceAlongSpline, bool InReverseDirection);
	void GetSplineFromIncomingNeighbor(class AFortTrack* InNeighbor, class USplineComponent** OutSpline, bool* OutReverseDirection);
	void GetSplineFromPositionAndOrientation(const struct FVector& InLocation, const struct FRotator& InRotation, class USplineComponent** OutSpline, float* OutDistanceAlongSpline, bool* OutReverseDirection);
	void InitializeTrack(class UPrimitiveComponent* InSwitchComp);
	bool IsConnectedToTrack(class AFortTrack* TargetTrack);
	bool IsConnectedToTrackList(const TArray<class AFortTrack*>& TargetTracks);
	void OnConfigurationChanged(int32 NewConfigurationIdx, int32 OldConfigurationIdx);
	void OnRep_ConfigurationIdx();
	void OnRep_NeighborsByDirection();
	void OnRep_SwitchState();
	void OnSwitchStateChanged(int32 NewSwitchState, int32 OldSwitchState, int32 NumSwitchStates);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTrack">();
	}
	static class AFortTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortTrack>();
	}
};
static_assert(alignof(AFortTrack) == 0x000010, "Wrong alignment on AFortTrack");
static_assert(sizeof(AFortTrack) == 0x001160, "Wrong size on AFortTrack");
static_assert(offsetof(AFortTrack, OnTrackGraphChanged) == 0x000FC8, "Member 'AFortTrack::OnTrackGraphChanged' has a wrong offset!");
static_assert(offsetof(AFortTrack, ToggleSwitchText) == 0x000FD8, "Member 'AFortTrack::ToggleSwitchText' has a wrong offset!");
static_assert(offsetof(AFortTrack, ToggleInteractTime) == 0x000FF0, "Member 'AFortTrack::ToggleInteractTime' has a wrong offset!");
static_assert(offsetof(AFortTrack, TrackPieceMeshesByType) == 0x000FF8, "Member 'AFortTrack::TrackPieceMeshesByType' has a wrong offset!");
static_assert(offsetof(AFortTrack, bUseFloorMesh) == 0x001020, "Member 'AFortTrack::bUseFloorMesh' has a wrong offset!");
static_assert(offsetof(AFortTrack, TrackFloorMeshesByVerticality) == 0x001028, "Member 'AFortTrack::TrackFloorMeshesByVerticality' has a wrong offset!");
static_assert(offsetof(AFortTrack, ConnectorMeshConfigs) == 0x001040, "Member 'AFortTrack::ConnectorMeshConfigs' has a wrong offset!");
static_assert(offsetof(AFortTrack, NeighborsByDirection) == 0x001050, "Member 'AFortTrack::NeighborsByDirection' has a wrong offset!");
static_assert(offsetof(AFortTrack, SwitchState) == 0x001070, "Member 'AFortTrack::SwitchState' has a wrong offset!");
static_assert(offsetof(AFortTrack, ConfigurationIdx) == 0x001074, "Member 'AFortTrack::ConfigurationIdx' has a wrong offset!");
static_assert(offsetof(AFortTrack, FloorCollisionResponseContainer) == 0x001078, "Member 'AFortTrack::FloorCollisionResponseContainer' has a wrong offset!");
static_assert(offsetof(AFortTrack, TrackMeshComp) == 0x001098, "Member 'AFortTrack::TrackMeshComp' has a wrong offset!");
static_assert(offsetof(AFortTrack, TrackFloorMeshComp) == 0x0010A0, "Member 'AFortTrack::TrackFloorMeshComp' has a wrong offset!");
static_assert(offsetof(AFortTrack, ConnectorMeshCompsByDirection) == 0x0010A8, "Member 'AFortTrack::ConnectorMeshCompsByDirection' has a wrong offset!");
static_assert(offsetof(AFortTrack, PlacementCollision1) == 0x0010C8, "Member 'AFortTrack::PlacementCollision1' has a wrong offset!");
static_assert(offsetof(AFortTrack, PlacementCollision2) == 0x0010D0, "Member 'AFortTrack::PlacementCollision2' has a wrong offset!");
static_assert(offsetof(AFortTrack, SplineComp1) == 0x0010D8, "Member 'AFortTrack::SplineComp1' has a wrong offset!");
static_assert(offsetof(AFortTrack, SplineComp2) == 0x0010E0, "Member 'AFortTrack::SplineComp2' has a wrong offset!");
static_assert(offsetof(AFortTrack, SwitchCompBase) == 0x0010E8, "Member 'AFortTrack::SwitchCompBase' has a wrong offset!");
static_assert(offsetof(AFortTrack, SwitchComp) == 0x0010F0, "Member 'AFortTrack::SwitchComp' has a wrong offset!");

// Class FortniteGame.OutpostStructureBase
// 0x0000 (0x0FD0 - 0x0FD0)
class AOutpostStructureBase : public ABuildingProp
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OutpostStructureBase">();
	}
	static class AOutpostStructureBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOutpostStructureBase>();
	}
};
static_assert(alignof(AOutpostStructureBase) == 0x000010, "Wrong alignment on AOutpostStructureBase");
static_assert(sizeof(AOutpostStructureBase) == 0x000FD0, "Wrong size on AOutpostStructureBase");

// Class FortniteGame.BuildingOutpostCraftingTable
// 0x0000 (0x0FD0 - 0x0FD0)
class ABuildingOutpostCraftingTable final : public AOutpostStructureBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingOutpostCraftingTable">();
	}
	static class ABuildingOutpostCraftingTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingOutpostCraftingTable>();
	}
};
static_assert(alignof(ABuildingOutpostCraftingTable) == 0x000010, "Wrong alignment on ABuildingOutpostCraftingTable");
static_assert(sizeof(ABuildingOutpostCraftingTable) == 0x000FD0, "Wrong size on ABuildingOutpostCraftingTable");

// Class FortniteGame.FortSimpleMiniMapIndicator
// 0x0138 (0x0450 - 0x0318)
class UFortSimpleMiniMapIndicator final : public UFortMiniMapIndicator
{
public:
	struct FSlateBrush                            NormalBrush;                                       // 0x0318(0x0090)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            AboveBelowBrush;                                   // 0x03A8(0x0090)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_438[0x18];                                     // 0x0438(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortSimpleMiniMapIndicator">();
	}
	static class UFortSimpleMiniMapIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortSimpleMiniMapIndicator>();
	}
};
static_assert(alignof(UFortSimpleMiniMapIndicator) == 0x000008, "Wrong alignment on UFortSimpleMiniMapIndicator");
static_assert(sizeof(UFortSimpleMiniMapIndicator) == 0x000450, "Wrong size on UFortSimpleMiniMapIndicator");
static_assert(offsetof(UFortSimpleMiniMapIndicator, NormalBrush) == 0x000318, "Member 'UFortSimpleMiniMapIndicator::NormalBrush' has a wrong offset!");
static_assert(offsetof(UFortSimpleMiniMapIndicator, AboveBelowBrush) == 0x0003A8, "Member 'UFortSimpleMiniMapIndicator::AboveBelowBrush' has a wrong offset!");

// Class FortniteGame.BuildingOutpostFabricator
// 0x0000 (0x0FD0 - 0x0FD0)
class ABuildingOutpostFabricator final : public AOutpostStructureBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingOutpostFabricator">();
	}
	static class ABuildingOutpostFabricator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingOutpostFabricator>();
	}
};
static_assert(alignof(ABuildingOutpostFabricator) == 0x000010, "Wrong alignment on ABuildingOutpostFabricator");
static_assert(sizeof(ABuildingOutpostFabricator) == 0x000FD0, "Wrong size on ABuildingOutpostFabricator");

// Class FortniteGame.BuildingOutpostStorageVault
// 0x0000 (0x0FD0 - 0x0FD0)
class ABuildingOutpostStorageVault final : public AOutpostStructureBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingOutpostStorageVault">();
	}
	static class ABuildingOutpostStorageVault* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingOutpostStorageVault>();
	}
};
static_assert(alignof(ABuildingOutpostStorageVault) == 0x000010, "Wrong alignment on ABuildingOutpostStorageVault");
static_assert(sizeof(ABuildingOutpostStorageVault) == 0x000FD0, "Wrong size on ABuildingOutpostStorageVault");

// Class FortniteGame.FortAIController
// 0x0150 (0x05D0 - 0x0480)
class AFortAIController : public AAIController
{
public:
	uint8                                         Pad_480[0x18];                                     // 0x0480(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bUsingNavMesh : 1;                                 // 0x0498(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAlwaysNotifyBumpWall : 1;                         // 0x0498(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInstantRotation : 1;                              // 0x0498(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTurnTransitionsEnabled : 1;                       // 0x0498(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_499[0x7];                                      // 0x0499(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortPathFollowingComponent*            FortPathFollowingComp;                             // 0x04A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIHotSpotUseInfo                      CurrentHotSpot;                                    // 0x04A8(0x0018)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         GoalInfoUpdateRate;                                // 0x04C0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C4[0x4];                                      // 0x04C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 GoalActor;                                         // 0x04C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GoalVisibilityPersistanceTime;                     // 0x04D0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D4[0xF4];                                     // 0x04D4(0x00F4)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortAIPawn*                            MyFortPawn;                                        // 0x05C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static bool IsIgnoringProximity(class AFortAIController* FortAIController);

	bool CreateBuildingActor(TSubclassOf<class ABuildingSMActor> BuildingClass, const struct FVector& BuildLoc, const struct FRotator& BuildRot, bool bMirrored);
	void IgnoreProximityForDuration(float DurationToIgnore);
	bool IsAllowedToSleep();
	void LockBehaviorResource();
	void LockMovementResource();
	void OnBuildingActorGoalDestroyed();
	void SetAlwaysGameplayRelevant(bool bInAlwaysGameplayRelevant);
	void SetFullPeripheralVision(bool bNewFullPeripheralVision);
	void SetGoalActor(class AActor* InActor, bool bLocationAlwaysKnown);
	void SetIsSleeping(bool bNewSleepStatus);
	void SetPawnAIType(EFortressAIType NewAIType, class AActor* SpawnSpot);
	void SetTeam(EFortTeam InTeam);
	void SetupCustomVIM(class UClass* VIM);
	void UnlockBehaviorResource();
	void UnlockMovementResource();
	void UnregisterForGoalDetection();
	void WakeUp();

	class UFortAIEncounterInfo* GetEncounterInfo() const;
	class AActor* GetGoalActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIController">();
	}
	static class AFortAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAIController>();
	}
};
static_assert(alignof(AFortAIController) == 0x000008, "Wrong alignment on AFortAIController");
static_assert(sizeof(AFortAIController) == 0x0005D0, "Wrong size on AFortAIController");
static_assert(offsetof(AFortAIController, FortPathFollowingComp) == 0x0004A0, "Member 'AFortAIController::FortPathFollowingComp' has a wrong offset!");
static_assert(offsetof(AFortAIController, CurrentHotSpot) == 0x0004A8, "Member 'AFortAIController::CurrentHotSpot' has a wrong offset!");
static_assert(offsetof(AFortAIController, GoalInfoUpdateRate) == 0x0004C0, "Member 'AFortAIController::GoalInfoUpdateRate' has a wrong offset!");
static_assert(offsetof(AFortAIController, GoalActor) == 0x0004C8, "Member 'AFortAIController::GoalActor' has a wrong offset!");
static_assert(offsetof(AFortAIController, GoalVisibilityPersistanceTime) == 0x0004D0, "Member 'AFortAIController::GoalVisibilityPersistanceTime' has a wrong offset!");
static_assert(offsetof(AFortAIController, MyFortPawn) == 0x0005C8, "Member 'AFortAIController::MyFortPawn' has a wrong offset!");

// Class FortniteGame.FortBotController
// 0x0010 (0x05E0 - 0x05D0)
class AFortBotController final : public AFortAIController
{
public:
	class UFortBotMissionLogic*                   CurrentMissionLogic;                               // 0x05D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D8[0x8];                                      // 0x05D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBotController">();
	}
	static class AFortBotController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortBotController>();
	}
};
static_assert(alignof(AFortBotController) == 0x000008, "Wrong alignment on AFortBotController");
static_assert(sizeof(AFortBotController) == 0x0005E0, "Wrong size on AFortBotController");
static_assert(offsetof(AFortBotController, CurrentMissionLogic) == 0x0005D0, "Member 'AFortBotController::CurrentMissionLogic' has a wrong offset!");

// Class FortniteGame.FortTokenToAttributeTable
// 0x0010 (0x0038 - 0x0028)
class UFortTokenToAttributeTable final : public UDataAsset
{
public:
	TArray<struct FTokenAttributePair>            TokenToAttributeList;                              // 0x0028(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTokenToAttributeTable">();
	}
	static class UFortTokenToAttributeTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortTokenToAttributeTable>();
	}
};
static_assert(alignof(UFortTokenToAttributeTable) == 0x000008, "Wrong alignment on UFortTokenToAttributeTable");
static_assert(sizeof(UFortTokenToAttributeTable) == 0x000038, "Wrong size on UFortTokenToAttributeTable");
static_assert(offsetof(UFortTokenToAttributeTable, TokenToAttributeList) == 0x000028, "Member 'UFortTokenToAttributeTable::TokenToAttributeList' has a wrong offset!");

// Class FortniteGame.BuildingOutpostStormshieldUpgrade
// 0x0000 (0x0FD0 - 0x0FD0)
class ABuildingOutpostStormshieldUpgrade : public AOutpostStructureBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingOutpostStormshieldUpgrade">();
	}
	static class ABuildingOutpostStormshieldUpgrade* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingOutpostStormshieldUpgrade>();
	}
};
static_assert(alignof(ABuildingOutpostStormshieldUpgrade) == 0x000010, "Wrong alignment on ABuildingOutpostStormshieldUpgrade");
static_assert(sizeof(ABuildingOutpostStormshieldUpgrade) == 0x000FD0, "Wrong size on ABuildingOutpostStormshieldUpgrade");

// Class FortniteGame.BuildingOutpostStormshieldCore
// 0x0000 (0x0FD0 - 0x0FD0)
class ABuildingOutpostStormshieldCore final : public ABuildingOutpostStormshieldUpgrade
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingOutpostStormshieldCore">();
	}
	static class ABuildingOutpostStormshieldCore* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingOutpostStormshieldCore>();
	}
};
static_assert(alignof(ABuildingOutpostStormshieldCore) == 0x000010, "Wrong alignment on ABuildingOutpostStormshieldCore");
static_assert(sizeof(ABuildingOutpostStormshieldCore) == 0x000FD0, "Wrong size on ABuildingOutpostStormshieldCore");

// Class FortniteGame.FortLobbyBeaconState
// 0x0098 (0x06D0 - 0x0638)
class AFortLobbyBeaconState : public ALobbyBeaconState
{
public:
	int32                                         MatchmakingLevel;                                  // 0x0638(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_63C[0x4];                                      // 0x063C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MissionGeneratorClassPath;                         // 0x0640(0x0010)(Net, ZeroConstructor, RepNotify, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortMissionGenerator*                  CachedMissionGeneratorCDO;                         // 0x0650(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELobbyMissionGeneratorDetailsRequirement      MissionGeneratorDetailsRequirement;                // 0x0658(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWorldRecordLoaded;                                // 0x0659(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_65A[0x76];                                     // 0x065A(0x0076)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_MissionGeneratorClassPath();
	void OnRep_MissionGeneratorDetailsRequirement();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortLobbyBeaconState">();
	}
	static class AFortLobbyBeaconState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortLobbyBeaconState>();
	}
};
static_assert(alignof(AFortLobbyBeaconState) == 0x000008, "Wrong alignment on AFortLobbyBeaconState");
static_assert(sizeof(AFortLobbyBeaconState) == 0x0006D0, "Wrong size on AFortLobbyBeaconState");
static_assert(offsetof(AFortLobbyBeaconState, MatchmakingLevel) == 0x000638, "Member 'AFortLobbyBeaconState::MatchmakingLevel' has a wrong offset!");
static_assert(offsetof(AFortLobbyBeaconState, MissionGeneratorClassPath) == 0x000640, "Member 'AFortLobbyBeaconState::MissionGeneratorClassPath' has a wrong offset!");
static_assert(offsetof(AFortLobbyBeaconState, CachedMissionGeneratorCDO) == 0x000650, "Member 'AFortLobbyBeaconState::CachedMissionGeneratorCDO' has a wrong offset!");
static_assert(offsetof(AFortLobbyBeaconState, MissionGeneratorDetailsRequirement) == 0x000658, "Member 'AFortLobbyBeaconState::MissionGeneratorDetailsRequirement' has a wrong offset!");
static_assert(offsetof(AFortLobbyBeaconState, bWorldRecordLoaded) == 0x000659, "Member 'AFortLobbyBeaconState::bWorldRecordLoaded' has a wrong offset!");

// Class FortniteGame.FortLobbyBeaconStatePvP
// 0x0010 (0x06E0 - 0x06D0)
class AFortLobbyBeaconStatePvP final : public AFortLobbyBeaconState
{
public:
	int32                                         PvPLobbyTimeLimit;                                 // 0x06D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PvPLobbyTimeRemaining;                             // 0x06D4(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6D8[0x8];                                      // 0x06D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_PvPLobbyTimeRemaining();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortLobbyBeaconStatePvP">();
	}
	static class AFortLobbyBeaconStatePvP* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortLobbyBeaconStatePvP>();
	}
};
static_assert(alignof(AFortLobbyBeaconStatePvP) == 0x000008, "Wrong alignment on AFortLobbyBeaconStatePvP");
static_assert(sizeof(AFortLobbyBeaconStatePvP) == 0x0006E0, "Wrong size on AFortLobbyBeaconStatePvP");
static_assert(offsetof(AFortLobbyBeaconStatePvP, PvPLobbyTimeLimit) == 0x0006D0, "Member 'AFortLobbyBeaconStatePvP::PvPLobbyTimeLimit' has a wrong offset!");
static_assert(offsetof(AFortLobbyBeaconStatePvP, PvPLobbyTimeRemaining) == 0x0006D4, "Member 'AFortLobbyBeaconStatePvP::PvPLobbyTimeRemaining' has a wrong offset!");

// Class FortniteGame.FortPawn
// 0x0740 (0x0EE0 - 0x07A0)
class AFortPawn : public ACharacter
{
public:
	uint8                                         Pad_7A0[0x68];                                     // 0x07A0(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    PawnStatHandle;                                    // 0x0808(0x0010)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_818[0x4];                                      // 0x0818(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SlidingFriction;                                   // 0x081C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlidingBrakingDeceleration;                        // 0x0820(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortMovementStyle                            CurrentMovementStyle;                              // 0x0824(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortPawnPushSize                             PushSize;                                          // 0x0825(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseBaseChanged;                                   // 0x0826(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TeleportCounter;                                   // 0x0827(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_828[0x4];                                      // 0x0828(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PawnUniqueID;                                      // 0x082C(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AFortWeapon*                            CurrentWeapon;                                     // 0x0830(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AFortWeapon*>                    CurrentWeaponList;                                 // 0x0838(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	bool                                          bIgnoreNextFallingDamage;                          // 0x0848(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_849[0x7];                                      // 0x0849(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   WeaponHandSocketName;                              // 0x0850(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SpawnSpot;                                         // 0x0858(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  DeathTags;                                         // 0x0860(0x0020)(Transient, NativeAccessSpecifierPublic)
	float                                         SpawnImmunityTime;                                 // 0x0880(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDying;                                          // 0x0884(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayedDying;                                      // 0x0885(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHiddenForDeath;                                 // 0x0886(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_887[0x1];                                      // 0x0887(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AFortPickup*>                    IncomingPickups;                                   // 0x0888(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FFortPickupEntryData>           PickupDirectionData;                               // 0x0898(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsKnockedback;                                    // 0x08A8(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsStunned;                                        // 0x08A9(0x0001)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsStaggered;                                      // 0x08AA(0x0001)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortControlRecoveryBehavior                  ControlRecoveryBehavior;                           // 0x08AB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AdditiveCringeCount;                               // 0x08AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditiveCringeDuration;                            // 0x08B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    PushMomentum;                                      // 0x08B4(0x000C)(BlueprintVisible, BlueprintReadOnly, Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C0[0x58];                                     // 0x08C0(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshSocket*                    DeathHitSocket;                                    // 0x0918(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDBNO;                                           // 0x0920(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_921[0x3];                                      // 0x0921(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastPostRenderTraceTime;                           // 0x0924(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPostRenderTraceSucceeded;                         // 0x0928(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_929[0x3];                                      // 0x0929(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TeamBeaconMaxDist;                                 // 0x092C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 TeamBeaconTextColor;                               // 0x0930(0x0004)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastTakeHitTimeTimeout;                            // 0x0934(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastDamagedTime;                                   // 0x0938(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipAnalogJump;                                   // 0x093C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_93D[0x3];                                      // 0x093D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortWeapon*                            CurrentlyAttachedWeapon;                           // 0x0940(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPrimitiveComponent*                    CachedNavFloor;                                    // 0x0948(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxFootstepDistance;                               // 0x0950(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_954[0x4];                                      // 0x0954(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             DefaultFootstepSound;                              // 0x0958(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             DefaultFastFootstepSound;                          // 0x0960(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             DefaultLandingSound;                               // 0x0968(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             DefaultHardLandingSound;                           // 0x0970(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             DefaultJumpSound;                                  // 0x0978(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCanCapsuleBeUsedForTargeting : 1;                 // 0x0980(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseLineTestForDamageZoneBoneDetection : 1;        // 0x0980(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_981[0x3];                                      // 0x0981(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LineTestForDamageZoneBoneDetectionRadius;          // 0x0984(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPawnDamageZones                       DamageZones[0x4];                                  // 0x0988(0x0018)(Edit, NativeAccessSpecifierPublic)
	uint8                                         DamageZoneActiveBitMask;                           // 0x09E8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9E9[0x3];                                      // 0x09E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TargettingZOffset;                                 // 0x09EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         JumpFlashCount;                                    // 0x09F0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9F1[0xF];                                      // 0x09F1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        EmoteAudioComp;                                    // 0x0A00(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPawnLanded;                                      // 0x0A08(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnHitPawn;                                         // 0x0A18(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnDied;                                            // 0x0A28(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnDeathEffects;                                    // 0x0A38(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_A48[0xE8];                                     // 0x0A48(0x00E8)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnDamaged;                                         // 0x0B30(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnWeaponEquippedDelegate;                          // 0x0B40(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            HealthRegenDelayGameplayEffect;                    // 0x0B50(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            HealthRegenGameplayEffect;                         // 0x0B58(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            ShieldRegenDelayGameplayEffect;                    // 0x0B60(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            ShieldRegenGameplayEffect;                         // 0x0B68(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsInvulnerable;                                   // 0x0B70(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B71[0xB];                                      // 0x0B71(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         WeaponHolsterCounter;                              // 0x0B7C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWeaponHolstered;                                  // 0x0B80(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B81[0x3];                                      // 0x0B81(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StaySpottedTime;                                   // 0x0B84(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SpottedEvent;                                      // 0x0B88(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bSpotted : 1;                                      // 0x0B90(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B91[0x7];                                      // 0x0B91(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortFeedbackBank*                      DefaultFeedback;                                   // 0x0B98(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFortPawnVocalChord>            VocalChords;                                       // 0x0BA0(0x0010)(Net, ZeroConstructor, Transient, RepNotify, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_BB0[0x50];                                     // 0x0BB0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortHealthSet*                         HealthSet;                                         // 0x0C00(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortControlResistanceSet*              ControlResistanceSet;                              // 0x0C08(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortDamageSet*                         DamageSet;                                         // 0x0C10(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortMovementSet*                       MovementSet;                                       // 0x0C18(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHealthSynced;                                     // 0x0C20(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C21[0xF];                                      // 0x0C21(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnAbilityDecisionWindowStackUpdated;               // 0x0C30(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UFortAbilitySystemComponent*            AbilitySystemComponent;                            // 0x0C40(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FFortActiveMontageDecisionWindow> DecisionWindowStack;                               // 0x0C48(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bPrimaryInputHeld;                                 // 0x0C58(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSecondaryInputHeld;                               // 0x0C59(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPrimaryInputQueued;                               // 0x0C5A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C5B[0x5];                                      // 0x0C5B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  GameplayTags;                                      // 0x0C60(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   DisplayName;                                       // 0x0C80(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FDamagerInfo>                   Damagers;                                          // 0x0C98(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class UFortHealthBarIndicator*                HealthBarIndicator;                                // 0x0CA8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CurrentCalloutTag;                                 // 0x0CB0(0x0008)(Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FCalloutEntry>                  CalloutEntries;                                    // 0x0CB8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         HealthBarWidth;                                    // 0x0CC8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HealthBarHeightMultiplier;                         // 0x0CCC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CD0[0x8];                                      // 0x0CD0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            SpottedBrush;                                      // 0x0CD8(0x0090)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FVector                                SpottedIconOffset;                                 // 0x0D68(0x000C)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ClientNonRenderedAnimUpdateRate;                   // 0x0D74(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxEvalRateForInterpolation;                       // 0x0D78(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D7C[0x4];                                      // 0x0D7C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 AnimUpdateRateVisibleMaxDistanceFactor;            // 0x0D80(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<int32, int32>                            LODToFrameSkipMap;                                 // 0x0D90(0x0050)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	EUpdateRateShiftBucket                        UroShiftBucket;                                    // 0x0DE0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DE1[0x1F];                                     // 0x0DE1(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bPostProcessNavLocation;                           // 0x0E00(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E01[0x7];                                      // 0x0E01(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortConversationSentence              CurrentSentence;                                   // 0x0E08(0x00B0)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_EB8[0x18];                                     // 0x0EB8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnPawnHealthChanged;                               // 0x0ED0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void AlignRotationToHitDirection(const struct FVector& HitDirection);
	bool AnimMontage_LocalJumpToSectionName(class FName SectionName);
	void AnimMontage_LocalSetNextSectionName(class UAnimMontage* AnimMontage, class FName SectionName, class FName NextSectionName);
	void ApplyKnockback(float KnockbackMagnitude, float KnockbackZAngle, const struct FVector& ImpulseDir);
	void AttachAssetToSocket(const struct FAssetAttachment& InAttachment);
	void ClearJumpFlashCount();
	void ClientInternalEquipWeapon(class AFortWeapon* Weap);
	void DetachAssetFromSocket(class FName SocketName);
	void DoFatalDamage(class UAbilitySystemComponent* KillerAbilitySystemComponent);
	class AFortWeapon* EquipWeaponDefinition(const class UFortWeaponItemDefinition* WeaponData, const struct FGuid& ItemEntryGuid);
	void ForceKill(const struct FGameplayTag& DeathReason, class AController* KillerController, class AActor* KillerActor);
	void GameplayCue(EGameplayCueEvent EventType, const struct FGameplayCueParameters& Parameters);
	void GameplayCue_Damage(EGameplayCueEvent EventType, const struct FGameplayCueParameters& Parameters);
	void GameplayCue_InstantDeath(EGameplayCueEvent EventType, const struct FGameplayCueParameters& Parameters);
	class USkeletalMeshComponent* GetAssetSkeletalMeshComponentAttachment(class FName SocketName);
	float GetCurrentMontageSectionTimeLeft();
	class AActor* GetMyMovementBaseActor();
	class UMaterialInstanceDynamic* GetPawnMID(int32 ElementIndex);
	float GetShieldOrHealthPercent();
	void HandleIsDying();
	void HandleIsHiddenForDeath();
	void HideBodyOnDeath();
	void InitializeDeathHitSocket(const struct FVector& WorldLocation, const struct FVector& WorldNormal);
	void LaunchCharacterJump(const struct FVector& LaunchVelocity, bool bXYOverride, bool bZOverride, bool bIgnoreFallDamage, bool bPlayFeedbackEvent);
	void OnBaseChanged(class AActor* NewBase);
	void OnBumpPushedPawn(class AFortPawn* InstigatedBy, float PushTimeLeft);
	void OnClearSentence();
	void OnDamagePlayEffects(float Damage, const struct FGameplayTagContainer& DamageTags, const struct FVector& Momentum, const struct FHitResult& HitInfo, class AFortPawn* InstigatedBy, class AActor* DamageCauser, const struct FGameplayEffectContextHandle& EffectContext);
	void OnDamageServer(float Damage, const struct FGameplayTagContainer& DamageTags, const struct FVector& Momentum, const struct FHitResult& HitInfo, class AController* InstigatedBy, class AActor* DamageCauser, const struct FGameplayEffectContextHandle& EffectContext);
	void OnDamageZoneStatusChanged(EFortDamageZone Zone, bool bStatus);
	void OnDeathPlayEffects(float Damage, const struct FGameplayTagContainer& DamageTags, const struct FVector& Momentum, const struct FHitResult& HitInfo, class AFortPawn* InstigatedBy, class AActor* DamageCauser, const struct FGameplayEffectContextHandle& EffectContext);
	void OnDeathServer(float Damage, const struct FGameplayTagContainer& DamageTags, const struct FVector& Momentum, const struct FHitResult& HitInfo, class AController* InstigatedBy, class AActor* DamageCauser, const struct FGameplayEffectContextHandle& EffectContext);
	void OnDisplaySentence(const class FText& SpeechText);
	void OnMontageEnded(class UAnimMontage* Montage, bool bInterrupted);
	void OnMontageStarted(class UAnimMontage* Montage);
	void OnOutOfControlResistanceServer(float ImpactDamageDone, const struct FGameplayTagContainer& SourceTags, const struct FGameplayEffectContextHandle& EffectContext, class AController* EffectInstigator, class AActor* EffectCauser);
	void OnRep_bWeaponHolstered();
	void OnRep_CurrentWeapon();
	void OnRep_DamageZoneActiveBitMask();
	void OnRep_IsDBNO();
	void OnRep_IsKnockedBack();
	void OnRep_JumpFlashCount();
	void OnRep_PawnUniqueID();
	void OnRep_PushMomentum();
	void OnRep_Sentence();
	void OnRep_TeleportCounter();
	void OnRep_VocalChords();
	void OnStunned();
	void OnTeleported();
	void OnWeaponEquipped(class AFortWeapon* NewWeapon, class AFortWeapon* PrevWeapon);
	void PawnStartFire(uint8 FireModeNum);
	void PawnStopFire(uint8 FireModeNum);
	void PawnUniqueIDSet();
	bool PickUpActor(class AActor* PickupTarget, const class UFortDecoItemDefinition* PlacementDecoItemDefinition);
	void PlayFootStepSound(int32 FootDown);
	float PlayLocalAnimMontage(class UAnimMontage* NewAnimMontage, float InPlayRate, class FName StartSectionName);
	void PlaySound(class USoundBase* Sound, float VolumeMultiplier, float PitchMultiplier);
	void PrototypeCharacterMovement(EMovementMode MovementMode, const struct FVector& LaunchVelocity);
	void RemoveCallout(const struct FGameplayTag& CalloutTagToRemove);
	void ResetFallingHeight();
	void ServerInternalEquipWeapon(class AFortWeapon* Weap);
	void ServerTeleportNearLocation(const struct FVector& ActorLocation);
	void SetCallout(const struct FGameplayTag& CalloutTagToSet, float Duration);
	void SetFNameBasedOnHitDirection(const struct FVector& HitDirection, class FName* NameResult, class FName NameFront, class FName NameBack, class FName NameLeft, class FName NameRight);
	void SetHealth(float NewHealthVal);
	void SetHolsterWeapon(bool bHolster, bool bPlayEquipAnim);
	void SetIsKnockedBack(bool bKnockback);
	void SetMaxHealth(float NewHealthVal);
	void SetPawnAndControlRotation(const struct FRotator& NewRotation);
	void SetPawnVisibility(bool bNewHidden, bool bPropagateToWeapon);
	void SetSpawnSpot(class AActor* InSpawnSpot);
	class AEmitterCameraLensEffectBase* SpawnCameraLensEffect(TSubclassOf<class AEmitterCameraLensEffectBase> LensEffectEmitterClass);
	class AFortEmitterCameraLensEffectDirectional* SpawnCameraLensEffectDirectional(TSubclassOf<class AFortEmitterCameraLensEffectDirectional> LensEffectEmitterClass, class AFortPawn* DamageDealer, const struct FHitResult& HitInfo);
	void StartPushMomentum(const struct FVector& NewPushMomentum, float Duration);
	void StopPushMomentum();
	void TriggerFeedbackEvent(class FName EventName, class AFortPawn* InstigatorPawn, class AFortPawn* Recipient, float OverriddenDelay);

	EFortControlRecoveryBehavior GetControlRecoveryBehavior() const;
	float GetControlResistance() const;
	class FText GetCurrentSentenceSpeechText() const;
	EFortDamageZone GetDamageZone(const struct FHitResult& InHitResult) const;
	struct FVector GetDefaultTargetingOrigin() const;
	struct FRotator GetDefaultTargetingRotation() const;
	class UFortAIEncounterInfo* GetEncounterInfo() const;
	float GetHealth() const;
	float GetHealthPercent() const;
	float GetKnockbackMultiplier() const;
	float GetKnockbackThreshold() const;
	class APlayerController* GetLocalViewingPlayerController() const;
	float GetMaxControlResistance() const;
	float GetMaxHealth() const;
	float GetMaxShield() const;
	int32 GetMeleeComboCounter() const;
	float GetMeleeReticleStrikeAngle(bool bPrimaryInput) const;
	struct FVector GetMovementPredictionPosition(float PredictionDeltaTime) const;
	float GetShield() const;
	void GetSphericalHitDirection(const struct FVector& HitDirection, float* Azimuth, float* Elevation) const;
	struct FTransform GetTargetingTransform(EFortAbilityTargetingSource Source, class UFortGameplayAbility* SourceAbility) const;
	bool HasCurrentMontage() const;
	bool IsActionInputIgnored() const;
	bool IsAllowChainStun() const;
	bool IsDBNO() const;
	bool IsDead() const;
	bool IsFrontalHit(const struct FVector& HitDirection) const;
	bool IsStaggered() const;
	bool IsWeaponHolstered() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPawn">();
	}
	static class AFortPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPawn>();
	}
};
static_assert(alignof(AFortPawn) == 0x000010, "Wrong alignment on AFortPawn");
static_assert(sizeof(AFortPawn) == 0x000EE0, "Wrong size on AFortPawn");
static_assert(offsetof(AFortPawn, PawnStatHandle) == 0x000808, "Member 'AFortPawn::PawnStatHandle' has a wrong offset!");
static_assert(offsetof(AFortPawn, SlidingFriction) == 0x00081C, "Member 'AFortPawn::SlidingFriction' has a wrong offset!");
static_assert(offsetof(AFortPawn, SlidingBrakingDeceleration) == 0x000820, "Member 'AFortPawn::SlidingBrakingDeceleration' has a wrong offset!");
static_assert(offsetof(AFortPawn, CurrentMovementStyle) == 0x000824, "Member 'AFortPawn::CurrentMovementStyle' has a wrong offset!");
static_assert(offsetof(AFortPawn, PushSize) == 0x000825, "Member 'AFortPawn::PushSize' has a wrong offset!");
static_assert(offsetof(AFortPawn, bUseBaseChanged) == 0x000826, "Member 'AFortPawn::bUseBaseChanged' has a wrong offset!");
static_assert(offsetof(AFortPawn, TeleportCounter) == 0x000827, "Member 'AFortPawn::TeleportCounter' has a wrong offset!");
static_assert(offsetof(AFortPawn, PawnUniqueID) == 0x00082C, "Member 'AFortPawn::PawnUniqueID' has a wrong offset!");
static_assert(offsetof(AFortPawn, CurrentWeapon) == 0x000830, "Member 'AFortPawn::CurrentWeapon' has a wrong offset!");
static_assert(offsetof(AFortPawn, CurrentWeaponList) == 0x000838, "Member 'AFortPawn::CurrentWeaponList' has a wrong offset!");
static_assert(offsetof(AFortPawn, bIgnoreNextFallingDamage) == 0x000848, "Member 'AFortPawn::bIgnoreNextFallingDamage' has a wrong offset!");
static_assert(offsetof(AFortPawn, WeaponHandSocketName) == 0x000850, "Member 'AFortPawn::WeaponHandSocketName' has a wrong offset!");
static_assert(offsetof(AFortPawn, SpawnSpot) == 0x000858, "Member 'AFortPawn::SpawnSpot' has a wrong offset!");
static_assert(offsetof(AFortPawn, DeathTags) == 0x000860, "Member 'AFortPawn::DeathTags' has a wrong offset!");
static_assert(offsetof(AFortPawn, SpawnImmunityTime) == 0x000880, "Member 'AFortPawn::SpawnImmunityTime' has a wrong offset!");
static_assert(offsetof(AFortPawn, bIsDying) == 0x000884, "Member 'AFortPawn::bIsDying' has a wrong offset!");
static_assert(offsetof(AFortPawn, bPlayedDying) == 0x000885, "Member 'AFortPawn::bPlayedDying' has a wrong offset!");
static_assert(offsetof(AFortPawn, bIsHiddenForDeath) == 0x000886, "Member 'AFortPawn::bIsHiddenForDeath' has a wrong offset!");
static_assert(offsetof(AFortPawn, IncomingPickups) == 0x000888, "Member 'AFortPawn::IncomingPickups' has a wrong offset!");
static_assert(offsetof(AFortPawn, PickupDirectionData) == 0x000898, "Member 'AFortPawn::PickupDirectionData' has a wrong offset!");
static_assert(offsetof(AFortPawn, bIsKnockedback) == 0x0008A8, "Member 'AFortPawn::bIsKnockedback' has a wrong offset!");
static_assert(offsetof(AFortPawn, bIsStunned) == 0x0008A9, "Member 'AFortPawn::bIsStunned' has a wrong offset!");
static_assert(offsetof(AFortPawn, bIsStaggered) == 0x0008AA, "Member 'AFortPawn::bIsStaggered' has a wrong offset!");
static_assert(offsetof(AFortPawn, ControlRecoveryBehavior) == 0x0008AB, "Member 'AFortPawn::ControlRecoveryBehavior' has a wrong offset!");
static_assert(offsetof(AFortPawn, AdditiveCringeCount) == 0x0008AC, "Member 'AFortPawn::AdditiveCringeCount' has a wrong offset!");
static_assert(offsetof(AFortPawn, AdditiveCringeDuration) == 0x0008B0, "Member 'AFortPawn::AdditiveCringeDuration' has a wrong offset!");
static_assert(offsetof(AFortPawn, PushMomentum) == 0x0008B4, "Member 'AFortPawn::PushMomentum' has a wrong offset!");
static_assert(offsetof(AFortPawn, DeathHitSocket) == 0x000918, "Member 'AFortPawn::DeathHitSocket' has a wrong offset!");
static_assert(offsetof(AFortPawn, bIsDBNO) == 0x000920, "Member 'AFortPawn::bIsDBNO' has a wrong offset!");
static_assert(offsetof(AFortPawn, LastPostRenderTraceTime) == 0x000924, "Member 'AFortPawn::LastPostRenderTraceTime' has a wrong offset!");
static_assert(offsetof(AFortPawn, bPostRenderTraceSucceeded) == 0x000928, "Member 'AFortPawn::bPostRenderTraceSucceeded' has a wrong offset!");
static_assert(offsetof(AFortPawn, TeamBeaconMaxDist) == 0x00092C, "Member 'AFortPawn::TeamBeaconMaxDist' has a wrong offset!");
static_assert(offsetof(AFortPawn, TeamBeaconTextColor) == 0x000930, "Member 'AFortPawn::TeamBeaconTextColor' has a wrong offset!");
static_assert(offsetof(AFortPawn, LastTakeHitTimeTimeout) == 0x000934, "Member 'AFortPawn::LastTakeHitTimeTimeout' has a wrong offset!");
static_assert(offsetof(AFortPawn, LastDamagedTime) == 0x000938, "Member 'AFortPawn::LastDamagedTime' has a wrong offset!");
static_assert(offsetof(AFortPawn, bSkipAnalogJump) == 0x00093C, "Member 'AFortPawn::bSkipAnalogJump' has a wrong offset!");
static_assert(offsetof(AFortPawn, CurrentlyAttachedWeapon) == 0x000940, "Member 'AFortPawn::CurrentlyAttachedWeapon' has a wrong offset!");
static_assert(offsetof(AFortPawn, CachedNavFloor) == 0x000948, "Member 'AFortPawn::CachedNavFloor' has a wrong offset!");
static_assert(offsetof(AFortPawn, MaxFootstepDistance) == 0x000950, "Member 'AFortPawn::MaxFootstepDistance' has a wrong offset!");
static_assert(offsetof(AFortPawn, DefaultFootstepSound) == 0x000958, "Member 'AFortPawn::DefaultFootstepSound' has a wrong offset!");
static_assert(offsetof(AFortPawn, DefaultFastFootstepSound) == 0x000960, "Member 'AFortPawn::DefaultFastFootstepSound' has a wrong offset!");
static_assert(offsetof(AFortPawn, DefaultLandingSound) == 0x000968, "Member 'AFortPawn::DefaultLandingSound' has a wrong offset!");
static_assert(offsetof(AFortPawn, DefaultHardLandingSound) == 0x000970, "Member 'AFortPawn::DefaultHardLandingSound' has a wrong offset!");
static_assert(offsetof(AFortPawn, DefaultJumpSound) == 0x000978, "Member 'AFortPawn::DefaultJumpSound' has a wrong offset!");
static_assert(offsetof(AFortPawn, LineTestForDamageZoneBoneDetectionRadius) == 0x000984, "Member 'AFortPawn::LineTestForDamageZoneBoneDetectionRadius' has a wrong offset!");
static_assert(offsetof(AFortPawn, DamageZones) == 0x000988, "Member 'AFortPawn::DamageZones' has a wrong offset!");
static_assert(offsetof(AFortPawn, DamageZoneActiveBitMask) == 0x0009E8, "Member 'AFortPawn::DamageZoneActiveBitMask' has a wrong offset!");
static_assert(offsetof(AFortPawn, TargettingZOffset) == 0x0009EC, "Member 'AFortPawn::TargettingZOffset' has a wrong offset!");
static_assert(offsetof(AFortPawn, JumpFlashCount) == 0x0009F0, "Member 'AFortPawn::JumpFlashCount' has a wrong offset!");
static_assert(offsetof(AFortPawn, EmoteAudioComp) == 0x000A00, "Member 'AFortPawn::EmoteAudioComp' has a wrong offset!");
static_assert(offsetof(AFortPawn, OnPawnLanded) == 0x000A08, "Member 'AFortPawn::OnPawnLanded' has a wrong offset!");
static_assert(offsetof(AFortPawn, OnHitPawn) == 0x000A18, "Member 'AFortPawn::OnHitPawn' has a wrong offset!");
static_assert(offsetof(AFortPawn, OnDied) == 0x000A28, "Member 'AFortPawn::OnDied' has a wrong offset!");
static_assert(offsetof(AFortPawn, OnDeathEffects) == 0x000A38, "Member 'AFortPawn::OnDeathEffects' has a wrong offset!");
static_assert(offsetof(AFortPawn, OnDamaged) == 0x000B30, "Member 'AFortPawn::OnDamaged' has a wrong offset!");
static_assert(offsetof(AFortPawn, OnWeaponEquippedDelegate) == 0x000B40, "Member 'AFortPawn::OnWeaponEquippedDelegate' has a wrong offset!");
static_assert(offsetof(AFortPawn, HealthRegenDelayGameplayEffect) == 0x000B50, "Member 'AFortPawn::HealthRegenDelayGameplayEffect' has a wrong offset!");
static_assert(offsetof(AFortPawn, HealthRegenGameplayEffect) == 0x000B58, "Member 'AFortPawn::HealthRegenGameplayEffect' has a wrong offset!");
static_assert(offsetof(AFortPawn, ShieldRegenDelayGameplayEffect) == 0x000B60, "Member 'AFortPawn::ShieldRegenDelayGameplayEffect' has a wrong offset!");
static_assert(offsetof(AFortPawn, ShieldRegenGameplayEffect) == 0x000B68, "Member 'AFortPawn::ShieldRegenGameplayEffect' has a wrong offset!");
static_assert(offsetof(AFortPawn, bIsInvulnerable) == 0x000B70, "Member 'AFortPawn::bIsInvulnerable' has a wrong offset!");
static_assert(offsetof(AFortPawn, WeaponHolsterCounter) == 0x000B7C, "Member 'AFortPawn::WeaponHolsterCounter' has a wrong offset!");
static_assert(offsetof(AFortPawn, bWeaponHolstered) == 0x000B80, "Member 'AFortPawn::bWeaponHolstered' has a wrong offset!");
static_assert(offsetof(AFortPawn, StaySpottedTime) == 0x000B84, "Member 'AFortPawn::StaySpottedTime' has a wrong offset!");
static_assert(offsetof(AFortPawn, SpottedEvent) == 0x000B88, "Member 'AFortPawn::SpottedEvent' has a wrong offset!");
static_assert(offsetof(AFortPawn, DefaultFeedback) == 0x000B98, "Member 'AFortPawn::DefaultFeedback' has a wrong offset!");
static_assert(offsetof(AFortPawn, VocalChords) == 0x000BA0, "Member 'AFortPawn::VocalChords' has a wrong offset!");
static_assert(offsetof(AFortPawn, HealthSet) == 0x000C00, "Member 'AFortPawn::HealthSet' has a wrong offset!");
static_assert(offsetof(AFortPawn, ControlResistanceSet) == 0x000C08, "Member 'AFortPawn::ControlResistanceSet' has a wrong offset!");
static_assert(offsetof(AFortPawn, DamageSet) == 0x000C10, "Member 'AFortPawn::DamageSet' has a wrong offset!");
static_assert(offsetof(AFortPawn, MovementSet) == 0x000C18, "Member 'AFortPawn::MovementSet' has a wrong offset!");
static_assert(offsetof(AFortPawn, bHealthSynced) == 0x000C20, "Member 'AFortPawn::bHealthSynced' has a wrong offset!");
static_assert(offsetof(AFortPawn, OnAbilityDecisionWindowStackUpdated) == 0x000C30, "Member 'AFortPawn::OnAbilityDecisionWindowStackUpdated' has a wrong offset!");
static_assert(offsetof(AFortPawn, AbilitySystemComponent) == 0x000C40, "Member 'AFortPawn::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(AFortPawn, DecisionWindowStack) == 0x000C48, "Member 'AFortPawn::DecisionWindowStack' has a wrong offset!");
static_assert(offsetof(AFortPawn, bPrimaryInputHeld) == 0x000C58, "Member 'AFortPawn::bPrimaryInputHeld' has a wrong offset!");
static_assert(offsetof(AFortPawn, bSecondaryInputHeld) == 0x000C59, "Member 'AFortPawn::bSecondaryInputHeld' has a wrong offset!");
static_assert(offsetof(AFortPawn, bPrimaryInputQueued) == 0x000C5A, "Member 'AFortPawn::bPrimaryInputQueued' has a wrong offset!");
static_assert(offsetof(AFortPawn, GameplayTags) == 0x000C60, "Member 'AFortPawn::GameplayTags' has a wrong offset!");
static_assert(offsetof(AFortPawn, DisplayName) == 0x000C80, "Member 'AFortPawn::DisplayName' has a wrong offset!");
static_assert(offsetof(AFortPawn, Damagers) == 0x000C98, "Member 'AFortPawn::Damagers' has a wrong offset!");
static_assert(offsetof(AFortPawn, HealthBarIndicator) == 0x000CA8, "Member 'AFortPawn::HealthBarIndicator' has a wrong offset!");
static_assert(offsetof(AFortPawn, CurrentCalloutTag) == 0x000CB0, "Member 'AFortPawn::CurrentCalloutTag' has a wrong offset!");
static_assert(offsetof(AFortPawn, CalloutEntries) == 0x000CB8, "Member 'AFortPawn::CalloutEntries' has a wrong offset!");
static_assert(offsetof(AFortPawn, HealthBarWidth) == 0x000CC8, "Member 'AFortPawn::HealthBarWidth' has a wrong offset!");
static_assert(offsetof(AFortPawn, HealthBarHeightMultiplier) == 0x000CCC, "Member 'AFortPawn::HealthBarHeightMultiplier' has a wrong offset!");
static_assert(offsetof(AFortPawn, SpottedBrush) == 0x000CD8, "Member 'AFortPawn::SpottedBrush' has a wrong offset!");
static_assert(offsetof(AFortPawn, SpottedIconOffset) == 0x000D68, "Member 'AFortPawn::SpottedIconOffset' has a wrong offset!");
static_assert(offsetof(AFortPawn, ClientNonRenderedAnimUpdateRate) == 0x000D74, "Member 'AFortPawn::ClientNonRenderedAnimUpdateRate' has a wrong offset!");
static_assert(offsetof(AFortPawn, MaxEvalRateForInterpolation) == 0x000D78, "Member 'AFortPawn::MaxEvalRateForInterpolation' has a wrong offset!");
static_assert(offsetof(AFortPawn, AnimUpdateRateVisibleMaxDistanceFactor) == 0x000D80, "Member 'AFortPawn::AnimUpdateRateVisibleMaxDistanceFactor' has a wrong offset!");
static_assert(offsetof(AFortPawn, LODToFrameSkipMap) == 0x000D90, "Member 'AFortPawn::LODToFrameSkipMap' has a wrong offset!");
static_assert(offsetof(AFortPawn, UroShiftBucket) == 0x000DE0, "Member 'AFortPawn::UroShiftBucket' has a wrong offset!");
static_assert(offsetof(AFortPawn, bPostProcessNavLocation) == 0x000E00, "Member 'AFortPawn::bPostProcessNavLocation' has a wrong offset!");
static_assert(offsetof(AFortPawn, CurrentSentence) == 0x000E08, "Member 'AFortPawn::CurrentSentence' has a wrong offset!");
static_assert(offsetof(AFortPawn, OnPawnHealthChanged) == 0x000ED0, "Member 'AFortPawn::OnPawnHealthChanged' has a wrong offset!");

// Class FortniteGame.FortTeamInfo
// 0x00F8 (0x0480 - 0x0388)
class AFortTeamInfo : public AInfo
{
public:
	uint8                                         Pad_388[0x8];                                      // 0x0388(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AController*>                    TeamMembers;                                       // 0x0390(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	EFortTeam                                     Team;                                              // 0x03A0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A1[0x7];                                      // 0x03A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ChatRoomId;                                        // 0x03A8(0x0010)(Net, ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTeamSpottedActorInfoArray             TeamSpottedActors;                                 // 0x03B8(0x00C8)(Net, Protected, NativeAccessSpecifierProtected)

public:
	void OnSpottedActorDied(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, class AActor* DamageCauser, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& Momentum);

	int32 GetTeamExperience() const;
	int32 GetTeamLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTeamInfo">();
	}
	static class AFortTeamInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortTeamInfo>();
	}
};
static_assert(alignof(AFortTeamInfo) == 0x000008, "Wrong alignment on AFortTeamInfo");
static_assert(sizeof(AFortTeamInfo) == 0x000480, "Wrong size on AFortTeamInfo");
static_assert(offsetof(AFortTeamInfo, TeamMembers) == 0x000390, "Member 'AFortTeamInfo::TeamMembers' has a wrong offset!");
static_assert(offsetof(AFortTeamInfo, Team) == 0x0003A0, "Member 'AFortTeamInfo::Team' has a wrong offset!");
static_assert(offsetof(AFortTeamInfo, ChatRoomId) == 0x0003A8, "Member 'AFortTeamInfo::ChatRoomId' has a wrong offset!");
static_assert(offsetof(AFortTeamInfo, TeamSpottedActors) == 0x0003B8, "Member 'AFortTeamInfo::TeamSpottedActors' has a wrong offset!");

// Class FortniteGame.BuildingFloor
// 0x0010 (0x0FD0 - 0x0FC0)
#pragma pack(push, 0x1)
class alignas(0x10) ABuildingFloor : public ABuildingSMActor
{
public:
	uint8                                         Pad_FC0[0x8];                                      // 0x0FC0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsBalcony() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingFloor">();
	}
	static class ABuildingFloor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingFloor>();
	}
};
#pragma pack(pop)
static_assert(alignof(ABuildingFloor) == 0x000010, "Wrong alignment on ABuildingFloor");
static_assert(sizeof(ABuildingFloor) == 0x000FD0, "Wrong size on ABuildingFloor");

// Class FortniteGame.BuildingStairs
// 0x0000 (0x0FD0 - 0x0FD0)
class ABuildingStairs : public ABuildingFloor
{
public:
	EBuildingStairsRailing                        RailingType;                                       // 0x0FC8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC9[0x7];                                      // 0x0FC9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingStairs">();
	}
	static class ABuildingStairs* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingStairs>();
	}
};
static_assert(alignof(ABuildingStairs) == 0x000010, "Wrong alignment on ABuildingStairs");
static_assert(sizeof(ABuildingStairs) == 0x000FD0, "Wrong size on ABuildingStairs");
static_assert(offsetof(ABuildingStairs, RailingType) == 0x000FC8, "Member 'ABuildingStairs::RailingType' has a wrong offset!");

// Class FortniteGame.FortConversation
// 0x0010 (0x0038 - 0x0028)
class UFortConversation final : public UDataAsset
{
public:
	TArray<struct FFortConversationSentence>      Sentences;                                         // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortConversation">();
	}
	static class UFortConversation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortConversation>();
	}
};
static_assert(alignof(UFortConversation) == 0x000008, "Wrong alignment on UFortConversation");
static_assert(sizeof(UFortConversation) == 0x000038, "Wrong size on UFortConversation");
static_assert(offsetof(UFortConversation, Sentences) == 0x000028, "Member 'UFortConversation::Sentences' has a wrong offset!");

// Class FortniteGame.FortGlobals
// 0x0208 (0x0230 - 0x0028)
class UFortGlobals final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LobbyMap;                                          // 0x0030(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinTheaterListRefreshDelay;                        // 0x0040(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTheaterListRefreshDelay;                        // 0x0044(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultCullObjectSize;                             // 0x0048(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultCullDistance;                               // 0x004C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinCullObjectSize;                                 // 0x0050(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinCullDistance;                                   // 0x0054(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxCullObjectSize;                                 // 0x0058(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxCullDistance;                                   // 0x005C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableNewCustomizationPanel;                      // 0x0060(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableInfluenceMap;                               // 0x0061(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableAIDespawning;                               // 0x0062(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableAutoSlotting;                               // 0x0063(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableDBNO;                                       // 0x0064(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableInWorldScoreNumbers;                        // 0x0065(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableNewRewardFlow;                              // 0x0066(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableLazyASC;                                    // 0x0067(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUsingGamepad;                                   // 0x0068(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableFriendCodes;                                // 0x0069(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x6];                                       // 0x006A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLoginFailureLogSubmitOptions          LoginFailureOptions;                               // 0x0070(0x0018)(Config, NativeAccessSpecifierPublic)
	struct FPurchaseFailureLogSubmitOptions       RealMoneyPurchaseFailureOptions;                   // 0x0088(0x0018)(Config, NativeAccessSpecifierPublic)
	bool                                          bSubmitReturnToMenuErrorLogs;                      // 0x00A0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnToMenuErrorLogTailKb;                        // 0x00A4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPartyFailureLogSubmit                 PartyJoinFailureLogSubmit;                         // 0x00A8(0x0018)(Config, NativeAccessSpecifierPublic)
	bool                                          bShowSkillTreeMovies;                              // 0x00C0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowMissionResultsMovies;                         // 0x00C1(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisablePlayerTeleportDuringMissionResults;        // 0x00C2(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableParticleEffectsDuringMissionResults;       // 0x00C3(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFlushGPUWhenPlayerIsTeleportedAtEndOfZone;        // 0x00C4(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStreamOutTextureDataWhenPlayerIsTeleportedAtEndOfZone; // 0x00C5(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTwitchEnabled;                                    // 0x00C6(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAccountLinkingEnabled;                            // 0x00C7(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortAccountLinkingUIConfig                   AccountLinkingUIConfig;                            // 0x00C8(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AccountLinkingUIURL;                               // 0x00D0(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableAccountLinkingUIURLButton;                  // 0x00E0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTwitchHeartbeatEnabled;                           // 0x00E1(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTwitchAllowDisplayViewernames;                    // 0x00E2(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E3[0x1];                                       // 0x00E3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxTwitchViewerNamesToCache;                       // 0x00E4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TwitchViewerNameExpirationMinutes;                 // 0x00E8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTwitchHeartbeatInterval;                        // 0x00EC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TwitchAccountInformationRefreshInterval;           // 0x00F0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowLogout;                                      // 0x00F4(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowQuit;                                        // 0x00F5(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasWorldMap;                                      // 0x00F6(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F7[0x1];                                       // 0x00F7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayerUnregistrationFailsafeTimer;                 // 0x00F8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUploadAthenaStats;                                // 0x00FC(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAthenaStatsFrontendEnabled;                       // 0x00FD(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAthenaLeaderboardFrontEndEnabled;                 // 0x00FE(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FF[0x1];                                       // 0x00FF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TimeBetweenLeaderboardRequestsMinutes;             // 0x0100(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSecondsBetweenUnimportantPresenceUpdates;       // 0x0104(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        AthenaReferencedObjects;                           // 0x0110(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	int32                                         NumOutstandingAthenaAsyncRequests;                 // 0x0120(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalAthenaAsyncRequests;                          // 0x0124(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_128[0x78];                                     // 0x0128(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSubGameAccess>                 SubGameAccess;                                     // 0x01A0(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B0[0x80];                                     // 0x01B0(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool AreFriendCodesEnabled();
	static EFortAccountLinkingUIConfig GetAccountLinkingUIConfig();
	static class FString GetAccountLinkingUIURL();
	static int32 GetMaxTheaterListRefreshDelay();
	static int32 GetMinTheaterListRefreshDelay();
	static bool IsAccountLinkingEnabled();
	static bool IsAccountLinkingUIURLButtonEnabled();
	static bool IsDisplayingTwitchViewerNamesAllowed();
	static bool IsNewRewardFlowEnabled();
	static bool IsTwitchEnabled();
	static bool ShouldDisableParticleEffectsDuringMissionResults();
	static bool ShouldDisablePlayerTeleportDuringMissionResults();
	static bool ShouldFlushGPUWhenPlayerIsTeleportedAtEndOfZone();
	static bool ShouldShowMissionResultsMovies();
	static bool ShouldShowSkillTreeMovies();
	static bool ShouldStreamOutTextureDataWhenPlayerIsTeleportedAtEndOfZone();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGlobals">();
	}
	static class UFortGlobals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGlobals>();
	}
};
static_assert(alignof(UFortGlobals) == 0x000008, "Wrong alignment on UFortGlobals");
static_assert(sizeof(UFortGlobals) == 0x000230, "Wrong size on UFortGlobals");
static_assert(offsetof(UFortGlobals, LobbyMap) == 0x000030, "Member 'UFortGlobals::LobbyMap' has a wrong offset!");
static_assert(offsetof(UFortGlobals, MinTheaterListRefreshDelay) == 0x000040, "Member 'UFortGlobals::MinTheaterListRefreshDelay' has a wrong offset!");
static_assert(offsetof(UFortGlobals, MaxTheaterListRefreshDelay) == 0x000044, "Member 'UFortGlobals::MaxTheaterListRefreshDelay' has a wrong offset!");
static_assert(offsetof(UFortGlobals, DefaultCullObjectSize) == 0x000048, "Member 'UFortGlobals::DefaultCullObjectSize' has a wrong offset!");
static_assert(offsetof(UFortGlobals, DefaultCullDistance) == 0x00004C, "Member 'UFortGlobals::DefaultCullDistance' has a wrong offset!");
static_assert(offsetof(UFortGlobals, MinCullObjectSize) == 0x000050, "Member 'UFortGlobals::MinCullObjectSize' has a wrong offset!");
static_assert(offsetof(UFortGlobals, MinCullDistance) == 0x000054, "Member 'UFortGlobals::MinCullDistance' has a wrong offset!");
static_assert(offsetof(UFortGlobals, MaxCullObjectSize) == 0x000058, "Member 'UFortGlobals::MaxCullObjectSize' has a wrong offset!");
static_assert(offsetof(UFortGlobals, MaxCullDistance) == 0x00005C, "Member 'UFortGlobals::MaxCullDistance' has a wrong offset!");
static_assert(offsetof(UFortGlobals, bEnableNewCustomizationPanel) == 0x000060, "Member 'UFortGlobals::bEnableNewCustomizationPanel' has a wrong offset!");
static_assert(offsetof(UFortGlobals, bEnableInfluenceMap) == 0x000061, "Member 'UFortGlobals::bEnableInfluenceMap' has a wrong offset!");
static_assert(offsetof(UFortGlobals, bEnableAIDespawning) == 0x000062, "Member 'UFortGlobals::bEnableAIDespawning' has a wrong offset!");
static_assert(offsetof(UFortGlobals, bEnableAutoSlotting) == 0x000063, "Member 'UFortGlobals::bEnableAutoSlotting' has a wrong offset!");
static_assert(offsetof(UFortGlobals, bEnableDBNO) == 0x000064, "Member 'UFortGlobals::bEnableDBNO' has a wrong offset!");
static_assert(offsetof(UFortGlobals, bEnableInWorldScoreNumbers) == 0x000065, "Member 'UFortGlobals::bEnableInWorldScoreNumbers' has a wrong offset!");
static_assert(offsetof(UFortGlobals, bEnableNewRewardFlow) == 0x000066, "Member 'UFortGlobals::bEnableNewRewardFlow' has a wrong offset!");
static_assert(offsetof(UFortGlobals, bEnableLazyASC) == 0x000067, "Member 'UFortGlobals::bEnableLazyASC' has a wrong offset!");
static_assert(offsetof(UFortGlobals, bIsUsingGamepad) == 0x000068, "Member 'UFortGlobals::bIsUsingGamepad' has a wrong offset!");
static_assert(offsetof(UFortGlobals, bEnableFriendCodes) == 0x000069, "Member 'UFortGlobals::bEnableFriendCodes' has a wrong offset!");
static_assert(offsetof(UFortGlobals, LoginFailureOptions) == 0x000070, "Member 'UFortGlobals::LoginFailureOptions' has a wrong offset!");
static_assert(offsetof(UFortGlobals, RealMoneyPurchaseFailureOptions) == 0x000088, "Member 'UFortGlobals::RealMoneyPurchaseFailureOptions' has a wrong offset!");
static_assert(offsetof(UFortGlobals, bSubmitReturnToMenuErrorLogs) == 0x0000A0, "Member 'UFortGlobals::bSubmitReturnToMenuErrorLogs' has a wrong offset!");
static_assert(offsetof(UFortGlobals, ReturnToMenuErrorLogTailKb) == 0x0000A4, "Member 'UFortGlobals::ReturnToMenuErrorLogTailKb' has a wrong offset!");
static_assert(offsetof(UFortGlobals, PartyJoinFailureLogSubmit) == 0x0000A8, "Member 'UFortGlobals::PartyJoinFailureLogSubmit' has a wrong offset!");
static_assert(offsetof(UFortGlobals, bShowSkillTreeMovies) == 0x0000C0, "Member 'UFortGlobals::bShowSkillTreeMovies' has a wrong offset!");
static_assert(offsetof(UFortGlobals, bShowMissionResultsMovies) == 0x0000C1, "Member 'UFortGlobals::bShowMissionResultsMovies' has a wrong offset!");
static_assert(offsetof(UFortGlobals, bDisablePlayerTeleportDuringMissionResults) == 0x0000C2, "Member 'UFortGlobals::bDisablePlayerTeleportDuringMissionResults' has a wrong offset!");
static_assert(offsetof(UFortGlobals, bDisableParticleEffectsDuringMissionResults) == 0x0000C3, "Member 'UFortGlobals::bDisableParticleEffectsDuringMissionResults' has a wrong offset!");
static_assert(offsetof(UFortGlobals, bFlushGPUWhenPlayerIsTeleportedAtEndOfZone) == 0x0000C4, "Member 'UFortGlobals::bFlushGPUWhenPlayerIsTeleportedAtEndOfZone' has a wrong offset!");
static_assert(offsetof(UFortGlobals, bStreamOutTextureDataWhenPlayerIsTeleportedAtEndOfZone) == 0x0000C5, "Member 'UFortGlobals::bStreamOutTextureDataWhenPlayerIsTeleportedAtEndOfZone' has a wrong offset!");
static_assert(offsetof(UFortGlobals, bTwitchEnabled) == 0x0000C6, "Member 'UFortGlobals::bTwitchEnabled' has a wrong offset!");
static_assert(offsetof(UFortGlobals, bAccountLinkingEnabled) == 0x0000C7, "Member 'UFortGlobals::bAccountLinkingEnabled' has a wrong offset!");
static_assert(offsetof(UFortGlobals, AccountLinkingUIConfig) == 0x0000C8, "Member 'UFortGlobals::AccountLinkingUIConfig' has a wrong offset!");
static_assert(offsetof(UFortGlobals, AccountLinkingUIURL) == 0x0000D0, "Member 'UFortGlobals::AccountLinkingUIURL' has a wrong offset!");
static_assert(offsetof(UFortGlobals, bEnableAccountLinkingUIURLButton) == 0x0000E0, "Member 'UFortGlobals::bEnableAccountLinkingUIURLButton' has a wrong offset!");
static_assert(offsetof(UFortGlobals, bTwitchHeartbeatEnabled) == 0x0000E1, "Member 'UFortGlobals::bTwitchHeartbeatEnabled' has a wrong offset!");
static_assert(offsetof(UFortGlobals, bTwitchAllowDisplayViewernames) == 0x0000E2, "Member 'UFortGlobals::bTwitchAllowDisplayViewernames' has a wrong offset!");
static_assert(offsetof(UFortGlobals, MaxTwitchViewerNamesToCache) == 0x0000E4, "Member 'UFortGlobals::MaxTwitchViewerNamesToCache' has a wrong offset!");
static_assert(offsetof(UFortGlobals, TwitchViewerNameExpirationMinutes) == 0x0000E8, "Member 'UFortGlobals::TwitchViewerNameExpirationMinutes' has a wrong offset!");
static_assert(offsetof(UFortGlobals, MinTwitchHeartbeatInterval) == 0x0000EC, "Member 'UFortGlobals::MinTwitchHeartbeatInterval' has a wrong offset!");
static_assert(offsetof(UFortGlobals, TwitchAccountInformationRefreshInterval) == 0x0000F0, "Member 'UFortGlobals::TwitchAccountInformationRefreshInterval' has a wrong offset!");
static_assert(offsetof(UFortGlobals, bAllowLogout) == 0x0000F4, "Member 'UFortGlobals::bAllowLogout' has a wrong offset!");
static_assert(offsetof(UFortGlobals, bAllowQuit) == 0x0000F5, "Member 'UFortGlobals::bAllowQuit' has a wrong offset!");
static_assert(offsetof(UFortGlobals, bHasWorldMap) == 0x0000F6, "Member 'UFortGlobals::bHasWorldMap' has a wrong offset!");
static_assert(offsetof(UFortGlobals, PlayerUnregistrationFailsafeTimer) == 0x0000F8, "Member 'UFortGlobals::PlayerUnregistrationFailsafeTimer' has a wrong offset!");
static_assert(offsetof(UFortGlobals, bUploadAthenaStats) == 0x0000FC, "Member 'UFortGlobals::bUploadAthenaStats' has a wrong offset!");
static_assert(offsetof(UFortGlobals, bAthenaStatsFrontendEnabled) == 0x0000FD, "Member 'UFortGlobals::bAthenaStatsFrontendEnabled' has a wrong offset!");
static_assert(offsetof(UFortGlobals, bAthenaLeaderboardFrontEndEnabled) == 0x0000FE, "Member 'UFortGlobals::bAthenaLeaderboardFrontEndEnabled' has a wrong offset!");
static_assert(offsetof(UFortGlobals, TimeBetweenLeaderboardRequestsMinutes) == 0x000100, "Member 'UFortGlobals::TimeBetweenLeaderboardRequestsMinutes' has a wrong offset!");
static_assert(offsetof(UFortGlobals, MinSecondsBetweenUnimportantPresenceUpdates) == 0x000104, "Member 'UFortGlobals::MinSecondsBetweenUnimportantPresenceUpdates' has a wrong offset!");
static_assert(offsetof(UFortGlobals, AthenaReferencedObjects) == 0x000110, "Member 'UFortGlobals::AthenaReferencedObjects' has a wrong offset!");
static_assert(offsetof(UFortGlobals, NumOutstandingAthenaAsyncRequests) == 0x000120, "Member 'UFortGlobals::NumOutstandingAthenaAsyncRequests' has a wrong offset!");
static_assert(offsetof(UFortGlobals, TotalAthenaAsyncRequests) == 0x000124, "Member 'UFortGlobals::TotalAthenaAsyncRequests' has a wrong offset!");
static_assert(offsetof(UFortGlobals, SubGameAccess) == 0x0001A0, "Member 'UFortGlobals::SubGameAccess' has a wrong offset!");

// Class FortniteGame.ThreatCloud
// 0x01C8 (0x0550 - 0x0388)
class AThreatCloud final : public AActor
{
public:
	TArray<class UBoxComponent*>                  LightningSourceAreas;                              // 0x0388(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            MiniMapIconBrush;                                  // 0x0398(0x0090)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         MiniMapIconPercent;                                // 0x0428(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_42C[0x4];                                      // 0x042C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            MiniMapFarOffIconBrush;                            // 0x0430(0x0090)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FLinearColor                           ActiveTint;                                        // 0x04C0(0x0010)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           InActiveTint;                                      // 0x04D0(0x0010)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ActiveTransitionTime;                              // 0x04E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DeathTimerDuration;                                // 0x04E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CloudMiniMapTickInterval;                          // 0x04E8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4EC[0x14];                                     // 0x04EC(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MiniMapFarOffIconDegreesOfArc;                     // 0x0500(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_504[0xC];                                      // 0x0504(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBox                                   ThreatBoxVolume;                                   // 0x0510(0x001C)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         GroundLevelUnderCloud;                             // 0x052C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_530[0x8];                                      // 0x0530(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        GoalActorLocations;                                // 0x0538(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_548[0x8];                                      // 0x0548(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ManualLightningFlash();
	void OnBeginDeath();
	void OnCloudActivated();
	void OnCloudDeactivated(EFortThreatDeactivationType DeactivationType);
	void OnCloudHiddenChange(bool bCloudsAreHidden);
	void OnCloudStart();
	void OnLightningStrike(const struct FVector& StartLocation, const struct FVector& EndLocation, class ABuildingRift* Rift, bool bLightningStruckRift);
	void OnThreatVolumeChanged();

	struct FBox GetThreatVolume() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThreatCloud">();
	}
	static class AThreatCloud* GetDefaultObj()
	{
		return GetDefaultObjImpl<AThreatCloud>();
	}
};
static_assert(alignof(AThreatCloud) == 0x000008, "Wrong alignment on AThreatCloud");
static_assert(sizeof(AThreatCloud) == 0x000550, "Wrong size on AThreatCloud");
static_assert(offsetof(AThreatCloud, LightningSourceAreas) == 0x000388, "Member 'AThreatCloud::LightningSourceAreas' has a wrong offset!");
static_assert(offsetof(AThreatCloud, MiniMapIconBrush) == 0x000398, "Member 'AThreatCloud::MiniMapIconBrush' has a wrong offset!");
static_assert(offsetof(AThreatCloud, MiniMapIconPercent) == 0x000428, "Member 'AThreatCloud::MiniMapIconPercent' has a wrong offset!");
static_assert(offsetof(AThreatCloud, MiniMapFarOffIconBrush) == 0x000430, "Member 'AThreatCloud::MiniMapFarOffIconBrush' has a wrong offset!");
static_assert(offsetof(AThreatCloud, ActiveTint) == 0x0004C0, "Member 'AThreatCloud::ActiveTint' has a wrong offset!");
static_assert(offsetof(AThreatCloud, InActiveTint) == 0x0004D0, "Member 'AThreatCloud::InActiveTint' has a wrong offset!");
static_assert(offsetof(AThreatCloud, ActiveTransitionTime) == 0x0004E0, "Member 'AThreatCloud::ActiveTransitionTime' has a wrong offset!");
static_assert(offsetof(AThreatCloud, DeathTimerDuration) == 0x0004E4, "Member 'AThreatCloud::DeathTimerDuration' has a wrong offset!");
static_assert(offsetof(AThreatCloud, CloudMiniMapTickInterval) == 0x0004E8, "Member 'AThreatCloud::CloudMiniMapTickInterval' has a wrong offset!");
static_assert(offsetof(AThreatCloud, MiniMapFarOffIconDegreesOfArc) == 0x000500, "Member 'AThreatCloud::MiniMapFarOffIconDegreesOfArc' has a wrong offset!");
static_assert(offsetof(AThreatCloud, ThreatBoxVolume) == 0x000510, "Member 'AThreatCloud::ThreatBoxVolume' has a wrong offset!");
static_assert(offsetof(AThreatCloud, GroundLevelUnderCloud) == 0x00052C, "Member 'AThreatCloud::GroundLevelUnderCloud' has a wrong offset!");
static_assert(offsetof(AThreatCloud, GoalActorLocations) == 0x000538, "Member 'AThreatCloud::GoalActorLocations' has a wrong offset!");

// Class FortniteGame.FortHomebaseBannerColorItemDefinition
// 0x0000 (0x0270 - 0x0270)
class UFortHomebaseBannerColorItemDefinition final : public UFortAccountItemDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortHomebaseBannerColorItemDefinition">();
	}
	static class UFortHomebaseBannerColorItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortHomebaseBannerColorItemDefinition>();
	}
};
static_assert(alignof(UFortHomebaseBannerColorItemDefinition) == 0x000010, "Wrong alignment on UFortHomebaseBannerColorItemDefinition");
static_assert(sizeof(UFortHomebaseBannerColorItemDefinition) == 0x000270, "Wrong size on UFortHomebaseBannerColorItemDefinition");

// Class FortniteGame.FortThreatVisualsManager
// 0x0200 (0x0588 - 0x0388)
class AFortThreatVisualsManager final : public AActor
{
public:
	uint8                                         Pad_388[0x8];                                      // 0x0388(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AThreatCloud>               CloudBlueprint;                                    // 0x0390(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CloudRadius;                                       // 0x0398(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ThreatBoxVolumeTopPadding;                         // 0x039C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ThreatBoxVolumeBottomPadding;                      // 0x03A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseLocalPlayersOnlyForCloudMinimumHeight;         // 0x03A4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHideClouds;                                       // 0x03A5(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A6[0x2];                                      // 0x03A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CloudMinimumHeightAbovePlayers;                    // 0x03A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CloudMinimumHeightAboveGround;                     // 0x03AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CloudMinimumAltitude;                              // 0x03B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CloudMaxVerticalDelta;                             // 0x03B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CloudMinSpeed;                                     // 0x03B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CloudMaxSpeed;                                     // 0x03BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StormWindCloudRadius;                              // 0x03C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StormWindGoalRadius;                               // 0x03C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StormWindFalloffRadius;                            // 0x03C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StormWindInactiveMagnitude;                        // 0x03CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StormWindActiveMagnitude;                          // 0x03D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StormWindDesiredDeltaBlendTime;                    // 0x03D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StormWindDirectionAdditionalAngle;                 // 0x03D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3DC[0x4];                                      // 0x03DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FThreatLocationArray                   ThreatLocations;                                   // 0x03E0(0x00C0)(Net, Transient, RepNotify, NativeAccessSpecifierPrivate)
	struct FStormWindArray                        StormWindArray;                                    // 0x04A0(0x00C0)(Net, Transient, RepNotify, NativeAccessSpecifierPrivate)
	TArray<struct FVector>                        GoalActorLocations;                                // 0x0560(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	int32                                         DistanceBetweenPixels;                             // 0x0570(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_574[0x14];                                     // 0x0574(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginThreatVisualsPrecursor(class AActor* SourceActor, const struct FVector& ThreatLocation);
	void OnBeginThreatVisualsPrecursor(class AActor* SourceActor, const struct FVector& EndLocation);
	void OnRep_GoalActorLocations();
	void OnRep_HideClouds();
	void OnRep_StormWinds();
	void OnRep_ThreatLocations();
	void OnThreatCloudsChanged(const TArray<struct FThreatLocationInfo>& ThreatLocationInfo);
	void OnWorldReady();
	void ResetMinimumCloudAltitude();
	void SetCloudsAreHidden(bool bHide);
	void SetMinimumCloudAltitude(float NewMinimumAltitude);

	bool GetCloudsAreHidden() const;
	class AThreatCloud* GetThreatCloud(const struct FThreatLocationInfo& ThreatLocInfo) const;
	const TArray<struct FThreatLocationInfo> GetThreatClouds() const;
	bool StormsExist() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortThreatVisualsManager">();
	}
	static class AFortThreatVisualsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortThreatVisualsManager>();
	}
};
static_assert(alignof(AFortThreatVisualsManager) == 0x000008, "Wrong alignment on AFortThreatVisualsManager");
static_assert(sizeof(AFortThreatVisualsManager) == 0x000588, "Wrong size on AFortThreatVisualsManager");
static_assert(offsetof(AFortThreatVisualsManager, CloudBlueprint) == 0x000390, "Member 'AFortThreatVisualsManager::CloudBlueprint' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, CloudRadius) == 0x000398, "Member 'AFortThreatVisualsManager::CloudRadius' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, ThreatBoxVolumeTopPadding) == 0x00039C, "Member 'AFortThreatVisualsManager::ThreatBoxVolumeTopPadding' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, ThreatBoxVolumeBottomPadding) == 0x0003A0, "Member 'AFortThreatVisualsManager::ThreatBoxVolumeBottomPadding' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, bUseLocalPlayersOnlyForCloudMinimumHeight) == 0x0003A4, "Member 'AFortThreatVisualsManager::bUseLocalPlayersOnlyForCloudMinimumHeight' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, bHideClouds) == 0x0003A5, "Member 'AFortThreatVisualsManager::bHideClouds' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, CloudMinimumHeightAbovePlayers) == 0x0003A8, "Member 'AFortThreatVisualsManager::CloudMinimumHeightAbovePlayers' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, CloudMinimumHeightAboveGround) == 0x0003AC, "Member 'AFortThreatVisualsManager::CloudMinimumHeightAboveGround' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, CloudMinimumAltitude) == 0x0003B0, "Member 'AFortThreatVisualsManager::CloudMinimumAltitude' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, CloudMaxVerticalDelta) == 0x0003B4, "Member 'AFortThreatVisualsManager::CloudMaxVerticalDelta' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, CloudMinSpeed) == 0x0003B8, "Member 'AFortThreatVisualsManager::CloudMinSpeed' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, CloudMaxSpeed) == 0x0003BC, "Member 'AFortThreatVisualsManager::CloudMaxSpeed' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, StormWindCloudRadius) == 0x0003C0, "Member 'AFortThreatVisualsManager::StormWindCloudRadius' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, StormWindGoalRadius) == 0x0003C4, "Member 'AFortThreatVisualsManager::StormWindGoalRadius' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, StormWindFalloffRadius) == 0x0003C8, "Member 'AFortThreatVisualsManager::StormWindFalloffRadius' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, StormWindInactiveMagnitude) == 0x0003CC, "Member 'AFortThreatVisualsManager::StormWindInactiveMagnitude' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, StormWindActiveMagnitude) == 0x0003D0, "Member 'AFortThreatVisualsManager::StormWindActiveMagnitude' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, StormWindDesiredDeltaBlendTime) == 0x0003D4, "Member 'AFortThreatVisualsManager::StormWindDesiredDeltaBlendTime' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, StormWindDirectionAdditionalAngle) == 0x0003D8, "Member 'AFortThreatVisualsManager::StormWindDirectionAdditionalAngle' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, ThreatLocations) == 0x0003E0, "Member 'AFortThreatVisualsManager::ThreatLocations' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, StormWindArray) == 0x0004A0, "Member 'AFortThreatVisualsManager::StormWindArray' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, GoalActorLocations) == 0x000560, "Member 'AFortThreatVisualsManager::GoalActorLocations' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, DistanceBetweenPixels) == 0x000570, "Member 'AFortThreatVisualsManager::DistanceBetweenPixels' has a wrong offset!");

// Class FortniteGame.FortQueryTest_IsCloseToHotspotSlot
// 0x0040 (0x0200 - 0x01C0)
class UFortQueryTest_IsCloseToHotspotSlot final : public UEnvQueryTest
{
public:
	TSubclassOf<class AFortAIHotSpot>             HotspotClass;                                      // 0x01C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              Radius;                                            // 0x01C8(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIgnoreItemsWithSlotData;                          // 0x01F8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F9[0x7];                                      // 0x01F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_IsCloseToHotspotSlot">();
	}
	static class UFortQueryTest_IsCloseToHotspotSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_IsCloseToHotspotSlot>();
	}
};
static_assert(alignof(UFortQueryTest_IsCloseToHotspotSlot) == 0x000008, "Wrong alignment on UFortQueryTest_IsCloseToHotspotSlot");
static_assert(sizeof(UFortQueryTest_IsCloseToHotspotSlot) == 0x000200, "Wrong size on UFortQueryTest_IsCloseToHotspotSlot");
static_assert(offsetof(UFortQueryTest_IsCloseToHotspotSlot, HotspotClass) == 0x0001C0, "Member 'UFortQueryTest_IsCloseToHotspotSlot::HotspotClass' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_IsCloseToHotspotSlot, Radius) == 0x0001C8, "Member 'UFortQueryTest_IsCloseToHotspotSlot::Radius' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_IsCloseToHotspotSlot, bIgnoreItemsWithSlotData) == 0x0001F8, "Member 'UFortQueryTest_IsCloseToHotspotSlot::bIgnoreItemsWithSlotData' has a wrong offset!");

// Class FortniteGame.FortTimeOfDayManager
// 0x0868 (0x0BF0 - 0x0388)
class AFortTimeOfDayManager : public AInfo
{
public:
	uint8                                         Pad_388[0x8];                                      // 0x0388(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeOfDay;                                         // 0x0390(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeOfDayReplicated;                               // 0x0394(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortDayPhase                                 CurrentDayNightPhase;                              // 0x0398(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortDayPhase                                 TransitionFromPhase;                               // 0x0399(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortDayPhase                                 TransitionToPhase;                                 // 0x039A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39B[0x1];                                      // 0x039B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TransitionBlendPercent;                            // 0x039C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DefaultTimeOfDaySpeed;                             // 0x03A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartTimeOfDayInGame;                              // 0x03A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeOfDaySpeed;                                    // 0x03A8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxTimeOfDayAccumulationFactor;                    // 0x03AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeOfDayAccumulator;                              // 0x03B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B4[0x4];                                      // 0x03B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     BasePostProcessMaterial;                           // 0x03B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               PostProcessMaterialMID;                            // 0x03C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint32                                        bHasClonedPPVs;                                    // 0x03C8(0x0004)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bSkipNight : 1;                                    // 0x03CC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bTimeStarted : 1;                                  // 0x03CC(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bHeightFogEnabled : 1;                             // 0x03CC(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bBaseHeightFogOnAltitude : 1;                      // 0x03CC(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_3CD[0x3];                                      // 0x03CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HeightFogZOffset;                                  // 0x03D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D4[0x4];                                      // 0x03D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCameraAltitudeAdjustments>     AltitudeAdjustments;                               // 0x03D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               SunriseDirectionalLightRotation;                   // 0x03E8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               SunsetDirectionalLightRotation;                    // 0x03F4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               DirectionalLightRotation;                          // 0x0400(0x000C)(BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               SunriseSunObjectRotation;                          // 0x040C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               SunsetSunObjectRotation;                           // 0x0418(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         SunObjectDivergencePower;                          // 0x0424(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DistanceToSunOrMoon;                               // 0x0428(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_42C[0x4];                                      // 0x042C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDirectionalLightComponent*             DirectionalLightComponent;                         // 0x0430(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UExponentialHeightFogComponent*         ActiveHeightFogComponent;                          // 0x0438(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortDayPhaseChangeParams*              DayPhaseChangeEventParams;                         // 0x0440(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDayPhaseInfo                          LightAndFogPhaseSettings[0x4];                     // 0x0448(0x0170)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UPostProcessComponent*                  MorningPostProcessComponent;                       // 0x0A08(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPostProcessComponent*                  DayPostProcessComponent;                           // 0x0A10(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPostProcessComponent*                  EveningPostProcessComponent;                       // 0x0A18(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPostProcessComponent*                  NightPostProcessComponent;                         // 0x0A20(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPostProcessComponent*                  DayPhasePostProcessComponent[0x4];                 // 0x0A28(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FExponentialHeightFogValues            CurrentTimeOfDayFogValues;                         // 0x0A48(0x0048)(BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FLinearColor                           CurrentTimeOfDayDirectionalLightColor;             // 0x0A90(0x0010)(BlueprintVisible, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialParameterCollection*           MaterialParameterCollection;                       // 0x0AA0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                RainParticleSystemRelativeOffset;                  // 0x0AA8(0x000C)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AB4[0x4];                                      // 0x0AB4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            SunMesh;                                           // 0x0AB8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            MoonMesh;                                          // 0x0AC0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMaterialInterface*>             SunMaterialOverrides;                              // 0x0AC8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class UMaterialInterface*>             MoonMaterialOverrides;                             // 0x0AD8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         SunScale;                                          // 0x0AE8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoonScale;                                         // 0x0AEC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     StarMapMaterial;                                   // 0x0AF0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstance*                      StormMaterialInst;                                 // 0x0AF8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             CloudMaskTexture;                                  // 0x0B00(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FExponentialHeightFogValues            StormFogValues;                                    // 0x0B08(0x0048)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FLinearColor                           LightningColor;                                    // 0x0B50(0x0010)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           StormLightColor;                                   // 0x0B60(0x0010)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnDayPhaseChangeEvent;                             // 0x0B70(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class USkyLightComponent*                     SkyLightComp;                                      // 0x0B80(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystemComponent*               RainParticleSystemComp;                            // 0x0B88(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   SunOrMoonMeshComp;                                 // 0x0B90(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   SkyDomeMeshComp;                                   // 0x0B98(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   StarMapMeshComp;                                   // 0x0BA0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               ActiveSkyBoxMat;                                   // 0x0BA8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               StarMapMID;                                        // 0x0BB0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StormStrength;                                     // 0x0BB8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BBC[0x34];                                     // 0x0BBC(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void BreakExponentialHeightFogValues(const struct FExponentialHeightFogValues& HeightFogValues, float* FogDensity, float* FogHeightFalloff, float* FogMaxOpacity, float* StartDistance, float* DirectionalInscatteringExponent, float* DirectionalInscatteringStartDistance, struct FLinearColor* DirectionalInscatteringColor, struct FLinearColor* FogInscatteringColor, float* VolumetricFogScatteringDistribution, float* VolumetricFogScatteringScale, float* VolumetricFogAbsorptionScale, float* VolumetricFogDistance);
	static class AFortTimeOfDayManager* GetTimeOfDayManagerFromContext(class UObject* WorldContextObject);
	static struct FExponentialHeightFogValues MakeExponentialHeightFogValues(float FogDensity, float FogHeightFalloff, float FogMaxOpacity, float StartDistance, float DirectionalInscatteringExponent, float DirectionalInscatteringStartDistance, const struct FLinearColor& DirectionalInscatteringColor, const struct FLinearColor& FogInscatteringColor, float VolumetricFogScatteringDistribution, float VolumetricFogScatteringScale, float VolumetricFogAbsorptionScale, float VolumetricFogDistance);

	void FFToTimeOfDay(float FastForwardTime, float FastForwardSpeed);
	void OnDayPhaseChange();
	void OnRep_HeightFogEnabled();
	void OnRep_TimeOfDay();
	void OnRep_TimeOfDayInit();
	void OnStormEnd();
	void OnStormStart();
	void OnUpdateDirectionalLightForTimeOfDay(const struct FLinearColor& AboutToApplyDirectionalLightColor);
	void SetDayPhase(const class FString& DayPhase);
	void SetDirectionalLightColorMultiplier(float NewDirectionalLightColorMultiplier);
	void SetFogDirectionalInscatteringMultiplier(float NewFogDirectionalInscatteringMultiplier);
	void SetLightningColorAlpha(float NewLightningColorAlpha);
	void SetStormStrength(float NewStormStrength);
	void SetTimeOfDay(const class FString& NewTimeOfDay);
	void SetTimeOfDayAbsoluteSpeed(float NewTimeOfDaySpeed);
	void SetTimeOfDayFloat(float TimeOfDayInHours);
	void SetTimeOfDayInHours(float TimeOfDayInHours);
	void SetTimeOfDayManagerVisibility(bool bVisible);
	void SetTimeOfDaySpeed(float TimeOfDaySpeedFactor);
	void SetTimeOfDaySpeedFloat(float InTimeOfDaySpeed);
	void ToggleDebugForceStormEffects();
	void ToggleSkipNight();

	EFortDayPhase GetPreviousDayPhase() const;
	float GetStormStrength() const;
	TArray<struct FThreatLocationInfo> GetThreatClouds() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTimeOfDayManager">();
	}
	static class AFortTimeOfDayManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortTimeOfDayManager>();
	}
};
static_assert(alignof(AFortTimeOfDayManager) == 0x000008, "Wrong alignment on AFortTimeOfDayManager");
static_assert(sizeof(AFortTimeOfDayManager) == 0x000BF0, "Wrong size on AFortTimeOfDayManager");
static_assert(offsetof(AFortTimeOfDayManager, TimeOfDay) == 0x000390, "Member 'AFortTimeOfDayManager::TimeOfDay' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, TimeOfDayReplicated) == 0x000394, "Member 'AFortTimeOfDayManager::TimeOfDayReplicated' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, CurrentDayNightPhase) == 0x000398, "Member 'AFortTimeOfDayManager::CurrentDayNightPhase' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, TransitionFromPhase) == 0x000399, "Member 'AFortTimeOfDayManager::TransitionFromPhase' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, TransitionToPhase) == 0x00039A, "Member 'AFortTimeOfDayManager::TransitionToPhase' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, TransitionBlendPercent) == 0x00039C, "Member 'AFortTimeOfDayManager::TransitionBlendPercent' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, DefaultTimeOfDaySpeed) == 0x0003A0, "Member 'AFortTimeOfDayManager::DefaultTimeOfDaySpeed' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, StartTimeOfDayInGame) == 0x0003A4, "Member 'AFortTimeOfDayManager::StartTimeOfDayInGame' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, TimeOfDaySpeed) == 0x0003A8, "Member 'AFortTimeOfDayManager::TimeOfDaySpeed' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, MaxTimeOfDayAccumulationFactor) == 0x0003AC, "Member 'AFortTimeOfDayManager::MaxTimeOfDayAccumulationFactor' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, TimeOfDayAccumulator) == 0x0003B0, "Member 'AFortTimeOfDayManager::TimeOfDayAccumulator' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, BasePostProcessMaterial) == 0x0003B8, "Member 'AFortTimeOfDayManager::BasePostProcessMaterial' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, PostProcessMaterialMID) == 0x0003C0, "Member 'AFortTimeOfDayManager::PostProcessMaterialMID' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, bHasClonedPPVs) == 0x0003C8, "Member 'AFortTimeOfDayManager::bHasClonedPPVs' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, HeightFogZOffset) == 0x0003D0, "Member 'AFortTimeOfDayManager::HeightFogZOffset' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, AltitudeAdjustments) == 0x0003D8, "Member 'AFortTimeOfDayManager::AltitudeAdjustments' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, SunriseDirectionalLightRotation) == 0x0003E8, "Member 'AFortTimeOfDayManager::SunriseDirectionalLightRotation' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, SunsetDirectionalLightRotation) == 0x0003F4, "Member 'AFortTimeOfDayManager::SunsetDirectionalLightRotation' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, DirectionalLightRotation) == 0x000400, "Member 'AFortTimeOfDayManager::DirectionalLightRotation' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, SunriseSunObjectRotation) == 0x00040C, "Member 'AFortTimeOfDayManager::SunriseSunObjectRotation' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, SunsetSunObjectRotation) == 0x000418, "Member 'AFortTimeOfDayManager::SunsetSunObjectRotation' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, SunObjectDivergencePower) == 0x000424, "Member 'AFortTimeOfDayManager::SunObjectDivergencePower' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, DistanceToSunOrMoon) == 0x000428, "Member 'AFortTimeOfDayManager::DistanceToSunOrMoon' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, DirectionalLightComponent) == 0x000430, "Member 'AFortTimeOfDayManager::DirectionalLightComponent' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, ActiveHeightFogComponent) == 0x000438, "Member 'AFortTimeOfDayManager::ActiveHeightFogComponent' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, DayPhaseChangeEventParams) == 0x000440, "Member 'AFortTimeOfDayManager::DayPhaseChangeEventParams' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, LightAndFogPhaseSettings) == 0x000448, "Member 'AFortTimeOfDayManager::LightAndFogPhaseSettings' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, MorningPostProcessComponent) == 0x000A08, "Member 'AFortTimeOfDayManager::MorningPostProcessComponent' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, DayPostProcessComponent) == 0x000A10, "Member 'AFortTimeOfDayManager::DayPostProcessComponent' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, EveningPostProcessComponent) == 0x000A18, "Member 'AFortTimeOfDayManager::EveningPostProcessComponent' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, NightPostProcessComponent) == 0x000A20, "Member 'AFortTimeOfDayManager::NightPostProcessComponent' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, DayPhasePostProcessComponent) == 0x000A28, "Member 'AFortTimeOfDayManager::DayPhasePostProcessComponent' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, CurrentTimeOfDayFogValues) == 0x000A48, "Member 'AFortTimeOfDayManager::CurrentTimeOfDayFogValues' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, CurrentTimeOfDayDirectionalLightColor) == 0x000A90, "Member 'AFortTimeOfDayManager::CurrentTimeOfDayDirectionalLightColor' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, MaterialParameterCollection) == 0x000AA0, "Member 'AFortTimeOfDayManager::MaterialParameterCollection' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, RainParticleSystemRelativeOffset) == 0x000AA8, "Member 'AFortTimeOfDayManager::RainParticleSystemRelativeOffset' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, SunMesh) == 0x000AB8, "Member 'AFortTimeOfDayManager::SunMesh' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, MoonMesh) == 0x000AC0, "Member 'AFortTimeOfDayManager::MoonMesh' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, SunMaterialOverrides) == 0x000AC8, "Member 'AFortTimeOfDayManager::SunMaterialOverrides' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, MoonMaterialOverrides) == 0x000AD8, "Member 'AFortTimeOfDayManager::MoonMaterialOverrides' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, SunScale) == 0x000AE8, "Member 'AFortTimeOfDayManager::SunScale' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, MoonScale) == 0x000AEC, "Member 'AFortTimeOfDayManager::MoonScale' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, StarMapMaterial) == 0x000AF0, "Member 'AFortTimeOfDayManager::StarMapMaterial' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, StormMaterialInst) == 0x000AF8, "Member 'AFortTimeOfDayManager::StormMaterialInst' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, CloudMaskTexture) == 0x000B00, "Member 'AFortTimeOfDayManager::CloudMaskTexture' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, StormFogValues) == 0x000B08, "Member 'AFortTimeOfDayManager::StormFogValues' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, LightningColor) == 0x000B50, "Member 'AFortTimeOfDayManager::LightningColor' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, StormLightColor) == 0x000B60, "Member 'AFortTimeOfDayManager::StormLightColor' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, OnDayPhaseChangeEvent) == 0x000B70, "Member 'AFortTimeOfDayManager::OnDayPhaseChangeEvent' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, SkyLightComp) == 0x000B80, "Member 'AFortTimeOfDayManager::SkyLightComp' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, RainParticleSystemComp) == 0x000B88, "Member 'AFortTimeOfDayManager::RainParticleSystemComp' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, SunOrMoonMeshComp) == 0x000B90, "Member 'AFortTimeOfDayManager::SunOrMoonMeshComp' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, SkyDomeMeshComp) == 0x000B98, "Member 'AFortTimeOfDayManager::SkyDomeMeshComp' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, StarMapMeshComp) == 0x000BA0, "Member 'AFortTimeOfDayManager::StarMapMeshComp' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, ActiveSkyBoxMat) == 0x000BA8, "Member 'AFortTimeOfDayManager::ActiveSkyBoxMat' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, StarMapMID) == 0x000BB0, "Member 'AFortTimeOfDayManager::StarMapMID' has a wrong offset!");
static_assert(offsetof(AFortTimeOfDayManager, StormStrength) == 0x000BB8, "Member 'AFortTimeOfDayManager::StormStrength' has a wrong offset!");

// Class FortniteGame.FortWorldSettings
// 0x0208 (0x0738 - 0x0530)
class AFortWorldSettings final : public AWorldSettings
{
public:
	uint8                                         Pad_530[0x50];                                     // 0x0530(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 WorldCells;                                        // 0x0580(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                WorldCellsOrigin;                                  // 0x0590(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WorldCellsFlags;                                   // 0x059C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bGenerateTestLevelSaves : 1;                       // 0x05A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisableCullDistance : 1;                          // 0x05A0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5A1[0x7];                                      // 0x05A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             TeamOnePvPMiniMapImage;                            // 0x05A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             TeamTwoPvPMiniMapImage;                            // 0x05B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PvPMapWorldCenter;                                 // 0x05B8(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PvPMapWorldWidth;                                  // 0x05C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PvPMapWorldHeight;                                 // 0x05C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bPvPUseWidgetRotation : 1;                         // 0x05C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5C9[0x3];                                      // 0x05C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MapZOffset;                                        // 0x05CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               MapRotation;                                       // 0x05D0(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5DC[0x4];                                      // 0x05DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             MapInitialMask;                                    // 0x05E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverrideMainMapSettings : 1;                      // 0x05E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bValidateNavGraphConnectivity : 1;                 // 0x05E8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLimitNavGraphSkyCells : 1;                        // 0x05E8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseProceduralFoliage : 1;                         // 0x05E8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseConditionalBuildingFoundations : 1;            // 0x05E8(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5E9[0x7];                                      // 0x05E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            AthenaMapImage;                                    // 0x05F0(0x0090)(Edit, NativeAccessSpecifierPublic)
	float                                         MapWorldScale;                                     // 0x0680(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MiniMapZoom;                                       // 0x0684(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FIntPoint>                      NavGraphSkyCells;                                  // 0x0688(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UCurveTable*                            SearchSpeedOverride;                               // 0x0698(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveTable*                            ResourceRateOverride;                              // 0x06A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bShowTimeOfDayManager : 1;                         // 0x06A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_6A9[0x7];                                      // 0x06A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   WorldTimeOfDayManager;                             // 0x06B0(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   DefaultWorldTimeOfDayManager;                      // 0x06D0(0x0020)(Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   ZoneThemeTimeOfDayManager;                         // 0x06F0(0x0020)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   MissionTimeOfDayManager;                           // 0x0710(0x0020)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortTimeOfDayManager*                  TimeOfDayManager;                                  // 0x0730(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, IsPlainOldData, NoDestructor, AdvancedDisplay, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortWorldSettings">();
	}
	static class AFortWorldSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortWorldSettings>();
	}
};
static_assert(alignof(AFortWorldSettings) == 0x000008, "Wrong alignment on AFortWorldSettings");
static_assert(sizeof(AFortWorldSettings) == 0x000738, "Wrong size on AFortWorldSettings");
static_assert(offsetof(AFortWorldSettings, WorldCells) == 0x000580, "Member 'AFortWorldSettings::WorldCells' has a wrong offset!");
static_assert(offsetof(AFortWorldSettings, WorldCellsOrigin) == 0x000590, "Member 'AFortWorldSettings::WorldCellsOrigin' has a wrong offset!");
static_assert(offsetof(AFortWorldSettings, WorldCellsFlags) == 0x00059C, "Member 'AFortWorldSettings::WorldCellsFlags' has a wrong offset!");
static_assert(offsetof(AFortWorldSettings, TeamOnePvPMiniMapImage) == 0x0005A8, "Member 'AFortWorldSettings::TeamOnePvPMiniMapImage' has a wrong offset!");
static_assert(offsetof(AFortWorldSettings, TeamTwoPvPMiniMapImage) == 0x0005B0, "Member 'AFortWorldSettings::TeamTwoPvPMiniMapImage' has a wrong offset!");
static_assert(offsetof(AFortWorldSettings, PvPMapWorldCenter) == 0x0005B8, "Member 'AFortWorldSettings::PvPMapWorldCenter' has a wrong offset!");
static_assert(offsetof(AFortWorldSettings, PvPMapWorldWidth) == 0x0005C0, "Member 'AFortWorldSettings::PvPMapWorldWidth' has a wrong offset!");
static_assert(offsetof(AFortWorldSettings, PvPMapWorldHeight) == 0x0005C4, "Member 'AFortWorldSettings::PvPMapWorldHeight' has a wrong offset!");
static_assert(offsetof(AFortWorldSettings, MapZOffset) == 0x0005CC, "Member 'AFortWorldSettings::MapZOffset' has a wrong offset!");
static_assert(offsetof(AFortWorldSettings, MapRotation) == 0x0005D0, "Member 'AFortWorldSettings::MapRotation' has a wrong offset!");
static_assert(offsetof(AFortWorldSettings, MapInitialMask) == 0x0005E0, "Member 'AFortWorldSettings::MapInitialMask' has a wrong offset!");
static_assert(offsetof(AFortWorldSettings, AthenaMapImage) == 0x0005F0, "Member 'AFortWorldSettings::AthenaMapImage' has a wrong offset!");
static_assert(offsetof(AFortWorldSettings, MapWorldScale) == 0x000680, "Member 'AFortWorldSettings::MapWorldScale' has a wrong offset!");
static_assert(offsetof(AFortWorldSettings, MiniMapZoom) == 0x000684, "Member 'AFortWorldSettings::MiniMapZoom' has a wrong offset!");
static_assert(offsetof(AFortWorldSettings, NavGraphSkyCells) == 0x000688, "Member 'AFortWorldSettings::NavGraphSkyCells' has a wrong offset!");
static_assert(offsetof(AFortWorldSettings, SearchSpeedOverride) == 0x000698, "Member 'AFortWorldSettings::SearchSpeedOverride' has a wrong offset!");
static_assert(offsetof(AFortWorldSettings, ResourceRateOverride) == 0x0006A0, "Member 'AFortWorldSettings::ResourceRateOverride' has a wrong offset!");
static_assert(offsetof(AFortWorldSettings, WorldTimeOfDayManager) == 0x0006B0, "Member 'AFortWorldSettings::WorldTimeOfDayManager' has a wrong offset!");
static_assert(offsetof(AFortWorldSettings, DefaultWorldTimeOfDayManager) == 0x0006D0, "Member 'AFortWorldSettings::DefaultWorldTimeOfDayManager' has a wrong offset!");
static_assert(offsetof(AFortWorldSettings, ZoneThemeTimeOfDayManager) == 0x0006F0, "Member 'AFortWorldSettings::ZoneThemeTimeOfDayManager' has a wrong offset!");
static_assert(offsetof(AFortWorldSettings, MissionTimeOfDayManager) == 0x000710, "Member 'AFortWorldSettings::MissionTimeOfDayManager' has a wrong offset!");
static_assert(offsetof(AFortWorldSettings, TimeOfDayManager) == 0x000730, "Member 'AFortWorldSettings::TimeOfDayManager' has a wrong offset!");

// Class FortniteGame.BuildingFoundation
// 0x00C0 (0x1080 - 0x0FC0)
#pragma pack(push, 0x1)
class alignas(0x10) ABuildingFoundation : public ABuildingSMActor
{
public:
	TArray<class UBuildingGroup*>                 BuildingGroups;                                    // 0x0FC0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UWorld>>          AdditionalWorlds;                                  // 0x0FD0(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FVector                                BuildingDeconstructorOrigin;                       // 0x0FE0(0x000C)(Edit, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                BuildingDeconstructorExtent;                       // 0x0FEC(0x000C)(Edit, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bConditionalFoundation : 1;                        // 0x0FF8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bOverrideNavigationGraphCells : 1;                 // 0x0FF8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bHasExcludedZone : 1;                              // 0x0FF8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_FF9[0x3];                                      // 0x0FF9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NavExclusionMinX;                                  // 0x0FFC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NavExclusionMaxX;                                  // 0x1000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NavExclusionMinY;                                  // 0x1004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NavExclusionMaxY;                                  // 0x1008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_100C[0x4];                                     // 0x100C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  BuildingGroupTagsToPickFrom;                       // 0x1010(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EBuildingFoundationType                       FoundationType;                                    // 0x1030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1031[0x7];                                     // 0x1031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LevelToStream;                                     // 0x1038(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBox                                   StreamingBoundingBox;                              // 0x1040(0x001C)(IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_105C[0x1C];                                    // 0x105C(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_LevelToStream();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingFoundation">();
	}
	static class ABuildingFoundation* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingFoundation>();
	}
};
#pragma pack(pop)
static_assert(alignof(ABuildingFoundation) == 0x000010, "Wrong alignment on ABuildingFoundation");
static_assert(sizeof(ABuildingFoundation) == 0x001080, "Wrong size on ABuildingFoundation");
static_assert(offsetof(ABuildingFoundation, BuildingGroups) == 0x000FC0, "Member 'ABuildingFoundation::BuildingGroups' has a wrong offset!");
static_assert(offsetof(ABuildingFoundation, AdditionalWorlds) == 0x000FD0, "Member 'ABuildingFoundation::AdditionalWorlds' has a wrong offset!");
static_assert(offsetof(ABuildingFoundation, BuildingDeconstructorOrigin) == 0x000FE0, "Member 'ABuildingFoundation::BuildingDeconstructorOrigin' has a wrong offset!");
static_assert(offsetof(ABuildingFoundation, BuildingDeconstructorExtent) == 0x000FEC, "Member 'ABuildingFoundation::BuildingDeconstructorExtent' has a wrong offset!");
static_assert(offsetof(ABuildingFoundation, NavExclusionMinX) == 0x000FFC, "Member 'ABuildingFoundation::NavExclusionMinX' has a wrong offset!");
static_assert(offsetof(ABuildingFoundation, NavExclusionMaxX) == 0x001000, "Member 'ABuildingFoundation::NavExclusionMaxX' has a wrong offset!");
static_assert(offsetof(ABuildingFoundation, NavExclusionMinY) == 0x001004, "Member 'ABuildingFoundation::NavExclusionMinY' has a wrong offset!");
static_assert(offsetof(ABuildingFoundation, NavExclusionMaxY) == 0x001008, "Member 'ABuildingFoundation::NavExclusionMaxY' has a wrong offset!");
static_assert(offsetof(ABuildingFoundation, BuildingGroupTagsToPickFrom) == 0x001010, "Member 'ABuildingFoundation::BuildingGroupTagsToPickFrom' has a wrong offset!");
static_assert(offsetof(ABuildingFoundation, FoundationType) == 0x001030, "Member 'ABuildingFoundation::FoundationType' has a wrong offset!");
static_assert(offsetof(ABuildingFoundation, LevelToStream) == 0x001038, "Member 'ABuildingFoundation::LevelToStream' has a wrong offset!");
static_assert(offsetof(ABuildingFoundation, StreamingBoundingBox) == 0x001040, "Member 'ABuildingFoundation::StreamingBoundingBox' has a wrong offset!");

// Class FortniteGame.BuildingFoundation3x3
// 0x0000 (0x1080 - 0x1080)
class ABuildingFoundation3x3 final : public ABuildingFoundation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingFoundation3x3">();
	}
	static class ABuildingFoundation3x3* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingFoundation3x3>();
	}
};
static_assert(alignof(ABuildingFoundation3x3) == 0x000010, "Wrong alignment on ABuildingFoundation3x3");
static_assert(sizeof(ABuildingFoundation3x3) == 0x001080, "Wrong size on ABuildingFoundation3x3");

// Class FortniteGame.BuildingFoundation5x10
// 0x0000 (0x1080 - 0x1080)
class ABuildingFoundation5x10 final : public ABuildingFoundation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingFoundation5x10">();
	}
	static class ABuildingFoundation5x10* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingFoundation5x10>();
	}
};
static_assert(alignof(ABuildingFoundation5x10) == 0x000010, "Wrong alignment on ABuildingFoundation5x10");
static_assert(sizeof(ABuildingFoundation5x10) == 0x001080, "Wrong size on ABuildingFoundation5x10");

// Class FortniteGame.FortEmoteItemDefinition
// 0x0040 (0x0460 - 0x0420)
class UFortEmoteItemDefinition final : public UFortWorldItemDefinition
{
public:
	class FText                                   CommandName;                                       // 0x0420(0x0018)(Edit, AssetRegistrySearchable, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   GameplayAbility;                                   // 0x0438(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_458[0x8];                                      // 0x0458(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FText GetCommandName() const;
	TSubclassOf<class UFortGameplayAbility> GetGameplayAbility() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortEmoteItemDefinition">();
	}
	static class UFortEmoteItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortEmoteItemDefinition>();
	}
};
static_assert(alignof(UFortEmoteItemDefinition) == 0x000010, "Wrong alignment on UFortEmoteItemDefinition");
static_assert(sizeof(UFortEmoteItemDefinition) == 0x000460, "Wrong size on UFortEmoteItemDefinition");
static_assert(offsetof(UFortEmoteItemDefinition, CommandName) == 0x000420, "Member 'UFortEmoteItemDefinition::CommandName' has a wrong offset!");
static_assert(offsetof(UFortEmoteItemDefinition, GameplayAbility) == 0x000438, "Member 'UFortEmoteItemDefinition::GameplayAbility' has a wrong offset!");

// Class FortniteGame.FortMissionPowerPointsInterface
// 0x0000 (0x0028 - 0x0028)
class IFortMissionPowerPointsInterface final : public IInterface
{
public:
	float GetAvailabilityWeight(float DifficultyLevel) const;
	float GetInitialRangeLerpValue(float PointsAvailable) const;
	float GetMaxRangeLerpValue(float PointsAvailable, float PreviousLerpValue) const;
	float GetPowerPointsCost(float LerpValue) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMissionPowerPointsInterface">();
	}
	static class IFortMissionPowerPointsInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortMissionPowerPointsInterface>();
	}
};
static_assert(alignof(IFortMissionPowerPointsInterface) == 0x000008, "Wrong alignment on IFortMissionPowerPointsInterface");
static_assert(sizeof(IFortMissionPowerPointsInterface) == 0x000028, "Wrong size on IFortMissionPowerPointsInterface");

// Class FortniteGame.BuildingFoundation5x5
// 0x0000 (0x1080 - 0x1080)
class ABuildingFoundation5x5 : public ABuildingFoundation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingFoundation5x5">();
	}
	static class ABuildingFoundation5x5* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingFoundation5x5>();
	}
};
static_assert(alignof(ABuildingFoundation5x5) == 0x000010, "Wrong alignment on ABuildingFoundation5x5");
static_assert(sizeof(ABuildingFoundation5x5) == 0x001080, "Wrong size on ABuildingFoundation5x5");

// Class FortniteGame.FortPathCostEstimator
// 0x0080 (0x00A8 - 0x0028)
class UFortPathCostEstimator final : public UObject
{
public:
	class AActor*                                 GoalActor;                                         // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFortNavigationGraph*                   NavGraph;                                          // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x70];                                      // 0x0038(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPathCostEstimator">();
	}
	static class UFortPathCostEstimator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPathCostEstimator>();
	}
};
static_assert(alignof(UFortPathCostEstimator) == 0x000008, "Wrong alignment on UFortPathCostEstimator");
static_assert(sizeof(UFortPathCostEstimator) == 0x0000A8, "Wrong size on UFortPathCostEstimator");
static_assert(offsetof(UFortPathCostEstimator, GoalActor) == 0x000028, "Member 'UFortPathCostEstimator::GoalActor' has a wrong offset!");
static_assert(offsetof(UFortPathCostEstimator, NavGraph) == 0x000030, "Member 'UFortPathCostEstimator::NavGraph' has a wrong offset!");

// Class FortniteGame.WorldTileFoundation
// 0x0020 (0x10A0 - 0x1080)
class AWorldTileFoundation final : public ABuildingFoundation
{
public:
	uint8                                         NumRotations;                                      // 0x1078(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1079[0x27];                                    // 0x1079(0x0027)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldTileFoundation">();
	}
	static class AWorldTileFoundation* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWorldTileFoundation>();
	}
};
static_assert(alignof(AWorldTileFoundation) == 0x000010, "Wrong alignment on AWorldTileFoundation");
static_assert(sizeof(AWorldTileFoundation) == 0x0010A0, "Wrong size on AWorldTileFoundation");
static_assert(offsetof(AWorldTileFoundation, NumRotations) == 0x001078, "Member 'AWorldTileFoundation::NumRotations' has a wrong offset!");

// Class FortniteGame.FortIntensityCurveSequence
// 0x0018 (0x0040 - 0x0028)
class UFortIntensityCurveSequence final : public UDataAsset
{
public:
	TArray<struct FDataTableRowHandle>            IntensityCurves;                                   // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	EFortIntensityCurveSequenceType               SequenceType;                                      // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortIntensityCurveSequence">();
	}
	static class UFortIntensityCurveSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortIntensityCurveSequence>();
	}
};
static_assert(alignof(UFortIntensityCurveSequence) == 0x000008, "Wrong alignment on UFortIntensityCurveSequence");
static_assert(sizeof(UFortIntensityCurveSequence) == 0x000040, "Wrong size on UFortIntensityCurveSequence");
static_assert(offsetof(UFortIntensityCurveSequence, IntensityCurves) == 0x000028, "Member 'UFortIntensityCurveSequence::IntensityCurves' has a wrong offset!");
static_assert(offsetof(UFortIntensityCurveSequence, SequenceType) == 0x000038, "Member 'UFortIntensityCurveSequence::SequenceType' has a wrong offset!");

// Class FortniteGame.FortQueryTest_PerceptionExists
// 0x0010 (0x01D0 - 0x01C0)
class UFortQueryTest_PerceptionExists final : public UEnvQueryTest
{
public:
	ECorePerceptionTypes                          Sense;                                             // 0x01C0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C1[0x7];                                      // 0x01C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UAISense>                   SenseClass;                                        // 0x01C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_PerceptionExists">();
	}
	static class UFortQueryTest_PerceptionExists* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_PerceptionExists>();
	}
};
static_assert(alignof(UFortQueryTest_PerceptionExists) == 0x000008, "Wrong alignment on UFortQueryTest_PerceptionExists");
static_assert(sizeof(UFortQueryTest_PerceptionExists) == 0x0001D0, "Wrong size on UFortQueryTest_PerceptionExists");
static_assert(offsetof(UFortQueryTest_PerceptionExists, Sense) == 0x0001C0, "Member 'UFortQueryTest_PerceptionExists::Sense' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_PerceptionExists, SenseClass) == 0x0001C8, "Member 'UFortQueryTest_PerceptionExists::SenseClass' has a wrong offset!");

// Class FortniteGame.BuildingPlayerPrimitivePreview
// 0x0000 (0x0FC0 - 0x0FC0)
class ABuildingPlayerPrimitivePreview : public ABuildingSMActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingPlayerPrimitivePreview">();
	}
	static class ABuildingPlayerPrimitivePreview* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingPlayerPrimitivePreview>();
	}
};
static_assert(alignof(ABuildingPlayerPrimitivePreview) == 0x000010, "Wrong alignment on ABuildingPlayerPrimitivePreview");
static_assert(sizeof(ABuildingPlayerPrimitivePreview) == 0x000FC0, "Wrong size on ABuildingPlayerPrimitivePreview");

// Class FortniteGame.BuildingLayoutRequirement
// 0x0060 (0x1020 - 0x0FC0)
class ABuildingLayoutRequirement final : public ABuildingPlayerPrimitivePreview
{
public:
	UMulticastDelegateProperty_                   OnLayoutSatisfied;                                 // 0x0FC0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnLayoutUnSatisfied;                               // 0x0FD0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class ABuildingSMActor>           LayoutRequirementSMActorClass;                     // 0x0FE0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreResourceTypeRequirements;                   // 0x0FE8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMakeSatisfyingActorIndestructibleWhileRequirementExists; // 0x0FE9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNeedToInitializeRequirementStatus;                // 0x0FEA(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRequirementSatisfied;                             // 0x0FEB(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELayoutRequirementStatus                      RequirementStatus;                                 // 0x0FEC(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortResourceType                             OverrideResourceType;                              // 0x0FED(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FEE[0x2];                                      // 0x0FEE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UMaterialInterface>      LayoutDisplayMaterial;                             // 0x0FF0(0x0020)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               LayoutDisplayMID;                                  // 0x1010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1018[0x8];                                     // 0x1018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateRequirement(bool bMakeVisible);
	void OnRep_RequirementStatus();
	void OnRequirementSatisfyingActorDied(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, class AActor* DamageCauser, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& Momentum);
	void SetRequiredResourceType(EFortResourceType DesiredResourceType);
	void SetRequirementVisible(bool bVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingLayoutRequirement">();
	}
	static class ABuildingLayoutRequirement* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingLayoutRequirement>();
	}
};
static_assert(alignof(ABuildingLayoutRequirement) == 0x000010, "Wrong alignment on ABuildingLayoutRequirement");
static_assert(sizeof(ABuildingLayoutRequirement) == 0x001020, "Wrong size on ABuildingLayoutRequirement");
static_assert(offsetof(ABuildingLayoutRequirement, OnLayoutSatisfied) == 0x000FC0, "Member 'ABuildingLayoutRequirement::OnLayoutSatisfied' has a wrong offset!");
static_assert(offsetof(ABuildingLayoutRequirement, OnLayoutUnSatisfied) == 0x000FD0, "Member 'ABuildingLayoutRequirement::OnLayoutUnSatisfied' has a wrong offset!");
static_assert(offsetof(ABuildingLayoutRequirement, LayoutRequirementSMActorClass) == 0x000FE0, "Member 'ABuildingLayoutRequirement::LayoutRequirementSMActorClass' has a wrong offset!");
static_assert(offsetof(ABuildingLayoutRequirement, bIgnoreResourceTypeRequirements) == 0x000FE8, "Member 'ABuildingLayoutRequirement::bIgnoreResourceTypeRequirements' has a wrong offset!");
static_assert(offsetof(ABuildingLayoutRequirement, bMakeSatisfyingActorIndestructibleWhileRequirementExists) == 0x000FE9, "Member 'ABuildingLayoutRequirement::bMakeSatisfyingActorIndestructibleWhileRequirementExists' has a wrong offset!");
static_assert(offsetof(ABuildingLayoutRequirement, bNeedToInitializeRequirementStatus) == 0x000FEA, "Member 'ABuildingLayoutRequirement::bNeedToInitializeRequirementStatus' has a wrong offset!");
static_assert(offsetof(ABuildingLayoutRequirement, bRequirementSatisfied) == 0x000FEB, "Member 'ABuildingLayoutRequirement::bRequirementSatisfied' has a wrong offset!");
static_assert(offsetof(ABuildingLayoutRequirement, RequirementStatus) == 0x000FEC, "Member 'ABuildingLayoutRequirement::RequirementStatus' has a wrong offset!");
static_assert(offsetof(ABuildingLayoutRequirement, OverrideResourceType) == 0x000FED, "Member 'ABuildingLayoutRequirement::OverrideResourceType' has a wrong offset!");
static_assert(offsetof(ABuildingLayoutRequirement, LayoutDisplayMaterial) == 0x000FF0, "Member 'ABuildingLayoutRequirement::LayoutDisplayMaterial' has a wrong offset!");
static_assert(offsetof(ABuildingLayoutRequirement, LayoutDisplayMID) == 0x001010, "Member 'ABuildingLayoutRequirement::LayoutDisplayMID' has a wrong offset!");

// Class FortniteGame.FortNeverPersistItemDefinition
// 0x0010 (0x0430 - 0x0420)
class UFortNeverPersistItemDefinition final : public UFortWorldItemDefinition
{
public:
	uint8                                         bAccumulateOnPlayerState : 1;                      // 0x0420(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_421[0xF];                                      // 0x0421(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNeverPersistItemDefinition">();
	}
	static class UFortNeverPersistItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNeverPersistItemDefinition>();
	}
};
static_assert(alignof(UFortNeverPersistItemDefinition) == 0x000010, "Wrong alignment on UFortNeverPersistItemDefinition");
static_assert(sizeof(UFortNeverPersistItemDefinition) == 0x000430, "Wrong size on UFortNeverPersistItemDefinition");

// Class FortniteGame.FortPatrolWardInterface
// 0x0000 (0x0028 - 0x0028)
class IFortPatrolWardInterface final : public IInterface
{
public:
	float GetAffectingDistance() const;
	EWardAffectType GetAffectingType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPatrolWardInterface">();
	}
	static class IFortPatrolWardInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortPatrolWardInterface>();
	}
};
static_assert(alignof(IFortPatrolWardInterface) == 0x000008, "Wrong alignment on IFortPatrolWardInterface");
static_assert(sizeof(IFortPatrolWardInterface) == 0x000028, "Wrong size on IFortPatrolWardInterface");

// Class FortniteGame.FortQueryTest_HasNearbyEncounterGoals
// 0x0038 (0x01F8 - 0x01C0)
class UFortQueryTest_HasNearbyEncounterGoals final : public UEnvQueryTest
{
public:
	uint8                                         bOnlyActiveEncounters : 1;                         // 0x01C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1C1[0x7];                                      // 0x01C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIDataProviderFloatValue              TestDistance;                                      // 0x01C8(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_HasNearbyEncounterGoals">();
	}
	static class UFortQueryTest_HasNearbyEncounterGoals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_HasNearbyEncounterGoals>();
	}
};
static_assert(alignof(UFortQueryTest_HasNearbyEncounterGoals) == 0x000008, "Wrong alignment on UFortQueryTest_HasNearbyEncounterGoals");
static_assert(sizeof(UFortQueryTest_HasNearbyEncounterGoals) == 0x0001F8, "Wrong size on UFortQueryTest_HasNearbyEncounterGoals");
static_assert(offsetof(UFortQueryTest_HasNearbyEncounterGoals, TestDistance) == 0x0001C8, "Member 'UFortQueryTest_HasNearbyEncounterGoals::TestDistance' has a wrong offset!");

// Class FortniteGame.BuildingRoof
// 0x0010 (0x0FD0 - 0x0FC0)
class ABuildingRoof : public ABuildingSMActor
{
public:
	uint8                                         Pad_FC0[0x10];                                     // 0x0FC0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingRoof">();
	}
	static class ABuildingRoof* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingRoof>();
	}
};
static_assert(alignof(ABuildingRoof) == 0x000010, "Wrong alignment on ABuildingRoof");
static_assert(sizeof(ABuildingRoof) == 0x000FD0, "Wrong size on ABuildingRoof");

// Class FortniteGame.FortAIPawn
// 0x0C10 (0x1AF0 - 0x0EE0)
#pragma pack(push, 0x1)
class alignas(0x10) AFortAIPawn : public AFortPawn
{
public:
	uint8                                         Pad_EE0[0x28];                                     // 0x0EE0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bNeedsDeathNotification : 1;                       // 0x0F08(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bKilledOrDowned : 1;                               // 0x0F08(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDespawnedDueToInactivity : 1;                     // 0x0F08(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNotifySpawnRift : 1;                              // 0x0F08(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsesDBNO : 1;                                     // 0x0F08(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHasInventory : 1;                                 // 0x0F08(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTrackNearbyPickups : 1;                           // 0x0F08(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsCharging : 1;                                   // 0x0F08(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Net, Transient, DisableEditOnInstance, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsCowering : 1;                                   // 0x0F09(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, Net, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShowMinimapFarOffDirectionArrow : 1;              // 0x0F09(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHasEngaged : 1;                                   // 0x0F09(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsAlwaysGameplayRelevant : 1;                     // 0x0F09(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_F09_4 : 1;                                  // 0x0F09(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bIsDebugSpawnedAI : 1;                             // 0x0F09(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEncounterExpectedLifespanExpired : 1;             // 0x0F09(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableBlockingCollisionWithOtherAI : 1;           // 0x0F09(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Net, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSetMiniMapIconRotation : 1;                       // 0x0F0A(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_F0B[0x5];                                      // 0x0F0B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnInventoryUpdated;                                // 0x0F10(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_F20[0x70];                                     // 0x0F20(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AIDifficultyLevel;                                 // 0x0F90(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortAILevelRatingDisplayType                 LevelRatingDisplayType;                            // 0x0F94(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F95[0x3];                                      // 0x0F95(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAIEncounterInfo*                   EncounterInfo;                                     // 0x0F98(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpawnSetIndex;                                     // 0x0FA0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  SpawnGroupGuid;                                    // 0x0FA4(0x0010)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnemyIndexInSpawnGroup;                            // 0x0FB4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FinishEncounterSpawnFallbackTime;                  // 0x0FB8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EncounterSpawnDisableRangedAttackingTime;          // 0x0FBC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EncounterSpawnDisableMeleeAttackingTime;           // 0x0FC0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC4[0x4];                                      // 0x0FC4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           EncounterExpectedLifespanTimerHandle;              // 0x0FC8(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	class AActor*                                 SpawnRift;                                         // 0x0FD0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SpawnSourceActor;                                  // 0x0FD8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTimeAllowedOutsideTether;                       // 0x0FE0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FE4[0x4];                                      // 0x0FE4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBehaviorTree*                          BehaviorTree;                                      // 0x0FE8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavigationQueryFilter>     DefaultNavFilter;                                  // 0x0FF0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavigationQueryFilter>     HuntingNavFilter;                                  // 0x0FF8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1000[0x8];                                     // 0x1000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DBNOInteractionDuration;                           // 0x1008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_100C[0x4];                                     // 0x100C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnDowned;                                          // 0x1010(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	ETInteractionType                             DBNOInteractionType;                               // 0x1020(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortMovementStyle                            MovementStyles[0x4];                               // 0x1021(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1025[0x3];                                     // 0x1025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UpdateNearbyPickupFrequency;                       // 0x1028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_102C[0x4];                                     // 0x102C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           RequiredWeaponPickupTag;                           // 0x1030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NoWeaponInCombatEventName;                         // 0x1038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NoWeaponOutOfCombatEventName;                      // 0x1040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TurnTransitionGameplayAbilityTag;                  // 0x1048(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UParticleSystem>         DeathParticles;                                    // 0x1068(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumRunVariations;                                  // 0x1088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentRunVariationIndex;                          // 0x108C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunVariationRadius;                                // 0x1090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EyeIndex;                                          // 0x1094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkinIndex;                                         // 0x1098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DefaultEyeColor;                                   // 0x109C(0x0010)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultEyeBrightness;                              // 0x10AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DefaultSkinColor;                                  // 0x10B0(0x0010)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultSkinGlow;                                   // 0x10C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           MinimapDefaultIconColor;                           // 0x10C4(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           PlayerManagerMinimapColor;                         // 0x10D4(0x0010)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10E4[0x14];                                    // 0x10E4(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            MiniMapIconBrush;                                  // 0x10F8(0x0090)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateBrush                            MiniMapAboveBelowIconBrush;                        // 0x1188(0x0090)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FMinimapGoalByTagColorsData>    MinimapGoalByTagColors;                            // 0x1218(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int8                                          MinimapGoalByTagColorIndex;                        // 0x1228(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1229[0x7];                                     // 0x1229(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AppearanceOverrideName;                            // 0x1230(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortAIPawnGender                             AppearanceOverrideGender;                          // 0x1238(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortCombatEvents                             FollowPlayerEvent;                                 // 0x1239(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETInteractionType                             InteractionType;                                   // 0x123A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_123B[0x1];                                     // 0x123B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FollowPlayerRange;                                 // 0x123C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteractionDuration;                               // 0x1240(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1244[0x4];                                     // 0x1244(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnInteraction;                                     // 0x1248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class ABuildingTrapDefender*                  DefenderTrap;                                      // 0x1258(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnActorBeginCrowdOverlap;                          // 0x1260(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         BitPad_1270_0 : 1;                                 // 0x1270(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bDebugAI : 1;                                      // 0x1270(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDebugAIAnim : 1;                                  // 0x1270(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUseBuildingAttackingHotspots : 1;                 // 0x1270(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanMoveThroughWalls : 1;                          // 0x1270(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanUseNavWalking : 1;                             // 0x1270(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanUseSimpleCollisions : 1;                       // 0x1270(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanUseStepAside : 1;                              // 0x1270(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanUseDoors : 1;                                  // 0x1271(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanUseShootingHotspots : 1;                       // 0x1271(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanSleep : 1;                                     // 0x1271(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsSleeping : 1;                                   // 0x1271(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bShouldStartSleeping : 1;                          // 0x1271(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanLookAtGoal : 1;                                // 0x1271(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanUseMeshPooling : 1;                            // 0x1271(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUseCrowdSimulation : 1;                           // 0x1271(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bControlWalkingOffLedges : 1;                      // 0x1272(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         BitPad_1272_1 : 7;                                 // 0x1272(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         BitPad_1273_0 : 1;                                 // 0x1273(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bUseAppearanceOverride : 1;                        // 0x1273(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanInteract : 1;                                  // 0x1273(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	EFortMovementUrgency                          MovementUrgency;                                   // 0x1274(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortressAIType                               AIType;                                            // 0x1275(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortTeam                                     Team;                                              // 0x1276(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1277[0x1];                                     // 0x1277(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SimpleCollisionsProfileName;                       // 0x1278(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFortAISpawnGroupUpgradeUIData         UpgradeUIData;                                     // 0x1280(0x00A8)(Net, Protected, NativeAccessSpecifierProtected)
	float                                         ScoreMultiplier;                                   // 0x1328(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortHotSpotSlot                              HotspotType;                                       // 0x132C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortPartialPathUsage                         PartialPathUsage;                                  // 0x132D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_132E[0x2];                                     // 0x132E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortPlayerStateZone*                   PlayerManager;                                     // 0x1330(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DefenderItemInstanceId;                            // 0x1338(0x0010)(Net, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DefenderSquadId;                                   // 0x1348(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DefenderPlacedTime;                                // 0x1350(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RecentlySeenInterval;                              // 0x1354(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               CurrentAIRotationRate;                             // 0x1358(0x000C)(BlueprintVisible, BlueprintReadOnly, Net, IsPlainOldData, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         MoveSoundStimulusBroadcastInterval;                // 0x1364(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1368[0x8];                                     // 0x1368(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UShapeComponent*                        WeaponCollisionComponent;                          // 0x1370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortInventory*                         Inventory;                                         // 0x1378(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AFortPickup*>                    NearbyPickups;                                     // 0x1380(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class AFortPickup*, float>               UnreachablePickups;                                // 0x1390(0x0050)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_13E0[0x10];                                    // 0x13E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFortAbilitySetHandle>          DefenderAlterationAbilitySetHandles;               // 0x13F0(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortAIAppearanceOverrideEntry> AppearanceOverrideEntries;                         // 0x1400(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	int32                                         AppearanceOverrideEntryIndex;                      // 0x1410(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                SpawnLocation;                                     // 0x1414(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               SpawnRotation;                                     // 0x1420(0x000C)(IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ABuildingActor>          SleepingFloor;                                     // 0x142C(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1434[0x4];                                     // 0x1434(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PelvisBoneName;                                    // 0x1438(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   HeadBoneName;                                      // 0x1440(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1448[0xC];                                     // 0x1448(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimapIndicatorUpdateFrequency;                   // 0x1454(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1458[0x8];                                     // 0x1458(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MiniMapViewableDistance;                           // 0x1460(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DistanceToPlayerManagerToShowHealthBar;            // 0x1464(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DistanceToOtherPlayersToShowHealthBar;             // 0x1468(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_146C[0xC];                                     // 0x146C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAIAttributesSet*                   AttributesSet;                                     // 0x1478(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortCharacterAttrSet*                  CharacterAttrSet;                                  // 0x1480(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortWeaponAttrSet*                     WeaponAttrSet;                                     // 0x1488(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             ImpactPhysicalSurfaceSounds[0x3F];                 // 0x1490(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        ImpactPhysicalSurfaceEffects[0x3F];                // 0x1688(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortSimpleMiniMapIndicator*            MiniMapIndicator;                                  // 0x1880(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MiniMapScale;                                      // 0x1888(0x0008)(Edit, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UFortAbilitySet*>                DefaultGameplayAbilitySets;                        // 0x1890(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class UFortAbilitySet*>                SpawnInheritedCharacterAbilitySets;                // 0x18A0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UFortGameplayModifierItemDefinition*> SpawnModifierDefinitions;                          // 0x18B0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UFortAbilitySystemComponent*            AIPawnAbilitySystemComponent;                      // 0x18C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  WallAttackGameplayAbilityTags;                     // 0x18C8(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  WallRangedAttackGameplayAbilityTags;               // 0x18E8(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  CeilingAttackGameplayAbilityTags;                  // 0x1908(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  FloorAttackGameplayAbilityTags;                    // 0x1928(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGameplayTagContainer>          FailedAbilityQueryTags;                            // 0x1948(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class AActor*                                 CurrentAimTarget;                                  // 0x1958(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortNavObstacleComponent*              NavObstacleComponent;                              // 0x1960(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1968[0x10];                                    // 0x1968(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	EFortAILODLevel                               CurrentFortAILODLevel;                             // 0x1978(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1979[0x11F];                                   // 0x1979(0x011F)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAccountItem*                       DefenderItem;                                      // 0x1A98(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1AA0[0x48];                                    // 0x1AA0(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static float GetGroundSpeedForUrgency(class AFortAIPawn* FortAIPawn, EFortMovementUrgency Urgency);
	static EFortMovementStyle GetMovementStyle(const class AFortAIPawn* FortAIPawn);
	static EFortMovementUrgency GetMovementUrgency(class AFortAIPawn* FortAIPawn);

	void AddFortAbilitySet(class UFortAbilitySet* FortAbilitySet);
	void AddUnreachablePickup(class AFortPickup* Pickup);
	bool CanHitTargetWithAbility(const struct FGameplayTagContainer& GameplayAbilityTag, class AActor* CanHitTarget, bool bUseIdealYawRotationToTarget);
	void ClearAIFocalPoint(bool bUseAttackingPriority);
	void FinishedEncounterSpawn();
	void ForceKillNoDBNO();
	void GrabPickup(class AFortPickup* Pickup);
	void OnAppearanceOverridden();
	void OnBeginSleepEffects();
	void OnDefenderTrapSet(class ABuildingTrapDefender* OldDefenderTrap);
	void OnEncounterSpawnEnableMeleeAttacking();
	void OnEncounterSpawnEnableRangedAttacking();
	void OnEndSleepEffects();
	void OnFinishedEncounterSpawn();
	bool OnOutsideOfTetherBeyondMaxTimeAllowed();
	void OnRep_AppearanceOverrideEntryIndex();
	void OnRep_bIsSleeping();
	void OnRep_CurrentAIRotationRate();
	void OnRep_CurrentFortAILODLevel();
	void OnRep_CurrentWeapon();
	void OnRep_EnableBlockingCollisionWithOtherAI();
	void OnRep_Inventory();
	void OnRep_MinimapViewableDistance();
	void OnSleepingAIsFloorBuildingActorDied(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, class AActor* DamageCauser, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& Momentum);
	void OnStartedEncounterSpawn();
	void ResetAIRotationRateToDefault();
	void ReviveFromDBNO();
	void SetAIFocalPoint(class AActor* FocusTarget, const struct FVector& FocalPoint, bool bUseAttackingPriority);
	void SetAIRotationRate(const struct FRotator& AIRotationRate);
	void SetAIType(EFortressAIType InAIType);
	void SetBlockCollisionWithOtherAI(bool bInEnableBlockingCollisionWithOtherAI);
	void SetCanInteract(bool CanInteract);
	void SetCanSleep(bool InCanSleep);
	void SetCollisionProfileName(class FName InCollisionProfileName);
	void SetCurrentAimTarget(class AActor* AimTarget);
	void SetDefenderTrap(class ABuildingTrapDefender* InDefenderTrap);
	void SetEncounterInfo(class UFortAIEncounterInfo* InEncounterInfo);
	void SetEyeColor(const struct FLinearColor& NewEyeColor, float NewEyeBrightness);
	void SetIsCharging(bool bNewIsCharging);
	void SetMinimapViewableDistance(float NewMinimapViewableDistance);
	void SetMinimumAILOD(EFortAILODLevel MinimumAILOD);
	void SetMovementUrgency(EFortMovementUrgency Urgency);
	void SetShouldStartSleeping(bool bHintStartSleeping);
	void SetSkinColor(const struct FLinearColor& NewSkinColor, float NewSkinBrightness);
	void SetWeaponCollisionComponent(class UShapeComponent* InWeaponCollisionComponent);
	void TriggerNoWeaponSpeech();
	void TurnOnSleepingOptimizations();

	EFortCustomGender GetCharacterGender() const;
	class AActor* GetCurrentAimTarget() const;
	float GetDifficultyLevel() const;
	class USoundBase* GetImpactPhysicalSurfaceSound(const struct FHitResult& Impact) const;
	int32 GetScoreValue() const;
	struct FVector GetSpawnLocation() const;
	int32 GetSpawnPointValue() const;
	struct FRotator GetSpawnRotation() const;
	bool HasTether() const;
	bool IsDefender() const;
	bool IsInCombat() const;
	bool IsInsideTetherBounds(bool bUseRelaxedTetherBounds) const;
	class UFortItem* K2_FindExistingItemForDefinition(const class UFortItemDefinition* ItemDefinition, bool bInStorageVault) const;
	class UFortItem* K2_GetDefenderItem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIPawn">();
	}
	static class AFortAIPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAIPawn>();
	}
};
#pragma pack(pop)
static_assert(alignof(AFortAIPawn) == 0x000010, "Wrong alignment on AFortAIPawn");
static_assert(sizeof(AFortAIPawn) == 0x001AF0, "Wrong size on AFortAIPawn");
static_assert(offsetof(AFortAIPawn, OnInventoryUpdated) == 0x000F10, "Member 'AFortAIPawn::OnInventoryUpdated' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, AIDifficultyLevel) == 0x000F90, "Member 'AFortAIPawn::AIDifficultyLevel' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, LevelRatingDisplayType) == 0x000F94, "Member 'AFortAIPawn::LevelRatingDisplayType' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, EncounterInfo) == 0x000F98, "Member 'AFortAIPawn::EncounterInfo' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, SpawnSetIndex) == 0x000FA0, "Member 'AFortAIPawn::SpawnSetIndex' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, SpawnGroupGuid) == 0x000FA4, "Member 'AFortAIPawn::SpawnGroupGuid' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, EnemyIndexInSpawnGroup) == 0x000FB4, "Member 'AFortAIPawn::EnemyIndexInSpawnGroup' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, FinishEncounterSpawnFallbackTime) == 0x000FB8, "Member 'AFortAIPawn::FinishEncounterSpawnFallbackTime' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, EncounterSpawnDisableRangedAttackingTime) == 0x000FBC, "Member 'AFortAIPawn::EncounterSpawnDisableRangedAttackingTime' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, EncounterSpawnDisableMeleeAttackingTime) == 0x000FC0, "Member 'AFortAIPawn::EncounterSpawnDisableMeleeAttackingTime' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, EncounterExpectedLifespanTimerHandle) == 0x000FC8, "Member 'AFortAIPawn::EncounterExpectedLifespanTimerHandle' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, SpawnRift) == 0x000FD0, "Member 'AFortAIPawn::SpawnRift' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, SpawnSourceActor) == 0x000FD8, "Member 'AFortAIPawn::SpawnSourceActor' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, MaxTimeAllowedOutsideTether) == 0x000FE0, "Member 'AFortAIPawn::MaxTimeAllowedOutsideTether' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, BehaviorTree) == 0x000FE8, "Member 'AFortAIPawn::BehaviorTree' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, DefaultNavFilter) == 0x000FF0, "Member 'AFortAIPawn::DefaultNavFilter' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, HuntingNavFilter) == 0x000FF8, "Member 'AFortAIPawn::HuntingNavFilter' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, DBNOInteractionDuration) == 0x001008, "Member 'AFortAIPawn::DBNOInteractionDuration' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, OnDowned) == 0x001010, "Member 'AFortAIPawn::OnDowned' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, DBNOInteractionType) == 0x001020, "Member 'AFortAIPawn::DBNOInteractionType' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, MovementStyles) == 0x001021, "Member 'AFortAIPawn::MovementStyles' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, UpdateNearbyPickupFrequency) == 0x001028, "Member 'AFortAIPawn::UpdateNearbyPickupFrequency' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, RequiredWeaponPickupTag) == 0x001030, "Member 'AFortAIPawn::RequiredWeaponPickupTag' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, NoWeaponInCombatEventName) == 0x001038, "Member 'AFortAIPawn::NoWeaponInCombatEventName' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, NoWeaponOutOfCombatEventName) == 0x001040, "Member 'AFortAIPawn::NoWeaponOutOfCombatEventName' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, TurnTransitionGameplayAbilityTag) == 0x001048, "Member 'AFortAIPawn::TurnTransitionGameplayAbilityTag' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, DeathParticles) == 0x001068, "Member 'AFortAIPawn::DeathParticles' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, NumRunVariations) == 0x001088, "Member 'AFortAIPawn::NumRunVariations' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, CurrentRunVariationIndex) == 0x00108C, "Member 'AFortAIPawn::CurrentRunVariationIndex' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, RunVariationRadius) == 0x001090, "Member 'AFortAIPawn::RunVariationRadius' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, EyeIndex) == 0x001094, "Member 'AFortAIPawn::EyeIndex' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, SkinIndex) == 0x001098, "Member 'AFortAIPawn::SkinIndex' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, DefaultEyeColor) == 0x00109C, "Member 'AFortAIPawn::DefaultEyeColor' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, DefaultEyeBrightness) == 0x0010AC, "Member 'AFortAIPawn::DefaultEyeBrightness' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, DefaultSkinColor) == 0x0010B0, "Member 'AFortAIPawn::DefaultSkinColor' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, DefaultSkinGlow) == 0x0010C0, "Member 'AFortAIPawn::DefaultSkinGlow' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, MinimapDefaultIconColor) == 0x0010C4, "Member 'AFortAIPawn::MinimapDefaultIconColor' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, PlayerManagerMinimapColor) == 0x0010D4, "Member 'AFortAIPawn::PlayerManagerMinimapColor' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, MiniMapIconBrush) == 0x0010F8, "Member 'AFortAIPawn::MiniMapIconBrush' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, MiniMapAboveBelowIconBrush) == 0x001188, "Member 'AFortAIPawn::MiniMapAboveBelowIconBrush' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, MinimapGoalByTagColors) == 0x001218, "Member 'AFortAIPawn::MinimapGoalByTagColors' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, MinimapGoalByTagColorIndex) == 0x001228, "Member 'AFortAIPawn::MinimapGoalByTagColorIndex' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, AppearanceOverrideName) == 0x001230, "Member 'AFortAIPawn::AppearanceOverrideName' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, AppearanceOverrideGender) == 0x001238, "Member 'AFortAIPawn::AppearanceOverrideGender' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, FollowPlayerEvent) == 0x001239, "Member 'AFortAIPawn::FollowPlayerEvent' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, InteractionType) == 0x00123A, "Member 'AFortAIPawn::InteractionType' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, FollowPlayerRange) == 0x00123C, "Member 'AFortAIPawn::FollowPlayerRange' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, InteractionDuration) == 0x001240, "Member 'AFortAIPawn::InteractionDuration' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, OnInteraction) == 0x001248, "Member 'AFortAIPawn::OnInteraction' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, DefenderTrap) == 0x001258, "Member 'AFortAIPawn::DefenderTrap' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, OnActorBeginCrowdOverlap) == 0x001260, "Member 'AFortAIPawn::OnActorBeginCrowdOverlap' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, MovementUrgency) == 0x001274, "Member 'AFortAIPawn::MovementUrgency' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, AIType) == 0x001275, "Member 'AFortAIPawn::AIType' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, Team) == 0x001276, "Member 'AFortAIPawn::Team' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, SimpleCollisionsProfileName) == 0x001278, "Member 'AFortAIPawn::SimpleCollisionsProfileName' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, UpgradeUIData) == 0x001280, "Member 'AFortAIPawn::UpgradeUIData' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, ScoreMultiplier) == 0x001328, "Member 'AFortAIPawn::ScoreMultiplier' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, HotspotType) == 0x00132C, "Member 'AFortAIPawn::HotspotType' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, PartialPathUsage) == 0x00132D, "Member 'AFortAIPawn::PartialPathUsage' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, PlayerManager) == 0x001330, "Member 'AFortAIPawn::PlayerManager' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, DefenderItemInstanceId) == 0x001338, "Member 'AFortAIPawn::DefenderItemInstanceId' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, DefenderSquadId) == 0x001348, "Member 'AFortAIPawn::DefenderSquadId' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, DefenderPlacedTime) == 0x001350, "Member 'AFortAIPawn::DefenderPlacedTime' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, RecentlySeenInterval) == 0x001354, "Member 'AFortAIPawn::RecentlySeenInterval' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, CurrentAIRotationRate) == 0x001358, "Member 'AFortAIPawn::CurrentAIRotationRate' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, MoveSoundStimulusBroadcastInterval) == 0x001364, "Member 'AFortAIPawn::MoveSoundStimulusBroadcastInterval' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, WeaponCollisionComponent) == 0x001370, "Member 'AFortAIPawn::WeaponCollisionComponent' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, Inventory) == 0x001378, "Member 'AFortAIPawn::Inventory' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, NearbyPickups) == 0x001380, "Member 'AFortAIPawn::NearbyPickups' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, UnreachablePickups) == 0x001390, "Member 'AFortAIPawn::UnreachablePickups' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, DefenderAlterationAbilitySetHandles) == 0x0013F0, "Member 'AFortAIPawn::DefenderAlterationAbilitySetHandles' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, AppearanceOverrideEntries) == 0x001400, "Member 'AFortAIPawn::AppearanceOverrideEntries' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, AppearanceOverrideEntryIndex) == 0x001410, "Member 'AFortAIPawn::AppearanceOverrideEntryIndex' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, SpawnLocation) == 0x001414, "Member 'AFortAIPawn::SpawnLocation' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, SpawnRotation) == 0x001420, "Member 'AFortAIPawn::SpawnRotation' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, SleepingFloor) == 0x00142C, "Member 'AFortAIPawn::SleepingFloor' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, PelvisBoneName) == 0x001438, "Member 'AFortAIPawn::PelvisBoneName' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, HeadBoneName) == 0x001440, "Member 'AFortAIPawn::HeadBoneName' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, MinimapIndicatorUpdateFrequency) == 0x001454, "Member 'AFortAIPawn::MinimapIndicatorUpdateFrequency' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, MiniMapViewableDistance) == 0x001460, "Member 'AFortAIPawn::MiniMapViewableDistance' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, DistanceToPlayerManagerToShowHealthBar) == 0x001464, "Member 'AFortAIPawn::DistanceToPlayerManagerToShowHealthBar' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, DistanceToOtherPlayersToShowHealthBar) == 0x001468, "Member 'AFortAIPawn::DistanceToOtherPlayersToShowHealthBar' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, AttributesSet) == 0x001478, "Member 'AFortAIPawn::AttributesSet' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, CharacterAttrSet) == 0x001480, "Member 'AFortAIPawn::CharacterAttrSet' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, WeaponAttrSet) == 0x001488, "Member 'AFortAIPawn::WeaponAttrSet' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, ImpactPhysicalSurfaceSounds) == 0x001490, "Member 'AFortAIPawn::ImpactPhysicalSurfaceSounds' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, ImpactPhysicalSurfaceEffects) == 0x001688, "Member 'AFortAIPawn::ImpactPhysicalSurfaceEffects' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, MiniMapIndicator) == 0x001880, "Member 'AFortAIPawn::MiniMapIndicator' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, MiniMapScale) == 0x001888, "Member 'AFortAIPawn::MiniMapScale' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, DefaultGameplayAbilitySets) == 0x001890, "Member 'AFortAIPawn::DefaultGameplayAbilitySets' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, SpawnInheritedCharacterAbilitySets) == 0x0018A0, "Member 'AFortAIPawn::SpawnInheritedCharacterAbilitySets' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, SpawnModifierDefinitions) == 0x0018B0, "Member 'AFortAIPawn::SpawnModifierDefinitions' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, AIPawnAbilitySystemComponent) == 0x0018C0, "Member 'AFortAIPawn::AIPawnAbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, WallAttackGameplayAbilityTags) == 0x0018C8, "Member 'AFortAIPawn::WallAttackGameplayAbilityTags' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, WallRangedAttackGameplayAbilityTags) == 0x0018E8, "Member 'AFortAIPawn::WallRangedAttackGameplayAbilityTags' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, CeilingAttackGameplayAbilityTags) == 0x001908, "Member 'AFortAIPawn::CeilingAttackGameplayAbilityTags' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, FloorAttackGameplayAbilityTags) == 0x001928, "Member 'AFortAIPawn::FloorAttackGameplayAbilityTags' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, FailedAbilityQueryTags) == 0x001948, "Member 'AFortAIPawn::FailedAbilityQueryTags' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, CurrentAimTarget) == 0x001958, "Member 'AFortAIPawn::CurrentAimTarget' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, NavObstacleComponent) == 0x001960, "Member 'AFortAIPawn::NavObstacleComponent' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, CurrentFortAILODLevel) == 0x001978, "Member 'AFortAIPawn::CurrentFortAILODLevel' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, DefenderItem) == 0x001A98, "Member 'AFortAIPawn::DefenderItem' has a wrong offset!");

// Class FortniteGame.FortPawn_Taker
// 0x0010 (0x1B00 - 0x1AF0)
class AFortPawn_Taker final : public AFortAIPawn
{
public:
	uint8                                         bUseClimbLinks : 1;                                // 0x1AE8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1AE9[0x7];                                     // 0x1AE9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBuildingHitTime>               BuildingCollisions;                                // 0x1AF0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPawn_Taker">();
	}
	static class AFortPawn_Taker* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPawn_Taker>();
	}
};
static_assert(alignof(AFortPawn_Taker) == 0x000010, "Wrong alignment on AFortPawn_Taker");
static_assert(sizeof(AFortPawn_Taker) == 0x001B00, "Wrong size on AFortPawn_Taker");
static_assert(offsetof(AFortPawn_Taker, BuildingCollisions) == 0x001AF0, "Member 'AFortPawn_Taker::BuildingCollisions' has a wrong offset!");

// Class FortniteGame.BuildingTrap
// 0x0120 (0x10E0 - 0x0FC0)
#pragma pack(push, 0x1)
class alignas(0x10) ABuildingTrap : public ABuildingSMActor
{
public:
	uint8                                         Pad_FC0[0x10];                                     // 0x0FC0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            TrapRangeMesh;                                     // 0x0FD0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            TrapPreviewMesh;                                   // 0x0FD8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortTrapItemDefinition*                TrapData;                                          // 0x0FE0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   AttachmentHintText;                                // 0x0FE8(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FFortTargetFilter                      TriggerFilter;                                     // 0x1000(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                TrapPlacementOffset;                               // 0x1020(0x000C)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_102C[0x4];                                     // 0x102C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAbilitySet*                        AbilitySet;                                        // 0x1030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortDamageSet*                         DamageAttributeSet;                                // 0x1038(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UFortAlterationItemDefinition*>  AppliedAlterations;                                // 0x1040(0x0010)(Net, ZeroConstructor, SaveGame, RepNotify, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortAbilitySetHandle>          AlterationAbilitySetHandles;                       // 0x1050(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class ABuildingSMActor*                       AttachedTo;                                        // 0x1060(0x0008)(Net, ZeroConstructor, SaveGame, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABuildingSMActor*                       LastAttachedTo;                                    // 0x1068(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DelayBeforeDestroyAfterDurabilityExpired;          // 0x1070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SavedDurabilityPct;                                // 0x1074(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1078[0x8];                                     // 0x1078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UPrimitiveComponent*>            TriggerComponents;                                 // 0x1080(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UPrimitiveComponent*>            DamageComponents;                                  // 0x1090(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UStaticMeshComponent*>           StaticMeshes;                                      // 0x10A0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	int32                                         TrapLevel;                                         // 0x10B0(0x0004)(Net, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10B4[0x24];                                    // 0x10B4(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddDamageComponent(class UPrimitiveComponent* DamageComponent);
	void AddTriggerComponent(class UPrimitiveComponent* TriggerComponent);
	void AttemptRetrigger(float Seconds);
	void FinishTrigger();
	float GetArmTime();
	struct FVector GetCenter();
	float GetReloadTime();
	void OnDestroy();
	void OnFinishedBuilding();
	void OnInitAlteration(class UFortAlterationItemDefinition* NewAlteration);
	void OnInitCosmeticAlterations(const struct FFortCosmeticModification& CosmeticMod);
	void OnOutOfDurability();
	void OnPlaced();
	void OnReloadBegin();
	void OnReloadEnd();
	void OnRep_AttachedTo();
	void OnRep_ReplicatedAppliedAlterations();
	void OnTriggerTouch(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void TriggerIfAppropriate();

	bool BP_ShouldTrigger(const TArray<class AActor*>& TouchingActors) const;
	TArray<class UFortAlterationItemDefinition*> GetAlterations() const;
	class ABuildingSMActor* GetBuildingAttachedTo() const;
	float GetDamageDelay() const;
	float GetDurabilityPercent() const;
	float GetFireDelay() const;
	struct FTransform GetFireLocationAndRotation() const;
	float GetMaxDurability() const;
	TArray<class AActor*> GetTouchingDamageTargets(const struct FFortTargetFilter& Filter) const;
	int32 GetTrapLevel() const;
	int32 GetTrapRating() const;
	bool HasDurability() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingTrap">();
	}
	static class ABuildingTrap* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingTrap>();
	}
};
#pragma pack(pop)
static_assert(alignof(ABuildingTrap) == 0x000010, "Wrong alignment on ABuildingTrap");
static_assert(sizeof(ABuildingTrap) == 0x0010E0, "Wrong size on ABuildingTrap");
static_assert(offsetof(ABuildingTrap, TrapRangeMesh) == 0x000FD0, "Member 'ABuildingTrap::TrapRangeMesh' has a wrong offset!");
static_assert(offsetof(ABuildingTrap, TrapPreviewMesh) == 0x000FD8, "Member 'ABuildingTrap::TrapPreviewMesh' has a wrong offset!");
static_assert(offsetof(ABuildingTrap, TrapData) == 0x000FE0, "Member 'ABuildingTrap::TrapData' has a wrong offset!");
static_assert(offsetof(ABuildingTrap, AttachmentHintText) == 0x000FE8, "Member 'ABuildingTrap::AttachmentHintText' has a wrong offset!");
static_assert(offsetof(ABuildingTrap, TriggerFilter) == 0x001000, "Member 'ABuildingTrap::TriggerFilter' has a wrong offset!");
static_assert(offsetof(ABuildingTrap, TrapPlacementOffset) == 0x001020, "Member 'ABuildingTrap::TrapPlacementOffset' has a wrong offset!");
static_assert(offsetof(ABuildingTrap, AbilitySet) == 0x001030, "Member 'ABuildingTrap::AbilitySet' has a wrong offset!");
static_assert(offsetof(ABuildingTrap, DamageAttributeSet) == 0x001038, "Member 'ABuildingTrap::DamageAttributeSet' has a wrong offset!");
static_assert(offsetof(ABuildingTrap, AppliedAlterations) == 0x001040, "Member 'ABuildingTrap::AppliedAlterations' has a wrong offset!");
static_assert(offsetof(ABuildingTrap, AlterationAbilitySetHandles) == 0x001050, "Member 'ABuildingTrap::AlterationAbilitySetHandles' has a wrong offset!");
static_assert(offsetof(ABuildingTrap, AttachedTo) == 0x001060, "Member 'ABuildingTrap::AttachedTo' has a wrong offset!");
static_assert(offsetof(ABuildingTrap, LastAttachedTo) == 0x001068, "Member 'ABuildingTrap::LastAttachedTo' has a wrong offset!");
static_assert(offsetof(ABuildingTrap, DelayBeforeDestroyAfterDurabilityExpired) == 0x001070, "Member 'ABuildingTrap::DelayBeforeDestroyAfterDurabilityExpired' has a wrong offset!");
static_assert(offsetof(ABuildingTrap, SavedDurabilityPct) == 0x001074, "Member 'ABuildingTrap::SavedDurabilityPct' has a wrong offset!");
static_assert(offsetof(ABuildingTrap, TriggerComponents) == 0x001080, "Member 'ABuildingTrap::TriggerComponents' has a wrong offset!");
static_assert(offsetof(ABuildingTrap, DamageComponents) == 0x001090, "Member 'ABuildingTrap::DamageComponents' has a wrong offset!");
static_assert(offsetof(ABuildingTrap, StaticMeshes) == 0x0010A0, "Member 'ABuildingTrap::StaticMeshes' has a wrong offset!");
static_assert(offsetof(ABuildingTrap, TrapLevel) == 0x0010B0, "Member 'ABuildingTrap::TrapLevel' has a wrong offset!");

// Class FortniteGame.FortAIDataProvider_AIDirector
// 0x0008 (0x0030 - 0x0028)
class UFortAIDataProvider_AIDirector final : public UAIDataProvider
{
public:
	float                                         AIRelevantDistanceToPlayer;                        // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EncounterRelevantDistanceToPlayer;                 // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIDataProvider_AIDirector">();
	}
	static class UFortAIDataProvider_AIDirector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIDataProvider_AIDirector>();
	}
};
static_assert(alignof(UFortAIDataProvider_AIDirector) == 0x000008, "Wrong alignment on UFortAIDataProvider_AIDirector");
static_assert(sizeof(UFortAIDataProvider_AIDirector) == 0x000030, "Wrong size on UFortAIDataProvider_AIDirector");
static_assert(offsetof(UFortAIDataProvider_AIDirector, AIRelevantDistanceToPlayer) == 0x000028, "Member 'UFortAIDataProvider_AIDirector::AIRelevantDistanceToPlayer' has a wrong offset!");
static_assert(offsetof(UFortAIDataProvider_AIDirector, EncounterRelevantDistanceToPlayer) == 0x00002C, "Member 'UFortAIDataProvider_AIDirector::EncounterRelevantDistanceToPlayer' has a wrong offset!");

// Class FortniteGame.BuildingTrapCeiling
// 0x0000 (0x10E0 - 0x10E0)
#pragma pack(push, 0x1)
class alignas(0x10) ABuildingTrapCeiling : public ABuildingTrap
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingTrapCeiling">();
	}
	static class ABuildingTrapCeiling* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingTrapCeiling>();
	}
};
#pragma pack(pop)
static_assert(alignof(ABuildingTrapCeiling) == 0x000010, "Wrong alignment on ABuildingTrapCeiling");
static_assert(sizeof(ABuildingTrapCeiling) == 0x0010E0, "Wrong size on ABuildingTrapCeiling");

// Class FortniteGame.BuildingTrapCeiling_Falling
// 0x0010 (0x10F0 - 0x10E0)
class ABuildingTrapCeiling_Falling final : public ABuildingTrapCeiling
{
public:
	class UStaticMeshComponent*                   VisibleMeshComponent;                              // 0x10D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        SpawnPoints;                                       // 0x10E0(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingTrapCeiling_Falling">();
	}
	static class ABuildingTrapCeiling_Falling* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingTrapCeiling_Falling>();
	}
};
static_assert(alignof(ABuildingTrapCeiling_Falling) == 0x000010, "Wrong alignment on ABuildingTrapCeiling_Falling");
static_assert(sizeof(ABuildingTrapCeiling_Falling) == 0x0010F0, "Wrong size on ABuildingTrapCeiling_Falling");
static_assert(offsetof(ABuildingTrapCeiling_Falling, VisibleMeshComponent) == 0x0010D8, "Member 'ABuildingTrapCeiling_Falling::VisibleMeshComponent' has a wrong offset!");
static_assert(offsetof(ABuildingTrapCeiling_Falling, SpawnPoints) == 0x0010E0, "Member 'ABuildingTrapCeiling_Falling::SpawnPoints' has a wrong offset!");

// Class FortniteGame.FortNavigationGraph
// 0x0178 (0x06A0 - 0x0528)
class AFortNavigationGraph final : public ANavigationData
{
public:
	uint8                                         Pad_528[0x178];                                    // 0x0528(0x0178)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavigationGraph">();
	}
	static class AFortNavigationGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortNavigationGraph>();
	}
};
static_assert(alignof(AFortNavigationGraph) == 0x000008, "Wrong alignment on AFortNavigationGraph");
static_assert(sizeof(AFortNavigationGraph) == 0x0006A0, "Wrong size on AFortNavigationGraph");

// Class FortniteGame.FortAbilitySystemComponentTooltipContext
// 0x0028 (0x0090 - 0x0068)
class UFortAbilitySystemComponentTooltipContext final : public UFortTooltipContext
{
public:
	struct FGameplayAttribute                     Attribute;                                         // 0x0068(0x0020)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FActiveGameplayEffectHandle            ActiveGEHandle;                                    // 0x0088(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UFortAbilitySystemComponentTooltipContext* SpawnAbilitySystemTooltipContext();
	static class UFortAbilitySystemComponentTooltipContext* SpawnAbilitySystemTooltipContextFromOtherContext(const class UFortTooltipContext* OtherContext);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAbilitySystemComponentTooltipContext">();
	}
	static class UFortAbilitySystemComponentTooltipContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAbilitySystemComponentTooltipContext>();
	}
};
static_assert(alignof(UFortAbilitySystemComponentTooltipContext) == 0x000008, "Wrong alignment on UFortAbilitySystemComponentTooltipContext");
static_assert(sizeof(UFortAbilitySystemComponentTooltipContext) == 0x000090, "Wrong size on UFortAbilitySystemComponentTooltipContext");
static_assert(offsetof(UFortAbilitySystemComponentTooltipContext, Attribute) == 0x000068, "Member 'UFortAbilitySystemComponentTooltipContext::Attribute' has a wrong offset!");
static_assert(offsetof(UFortAbilitySystemComponentTooltipContext, ActiveGEHandle) == 0x000088, "Member 'UFortAbilitySystemComponentTooltipContext::ActiveGEHandle' has a wrong offset!");

// Class FortniteGame.FortAIDirectorEventManager
// 0x0050 (0x03D8 - 0x0388)
class AFortAIDirectorEventManager final : public AActor
{
public:
	uint8                                         Pad_388[0x50];                                     // 0x0388(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIDirectorEventManager">();
	}
	static class AFortAIDirectorEventManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAIDirectorEventManager>();
	}
};
static_assert(alignof(AFortAIDirectorEventManager) == 0x000008, "Wrong alignment on AFortAIDirectorEventManager");
static_assert(sizeof(AFortAIDirectorEventManager) == 0x0003D8, "Wrong size on AFortAIDirectorEventManager");

// Class FortniteGame.BuildingTrapFloor
// 0x0000 (0x10E0 - 0x10E0)
#pragma pack(push, 0x1)
class alignas(0x10) ABuildingTrapFloor : public ABuildingTrap
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingTrapFloor">();
	}
	static class ABuildingTrapFloor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingTrapFloor>();
	}
};
#pragma pack(pop)
static_assert(alignof(ABuildingTrapFloor) == 0x000010, "Wrong alignment on ABuildingTrapFloor");
static_assert(sizeof(ABuildingTrapFloor) == 0x0010E0, "Wrong size on ABuildingTrapFloor");

// Class FortniteGame.BuildingTrapDefender
// 0x0050 (0x1130 - 0x10E0)
class ABuildingTrapDefender final : public ABuildingTrapFloor
{
public:
	EFortDefenderInteractionError                 LastInteractError;                                 // 0x10D8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10D9[0x7];                                     // 0x10D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortAIPawn*                            DefenderPawn;                                      // 0x10E0(0x0008)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortDefenderItemDefinition*            DefenderItemDefinition;                            // 0x10E8(0x0008)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DefenderItemLevel;                                 // 0x10F0(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10F4[0x4];                                     // 0x10F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   DefenderPawnOrItemSet;                             // 0x10F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, BlueprintCallable, NativeAccessSpecifierProtected)
	uint8                                         Pad_1108[0x28];                                    // 0x1108(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearCurrentDefender(bool bForceKillDefender);
	void DeployDefender(const class AFortPlayerController* ItemSelectorPC, const class UFortDefenderItem* InDefenderItem, const class FName& InDefenderSquadId);
	class FText GetLastInteractErrorText();
	void OnRep_DefenderItemDefinition();
	void OnRep_DefenderPawn();
	void RemoveCurrentDefender(class AFortPlayerStateZone* RequestingPlayer, bool bRemovalCausedByPlayerJoin);
	class AFortAIPawn* SpawnDefenderfromItem(class UFortAccountItem* DefenderItem, const class FName& DefenderSquadId, const struct FTransform& SpawnTransform, class AActor* InOwner);

	struct FTransform GetDefenderSpawnTransform() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingTrapDefender">();
	}
	static class ABuildingTrapDefender* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingTrapDefender>();
	}
};
static_assert(alignof(ABuildingTrapDefender) == 0x000010, "Wrong alignment on ABuildingTrapDefender");
static_assert(sizeof(ABuildingTrapDefender) == 0x001130, "Wrong size on ABuildingTrapDefender");
static_assert(offsetof(ABuildingTrapDefender, LastInteractError) == 0x0010D8, "Member 'ABuildingTrapDefender::LastInteractError' has a wrong offset!");
static_assert(offsetof(ABuildingTrapDefender, DefenderPawn) == 0x0010E0, "Member 'ABuildingTrapDefender::DefenderPawn' has a wrong offset!");
static_assert(offsetof(ABuildingTrapDefender, DefenderItemDefinition) == 0x0010E8, "Member 'ABuildingTrapDefender::DefenderItemDefinition' has a wrong offset!");
static_assert(offsetof(ABuildingTrapDefender, DefenderItemLevel) == 0x0010F0, "Member 'ABuildingTrapDefender::DefenderItemLevel' has a wrong offset!");
static_assert(offsetof(ABuildingTrapDefender, DefenderPawnOrItemSet) == 0x0010F8, "Member 'ABuildingTrapDefender::DefenderPawnOrItemSet' has a wrong offset!");

// Class FortniteGame.FortAIFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UFortAIFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void MakeNoiseEvent(class AActor* NoiseMaker, float MaxRange);
	static void MakeNoiseEventAtLocation(class AActor* NoiseMaker, float MaxRange, const struct FVector& NoiseLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIFunctionLibrary">();
	}
	static class UFortAIFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIFunctionLibrary>();
	}
};
static_assert(alignof(UFortAIFunctionLibrary) == 0x000008, "Wrong alignment on UFortAIFunctionLibrary");
static_assert(sizeof(UFortAIFunctionLibrary) == 0x000028, "Wrong size on UFortAIFunctionLibrary");

// Class FortniteGame.FortTrapTooltip
// 0x0020 (0x00B0 - 0x0090)
class UFortTrapTooltip final : public UFortWorldItemTooltip
{
public:
	uint8                                         Pad_90[0x20];                                      // 0x0090(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetNumericValue(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, float* OutVal) const;
	bool GetTextForToken(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, class FText* OutText) const;
	bool GetTokenizedDescriptionText(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, TArray<class FText>* OutDescription) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTrapTooltip">();
	}
	static class UFortTrapTooltip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortTrapTooltip>();
	}
};
static_assert(alignof(UFortTrapTooltip) == 0x000008, "Wrong alignment on UFortTrapTooltip");
static_assert(sizeof(UFortTrapTooltip) == 0x0000B0, "Wrong size on UFortTrapTooltip");

// Class FortniteGame.BuildingTrapWall
// 0x0000 (0x10E0 - 0x10E0)
class ABuildingTrapWall final : public ABuildingTrap
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingTrapWall">();
	}
	static class ABuildingTrapWall* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingTrapWall>();
	}
};
static_assert(alignof(ABuildingTrapWall) == 0x000010, "Wrong alignment on ABuildingTrapWall");
static_assert(sizeof(ABuildingTrapWall) == 0x0010E0, "Wrong size on ABuildingTrapWall");

// Class FortniteGame.BuildingWall
// 0x00F0 (0x10B0 - 0x0FC0)
class ABuildingWall : public ABuildingSMActor
{
public:
	uint8                                         Pad_FC0[0x8];                                      // 0x0FC0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FClimbLinkData                         ClimbLink;                                         // 0x0FC8(0x002C)(DuplicateTransient, NoDestructor, NativeAccessSpecifierPublic)
	EBuildingWallArea                             AreaShapeType;                                     // 0x0FF4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FF5[0x3];                                      // 0x0FF5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DoorOffset;                                        // 0x0FF8(0x000C)(Edit, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1004[0x4];                                     // 0x1004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   DoorObstacleClass;                                 // 0x1008(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             DoorOpeningSound;                                  // 0x1028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             DoorClosingSound;                                  // 0x1030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     DoorAnimatingMaterial;                             // 0x1038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            DoorMesh;                                          // 0x1040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   DoorComponent;                                     // 0x1048(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortDoorLinkComponent*                 DoorSmartLinkComp;                                 // 0x1050(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   DoorBlueprintMeshComp;                             // 0x1058(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMaterialInstanceDynamic*>       DoorAnimatingMIDs;                                 // 0x1060(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         bDoorOpen : 1;                                     // 0x1070(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDoorCollisionDisabled : 1;                        // 0x1070(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Net, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1071[0x3];                                     // 0x1071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               DoorDesiredRotation;                               // 0x1074(0x000C)(Net, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1080[0x24];                                    // 0x1080(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBuildingActorNavArea                  AreaPatternOverride;                               // 0x10A4(0x0004)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_10A8[0x4];                                     // 0x10A8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bCreateClimbLink : 1;                              // 0x10AC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_10AD[0x3];                                     // 0x10AD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_bDoorCollisionDisabled();
	void OnRep_bDoorOpen();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingWall">();
	}
	static class ABuildingWall* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingWall>();
	}
};
static_assert(alignof(ABuildingWall) == 0x000010, "Wrong alignment on ABuildingWall");
static_assert(sizeof(ABuildingWall) == 0x0010B0, "Wrong size on ABuildingWall");
static_assert(offsetof(ABuildingWall, ClimbLink) == 0x000FC8, "Member 'ABuildingWall::ClimbLink' has a wrong offset!");
static_assert(offsetof(ABuildingWall, AreaShapeType) == 0x000FF4, "Member 'ABuildingWall::AreaShapeType' has a wrong offset!");
static_assert(offsetof(ABuildingWall, DoorOffset) == 0x000FF8, "Member 'ABuildingWall::DoorOffset' has a wrong offset!");
static_assert(offsetof(ABuildingWall, DoorObstacleClass) == 0x001008, "Member 'ABuildingWall::DoorObstacleClass' has a wrong offset!");
static_assert(offsetof(ABuildingWall, DoorOpeningSound) == 0x001028, "Member 'ABuildingWall::DoorOpeningSound' has a wrong offset!");
static_assert(offsetof(ABuildingWall, DoorClosingSound) == 0x001030, "Member 'ABuildingWall::DoorClosingSound' has a wrong offset!");
static_assert(offsetof(ABuildingWall, DoorAnimatingMaterial) == 0x001038, "Member 'ABuildingWall::DoorAnimatingMaterial' has a wrong offset!");
static_assert(offsetof(ABuildingWall, DoorMesh) == 0x001040, "Member 'ABuildingWall::DoorMesh' has a wrong offset!");
static_assert(offsetof(ABuildingWall, DoorComponent) == 0x001048, "Member 'ABuildingWall::DoorComponent' has a wrong offset!");
static_assert(offsetof(ABuildingWall, DoorSmartLinkComp) == 0x001050, "Member 'ABuildingWall::DoorSmartLinkComp' has a wrong offset!");
static_assert(offsetof(ABuildingWall, DoorBlueprintMeshComp) == 0x001058, "Member 'ABuildingWall::DoorBlueprintMeshComp' has a wrong offset!");
static_assert(offsetof(ABuildingWall, DoorAnimatingMIDs) == 0x001060, "Member 'ABuildingWall::DoorAnimatingMIDs' has a wrong offset!");
static_assert(offsetof(ABuildingWall, DoorDesiredRotation) == 0x001074, "Member 'ABuildingWall::DoorDesiredRotation' has a wrong offset!");
static_assert(offsetof(ABuildingWall, AreaPatternOverride) == 0x0010A4, "Member 'ABuildingWall::AreaPatternOverride' has a wrong offset!");

// Class FortniteGame.FortInescapableZoneTracker
// 0x0040 (0x0068 - 0x0028)
class UFortInescapableZoneTracker final : public UObject
{
public:
	class AFortNavigationGraph*                   NavGraph;                                          // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30[0x38];                                      // 0x0030(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortInescapableZoneTracker">();
	}
	static class UFortInescapableZoneTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortInescapableZoneTracker>();
	}
};
static_assert(alignof(UFortInescapableZoneTracker) == 0x000008, "Wrong alignment on UFortInescapableZoneTracker");
static_assert(sizeof(UFortInescapableZoneTracker) == 0x000068, "Wrong size on UFortInescapableZoneTracker");
static_assert(offsetof(UFortInescapableZoneTracker, NavGraph) == 0x000028, "Member 'UFortInescapableZoneTracker::NavGraph' has a wrong offset!");

// Class FortniteGame.FortAIEncounterInfo
// 0x0BD8 (0x0C00 - 0x0028)
class UFortAIEncounterInfo final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAISpawnGroupProgressionInfo*       SpawnGroupProgressionInfo;                         // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFortSpawnPointsPercentageCurveSequenceInstanceInfo SpawnPointsPercentageCurveSequence;                // 0x0040(0x0010)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FFortIntensityCurveSequenceInstanceInfo IntensityCurveSequence;                            // 0x0050(0x0010)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         BurstSpawnPointsPercentage;                        // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpawnPointsMultiplier;                             // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseBreathers;                                     // 0x0068(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCurveTableRowHandle                   LowPlayerPerformanceBreatherTimeSecondsCurve;      // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   NormalPlayerPerformanceBreatherTimeSecondsCurve;   // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   HighPlayerPerformanceBreatherTimeSecondsCurve;     // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         EncounterTimeSeconds;                              // 0x00A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUtilityTypeFloatPair>          LockedUtilityValues;                               // 0x00A8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         NumFreeUtilities;                                  // 0x00B8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         UtilityAdjustmentPeriodSeconds;                    // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinSpawnDistance;                                  // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxSpawnDistance;                                  // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumDirections;                                     // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bChangeDirectionsOnRest;                           // 0x00CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CD[0x3];                                       // 0x00CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnPointsPercentageLimit;                        // 0x00D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PawnNumberLimit;                                   // 0x00D4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFortEncounterPawnNumberCaps           PawnNumberCaps;                                    // 0x00D8(0x0018)(Protected, NativeAccessSpecifierProtected)
	float                                         SpawningIntervalSeconds;                           // 0x00F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnEncounterSpawnDirectionsChosen;                  // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         NextSpawningTime;                                  // 0x0108(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortAIEncounterSpawnGroupCapsProfile  EncounterSpawnGroupCapsProfile;                    // 0x0110(0x0030)(NativeAccessSpecifierPublic)
	struct FFortAIEncounterSpawnPointsProfile     EncounterSpawnPointsProfile;                       // 0x0140(0x0040)(NativeAccessSpecifierPublic)
	TArray<struct FFortAISpawnGroupUpgrade>       AvailableUpgrades;                                 // 0x0180(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCurveTableRowHandle>           PawnDifficultyLevelModifiers;                      // 0x0190(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FCurveTableRowHandle                   DesiredHostilityCurve;                             // 0x01A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	class UFortIntensityCurveSequenceProgression* IntensitySequenceProgression;                      // 0x01B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B8[0x70];                                     // 0x01B8(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AliveMultiplier;                                   // 0x0228(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortEncounterSpawnLimitType                  SpawnLimitType;                                    // 0x022C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22D[0x3];                                      // 0x022D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SpawnLimit;                                        // 0x0230(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PawnNumberLimitProgress;                           // 0x0234(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpawnPointsLimitProgress;                          // 0x0238(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnLimitReached;                                // 0x023C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasSpawnedAllBurstSpawnAI;                        // 0x023D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideAliveCounts;                              // 0x023E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23F[0x1];                                      // 0x023F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinAliveOverride;                                  // 0x0240(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxAliveOverride;                                  // 0x0244(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HostilityThreshold;                                // 0x0248(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PeakTimeSeconds;                                   // 0x024C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BreatherTimeSeconds;                               // 0x0250(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRampTimeSeconds;                                // 0x0254(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTimeBetweenBreathesSeconds;                     // 0x0258(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFadeTimeSeconds;                                // 0x025C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeEndIntensity;                                  // 0x0260(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeEndRemainingSpawnPointsPercentage;             // 0x0264(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CompletionPercentageToDisableBreathers;            // 0x0268(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26C[0x4];                                      // 0x026C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnEncounterAllEnemiesKilled;                       // 0x0270(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnEncounterEnemySpawned;                           // 0x0280(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnEncounterCompleted;                              // 0x0290(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnEncounterPawnDied;                               // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B0[0x3];                                      // 0x02B0(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDisplayThreatVisuals;                             // 0x02B3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseDesiredUtilities[0x10];                        // 0x02B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F4[0x4];                                      // 0x02F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  UtilitiesRequiredTags[0x10];                       // 0x02F8(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  InjectedTagForUtilityCheck;                        // 0x04F8(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_518[0x4];                                      // 0x0518(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxLargeSpawnGroupDiscountInterval;                // 0x051C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSelectionToSpawningDelay;                       // 0x0520(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_524[0x54];                                     // 0x0524(0x0054)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUtilityTypeFloatPair>          CurrentDesiredUtilities;                           // 0x0578(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         UtilityRecentSelectionPenalties[0x10];             // 0x0588(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UtilityEffectivenessMeasurements[0x10];            // 0x05C8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCurveTableRowHandle                   UtilityEffectivenessMultiplierCurve;               // 0x0608(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	float                                         UtilityEffectivenessInfluenceCap;                  // 0x0618(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61C[0x4];                                      // 0x061C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUtilityTypeFloatPair>          CurrentTopUtilityPercentages;                      // 0x0620(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EFortAIUtility>                        UsedTopUtilities;                                  // 0x0630(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	int32                                         NumUtilitiesConsidered;                            // 0x0640(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReactivityPercentage;                              // 0x0644(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAdjustUtilitiesDuringRest;                        // 0x0648(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDespawnAIsDuringRest;                             // 0x0649(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64A[0x2];                                      // 0x064A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastPlayerCombatFactorUpdateTime;                  // 0x064C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastUtilityAdjustTime;                             // 0x0650(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastSpawnPointAdjustmentTime;                      // 0x0654(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastLargeGroupSpawnTime;                           // 0x0658(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65C[0x4];                                      // 0x065C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAIEncounterSpawnGroupWeights>  EnemySpawnData;                                    // 0x0660(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FFortAIEncounterPIDController          EncounterPIDController;                            // 0x0670(0x0068)(NoDestructor, NativeAccessSpecifierPublic)
	int32                                         CurrentSpawnPointsCap;                             // 0x06D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentSpawnPointsUsed;                            // 0x06DC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6E0[0x8];                                      // 0x06E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FailSafeMinSpawnPoints;                            // 0x06E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6EC[0x4];                                      // 0x06EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSpawnGroupInstanceInfo>        ActiveSpawnGroups;                                 // 0x06F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         EncounterEngagementDistance;                       // 0x0700(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRelevantBuildingDamagedDistance;                // 0x0704(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRelevantBuildingDamagedDistance;                // 0x0708(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_70C[0x14];                                     // 0x070C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 CurrentGroupSpawnPoint;                            // 0x0720(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortEncounterState                           EncounterState;                                    // 0x0728(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortEncounterPacingState                     PacingState;                                       // 0x0729(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72A[0x2];                                      // 0x072A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastPacingStateTransitionTime;                     // 0x072C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFortAIEncounterWaveProgressEstimation WaveProgressEstimate;                              // 0x0730(0x001C)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         DesiredDifficultyLevel;                            // 0x074C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DifficultyLevelOverride;                           // 0x0750(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_754[0x4];                                      // 0x0754(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortAIDirector*                        MyAIDirector;                                      // 0x0758(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFortGoalActorEncounterDataManagerPair> DataManagers;                                      // 0x0760(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class AActor*                                 TargetObjective;                                   // 0x0770(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyActiveAtNight;                                // 0x0778(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_779[0x3];                                      // 0x0779(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumRiftsToUse;                                     // 0x077C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinRiftsToUse;                                     // 0x0780(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumRiftsUsed;                                      // 0x0784(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFortEncounterSettings                 EncounterSettings;                                 // 0x0788(0x0058)(NativeAccessSpecifierPublic)
	float                                         EncounterStartTime;                                // 0x07E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HostilityCurveStartTime;                           // 0x07E4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEncounterEnvironmentQueryInfo         DefaultEnvironmentQueryInfo;                       // 0x07E8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FEncounterEnvironmentQueryInfo         FallbackEnvironmentQueryInfo;                      // 0x0810(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FEncounterEnvironmentQueryInfo         OverrideEnvironmentQueryInfo;                      // 0x0838(0x0028)(NativeAccessSpecifierPublic)
	struct FEncounterEnvironmentQueryInfo         CurrentEnvironmentQueryInfo;                       // 0x0860(0x0028)(NativeAccessSpecifierPublic)
	bool                                          bNukeWavesAtDaybreak;                              // 0x0888(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNukeWavesAtEncounterEnd;                          // 0x0889(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNukeWavesAtEncounterDeactivation;                 // 0x088A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_88B[0x1];                                      // 0x088B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ObjectiveSafeRadius;                               // 0x088C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActiveEnemyCap;                                    // 0x0890(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentHostilityLevel;                             // 0x0894(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HostilityScalePerPlayerCount[0x4];                 // 0x0898(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnEncounterRampStarted;                            // 0x08A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnEncounterPeakStarted;                            // 0x08B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnEncounterFadeStarted;                            // 0x08C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnEncounterRestStarted;                            // 0x08D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnEncounterCombatParticipation;                    // 0x08E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class ABuildingRift>              RiftClassTemplate;                                 // 0x08F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_900[0x20];                                     // 0x0900(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TWeakObjectPtr<class AActor>, struct FFortAISpawnerData> ExternalAISpawners;                                // 0x0920(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UFortAIEncounterRiftManager*            RiftManager;                                       // 0x0970(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 AssociatedMissionName;                             // 0x0978(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bCanBeActive : 1;                                  // 0x0988(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_989[0x7];                                      // 0x0989(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UFortAIAssignment*>              EncounterAssignments;                              // 0x0990(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UFortAIAssignmentSettings*              DefaultEncounterAssignmentSettings;                // 0x09A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A8[0x20];                                     // 0x09A8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxActiveAlive;                                    // 0x09C8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSpawnPointsUsed;                                // 0x09CC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            OverrideSpawnPointsCurve;                          // 0x09D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9D8[0x1F8];                                    // 0x09D8(0x01F8)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUseAILifespans;                                   // 0x0BD0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTrackCombatParticipation;                         // 0x0BD1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BD2[0x6];                                      // 0x0BD2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  ModifierTags;                                      // 0x0BD8(0x0020)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	class AFortGameplayMutator_AILevelVariance*   AILevelMutator;                                    // 0x0BF8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UFortAIAssignment* CreateEncounterAssignment(class UFortAIAssignmentSettings* AssignmentSettings, class AActor* GoalActor);
	class AFortAIDirectorDataManager* GetEncounterDataManager();
	float GetEncounterTimeSeconds();
	bool GroupHasAIRemainingToSpawn(const struct FFortAISpawnerData& FortAISpawnerData);
	void OnEncounterPawnDamaged(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, class AActor* DamageCauser, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& Momentum);
	void OnFadeStarted();
	void OnGoalTakeDamage(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, class AActor* DamageCauser, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& Momentum);
	void OnPeakStarted();
	void OnRampStarted();
	void OnRestStarted();
	void RegisterAISpawner(class AActor* InAISpawner);
	void RequestActivation(int32 ActivationDelay);
	bool ReserveNextAIPawn(const struct FFortAISpawnerData& FortAISpawnerData, struct FFortSpawnAIRequest* FortAISpawnRequest);
	void SetEncounterActivationState(bool bEncounterActivityState);
	void SetPawnNumberLimit(int32 InPawnNumberLimit);
	void SpawnAIGroup(const class UFortAISpawnGroup* SpawnGroupToSpawn, const struct FVector& SpawnLocation, const struct FRotator& SpawnRotation, class AActor* SpawnSource, const TArray<class UFortAbilitySet*>& AbilitySetsToGrantOnSpawn, bool bAllowAssigningToExternalSpawners, float SecondsBetweenSpawns);
	class AFortAIPawn* SpawnAIPawnReservedForEnemySpawner(class AActor* EnemySpawner, const struct FVector& SpawnLocation, const struct FRotator& SpawnRotation);
	void UnRegisterAISpawner(class AActor* InAISpawner);

	bool EncounterHasReservedSpawnRequestForEnemySpawner(class AActor* EnemySpawner) const;
	bool GetCurrentSpawnAreaDirections(TArray<EFortEncounterDirection>* OutDirections) const;
	int32 GetPawnNumberLimit() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIEncounterInfo">();
	}
	static class UFortAIEncounterInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIEncounterInfo>();
	}
};
static_assert(alignof(UFortAIEncounterInfo) == 0x000008, "Wrong alignment on UFortAIEncounterInfo");
static_assert(sizeof(UFortAIEncounterInfo) == 0x000C00, "Wrong size on UFortAIEncounterInfo");
static_assert(offsetof(UFortAIEncounterInfo, SpawnGroupProgressionInfo) == 0x000038, "Member 'UFortAIEncounterInfo::SpawnGroupProgressionInfo' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, SpawnPointsPercentageCurveSequence) == 0x000040, "Member 'UFortAIEncounterInfo::SpawnPointsPercentageCurveSequence' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, IntensityCurveSequence) == 0x000050, "Member 'UFortAIEncounterInfo::IntensityCurveSequence' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, BurstSpawnPointsPercentage) == 0x000060, "Member 'UFortAIEncounterInfo::BurstSpawnPointsPercentage' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, SpawnPointsMultiplier) == 0x000064, "Member 'UFortAIEncounterInfo::SpawnPointsMultiplier' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, bUseBreathers) == 0x000068, "Member 'UFortAIEncounterInfo::bUseBreathers' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, LowPlayerPerformanceBreatherTimeSecondsCurve) == 0x000070, "Member 'UFortAIEncounterInfo::LowPlayerPerformanceBreatherTimeSecondsCurve' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, NormalPlayerPerformanceBreatherTimeSecondsCurve) == 0x000080, "Member 'UFortAIEncounterInfo::NormalPlayerPerformanceBreatherTimeSecondsCurve' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, HighPlayerPerformanceBreatherTimeSecondsCurve) == 0x000090, "Member 'UFortAIEncounterInfo::HighPlayerPerformanceBreatherTimeSecondsCurve' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, EncounterTimeSeconds) == 0x0000A0, "Member 'UFortAIEncounterInfo::EncounterTimeSeconds' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, LockedUtilityValues) == 0x0000A8, "Member 'UFortAIEncounterInfo::LockedUtilityValues' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, NumFreeUtilities) == 0x0000B8, "Member 'UFortAIEncounterInfo::NumFreeUtilities' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, UtilityAdjustmentPeriodSeconds) == 0x0000BC, "Member 'UFortAIEncounterInfo::UtilityAdjustmentPeriodSeconds' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, MinSpawnDistance) == 0x0000C0, "Member 'UFortAIEncounterInfo::MinSpawnDistance' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, MaxSpawnDistance) == 0x0000C4, "Member 'UFortAIEncounterInfo::MaxSpawnDistance' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, NumDirections) == 0x0000C8, "Member 'UFortAIEncounterInfo::NumDirections' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, bChangeDirectionsOnRest) == 0x0000CC, "Member 'UFortAIEncounterInfo::bChangeDirectionsOnRest' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, SpawnPointsPercentageLimit) == 0x0000D0, "Member 'UFortAIEncounterInfo::SpawnPointsPercentageLimit' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, PawnNumberLimit) == 0x0000D4, "Member 'UFortAIEncounterInfo::PawnNumberLimit' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, PawnNumberCaps) == 0x0000D8, "Member 'UFortAIEncounterInfo::PawnNumberCaps' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, SpawningIntervalSeconds) == 0x0000F0, "Member 'UFortAIEncounterInfo::SpawningIntervalSeconds' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, OnEncounterSpawnDirectionsChosen) == 0x0000F8, "Member 'UFortAIEncounterInfo::OnEncounterSpawnDirectionsChosen' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, NextSpawningTime) == 0x000108, "Member 'UFortAIEncounterInfo::NextSpawningTime' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, EncounterSpawnGroupCapsProfile) == 0x000110, "Member 'UFortAIEncounterInfo::EncounterSpawnGroupCapsProfile' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, EncounterSpawnPointsProfile) == 0x000140, "Member 'UFortAIEncounterInfo::EncounterSpawnPointsProfile' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, AvailableUpgrades) == 0x000180, "Member 'UFortAIEncounterInfo::AvailableUpgrades' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, PawnDifficultyLevelModifiers) == 0x000190, "Member 'UFortAIEncounterInfo::PawnDifficultyLevelModifiers' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, DesiredHostilityCurve) == 0x0001A0, "Member 'UFortAIEncounterInfo::DesiredHostilityCurve' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, IntensitySequenceProgression) == 0x0001B0, "Member 'UFortAIEncounterInfo::IntensitySequenceProgression' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, AliveMultiplier) == 0x000228, "Member 'UFortAIEncounterInfo::AliveMultiplier' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, SpawnLimitType) == 0x00022C, "Member 'UFortAIEncounterInfo::SpawnLimitType' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, SpawnLimit) == 0x000230, "Member 'UFortAIEncounterInfo::SpawnLimit' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, PawnNumberLimitProgress) == 0x000234, "Member 'UFortAIEncounterInfo::PawnNumberLimitProgress' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, SpawnPointsLimitProgress) == 0x000238, "Member 'UFortAIEncounterInfo::SpawnPointsLimitProgress' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, bSpawnLimitReached) == 0x00023C, "Member 'UFortAIEncounterInfo::bSpawnLimitReached' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, bHasSpawnedAllBurstSpawnAI) == 0x00023D, "Member 'UFortAIEncounterInfo::bHasSpawnedAllBurstSpawnAI' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, bOverrideAliveCounts) == 0x00023E, "Member 'UFortAIEncounterInfo::bOverrideAliveCounts' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, MinAliveOverride) == 0x000240, "Member 'UFortAIEncounterInfo::MinAliveOverride' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, MaxAliveOverride) == 0x000244, "Member 'UFortAIEncounterInfo::MaxAliveOverride' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, HostilityThreshold) == 0x000248, "Member 'UFortAIEncounterInfo::HostilityThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, PeakTimeSeconds) == 0x00024C, "Member 'UFortAIEncounterInfo::PeakTimeSeconds' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, BreatherTimeSeconds) == 0x000250, "Member 'UFortAIEncounterInfo::BreatherTimeSeconds' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, MaxRampTimeSeconds) == 0x000254, "Member 'UFortAIEncounterInfo::MaxRampTimeSeconds' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, MinTimeBetweenBreathesSeconds) == 0x000258, "Member 'UFortAIEncounterInfo::MinTimeBetweenBreathesSeconds' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, MaxFadeTimeSeconds) == 0x00025C, "Member 'UFortAIEncounterInfo::MaxFadeTimeSeconds' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, FadeEndIntensity) == 0x000260, "Member 'UFortAIEncounterInfo::FadeEndIntensity' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, FadeEndRemainingSpawnPointsPercentage) == 0x000264, "Member 'UFortAIEncounterInfo::FadeEndRemainingSpawnPointsPercentage' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, CompletionPercentageToDisableBreathers) == 0x000268, "Member 'UFortAIEncounterInfo::CompletionPercentageToDisableBreathers' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, OnEncounterAllEnemiesKilled) == 0x000270, "Member 'UFortAIEncounterInfo::OnEncounterAllEnemiesKilled' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, OnEncounterEnemySpawned) == 0x000280, "Member 'UFortAIEncounterInfo::OnEncounterEnemySpawned' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, OnEncounterCompleted) == 0x000290, "Member 'UFortAIEncounterInfo::OnEncounterCompleted' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, OnEncounterPawnDied) == 0x0002A0, "Member 'UFortAIEncounterInfo::OnEncounterPawnDied' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, bDisplayThreatVisuals) == 0x0002B3, "Member 'UFortAIEncounterInfo::bDisplayThreatVisuals' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, BaseDesiredUtilities) == 0x0002B4, "Member 'UFortAIEncounterInfo::BaseDesiredUtilities' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, UtilitiesRequiredTags) == 0x0002F8, "Member 'UFortAIEncounterInfo::UtilitiesRequiredTags' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, InjectedTagForUtilityCheck) == 0x0004F8, "Member 'UFortAIEncounterInfo::InjectedTagForUtilityCheck' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, MaxLargeSpawnGroupDiscountInterval) == 0x00051C, "Member 'UFortAIEncounterInfo::MaxLargeSpawnGroupDiscountInterval' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, MaxSelectionToSpawningDelay) == 0x000520, "Member 'UFortAIEncounterInfo::MaxSelectionToSpawningDelay' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, CurrentDesiredUtilities) == 0x000578, "Member 'UFortAIEncounterInfo::CurrentDesiredUtilities' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, UtilityRecentSelectionPenalties) == 0x000588, "Member 'UFortAIEncounterInfo::UtilityRecentSelectionPenalties' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, UtilityEffectivenessMeasurements) == 0x0005C8, "Member 'UFortAIEncounterInfo::UtilityEffectivenessMeasurements' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, UtilityEffectivenessMultiplierCurve) == 0x000608, "Member 'UFortAIEncounterInfo::UtilityEffectivenessMultiplierCurve' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, UtilityEffectivenessInfluenceCap) == 0x000618, "Member 'UFortAIEncounterInfo::UtilityEffectivenessInfluenceCap' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, CurrentTopUtilityPercentages) == 0x000620, "Member 'UFortAIEncounterInfo::CurrentTopUtilityPercentages' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, UsedTopUtilities) == 0x000630, "Member 'UFortAIEncounterInfo::UsedTopUtilities' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, NumUtilitiesConsidered) == 0x000640, "Member 'UFortAIEncounterInfo::NumUtilitiesConsidered' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, ReactivityPercentage) == 0x000644, "Member 'UFortAIEncounterInfo::ReactivityPercentage' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, bAdjustUtilitiesDuringRest) == 0x000648, "Member 'UFortAIEncounterInfo::bAdjustUtilitiesDuringRest' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, bDespawnAIsDuringRest) == 0x000649, "Member 'UFortAIEncounterInfo::bDespawnAIsDuringRest' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, LastPlayerCombatFactorUpdateTime) == 0x00064C, "Member 'UFortAIEncounterInfo::LastPlayerCombatFactorUpdateTime' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, LastUtilityAdjustTime) == 0x000650, "Member 'UFortAIEncounterInfo::LastUtilityAdjustTime' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, LastSpawnPointAdjustmentTime) == 0x000654, "Member 'UFortAIEncounterInfo::LastSpawnPointAdjustmentTime' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, LastLargeGroupSpawnTime) == 0x000658, "Member 'UFortAIEncounterInfo::LastLargeGroupSpawnTime' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, EnemySpawnData) == 0x000660, "Member 'UFortAIEncounterInfo::EnemySpawnData' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, EncounterPIDController) == 0x000670, "Member 'UFortAIEncounterInfo::EncounterPIDController' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, CurrentSpawnPointsCap) == 0x0006D8, "Member 'UFortAIEncounterInfo::CurrentSpawnPointsCap' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, CurrentSpawnPointsUsed) == 0x0006DC, "Member 'UFortAIEncounterInfo::CurrentSpawnPointsUsed' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, FailSafeMinSpawnPoints) == 0x0006E8, "Member 'UFortAIEncounterInfo::FailSafeMinSpawnPoints' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, ActiveSpawnGroups) == 0x0006F0, "Member 'UFortAIEncounterInfo::ActiveSpawnGroups' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, EncounterEngagementDistance) == 0x000700, "Member 'UFortAIEncounterInfo::EncounterEngagementDistance' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, MinRelevantBuildingDamagedDistance) == 0x000704, "Member 'UFortAIEncounterInfo::MinRelevantBuildingDamagedDistance' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, MaxRelevantBuildingDamagedDistance) == 0x000708, "Member 'UFortAIEncounterInfo::MaxRelevantBuildingDamagedDistance' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, CurrentGroupSpawnPoint) == 0x000720, "Member 'UFortAIEncounterInfo::CurrentGroupSpawnPoint' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, EncounterState) == 0x000728, "Member 'UFortAIEncounterInfo::EncounterState' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, PacingState) == 0x000729, "Member 'UFortAIEncounterInfo::PacingState' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, LastPacingStateTransitionTime) == 0x00072C, "Member 'UFortAIEncounterInfo::LastPacingStateTransitionTime' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, WaveProgressEstimate) == 0x000730, "Member 'UFortAIEncounterInfo::WaveProgressEstimate' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, DesiredDifficultyLevel) == 0x00074C, "Member 'UFortAIEncounterInfo::DesiredDifficultyLevel' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, DifficultyLevelOverride) == 0x000750, "Member 'UFortAIEncounterInfo::DifficultyLevelOverride' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, MyAIDirector) == 0x000758, "Member 'UFortAIEncounterInfo::MyAIDirector' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, DataManagers) == 0x000760, "Member 'UFortAIEncounterInfo::DataManagers' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, TargetObjective) == 0x000770, "Member 'UFortAIEncounterInfo::TargetObjective' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, bOnlyActiveAtNight) == 0x000778, "Member 'UFortAIEncounterInfo::bOnlyActiveAtNight' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, NumRiftsToUse) == 0x00077C, "Member 'UFortAIEncounterInfo::NumRiftsToUse' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, MinRiftsToUse) == 0x000780, "Member 'UFortAIEncounterInfo::MinRiftsToUse' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, NumRiftsUsed) == 0x000784, "Member 'UFortAIEncounterInfo::NumRiftsUsed' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, EncounterSettings) == 0x000788, "Member 'UFortAIEncounterInfo::EncounterSettings' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, EncounterStartTime) == 0x0007E0, "Member 'UFortAIEncounterInfo::EncounterStartTime' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, HostilityCurveStartTime) == 0x0007E4, "Member 'UFortAIEncounterInfo::HostilityCurveStartTime' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, DefaultEnvironmentQueryInfo) == 0x0007E8, "Member 'UFortAIEncounterInfo::DefaultEnvironmentQueryInfo' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, FallbackEnvironmentQueryInfo) == 0x000810, "Member 'UFortAIEncounterInfo::FallbackEnvironmentQueryInfo' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, OverrideEnvironmentQueryInfo) == 0x000838, "Member 'UFortAIEncounterInfo::OverrideEnvironmentQueryInfo' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, CurrentEnvironmentQueryInfo) == 0x000860, "Member 'UFortAIEncounterInfo::CurrentEnvironmentQueryInfo' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, bNukeWavesAtDaybreak) == 0x000888, "Member 'UFortAIEncounterInfo::bNukeWavesAtDaybreak' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, bNukeWavesAtEncounterEnd) == 0x000889, "Member 'UFortAIEncounterInfo::bNukeWavesAtEncounterEnd' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, bNukeWavesAtEncounterDeactivation) == 0x00088A, "Member 'UFortAIEncounterInfo::bNukeWavesAtEncounterDeactivation' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, ObjectiveSafeRadius) == 0x00088C, "Member 'UFortAIEncounterInfo::ObjectiveSafeRadius' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, ActiveEnemyCap) == 0x000890, "Member 'UFortAIEncounterInfo::ActiveEnemyCap' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, CurrentHostilityLevel) == 0x000894, "Member 'UFortAIEncounterInfo::CurrentHostilityLevel' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, HostilityScalePerPlayerCount) == 0x000898, "Member 'UFortAIEncounterInfo::HostilityScalePerPlayerCount' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, OnEncounterRampStarted) == 0x0008A8, "Member 'UFortAIEncounterInfo::OnEncounterRampStarted' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, OnEncounterPeakStarted) == 0x0008B8, "Member 'UFortAIEncounterInfo::OnEncounterPeakStarted' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, OnEncounterFadeStarted) == 0x0008C8, "Member 'UFortAIEncounterInfo::OnEncounterFadeStarted' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, OnEncounterRestStarted) == 0x0008D8, "Member 'UFortAIEncounterInfo::OnEncounterRestStarted' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, OnEncounterCombatParticipation) == 0x0008E8, "Member 'UFortAIEncounterInfo::OnEncounterCombatParticipation' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, RiftClassTemplate) == 0x0008F8, "Member 'UFortAIEncounterInfo::RiftClassTemplate' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, ExternalAISpawners) == 0x000920, "Member 'UFortAIEncounterInfo::ExternalAISpawners' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, RiftManager) == 0x000970, "Member 'UFortAIEncounterInfo::RiftManager' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, AssociatedMissionName) == 0x000978, "Member 'UFortAIEncounterInfo::AssociatedMissionName' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, EncounterAssignments) == 0x000990, "Member 'UFortAIEncounterInfo::EncounterAssignments' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, DefaultEncounterAssignmentSettings) == 0x0009A0, "Member 'UFortAIEncounterInfo::DefaultEncounterAssignmentSettings' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, MaxActiveAlive) == 0x0009C8, "Member 'UFortAIEncounterInfo::MaxActiveAlive' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, MaxSpawnPointsUsed) == 0x0009CC, "Member 'UFortAIEncounterInfo::MaxSpawnPointsUsed' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, OverrideSpawnPointsCurve) == 0x0009D0, "Member 'UFortAIEncounterInfo::OverrideSpawnPointsCurve' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, bUseAILifespans) == 0x000BD0, "Member 'UFortAIEncounterInfo::bUseAILifespans' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, bTrackCombatParticipation) == 0x000BD1, "Member 'UFortAIEncounterInfo::bTrackCombatParticipation' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, ModifierTags) == 0x000BD8, "Member 'UFortAIEncounterInfo::ModifierTags' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, AILevelMutator) == 0x000BF8, "Member 'UFortAIEncounterInfo::AILevelMutator' has a wrong offset!");

// Class FortniteGame.FortQueryTest_IsGoalForAssignment
// 0x0038 (0x01F8 - 0x01C0)
class UFortQueryTest_IsGoalForAssignment final : public UEnvQueryTest
{
public:
	bool                                          bRetrieveRootAssignmentFromOwner;                  // 0x01C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C1[0x7];                                      // 0x01C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortAIAssignmentIdentifier            RootAssignmentID;                                  // 0x01C8(0x0030)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_IsGoalForAssignment">();
	}
	static class UFortQueryTest_IsGoalForAssignment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_IsGoalForAssignment>();
	}
};
static_assert(alignof(UFortQueryTest_IsGoalForAssignment) == 0x000008, "Wrong alignment on UFortQueryTest_IsGoalForAssignment");
static_assert(sizeof(UFortQueryTest_IsGoalForAssignment) == 0x0001F8, "Wrong size on UFortQueryTest_IsGoalForAssignment");
static_assert(offsetof(UFortQueryTest_IsGoalForAssignment, bRetrieveRootAssignmentFromOwner) == 0x0001C0, "Member 'UFortQueryTest_IsGoalForAssignment::bRetrieveRootAssignmentFromOwner' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_IsGoalForAssignment, RootAssignmentID) == 0x0001C8, "Member 'UFortQueryTest_IsGoalForAssignment::RootAssignmentID' has a wrong offset!");

// Class FortniteGame.FortPlayerSpawnPad
// 0x0020 (0x0FE0 - 0x0FC0)
class AFortPlayerSpawnPad final : public ABuildingSMActor
{
public:
	TArray<class UStaticMeshComponent*>           Chests;                                            // 0x0FC0(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_FD0[0x10];                                     // 0x0FD0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChestProgressionUpdate(const struct FVector& PrimaryChestOffset, const struct FVector& ChestOffset);
	void InitializeChestProgression();
	void PrestreamChestTextures();

	void GetPossessedPlayerPawnsByID(TArray<class AFortPlayerPawn*>* SortedPlayerPawns) const;
	int32 GetRewardedChestLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerSpawnPad">();
	}
	static class AFortPlayerSpawnPad* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerSpawnPad>();
	}
};
static_assert(alignof(AFortPlayerSpawnPad) == 0x000010, "Wrong alignment on AFortPlayerSpawnPad");
static_assert(sizeof(AFortPlayerSpawnPad) == 0x000FE0, "Wrong size on AFortPlayerSpawnPad");
static_assert(offsetof(AFortPlayerSpawnPad, Chests) == 0x000FC0, "Member 'AFortPlayerSpawnPad::Chests' has a wrong offset!");

// Class FortniteGame.KeepHeartBase
// 0x00B0 (0x1070 - 0x0FC0)
#pragma pack(push, 0x1)
class alignas(0x10) AKeepHeartBase : public ABuildingSMActor
{
public:
	TSoftClassPtr<class UClass>                   BuildingInstructionsHandlerClass;                  // 0x0FC0(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FE0[0x80];                                     // 0x0FE0(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortSaveFileBuildingInstructionsHandler* SaveFileInstructionsHandler;                       // 0x1060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool IsKeepLoaded();
	bool IsKeepOwner(const class AFortPlayerController* FortPC);
	void LoadUserKeep(class AFortPlayerController* FortPC);
	bool ResetUserKeep(class AFortPlayerController* FortPC);
	bool SaveUserKeep(class AFortPlayerController* FortPC);
	void SetAllowLooting(bool bAllowed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KeepHeartBase">();
	}
	static class AKeepHeartBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKeepHeartBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(AKeepHeartBase) == 0x000010, "Wrong alignment on AKeepHeartBase");
static_assert(sizeof(AKeepHeartBase) == 0x001070, "Wrong size on AKeepHeartBase");
static_assert(offsetof(AKeepHeartBase, BuildingInstructionsHandlerClass) == 0x000FC0, "Member 'AKeepHeartBase::BuildingInstructionsHandlerClass' has a wrong offset!");
static_assert(offsetof(AKeepHeartBase, SaveFileInstructionsHandler) == 0x001060, "Member 'AKeepHeartBase::SaveFileInstructionsHandler' has a wrong offset!");

// Class FortniteGame.FortTeamInfoPvPBaseDestruction
// 0x0250 (0x06D0 - 0x0480)
class AFortTeamInfoPvPBaseDestruction final : public AFortTeamInfo
{
public:
	class AFortPvPBaseCornerstone*                TeamCornerstone;                                   // 0x0480(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTeamStrategicBuildingEntryArray       TeamStrategicBuildingActors;                       // 0x0488(0x00C0)(Net, Transient, Protected, NativeAccessSpecifierProtected)
	struct FTeamFOBCoreBuildingEntryArray         TeamFOBCoreBuildingActors;                         // 0x0548(0x00C0)(Net, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         bAllFOBCoresLoaded : 1;                            // 0x0608(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_609[0x77];                                     // 0x0609(0x0077)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StrategicBuildingHandleGenerator;                  // 0x0680(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TeamLevel;                                         // 0x0684(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnHandleTeamLevelChanged;                          // 0x0688(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	int32                                         TeamExperience;                                    // 0x0698(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_69C[0x4];                                      // 0x069C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnHandleTeamXPChanged;                             // 0x06A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnFOBCoresLoaded;                                  // 0x06B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnFOBCoresDestroyed;                               // 0x06C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)

public:
	void GetTeamFOBCores(TArray<class ABuildingFOBCoreActor*>* OutFOBCores);
	void GetTeamFOBCoresAndSpawnTags(TArray<class ABuildingFOBCoreActor*>* OutFOBCores, TArray<struct FGameplayTagContainer>* OutFOBSpawnTags);
	void OnRep_AllFOBCoresLoaded();
	void OnRep_TeamExperience();
	void OnRep_TeamFOBCoreBuildingActors();
	void OnRep_TeamLevel();

	class AStrategicBuildingActor* GetStrategicBuildingActor(const struct FTeamStrategicBuildingHandle& Handle) const;
	class AFortPvPBaseCornerstone* GetTeamCornerstone() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTeamInfoPvPBaseDestruction">();
	}
	static class AFortTeamInfoPvPBaseDestruction* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortTeamInfoPvPBaseDestruction>();
	}
};
static_assert(alignof(AFortTeamInfoPvPBaseDestruction) == 0x000008, "Wrong alignment on AFortTeamInfoPvPBaseDestruction");
static_assert(sizeof(AFortTeamInfoPvPBaseDestruction) == 0x0006D0, "Wrong size on AFortTeamInfoPvPBaseDestruction");
static_assert(offsetof(AFortTeamInfoPvPBaseDestruction, TeamCornerstone) == 0x000480, "Member 'AFortTeamInfoPvPBaseDestruction::TeamCornerstone' has a wrong offset!");
static_assert(offsetof(AFortTeamInfoPvPBaseDestruction, TeamStrategicBuildingActors) == 0x000488, "Member 'AFortTeamInfoPvPBaseDestruction::TeamStrategicBuildingActors' has a wrong offset!");
static_assert(offsetof(AFortTeamInfoPvPBaseDestruction, TeamFOBCoreBuildingActors) == 0x000548, "Member 'AFortTeamInfoPvPBaseDestruction::TeamFOBCoreBuildingActors' has a wrong offset!");
static_assert(offsetof(AFortTeamInfoPvPBaseDestruction, StrategicBuildingHandleGenerator) == 0x000680, "Member 'AFortTeamInfoPvPBaseDestruction::StrategicBuildingHandleGenerator' has a wrong offset!");
static_assert(offsetof(AFortTeamInfoPvPBaseDestruction, TeamLevel) == 0x000684, "Member 'AFortTeamInfoPvPBaseDestruction::TeamLevel' has a wrong offset!");
static_assert(offsetof(AFortTeamInfoPvPBaseDestruction, OnHandleTeamLevelChanged) == 0x000688, "Member 'AFortTeamInfoPvPBaseDestruction::OnHandleTeamLevelChanged' has a wrong offset!");
static_assert(offsetof(AFortTeamInfoPvPBaseDestruction, TeamExperience) == 0x000698, "Member 'AFortTeamInfoPvPBaseDestruction::TeamExperience' has a wrong offset!");
static_assert(offsetof(AFortTeamInfoPvPBaseDestruction, OnHandleTeamXPChanged) == 0x0006A0, "Member 'AFortTeamInfoPvPBaseDestruction::OnHandleTeamXPChanged' has a wrong offset!");
static_assert(offsetof(AFortTeamInfoPvPBaseDestruction, OnFOBCoresLoaded) == 0x0006B0, "Member 'AFortTeamInfoPvPBaseDestruction::OnFOBCoresLoaded' has a wrong offset!");
static_assert(offsetof(AFortTeamInfoPvPBaseDestruction, OnFOBCoresDestroyed) == 0x0006C0, "Member 'AFortTeamInfoPvPBaseDestruction::OnFOBCoresDestroyed' has a wrong offset!");

// Class FortniteGame.FortAIDirectorDataManager
// 0x00F0 (0x0478 - 0x0388)
class AFortAIDirectorDataManager final : public AActor
{
public:
	class UObject*                                OwnerObject;                                       // 0x0388(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FAIDirectorEventData>           EventsToTrack;                                     // 0x0390(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortAIDirectorFactorData>      FactorsToTrack;                                    // 0x03A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B0[0xA0];                                     // 0x03B0(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EFortAIDirectorEvent>                  EventsBeingTracked;                                // 0x0450(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<EFortAIDirectorFactor>                 FactorsBeingTracked;                               // 0x0460(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_470[0x8];                                      // 0x0470(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void TriggerEvent(const struct FFortAIDirectorEvent& TriggeredEvent);

	float GetAIDirectorFactorValue(EFortAIDirectorFactor AIDirectorFactor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIDirectorDataManager">();
	}
	static class AFortAIDirectorDataManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAIDirectorDataManager>();
	}
};
static_assert(alignof(AFortAIDirectorDataManager) == 0x000008, "Wrong alignment on AFortAIDirectorDataManager");
static_assert(sizeof(AFortAIDirectorDataManager) == 0x000478, "Wrong size on AFortAIDirectorDataManager");
static_assert(offsetof(AFortAIDirectorDataManager, OwnerObject) == 0x000388, "Member 'AFortAIDirectorDataManager::OwnerObject' has a wrong offset!");
static_assert(offsetof(AFortAIDirectorDataManager, EventsToTrack) == 0x000390, "Member 'AFortAIDirectorDataManager::EventsToTrack' has a wrong offset!");
static_assert(offsetof(AFortAIDirectorDataManager, FactorsToTrack) == 0x0003A0, "Member 'AFortAIDirectorDataManager::FactorsToTrack' has a wrong offset!");
static_assert(offsetof(AFortAIDirectorDataManager, EventsBeingTracked) == 0x000450, "Member 'AFortAIDirectorDataManager::EventsBeingTracked' has a wrong offset!");
static_assert(offsetof(AFortAIDirectorDataManager, FactorsBeingTracked) == 0x000460, "Member 'AFortAIDirectorDataManager::FactorsBeingTracked' has a wrong offset!");

// Class FortniteGame.KeepHeart
// 0x0020 (0x1090 - 0x1070)
class AKeepHeart final : public AKeepHeartBase
{
public:
	class AActor*                                 DecorationRoomPlacement;                           // 0x1068(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            PermaniteHealEffect;                               // 0x1070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PermaniteWallWeight;                               // 0x1078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PermaniteFloorWeight;                              // 0x107C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PermaniteStairWeight;                              // 0x1080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PermaniteRoofWeight;                               // 0x1084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKeepDefenseState                             DefenseState;                                      // 0x1088(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1089[0x7];                                     // 0x1089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DelayedVoteSuccess();
	bool DestroyNonPermaniteStructures();
	float GetAveragePermaniteLevel();
	int32 GetUpgradeAllPermaniteCost(class AFortPlayerController* FortPC, bool bQuickUpgrade);
	float GetWorldStreamingInProgress();
	void HandleVoteComplete(bool bResult);
	bool IsWorldStreamedIn();
	bool IsWorldStreamingIn();
	void NotifyEncounterEnded(class UFortAIEncounterInfo* EndedEncounter);
	void NotifyEncounterStarted(class UFortAIEncounterInfo* StartedEncounter);
	void OnDefenseLevelChanged();
	void OnVoteComplete(bool bResult);
	void OnWorldStreamedIn();
	void ResetContainers();
	void RestoreContainers();
	void RestoreKeepHealth();
	void SetPermaniteAvailability(bool bAvailable);
	void StartVote(const class FText& VoteText, const class FText& YesText, const class FText& NoText, float PercentageToPass, bool bSkipIfOnePlayerOnly);
	void StreamInWorld();
	void StreamOutWorld();
	bool UpgradeAllPermaniteStructures(class AFortPlayerController* FortPC, bool bQuickUpgrade);

	int32 GetDefenseLevel() const;
	bool IsDefenseActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KeepHeart">();
	}
	static class AKeepHeart* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKeepHeart>();
	}
};
static_assert(alignof(AKeepHeart) == 0x000010, "Wrong alignment on AKeepHeart");
static_assert(sizeof(AKeepHeart) == 0x001090, "Wrong size on AKeepHeart");
static_assert(offsetof(AKeepHeart, DecorationRoomPlacement) == 0x001068, "Member 'AKeepHeart::DecorationRoomPlacement' has a wrong offset!");
static_assert(offsetof(AKeepHeart, PermaniteHealEffect) == 0x001070, "Member 'AKeepHeart::PermaniteHealEffect' has a wrong offset!");
static_assert(offsetof(AKeepHeart, PermaniteWallWeight) == 0x001078, "Member 'AKeepHeart::PermaniteWallWeight' has a wrong offset!");
static_assert(offsetof(AKeepHeart, PermaniteFloorWeight) == 0x00107C, "Member 'AKeepHeart::PermaniteFloorWeight' has a wrong offset!");
static_assert(offsetof(AKeepHeart, PermaniteStairWeight) == 0x001080, "Member 'AKeepHeart::PermaniteStairWeight' has a wrong offset!");
static_assert(offsetof(AKeepHeart, PermaniteRoofWeight) == 0x001084, "Member 'AKeepHeart::PermaniteRoofWeight' has a wrong offset!");
static_assert(offsetof(AKeepHeart, DefenseState) == 0x001088, "Member 'AKeepHeart::DefenseState' has a wrong offset!");

// Class FortniteGame.ManorHeart
// 0x0030 (0x10A0 - 0x1070)
class AManorHeart final : public AKeepHeartBase
{
public:
	class AActor*                                 KeepIconActor;                                     // 0x1068(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         ContainerNamesToDestroy;                           // 0x1070(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            InfiniteStaminaEffect;                             // 0x1080(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1088[0x18];                                    // 0x1088(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void TravelToNewWorld(const class FString& NewTheaterId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ManorHeart">();
	}
	static class AManorHeart* GetDefaultObj()
	{
		return GetDefaultObjImpl<AManorHeart>();
	}
};
static_assert(alignof(AManorHeart) == 0x000010, "Wrong alignment on AManorHeart");
static_assert(sizeof(AManorHeart) == 0x0010A0, "Wrong size on AManorHeart");
static_assert(offsetof(AManorHeart, KeepIconActor) == 0x001068, "Member 'AManorHeart::KeepIconActor' has a wrong offset!");
static_assert(offsetof(AManorHeart, ContainerNamesToDestroy) == 0x001070, "Member 'AManorHeart::ContainerNamesToDestroy' has a wrong offset!");
static_assert(offsetof(AManorHeart, InfiniteStaminaEffect) == 0x001080, "Member 'AManorHeart::InfiniteStaminaEffect' has a wrong offset!");

// Class FortniteGame.FortInitializeFromObjectInterface
// 0x0000 (0x0028 - 0x0028)
class IFortInitializeFromObjectInterface final : public IInterface
{
public:
	void InitFromObject(class UObject* InitObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortInitializeFromObjectInterface">();
	}
	static class IFortInitializeFromObjectInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortInitializeFromObjectInterface>();
	}
};
static_assert(alignof(IFortInitializeFromObjectInterface) == 0x000008, "Wrong alignment on IFortInitializeFromObjectInterface");
static_assert(sizeof(IFortInitializeFromObjectInterface) == 0x000028, "Wrong size on IFortInitializeFromObjectInterface");

// Class FortniteGame.FortQuestItemDefinitionTooltip
// 0x0000 (0x0090 - 0x0090)
class UFortQuestItemDefinitionTooltip final : public UFortItemDefinitionTooltip
{
public:
	bool GetTextForToken(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, class FText* OutText) const;
	bool GetTokenizedDescriptionText(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, TArray<class FText>* OutDescription) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQuestItemDefinitionTooltip">();
	}
	static class UFortQuestItemDefinitionTooltip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQuestItemDefinitionTooltip>();
	}
};
static_assert(alignof(UFortQuestItemDefinitionTooltip) == 0x000008, "Wrong alignment on UFortQuestItemDefinitionTooltip");
static_assert(sizeof(UFortQuestItemDefinitionTooltip) == 0x000090, "Wrong size on UFortQuestItemDefinitionTooltip");

// Class FortniteGame.FortAIEncounterSequence
// 0x0050 (0x0078 - 0x0028)
class UFortAIEncounterSequence final : public UObject
{
public:
	struct FFortGeneratedEncounterSequence        GeneratedEncounterSequence;                        // 0x0028(0x0030)(Protected, NativeAccessSpecifierProtected)
	int32                                         CurrentEncounterIndexInSequence;                   // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAIEncounterInfo*                   CurrentEncounter;                                  // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortAIDirector*                        AssociatedAIDirector;                              // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortMission*                           AssociatedMission;                                 // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	EFortEncounterSequenceResult Next();
	EFortEncounterSequenceResult Previous();
	class UFortAIEncounterInfo* StartCurrentEncounter(EFortEncounterSequenceResult* OutRequestResult, const TArray<class AActor*>& TargetActors, class UFortAIAssignmentSettings* AssignmentSettings, const struct FEncounterEnvironmentQueryInfo& OverrideEnvironmentQueryInfo, class AActor* OptionalQueryActor, const struct FGameplayTagContainer& InjectedTags, const struct FFortEncounterSettings& EncounterSettings, int32 ActivationDelay);
	void StopCurrentEncounter();

	bool EncounterBelongsToSequence(class UFortAIEncounterInfo* InEncounter) const;
	class UFortAIEncounterInfo* GetCurrentEncounter() const;
	int32 GetEncounterIndexInSequence() const;
	int32 GetNumEncountersInSequence() const;
	bool HasEncounter() const;
	bool IsOnFinalIndexInSequence() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIEncounterSequence">();
	}
	static class UFortAIEncounterSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIEncounterSequence>();
	}
};
static_assert(alignof(UFortAIEncounterSequence) == 0x000008, "Wrong alignment on UFortAIEncounterSequence");
static_assert(sizeof(UFortAIEncounterSequence) == 0x000078, "Wrong size on UFortAIEncounterSequence");
static_assert(offsetof(UFortAIEncounterSequence, GeneratedEncounterSequence) == 0x000028, "Member 'UFortAIEncounterSequence::GeneratedEncounterSequence' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterSequence, CurrentEncounterIndexInSequence) == 0x000058, "Member 'UFortAIEncounterSequence::CurrentEncounterIndexInSequence' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterSequence, CurrentEncounter) == 0x000060, "Member 'UFortAIEncounterSequence::CurrentEncounter' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterSequence, AssociatedAIDirector) == 0x000068, "Member 'UFortAIEncounterSequence::AssociatedAIDirector' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterSequence, AssociatedMission) == 0x000070, "Member 'UFortAIEncounterSequence::AssociatedMission' has a wrong offset!");

// Class FortniteGame.FortDynamicBuilder
// 0x0118 (0x0850 - 0x0738)
class AFortDynamicBuilder : public ABuildingActor
{
public:
	class UFortBuildingInstructions*              BuildingInstructions;                              // 0x0738(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSelectiveDestruction;                             // 0x0740(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoCollisionFail;                                  // 0x0741(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreMissionActors;                              // 0x0742(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShrinkAndDestroyEffect;                           // 0x0743(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDrawBounds;                                  // 0x0744(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePlayerBuildAnimations;                         // 0x0745(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_746[0x2];                                      // 0x0746(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BuildingConstructionTime;                          // 0x0748(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFDynamicBuildOrder                           BuildOrder;                                        // 0x074C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReverseBuild;                                     // 0x074D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74E[0x2];                                      // 0x074E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OverrideOwnerPersistentId;                         // 0x0750(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_754[0xDC];                                     // 0x0754(0x00DC)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentIndex;                                      // 0x0830(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_834[0x4];                                      // 0x0834(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ABuildingActor*>                 AllBuiltActors;                                    // 0x0838(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_848[0x8];                                      // 0x0848(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDynamicBuilder">();
	}
	static class AFortDynamicBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortDynamicBuilder>();
	}
};
static_assert(alignof(AFortDynamicBuilder) == 0x000008, "Wrong alignment on AFortDynamicBuilder");
static_assert(sizeof(AFortDynamicBuilder) == 0x000850, "Wrong size on AFortDynamicBuilder");
static_assert(offsetof(AFortDynamicBuilder, BuildingInstructions) == 0x000738, "Member 'AFortDynamicBuilder::BuildingInstructions' has a wrong offset!");
static_assert(offsetof(AFortDynamicBuilder, bSelectiveDestruction) == 0x000740, "Member 'AFortDynamicBuilder::bSelectiveDestruction' has a wrong offset!");
static_assert(offsetof(AFortDynamicBuilder, bNoCollisionFail) == 0x000741, "Member 'AFortDynamicBuilder::bNoCollisionFail' has a wrong offset!");
static_assert(offsetof(AFortDynamicBuilder, bIgnoreMissionActors) == 0x000742, "Member 'AFortDynamicBuilder::bIgnoreMissionActors' has a wrong offset!");
static_assert(offsetof(AFortDynamicBuilder, bShrinkAndDestroyEffect) == 0x000743, "Member 'AFortDynamicBuilder::bShrinkAndDestroyEffect' has a wrong offset!");
static_assert(offsetof(AFortDynamicBuilder, bDebugDrawBounds) == 0x000744, "Member 'AFortDynamicBuilder::bDebugDrawBounds' has a wrong offset!");
static_assert(offsetof(AFortDynamicBuilder, bUsePlayerBuildAnimations) == 0x000745, "Member 'AFortDynamicBuilder::bUsePlayerBuildAnimations' has a wrong offset!");
static_assert(offsetof(AFortDynamicBuilder, BuildingConstructionTime) == 0x000748, "Member 'AFortDynamicBuilder::BuildingConstructionTime' has a wrong offset!");
static_assert(offsetof(AFortDynamicBuilder, BuildOrder) == 0x00074C, "Member 'AFortDynamicBuilder::BuildOrder' has a wrong offset!");
static_assert(offsetof(AFortDynamicBuilder, bReverseBuild) == 0x00074D, "Member 'AFortDynamicBuilder::bReverseBuild' has a wrong offset!");
static_assert(offsetof(AFortDynamicBuilder, OverrideOwnerPersistentId) == 0x000750, "Member 'AFortDynamicBuilder::OverrideOwnerPersistentId' has a wrong offset!");
static_assert(offsetof(AFortDynamicBuilder, CurrentIndex) == 0x000830, "Member 'AFortDynamicBuilder::CurrentIndex' has a wrong offset!");
static_assert(offsetof(AFortDynamicBuilder, AllBuiltActors) == 0x000838, "Member 'AFortDynamicBuilder::AllBuiltActors' has a wrong offset!");

// Class FortniteGame.FortClientDynamicBuilder
// 0x0000 (0x0850 - 0x0850)
class AFortClientDynamicBuilder final : public AFortDynamicBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortClientDynamicBuilder">();
	}
	static class AFortClientDynamicBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortClientDynamicBuilder>();
	}
};
static_assert(alignof(AFortClientDynamicBuilder) == 0x000008, "Wrong alignment on AFortClientDynamicBuilder");
static_assert(sizeof(AFortClientDynamicBuilder) == 0x000850, "Wrong size on AFortClientDynamicBuilder");

// Class FortniteGame.FortAIPerceptionSystem
// 0x0000 (0x0130 - 0x0130)
class UFortAIPerceptionSystem final : public UAIPerceptionSystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIPerceptionSystem">();
	}
	static class UFortAIPerceptionSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIPerceptionSystem>();
	}
};
static_assert(alignof(UFortAIPerceptionSystem) == 0x000008, "Wrong alignment on UFortAIPerceptionSystem");
static_assert(sizeof(UFortAIPerceptionSystem) == 0x000130, "Wrong size on UFortAIPerceptionSystem");

// Class FortniteGame.FortEnemySpawn
// 0x0008 (0x0740 - 0x0738)
class AFortEnemySpawn final : public ABuildingActor
{
public:
	float                                         ClusterRadius;                                     // 0x0738(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_73C[0x4];                                      // 0x073C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortEnemySpawn">();
	}
	static class AFortEnemySpawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortEnemySpawn>();
	}
};
static_assert(alignof(AFortEnemySpawn) == 0x000008, "Wrong alignment on AFortEnemySpawn");
static_assert(sizeof(AFortEnemySpawn) == 0x000740, "Wrong size on AFortEnemySpawn");
static_assert(offsetof(AFortEnemySpawn, ClusterRadius) == 0x000738, "Member 'AFortEnemySpawn::ClusterRadius' has a wrong offset!");

// Class FortniteGame.FortGameplayTagVolumeInterface
// 0x0000 (0x0028 - 0x0028)
class IFortGameplayTagVolumeInterface final : public IInterface
{
public:
	void ApplyTags();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameplayTagVolumeInterface">();
	}
	static class IFortGameplayTagVolumeInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortGameplayTagVolumeInterface>();
	}
};
static_assert(alignof(IFortGameplayTagVolumeInterface) == 0x000008, "Wrong alignment on IFortGameplayTagVolumeInterface");
static_assert(sizeof(IFortGameplayTagVolumeInterface) == 0x000028, "Wrong size on IFortGameplayTagVolumeInterface");

// Class FortniteGame.FortAccountBuffItem
// 0x0008 (0x0140 - 0x0138)
class UFortAccountBuffItem final : public UFortAccountItem
{
public:
	struct FDateTime                              expiration_date;                                   // 0x0138(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool IsActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAccountBuffItem">();
	}
	static class UFortAccountBuffItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAccountBuffItem>();
	}
};
static_assert(alignof(UFortAccountBuffItem) == 0x000008, "Wrong alignment on UFortAccountBuffItem");
static_assert(sizeof(UFortAccountBuffItem) == 0x000140, "Wrong size on UFortAccountBuffItem");
static_assert(offsetof(UFortAccountBuffItem, expiration_date) == 0x000138, "Member 'UFortAccountBuffItem::expiration_date' has a wrong offset!");

// Class FortniteGame.FortAIRootAssignmentProviderInterface
// 0x0000 (0x0028 - 0x0028)
class IFortAIRootAssignmentProviderInterface final : public IInterface
{
public:
	const struct FFortAIAssignmentIdentifier GetRootAssignmentIdentifier() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIRootAssignmentProviderInterface">();
	}
	static class IFortAIRootAssignmentProviderInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortAIRootAssignmentProviderInterface>();
	}
};
static_assert(alignof(IFortAIRootAssignmentProviderInterface) == 0x000008, "Wrong alignment on IFortAIRootAssignmentProviderInterface");
static_assert(sizeof(IFortAIRootAssignmentProviderInterface) == 0x000028, "Wrong size on IFortAIRootAssignmentProviderInterface");

// Class FortniteGame.FortAccountItemTooltip
// 0x0000 (0x0090 - 0x0090)
class UFortAccountItemTooltip : public UFortItemTooltip
{
public:
	bool GetNumericValue(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, float* OutVal) const;
	bool GetTextForToken(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, class FText* OutText) const;
	bool GetTokenizedDescriptionText(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, TArray<class FText>* OutDescription) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAccountItemTooltip">();
	}
	static class UFortAccountItemTooltip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAccountItemTooltip>();
	}
};
static_assert(alignof(UFortAccountItemTooltip) == 0x000008, "Wrong alignment on UFortAccountItemTooltip");
static_assert(sizeof(UFortAccountItemTooltip) == 0x000090, "Wrong size on UFortAccountItemTooltip");

// Class FortniteGame.FortCharacterTooltip
// 0x0020 (0x00B0 - 0x0090)
class UFortCharacterTooltip : public UFortAccountItemTooltip
{
public:
	uint8                                         Pad_90[0x20];                                      // 0x0090(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetNumericValue(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, float* OutVal) const;
	bool GetTextForToken(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, class FText* OutText) const;
	bool GetTokenizedDescriptionText(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, TArray<class FText>* OutDescription) const;
	bool GetValueData(const class UObject* ObjectToDescribe, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, struct FFortTooltipValueData* OutData) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCharacterTooltip">();
	}
	static class UFortCharacterTooltip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCharacterTooltip>();
	}
};
static_assert(alignof(UFortCharacterTooltip) == 0x000008, "Wrong alignment on UFortCharacterTooltip");
static_assert(sizeof(UFortCharacterTooltip) == 0x0000B0, "Wrong size on UFortCharacterTooltip");

// Class FortniteGame.FortWorkerTooltip
// 0x0000 (0x00B0 - 0x00B0)
class UFortWorkerTooltip final : public UFortCharacterTooltip
{
public:
	bool GetNumericValue(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, float* OutVal) const;
	bool GetTextForToken(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, class FText* OutText) const;
	bool GetTokenizedDescriptionText(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, TArray<class FText>* OutDescription) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortWorkerTooltip">();
	}
	static class UFortWorkerTooltip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortWorkerTooltip>();
	}
};
static_assert(alignof(UFortWorkerTooltip) == 0x000008, "Wrong alignment on UFortWorkerTooltip");
static_assert(sizeof(UFortWorkerTooltip) == 0x0000B0, "Wrong size on UFortWorkerTooltip");

// Class FortniteGame.FortGameplayTagBuildingActor
// 0x0048 (0x0780 - 0x0738)
class AFortGameplayTagBuildingActor final : public ABuildingActor
{
public:
	uint8                                         Pad_738[0x8];                                      // 0x0738(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAutomaticallyGenerated;                           // 0x0740(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_741[0x7];                                      // 0x0741(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  TagsToApplyOnSave;                                 // 0x0748(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	int32                                         XGridCells;                                        // 0x0768(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         YGridCells;                                        // 0x076C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ZGridCells;                                        // 0x0770(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_774[0x4];                                      // 0x0774(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          BoxComponent;                                      // 0x0778(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameplayTagBuildingActor">();
	}
	static class AFortGameplayTagBuildingActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGameplayTagBuildingActor>();
	}
};
static_assert(alignof(AFortGameplayTagBuildingActor) == 0x000008, "Wrong alignment on AFortGameplayTagBuildingActor");
static_assert(sizeof(AFortGameplayTagBuildingActor) == 0x000780, "Wrong size on AFortGameplayTagBuildingActor");
static_assert(offsetof(AFortGameplayTagBuildingActor, bAutomaticallyGenerated) == 0x000740, "Member 'AFortGameplayTagBuildingActor::bAutomaticallyGenerated' has a wrong offset!");
static_assert(offsetof(AFortGameplayTagBuildingActor, TagsToApplyOnSave) == 0x000748, "Member 'AFortGameplayTagBuildingActor::TagsToApplyOnSave' has a wrong offset!");
static_assert(offsetof(AFortGameplayTagBuildingActor, XGridCells) == 0x000768, "Member 'AFortGameplayTagBuildingActor::XGridCells' has a wrong offset!");
static_assert(offsetof(AFortGameplayTagBuildingActor, YGridCells) == 0x00076C, "Member 'AFortGameplayTagBuildingActor::YGridCells' has a wrong offset!");
static_assert(offsetof(AFortGameplayTagBuildingActor, ZGridCells) == 0x000770, "Member 'AFortGameplayTagBuildingActor::ZGridCells' has a wrong offset!");
static_assert(offsetof(AFortGameplayTagBuildingActor, BoxComponent) == 0x000778, "Member 'AFortGameplayTagBuildingActor::BoxComponent' has a wrong offset!");

// Class FortniteGame.FortPlacementActor
// 0x0008 (0x0740 - 0x0738)
class AFortPlacementActor : public ABuildingActor
{
public:
	TWeakObjectPtr<class AActor>                  OccupyingActor;                                    // 0x0738(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlacementActor">();
	}
	static class AFortPlacementActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlacementActor>();
	}
};
static_assert(alignof(AFortPlacementActor) == 0x000008, "Wrong alignment on AFortPlacementActor");
static_assert(sizeof(AFortPlacementActor) == 0x000740, "Wrong size on AFortPlacementActor");
static_assert(offsetof(AFortPlacementActor, OccupyingActor) == 0x000738, "Member 'AFortPlacementActor::OccupyingActor' has a wrong offset!");

// Class FortniteGame.FortAsyncAction_HomebaseContextPurchaseNode
// 0x0030 (0x0058 - 0x0028)
class UFortAsyncAction_HomebaseContextPurchaseNode final : public UBlueprintAsyncActionBase
{
public:
	UMulticastDelegateProperty_                   OnMCPPurchaseSucceeded;                            // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMCPPurchaseFailed;                               // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UHomeBaseContext>        HomeBaseContext;                                   // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   IdOfNodeToPurchase;                                // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UFortAsyncAction_HomebaseContextPurchaseNode* PurchaseNode(const class UHomeBaseContext* HomeBaseContext_0, const class FName& IdOfNodeToPurchase_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAsyncAction_HomebaseContextPurchaseNode">();
	}
	static class UFortAsyncAction_HomebaseContextPurchaseNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAsyncAction_HomebaseContextPurchaseNode>();
	}
};
static_assert(alignof(UFortAsyncAction_HomebaseContextPurchaseNode) == 0x000008, "Wrong alignment on UFortAsyncAction_HomebaseContextPurchaseNode");
static_assert(sizeof(UFortAsyncAction_HomebaseContextPurchaseNode) == 0x000058, "Wrong size on UFortAsyncAction_HomebaseContextPurchaseNode");
static_assert(offsetof(UFortAsyncAction_HomebaseContextPurchaseNode, OnMCPPurchaseSucceeded) == 0x000028, "Member 'UFortAsyncAction_HomebaseContextPurchaseNode::OnMCPPurchaseSucceeded' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_HomebaseContextPurchaseNode, OnMCPPurchaseFailed) == 0x000038, "Member 'UFortAsyncAction_HomebaseContextPurchaseNode::OnMCPPurchaseFailed' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_HomebaseContextPurchaseNode, HomeBaseContext) == 0x000048, "Member 'UFortAsyncAction_HomebaseContextPurchaseNode::HomeBaseContext' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_HomebaseContextPurchaseNode, IdOfNodeToPurchase) == 0x000050, "Member 'UFortAsyncAction_HomebaseContextPurchaseNode::IdOfNodeToPurchase' has a wrong offset!");

// Class FortniteGame.BuildingActorEditorComponent
// 0x0040 (0x0820 - 0x07E0)
class UBuildingActorEditorComponent final : public UStaticMeshComponent
{
public:
	TSoftObjectPtr<class UMaterialInterface>      CurrentlySnappedMaterial;                          // 0x07E0(0x0020)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStaticMesh>             CubeMesh;                                          // 0x0800(0x0020)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingActorEditorComponent">();
	}
	static class UBuildingActorEditorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingActorEditorComponent>();
	}
};
static_assert(alignof(UBuildingActorEditorComponent) == 0x000010, "Wrong alignment on UBuildingActorEditorComponent");
static_assert(sizeof(UBuildingActorEditorComponent) == 0x000820, "Wrong size on UBuildingActorEditorComponent");
static_assert(offsetof(UBuildingActorEditorComponent, CurrentlySnappedMaterial) == 0x0007E0, "Member 'UBuildingActorEditorComponent::CurrentlySnappedMaterial' has a wrong offset!");
static_assert(offsetof(UBuildingActorEditorComponent, CubeMesh) == 0x000800, "Member 'UBuildingActorEditorComponent::CubeMesh' has a wrong offset!");

// Class FortniteGame.BuildingActorHotSpotRenderingComponent
// 0x0000 (0x0670 - 0x0670)
class UBuildingActorHotSpotRenderingComponent final : public UPrimitiveComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingActorHotSpotRenderingComponent">();
	}
	static class UBuildingActorHotSpotRenderingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingActorHotSpotRenderingComponent>();
	}
};
static_assert(alignof(UBuildingActorHotSpotRenderingComponent) == 0x000010, "Wrong alignment on UBuildingActorHotSpotRenderingComponent");
static_assert(sizeof(UBuildingActorHotSpotRenderingComponent) == 0x000670, "Wrong size on UBuildingActorHotSpotRenderingComponent");

// Class FortniteGame.BuildingConnectivityComponent
// 0x00E0 (0x0370 - 0x0290)
class UBuildingConnectivityComponent final : public USceneComponent
{
public:
	TArray<struct FFortConnectionData>            Connections;                                       // 0x0290(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, SaveGame, RepNotify, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           SocketNames;                                       // 0x02A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bAutoConnectOnInitialize;                          // 0x02B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDrawDebugData;                                    // 0x02B1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B2[0x6];                                      // 0x02B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class ABuildingSMActor*                       BuildingOwner;                                     // 0x02B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ABuildingConnectivityEffect*>    ConnectionEffects;                                 // 0x02C0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsPowered;                                        // 0x02D0(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, SaveGame, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsProvidingPower;                                 // 0x02D1(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, SaveGame, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAbleToProvidePower;                             // 0x02D2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowConnections;                                 // 0x02D3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowsPowerToPassThrough;                         // 0x02D4(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D5[0x3];                                      // 0x02D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   AuthorityOnConnectedDelegate;                      // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   AuthorityOnDisconnectedDelegate;                   // 0x02E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   ClientOnConnectedDelegate;                         // 0x02F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   ClientOnDisconnectedDelegate;                      // 0x0308(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   AuthorityOnPoweredDelegate;                        // 0x0318(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   AuthorityOnUnpoweredDelegate;                      // 0x0328(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   ClientOnPoweredDelegate;                           // 0x0338(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   ClientOnUnpoweredDelegate;                         // 0x0348(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_358[0x18];                                     // 0x0358(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CONNECT(const struct FFortConnectionData& NewConnection);
	void DISCONNECT(const struct FFortConnectionData& NewDisconnection);
	void DisconnectAll();
	void DrawDebugData();
	bool K2_IsPowered();
	void OnPlaced();
	void OnRep_bIsPowered();
	void OnRep_bIsProvidingPower();
	void OnRep_Connections();

	bool CanConnectTo(class ABuildingSMActor* TestActor) const;
	bool IsConnectedTo(class ABuildingSMActor* TestActor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingConnectivityComponent">();
	}
	static class UBuildingConnectivityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingConnectivityComponent>();
	}
};
static_assert(alignof(UBuildingConnectivityComponent) == 0x000008, "Wrong alignment on UBuildingConnectivityComponent");
static_assert(sizeof(UBuildingConnectivityComponent) == 0x000370, "Wrong size on UBuildingConnectivityComponent");
static_assert(offsetof(UBuildingConnectivityComponent, Connections) == 0x000290, "Member 'UBuildingConnectivityComponent::Connections' has a wrong offset!");
static_assert(offsetof(UBuildingConnectivityComponent, SocketNames) == 0x0002A0, "Member 'UBuildingConnectivityComponent::SocketNames' has a wrong offset!");
static_assert(offsetof(UBuildingConnectivityComponent, bAutoConnectOnInitialize) == 0x0002B0, "Member 'UBuildingConnectivityComponent::bAutoConnectOnInitialize' has a wrong offset!");
static_assert(offsetof(UBuildingConnectivityComponent, bDrawDebugData) == 0x0002B1, "Member 'UBuildingConnectivityComponent::bDrawDebugData' has a wrong offset!");
static_assert(offsetof(UBuildingConnectivityComponent, BuildingOwner) == 0x0002B8, "Member 'UBuildingConnectivityComponent::BuildingOwner' has a wrong offset!");
static_assert(offsetof(UBuildingConnectivityComponent, ConnectionEffects) == 0x0002C0, "Member 'UBuildingConnectivityComponent::ConnectionEffects' has a wrong offset!");
static_assert(offsetof(UBuildingConnectivityComponent, bIsPowered) == 0x0002D0, "Member 'UBuildingConnectivityComponent::bIsPowered' has a wrong offset!");
static_assert(offsetof(UBuildingConnectivityComponent, bIsProvidingPower) == 0x0002D1, "Member 'UBuildingConnectivityComponent::bIsProvidingPower' has a wrong offset!");
static_assert(offsetof(UBuildingConnectivityComponent, bIsAbleToProvidePower) == 0x0002D2, "Member 'UBuildingConnectivityComponent::bIsAbleToProvidePower' has a wrong offset!");
static_assert(offsetof(UBuildingConnectivityComponent, bAllowConnections) == 0x0002D3, "Member 'UBuildingConnectivityComponent::bAllowConnections' has a wrong offset!");
static_assert(offsetof(UBuildingConnectivityComponent, bAllowsPowerToPassThrough) == 0x0002D4, "Member 'UBuildingConnectivityComponent::bAllowsPowerToPassThrough' has a wrong offset!");
static_assert(offsetof(UBuildingConnectivityComponent, AuthorityOnConnectedDelegate) == 0x0002D8, "Member 'UBuildingConnectivityComponent::AuthorityOnConnectedDelegate' has a wrong offset!");
static_assert(offsetof(UBuildingConnectivityComponent, AuthorityOnDisconnectedDelegate) == 0x0002E8, "Member 'UBuildingConnectivityComponent::AuthorityOnDisconnectedDelegate' has a wrong offset!");
static_assert(offsetof(UBuildingConnectivityComponent, ClientOnConnectedDelegate) == 0x0002F8, "Member 'UBuildingConnectivityComponent::ClientOnConnectedDelegate' has a wrong offset!");
static_assert(offsetof(UBuildingConnectivityComponent, ClientOnDisconnectedDelegate) == 0x000308, "Member 'UBuildingConnectivityComponent::ClientOnDisconnectedDelegate' has a wrong offset!");
static_assert(offsetof(UBuildingConnectivityComponent, AuthorityOnPoweredDelegate) == 0x000318, "Member 'UBuildingConnectivityComponent::AuthorityOnPoweredDelegate' has a wrong offset!");
static_assert(offsetof(UBuildingConnectivityComponent, AuthorityOnUnpoweredDelegate) == 0x000328, "Member 'UBuildingConnectivityComponent::AuthorityOnUnpoweredDelegate' has a wrong offset!");
static_assert(offsetof(UBuildingConnectivityComponent, ClientOnPoweredDelegate) == 0x000338, "Member 'UBuildingConnectivityComponent::ClientOnPoweredDelegate' has a wrong offset!");
static_assert(offsetof(UBuildingConnectivityComponent, ClientOnUnpoweredDelegate) == 0x000348, "Member 'UBuildingConnectivityComponent::ClientOnUnpoweredDelegate' has a wrong offset!");

// Class FortniteGame.BuildingConnectivityEffect
// 0x0038 (0x03C0 - 0x0388)
class ABuildingConnectivityEffect final : public AActor
{
public:
	struct FFortConnectionData                    ConnectionData;                                    // 0x0388(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bDebugDraw;                                        // 0x03B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B9[0x7];                                      // 0x03B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnConnect(const struct FTransform& T1, const struct FTransform& T2);
	void OnDisconnect();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingConnectivityEffect">();
	}
	static class ABuildingConnectivityEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingConnectivityEffect>();
	}
};
static_assert(alignof(ABuildingConnectivityEffect) == 0x000008, "Wrong alignment on ABuildingConnectivityEffect");
static_assert(sizeof(ABuildingConnectivityEffect) == 0x0003C0, "Wrong size on ABuildingConnectivityEffect");
static_assert(offsetof(ABuildingConnectivityEffect, ConnectionData) == 0x000388, "Member 'ABuildingConnectivityEffect::ConnectionData' has a wrong offset!");
static_assert(offsetof(ABuildingConnectivityEffect, bDebugDraw) == 0x0003B8, "Member 'ABuildingConnectivityEffect::bDebugDraw' has a wrong offset!");

// Class FortniteGame.BuildingConnectivityManager
// 0x0010 (0x0398 - 0x0388)
class ABuildingConnectivityManager final : public AActor
{
public:
	TArray<class ABuildingSMActor*>               ConnectivityActors;                                // 0x0388(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingConnectivityManager">();
	}
	static class ABuildingConnectivityManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingConnectivityManager>();
	}
};
static_assert(alignof(ABuildingConnectivityManager) == 0x000008, "Wrong alignment on ABuildingConnectivityManager");
static_assert(sizeof(ABuildingConnectivityManager) == 0x000398, "Wrong size on ABuildingConnectivityManager");
static_assert(offsetof(ABuildingConnectivityManager, ConnectivityActors) == 0x000388, "Member 'ABuildingConnectivityManager::ConnectivityActors' has a wrong offset!");

// Class FortniteGame.BuildingEditModeMetadata
// 0x00F0 (0x0118 - 0x0028)
class UBuildingEditModeMetadata : public UDataAsset
{
public:
	uint8                                         bHasNavigableOpening : 1;                          // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHasCustomAttackLocation : 1;                      // 0x0028(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBuildingActorHotSpotConfig*            DefaultHotspotConfig;                              // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAIHotSpotConfig*                       ShootingHotSpotConfig;                             // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ShapeGuid;                                         // 0x0040(0x0010)(Edit, EditConst, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FConnectivityCube                      ConnectivityCubeData;                              // 0x0058(0x00C0)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingEditModeMetadata">();
	}
	static class UBuildingEditModeMetadata* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingEditModeMetadata>();
	}
};
static_assert(alignof(UBuildingEditModeMetadata) == 0x000008, "Wrong alignment on UBuildingEditModeMetadata");
static_assert(sizeof(UBuildingEditModeMetadata) == 0x000118, "Wrong size on UBuildingEditModeMetadata");
static_assert(offsetof(UBuildingEditModeMetadata, DefaultHotspotConfig) == 0x000030, "Member 'UBuildingEditModeMetadata::DefaultHotspotConfig' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeMetadata, ShootingHotSpotConfig) == 0x000038, "Member 'UBuildingEditModeMetadata::ShootingHotSpotConfig' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeMetadata, ShapeGuid) == 0x000040, "Member 'UBuildingEditModeMetadata::ShapeGuid' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeMetadata, ConnectivityCubeData) == 0x000058, "Member 'UBuildingEditModeMetadata::ConnectivityCubeData' has a wrong offset!");

// Class FortniteGame.FortHomebaseBannerColorMap
// 0x0050 (0x0078 - 0x0028)
class UFortHomebaseBannerColorMap final : public UDataAsset
{
public:
	TMap<class FName, struct FHomebaseBannerColor> ColorMap;                                          // 0x0028(0x0050)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortHomebaseBannerColorMap">();
	}
	static class UFortHomebaseBannerColorMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortHomebaseBannerColorMap>();
	}
};
static_assert(alignof(UFortHomebaseBannerColorMap) == 0x000008, "Wrong alignment on UFortHomebaseBannerColorMap");
static_assert(sizeof(UFortHomebaseBannerColorMap) == 0x000078, "Wrong size on UFortHomebaseBannerColorMap");
static_assert(offsetof(UFortHomebaseBannerColorMap, ColorMap) == 0x000028, "Member 'UFortHomebaseBannerColorMap::ColorMap' has a wrong offset!");

// Class FortniteGame.BuildingEditModeMetadata_BinaryToggle
// 0x0010 (0x0128 - 0x0118)
class UBuildingEditModeMetadata_BinaryToggle : public UBuildingEditModeMetadata
{
public:
	TArray<EBinaryToggleValues>                   TileData;                                          // 0x0118(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditFixedSize, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingEditModeMetadata_BinaryToggle">();
	}
	static class UBuildingEditModeMetadata_BinaryToggle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingEditModeMetadata_BinaryToggle>();
	}
};
static_assert(alignof(UBuildingEditModeMetadata_BinaryToggle) == 0x000008, "Wrong alignment on UBuildingEditModeMetadata_BinaryToggle");
static_assert(sizeof(UBuildingEditModeMetadata_BinaryToggle) == 0x000128, "Wrong size on UBuildingEditModeMetadata_BinaryToggle");
static_assert(offsetof(UBuildingEditModeMetadata_BinaryToggle, TileData) == 0x000118, "Member 'UBuildingEditModeMetadata_BinaryToggle::TileData' has a wrong offset!");

// Class FortniteGame.BuildingEditModeMetadata_Floor
// 0x0000 (0x0128 - 0x0128)
class UBuildingEditModeMetadata_Floor final : public UBuildingEditModeMetadata_BinaryToggle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingEditModeMetadata_Floor">();
	}
	static class UBuildingEditModeMetadata_Floor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingEditModeMetadata_Floor>();
	}
};
static_assert(alignof(UBuildingEditModeMetadata_Floor) == 0x000008, "Wrong alignment on UBuildingEditModeMetadata_Floor");
static_assert(sizeof(UBuildingEditModeMetadata_Floor) == 0x000128, "Wrong size on UBuildingEditModeMetadata_Floor");

// Class FortniteGame.BuildingEditModeMetadata_Roof
// 0x0010 (0x0138 - 0x0128)
class UBuildingEditModeMetadata_Roof final : public UBuildingEditModeMetadata_BinaryToggle
{
public:
	TArray<struct FAuxiliaryEditTileMeshData>     AuxEditTileMeshData;                               // 0x0128(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingEditModeMetadata_Roof">();
	}
	static class UBuildingEditModeMetadata_Roof* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingEditModeMetadata_Roof>();
	}
};
static_assert(alignof(UBuildingEditModeMetadata_Roof) == 0x000008, "Wrong alignment on UBuildingEditModeMetadata_Roof");
static_assert(sizeof(UBuildingEditModeMetadata_Roof) == 0x000138, "Wrong size on UBuildingEditModeMetadata_Roof");
static_assert(offsetof(UBuildingEditModeMetadata_Roof, AuxEditTileMeshData) == 0x000128, "Member 'UBuildingEditModeMetadata_Roof::AuxEditTileMeshData' has a wrong offset!");

// Class FortniteGame.BuildingEditModeMetadata_Wall
// 0x0000 (0x0128 - 0x0128)
class UBuildingEditModeMetadata_Wall final : public UBuildingEditModeMetadata_BinaryToggle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingEditModeMetadata_Wall">();
	}
	static class UBuildingEditModeMetadata_Wall* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingEditModeMetadata_Wall>();
	}
};
static_assert(alignof(UBuildingEditModeMetadata_Wall) == 0x000008, "Wrong alignment on UBuildingEditModeMetadata_Wall");
static_assert(sizeof(UBuildingEditModeMetadata_Wall) == 0x000128, "Wrong size on UBuildingEditModeMetadata_Wall");

// Class FortniteGame.FortAITask_NavmeshWait
// 0x0010 (0x0080 - 0x0070)
class UFortAITask_NavmeshWait final : public UAITask
{
public:
	uint8                                         Pad_70[0x10];                                      // 0x0070(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAITask_NavmeshWait">();
	}
	static class UFortAITask_NavmeshWait* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAITask_NavmeshWait>();
	}
};
static_assert(alignof(UFortAITask_NavmeshWait) == 0x000008, "Wrong alignment on UFortAITask_NavmeshWait");
static_assert(sizeof(UFortAITask_NavmeshWait) == 0x000080, "Wrong size on UFortAITask_NavmeshWait");

// Class FortniteGame.BuildingEditModeMetadata_Pillar
// 0x0000 (0x0118 - 0x0118)
class UBuildingEditModeMetadata_Pillar final : public UBuildingEditModeMetadata
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingEditModeMetadata_Pillar">();
	}
	static class UBuildingEditModeMetadata_Pillar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingEditModeMetadata_Pillar>();
	}
};
static_assert(alignof(UBuildingEditModeMetadata_Pillar) == 0x000008, "Wrong alignment on UBuildingEditModeMetadata_Pillar");
static_assert(sizeof(UBuildingEditModeMetadata_Pillar) == 0x000118, "Wrong size on UBuildingEditModeMetadata_Pillar");

// Class FortniteGame.BuildingEditModeMetadata_Stair
// 0x0010 (0x0128 - 0x0118)
class UBuildingEditModeMetadata_Stair final : public UBuildingEditModeMetadata
{
public:
	TArray<int32>                                 TileData;                                          // 0x0118(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditFixedSize, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingEditModeMetadata_Stair">();
	}
	static class UBuildingEditModeMetadata_Stair* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingEditModeMetadata_Stair>();
	}
};
static_assert(alignof(UBuildingEditModeMetadata_Stair) == 0x000008, "Wrong alignment on UBuildingEditModeMetadata_Stair");
static_assert(sizeof(UBuildingEditModeMetadata_Stair) == 0x000128, "Wrong size on UBuildingEditModeMetadata_Stair");
static_assert(offsetof(UBuildingEditModeMetadata_Stair, TileData) == 0x000118, "Member 'UBuildingEditModeMetadata_Stair::TileData' has a wrong offset!");

// Class FortniteGame.FortAITask_ExecuteAbility
// 0x0080 (0x00F0 - 0x0070)
class UFortAITask_ExecuteAbility final : public UAITask
{
public:
	uint8                                         Pad_70[0x80];                                      // 0x0070(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAITask_ExecuteAbility">();
	}
	static class UFortAITask_ExecuteAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAITask_ExecuteAbility>();
	}
};
static_assert(alignof(UFortAITask_ExecuteAbility) == 0x000008, "Wrong alignment on UFortAITask_ExecuteAbility");
static_assert(sizeof(UFortAITask_ExecuteAbility) == 0x0000F0, "Wrong size on UFortAITask_ExecuteAbility");

// Class FortniteGame.BuildingEditModeMetadataContainer
// 0x0010 (0x0038 - 0x0028)
class UBuildingEditModeMetadataContainer final : public UDataAsset
{
public:
	TArray<class UBuildingEditModeMetadata*>      MetadataCollection;                                // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingEditModeMetadataContainer">();
	}
	static class UBuildingEditModeMetadataContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingEditModeMetadataContainer>();
	}
};
static_assert(alignof(UBuildingEditModeMetadataContainer) == 0x000008, "Wrong alignment on UBuildingEditModeMetadataContainer");
static_assert(sizeof(UBuildingEditModeMetadataContainer) == 0x000038, "Wrong size on UBuildingEditModeMetadataContainer");
static_assert(offsetof(UBuildingEditModeMetadataContainer, MetadataCollection) == 0x000028, "Member 'UBuildingEditModeMetadataContainer::MetadataCollection' has a wrong offset!");

// Class FortniteGame.BuildingEditModeSupport_BinaryToggle
// 0x0020 (0x02B0 - 0x0290)
class UBuildingEditModeSupport_BinaryToggle : public UBuildingEditModeSupport
{
public:
	class UBuildingEditModeMetadata_BinaryToggle* BinaryTogglePreviewData;                           // 0x0290(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBinaryToggleValues                           CurToggleAction;                                   // 0x0298(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_299[0x3];                                      // 0x0299(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           DefaultBlueTileColor;                              // 0x029C(0x0010)(Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AC[0x4];                                      // 0x02AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingEditModeSupport_BinaryToggle">();
	}
	static class UBuildingEditModeSupport_BinaryToggle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingEditModeSupport_BinaryToggle>();
	}
};
static_assert(alignof(UBuildingEditModeSupport_BinaryToggle) == 0x000010, "Wrong alignment on UBuildingEditModeSupport_BinaryToggle");
static_assert(sizeof(UBuildingEditModeSupport_BinaryToggle) == 0x0002B0, "Wrong size on UBuildingEditModeSupport_BinaryToggle");
static_assert(offsetof(UBuildingEditModeSupport_BinaryToggle, BinaryTogglePreviewData) == 0x000290, "Member 'UBuildingEditModeSupport_BinaryToggle::BinaryTogglePreviewData' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport_BinaryToggle, CurToggleAction) == 0x000298, "Member 'UBuildingEditModeSupport_BinaryToggle::CurToggleAction' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport_BinaryToggle, DefaultBlueTileColor) == 0x00029C, "Member 'UBuildingEditModeSupport_BinaryToggle::DefaultBlueTileColor' has a wrong offset!");

// Class FortniteGame.FortBotMissionManager
// 0x00A0 (0x00C8 - 0x0028)
class UFortBotMissionManager final : public UObject
{
public:
	TSoftClassPtr<class UClass>                   BotPawnClass;                                      // 0x0028(0x0020)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AFortPawn*>                      BotPawns;                                          // 0x0048(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UFortBotMissionLogic*>           ActiveMissionsLogicData;                           // 0x0058(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UFortBotMissionLogic*                   PrimaryMissionLogicData;                           // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_70[0x58];                                      // 0x0070(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBotMissionManager">();
	}
	static class UFortBotMissionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBotMissionManager>();
	}
};
static_assert(alignof(UFortBotMissionManager) == 0x000008, "Wrong alignment on UFortBotMissionManager");
static_assert(sizeof(UFortBotMissionManager) == 0x0000C8, "Wrong size on UFortBotMissionManager");
static_assert(offsetof(UFortBotMissionManager, BotPawnClass) == 0x000028, "Member 'UFortBotMissionManager::BotPawnClass' has a wrong offset!");
static_assert(offsetof(UFortBotMissionManager, BotPawns) == 0x000048, "Member 'UFortBotMissionManager::BotPawns' has a wrong offset!");
static_assert(offsetof(UFortBotMissionManager, ActiveMissionsLogicData) == 0x000058, "Member 'UFortBotMissionManager::ActiveMissionsLogicData' has a wrong offset!");
static_assert(offsetof(UFortBotMissionManager, PrimaryMissionLogicData) == 0x000068, "Member 'UFortBotMissionManager::PrimaryMissionLogicData' has a wrong offset!");

// Class FortniteGame.BuildingEditModeSupport_Floor
// 0x0000 (0x02B0 - 0x02B0)
class UBuildingEditModeSupport_Floor final : public UBuildingEditModeSupport_BinaryToggle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingEditModeSupport_Floor">();
	}
	static class UBuildingEditModeSupport_Floor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingEditModeSupport_Floor>();
	}
};
static_assert(alignof(UBuildingEditModeSupport_Floor) == 0x000010, "Wrong alignment on UBuildingEditModeSupport_Floor");
static_assert(sizeof(UBuildingEditModeSupport_Floor) == 0x0002B0, "Wrong size on UBuildingEditModeSupport_Floor");

// Class FortniteGame.BuildingEditModeSupport_Roof
// 0x0020 (0x02D0 - 0x02B0)
class UBuildingEditModeSupport_Roof final : public UBuildingEditModeSupport_BinaryToggle
{
public:
	TArray<struct FTileCompInterpData>            TileInterpData;                                    // 0x02B0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C0[0x10];                                     // 0x02C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingEditModeSupport_Roof">();
	}
	static class UBuildingEditModeSupport_Roof* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingEditModeSupport_Roof>();
	}
};
static_assert(alignof(UBuildingEditModeSupport_Roof) == 0x000010, "Wrong alignment on UBuildingEditModeSupport_Roof");
static_assert(sizeof(UBuildingEditModeSupport_Roof) == 0x0002D0, "Wrong size on UBuildingEditModeSupport_Roof");
static_assert(offsetof(UBuildingEditModeSupport_Roof, TileInterpData) == 0x0002B0, "Member 'UBuildingEditModeSupport_Roof::TileInterpData' has a wrong offset!");

// Class FortniteGame.FortNavArea_DefaultSmashable
// 0x0000 (0x0048 - 0x0048)
class UFortNavArea_DefaultSmashable : public UFortNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_DefaultSmashable">();
	}
	static class UFortNavArea_DefaultSmashable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_DefaultSmashable>();
	}
};
static_assert(alignof(UFortNavArea_DefaultSmashable) == 0x000008, "Wrong alignment on UFortNavArea_DefaultSmashable");
static_assert(sizeof(UFortNavArea_DefaultSmashable) == 0x000048, "Wrong size on UFortNavArea_DefaultSmashable");

// Class FortniteGame.FortAITask_Move
// 0x0038 (0x0148 - 0x0110)
class UFortAITask_Move : public UAITask_MoveTo
{
public:
	struct FFortMoveConfig                        MoveConfig;                                        // 0x0110(0x0028)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_138[0x10];                                     // 0x0138(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAITask_Move">();
	}
	static class UFortAITask_Move* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAITask_Move>();
	}
};
static_assert(alignof(UFortAITask_Move) == 0x000008, "Wrong alignment on UFortAITask_Move");
static_assert(sizeof(UFortAITask_Move) == 0x000148, "Wrong size on UFortAITask_Move");
static_assert(offsetof(UFortAITask_Move, MoveConfig) == 0x000110, "Member 'UFortAITask_Move::MoveConfig' has a wrong offset!");

// Class FortniteGame.FortAbilityTask_MoveAI
// 0x0038 (0x0180 - 0x0148)
class UFortAbilityTask_MoveAI final : public UFortAITask_Move
{
public:
	UMulticastDelegateProperty_                   OnComplete;                                        // 0x0148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnInterrupted;                                     // 0x0158(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnCancelled;                                       // 0x0168(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_178[0x8];                                      // 0x0178(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UFortAbilityTask_MoveAI* CreateMoveAITask(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, class AActor* MoveActor, const struct FVector& MoveLocation, EPawnActionMoveMode MoveMode, EPathObstacleAction PathObstacleAction, bool bStopAtEnd, EAIOptionFlag AcceptPartialPath, bool bFinishOnPlayerCollision, bool bProjectGoalLocationOnNavMesh, float AcceptableRadius, TSubclassOf<class AFortPawn> PushBumpedPawnClass, TSubclassOf<class UNavigationQueryFilter> FilterClass, bool bUseContinuousGoalTracking);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAbilityTask_MoveAI">();
	}
	static class UFortAbilityTask_MoveAI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAbilityTask_MoveAI>();
	}
};
static_assert(alignof(UFortAbilityTask_MoveAI) == 0x000008, "Wrong alignment on UFortAbilityTask_MoveAI");
static_assert(sizeof(UFortAbilityTask_MoveAI) == 0x000180, "Wrong size on UFortAbilityTask_MoveAI");
static_assert(offsetof(UFortAbilityTask_MoveAI, OnComplete) == 0x000148, "Member 'UFortAbilityTask_MoveAI::OnComplete' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_MoveAI, OnInterrupted) == 0x000158, "Member 'UFortAbilityTask_MoveAI::OnInterrupted' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_MoveAI, OnCancelled) == 0x000168, "Member 'UFortAbilityTask_MoveAI::OnCancelled' has a wrong offset!");

// Class FortniteGame.BuildingEditModeSupport_Wall
// 0x0000 (0x02B0 - 0x02B0)
class UBuildingEditModeSupport_Wall final : public UBuildingEditModeSupport_BinaryToggle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingEditModeSupport_Wall">();
	}
	static class UBuildingEditModeSupport_Wall* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingEditModeSupport_Wall>();
	}
};
static_assert(alignof(UBuildingEditModeSupport_Wall) == 0x000010, "Wrong alignment on UBuildingEditModeSupport_Wall");
static_assert(sizeof(UBuildingEditModeSupport_Wall) == 0x0002B0, "Wrong size on UBuildingEditModeSupport_Wall");

// Class FortniteGame.BuildingEditModeSupport_Stair
// 0x00B0 (0x0340 - 0x0290)
class UBuildingEditModeSupport_Stair final : public UBuildingEditModeSupport
{
public:
	class UBuildingEditModeMetadata_Stair*        StairPreviewMetadata;                              // 0x0290(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBuildingEditModeMetadata_Stair*        LastValidMetadataConfiguration;                    // 0x0298(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UStaticMesh>             AuxiliaryIndicatorMesh;                            // 0x02A0(0x0020)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UStaticMeshComponent*>           AuxiliaryIndicatorComponents;                      // 0x02C0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   ActivatedAuxIndicatorComponent;                    // 0x02D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UMaterialInterface>      AuxIndicatorComponentParentMaterial;               // 0x02D8(0x0020)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              AuxIndicatorArrowTexture;                          // 0x02F8(0x0020)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              AuxIndicatorGridTexture;                           // 0x0318(0x0020)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_338[0x8];                                      // 0x0338(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingEditModeSupport_Stair">();
	}
	static class UBuildingEditModeSupport_Stair* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingEditModeSupport_Stair>();
	}
};
static_assert(alignof(UBuildingEditModeSupport_Stair) == 0x000010, "Wrong alignment on UBuildingEditModeSupport_Stair");
static_assert(sizeof(UBuildingEditModeSupport_Stair) == 0x000340, "Wrong size on UBuildingEditModeSupport_Stair");
static_assert(offsetof(UBuildingEditModeSupport_Stair, StairPreviewMetadata) == 0x000290, "Member 'UBuildingEditModeSupport_Stair::StairPreviewMetadata' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport_Stair, LastValidMetadataConfiguration) == 0x000298, "Member 'UBuildingEditModeSupport_Stair::LastValidMetadataConfiguration' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport_Stair, AuxiliaryIndicatorMesh) == 0x0002A0, "Member 'UBuildingEditModeSupport_Stair::AuxiliaryIndicatorMesh' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport_Stair, AuxiliaryIndicatorComponents) == 0x0002C0, "Member 'UBuildingEditModeSupport_Stair::AuxiliaryIndicatorComponents' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport_Stair, ActivatedAuxIndicatorComponent) == 0x0002D0, "Member 'UBuildingEditModeSupport_Stair::ActivatedAuxIndicatorComponent' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport_Stair, AuxIndicatorComponentParentMaterial) == 0x0002D8, "Member 'UBuildingEditModeSupport_Stair::AuxIndicatorComponentParentMaterial' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport_Stair, AuxIndicatorArrowTexture) == 0x0002F8, "Member 'UBuildingEditModeSupport_Stair::AuxIndicatorArrowTexture' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport_Stair, AuxIndicatorGridTexture) == 0x000318, "Member 'UBuildingEditModeSupport_Stair::AuxIndicatorGridTexture' has a wrong offset!");

// Class FortniteGame.ManorPortal
// 0x0048 (0x03D0 - 0x0388)
class AManorPortal final : public AActor
{
public:
	uint8                                         Pad_388[0x48];                                     // 0x0388(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BlueprintOnUnlockPortalComplete();
	int32 GetCurrencyCost(class AFortPlayerController* Player);
	int32 GetPlayerCurrencyAmount(class AFortPlayerController* Player);
	bool IsPortalUnlocked(class AFortPlayerController* Player);
	bool IsProfileValidToReadPortalAvailability(class AFortPlayerController* Player);
	void OpenUnlockMenu(class AFortPlayerController* Player);
	void UnlockPortal(class AFortPlayerController* Player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ManorPortal">();
	}
	static class AManorPortal* GetDefaultObj()
	{
		return GetDefaultObjImpl<AManorPortal>();
	}
};
static_assert(alignof(AManorPortal) == 0x000008, "Wrong alignment on AManorPortal");
static_assert(sizeof(AManorPortal) == 0x0003D0, "Wrong size on AManorPortal");

// Class FortniteGame.FortClientAnnouncement_TutorialInterface
// 0x0000 (0x0028 - 0x0028)
class IFortClientAnnouncement_TutorialInterface final : public IInterface
{
public:
	void HideTutorialWidget();
	void SetButtonEnabled(bool bButtonEnabled);
	void SetDetailText(const class FText& NameText);
	void SetHAlign(EHorizontalAlignment HAlign);
	void SetLightboxDisableInputOnly(bool bLightboxDisableInputOnly);
	void SetLightboxEnabled(bool bLightboxEnabled);
	void SetNameText(const class FText& NameText);
	void SetPadding(const struct FMargin& Padding);
	void SetSystemText(const class FText& SystemText);
	void SetTitleText(const class FText& NameText);
	void SetVAlign(EVerticalAlignment VAlign);
	void WaitForContinue(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortClientAnnouncement_TutorialInterface">();
	}
	static class IFortClientAnnouncement_TutorialInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortClientAnnouncement_TutorialInterface>();
	}
};
static_assert(alignof(IFortClientAnnouncement_TutorialInterface) == 0x000008, "Wrong alignment on IFortClientAnnouncement_TutorialInterface");
static_assert(sizeof(IFortClientAnnouncement_TutorialInterface) == 0x000028, "Wrong size on IFortClientAnnouncement_TutorialInterface");

// Class FortniteGame.FortAnimInstance
// 0x0088 (0x03E0 - 0x0358)
class UFortAnimInstance : public UAnimInstance
{
public:
	bool                                          bUpdateAllPawnProperties;                          // 0x0358(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_359[0x3];                                      // 0x0359(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VelocityLerpAlpha;                                 // 0x035C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                PawnVelocity;                                      // 0x0360(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinSpeed2DThreshold;                               // 0x036C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PawnSpeed2D;                                       // 0x0370(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PawnVelocityZ;                                     // 0x0374(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PawnMovementDirectionAzimuth;                      // 0x0378(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PawnMovementDirectionElevation;                    // 0x037C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               PawnDeltaRotation;                                 // 0x0380(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               PawnLastRotation;                                  // 0x038C(0x000C)(Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsJumping;                                        // 0x0398(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFalling;                                        // 0x0399(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldPredictLanding;                             // 0x039A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLandingPredicted;                                 // 0x039B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PredictedFallTimeLeft;                             // 0x039C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FallLookAheadSubStepping;                          // 0x03A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FallLookAheadMaxIterations;                        // 0x03A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugLandPrediction;                              // 0x03A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRecordJumpPositions;                              // 0x03A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsRecordingJump;                                  // 0x03AA(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3AB[0x1];                                      // 0x03AB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RecordJumpFrameCount;                              // 0x03AC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                RecordJumpInitialJumpLocation;                     // 0x03B0(0x000C)(Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimPitch;                                          // 0x03BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimYaw;                                            // 0x03C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeForRecentlyFired;                              // 0x03C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeToReachRelaxedLevel1;                          // 0x03C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeToReachRelaxedLevel2;                          // 0x03CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRecentlyFired;                                    // 0x03D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsRelaxedLevel1;                                  // 0x03D1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsRelaxedLevel2;                                  // 0x03D2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D3[0x1];                                      // 0x03D3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RelaxedLevelTimeCounter;                           // 0x03D4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SavedWeaponLastFireTime;                           // 0x03D8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3DC[0x4];                                      // 0x03DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AnimNotify_LeftFootStep(const class UAnimNotify* Notify);
	void AnimNotify_RightFootStep(const class UAnimNotify* Notify);
	class AFortAIPawn* TryGetFortAIPawn();
	class AFortPawn* TryGetFortPawn();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAnimInstance">();
	}
	static class UFortAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAnimInstance>();
	}
};
static_assert(alignof(UFortAnimInstance) == 0x000008, "Wrong alignment on UFortAnimInstance");
static_assert(sizeof(UFortAnimInstance) == 0x0003E0, "Wrong size on UFortAnimInstance");
static_assert(offsetof(UFortAnimInstance, bUpdateAllPawnProperties) == 0x000358, "Member 'UFortAnimInstance::bUpdateAllPawnProperties' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, VelocityLerpAlpha) == 0x00035C, "Member 'UFortAnimInstance::VelocityLerpAlpha' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, PawnVelocity) == 0x000360, "Member 'UFortAnimInstance::PawnVelocity' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, MinSpeed2DThreshold) == 0x00036C, "Member 'UFortAnimInstance::MinSpeed2DThreshold' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, PawnSpeed2D) == 0x000370, "Member 'UFortAnimInstance::PawnSpeed2D' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, PawnVelocityZ) == 0x000374, "Member 'UFortAnimInstance::PawnVelocityZ' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, PawnMovementDirectionAzimuth) == 0x000378, "Member 'UFortAnimInstance::PawnMovementDirectionAzimuth' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, PawnMovementDirectionElevation) == 0x00037C, "Member 'UFortAnimInstance::PawnMovementDirectionElevation' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, PawnDeltaRotation) == 0x000380, "Member 'UFortAnimInstance::PawnDeltaRotation' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, PawnLastRotation) == 0x00038C, "Member 'UFortAnimInstance::PawnLastRotation' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, bIsJumping) == 0x000398, "Member 'UFortAnimInstance::bIsJumping' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, bIsFalling) == 0x000399, "Member 'UFortAnimInstance::bIsFalling' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, bShouldPredictLanding) == 0x00039A, "Member 'UFortAnimInstance::bShouldPredictLanding' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, bLandingPredicted) == 0x00039B, "Member 'UFortAnimInstance::bLandingPredicted' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, PredictedFallTimeLeft) == 0x00039C, "Member 'UFortAnimInstance::PredictedFallTimeLeft' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, FallLookAheadSubStepping) == 0x0003A0, "Member 'UFortAnimInstance::FallLookAheadSubStepping' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, FallLookAheadMaxIterations) == 0x0003A4, "Member 'UFortAnimInstance::FallLookAheadMaxIterations' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, bDebugLandPrediction) == 0x0003A8, "Member 'UFortAnimInstance::bDebugLandPrediction' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, bRecordJumpPositions) == 0x0003A9, "Member 'UFortAnimInstance::bRecordJumpPositions' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, bIsRecordingJump) == 0x0003AA, "Member 'UFortAnimInstance::bIsRecordingJump' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, RecordJumpFrameCount) == 0x0003AC, "Member 'UFortAnimInstance::RecordJumpFrameCount' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, RecordJumpInitialJumpLocation) == 0x0003B0, "Member 'UFortAnimInstance::RecordJumpInitialJumpLocation' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, AimPitch) == 0x0003BC, "Member 'UFortAnimInstance::AimPitch' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, AimYaw) == 0x0003C0, "Member 'UFortAnimInstance::AimYaw' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, TimeForRecentlyFired) == 0x0003C4, "Member 'UFortAnimInstance::TimeForRecentlyFired' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, TimeToReachRelaxedLevel1) == 0x0003C8, "Member 'UFortAnimInstance::TimeToReachRelaxedLevel1' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, TimeToReachRelaxedLevel2) == 0x0003CC, "Member 'UFortAnimInstance::TimeToReachRelaxedLevel2' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, bRecentlyFired) == 0x0003D0, "Member 'UFortAnimInstance::bRecentlyFired' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, bIsRelaxedLevel1) == 0x0003D1, "Member 'UFortAnimInstance::bIsRelaxedLevel1' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, bIsRelaxedLevel2) == 0x0003D2, "Member 'UFortAnimInstance::bIsRelaxedLevel2' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, RelaxedLevelTimeCounter) == 0x0003D4, "Member 'UFortAnimInstance::RelaxedLevelTimeCounter' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, SavedWeaponLastFireTime) == 0x0003D8, "Member 'UFortAnimInstance::SavedWeaponLastFireTime' has a wrong offset!");

// Class FortniteGame.FortAIAnimInstance
// 0x0028 (0x0408 - 0x03E0)
class UFortAIAnimInstance : public UFortAnimInstance
{
public:
	float                                         Speed;                                             // 0x03E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpwardVelocity;                                    // 0x03E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementDirection;                                 // 0x03E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowerBodyCurrentWeight;                            // 0x03EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowerBodyBlendTime;                                // 0x03F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RunVariation;                                      // 0x03F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WalkVariation;                                     // 0x03F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortMovementStyle                            MovementStyle;                                     // 0x03FC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3FD[0x3];                                      // 0x03FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         BlockGetUp : 1;                                    // 0x0400(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsStunned : 1;                                    // 0x0400(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsKnockedback : 1;                                // 0x0400(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsStaggered : 1;                                  // 0x0400(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsSleeping : 1;                                   // 0x0400(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsDBNO : 1;                                       // 0x0400(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsCowering : 1;                                   // 0x0400(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHasWeapon : 1;                                    // 0x0400(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAdditiveHitReactLoop : 1;                         // 0x0401(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseAltSleepAnim : 1;                              // 0x0401(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShouldUseMovementLocomotion : 1;                  // 0x0401(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanLookAtAimTarget : 1;                           // 0x0401(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsTargeting : 1;                                  // 0x0401(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTransitionToIdle : 1;                             // 0x0401(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_402[0x2];                                      // 0x0402(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	EFortWeaponCoreAnimation                      WeaponCoreAnimation;                               // 0x0404(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_405[0x3];                                      // 0x0405(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIAnimInstance">();
	}
	static class UFortAIAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIAnimInstance>();
	}
};
static_assert(alignof(UFortAIAnimInstance) == 0x000008, "Wrong alignment on UFortAIAnimInstance");
static_assert(sizeof(UFortAIAnimInstance) == 0x000408, "Wrong size on UFortAIAnimInstance");
static_assert(offsetof(UFortAIAnimInstance, Speed) == 0x0003E0, "Member 'UFortAIAnimInstance::Speed' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance, UpwardVelocity) == 0x0003E4, "Member 'UFortAIAnimInstance::UpwardVelocity' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance, MovementDirection) == 0x0003E8, "Member 'UFortAIAnimInstance::MovementDirection' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance, LowerBodyCurrentWeight) == 0x0003EC, "Member 'UFortAIAnimInstance::LowerBodyCurrentWeight' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance, LowerBodyBlendTime) == 0x0003F0, "Member 'UFortAIAnimInstance::LowerBodyBlendTime' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance, RunVariation) == 0x0003F4, "Member 'UFortAIAnimInstance::RunVariation' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance, WalkVariation) == 0x0003F8, "Member 'UFortAIAnimInstance::WalkVariation' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance, MovementStyle) == 0x0003FC, "Member 'UFortAIAnimInstance::MovementStyle' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance, WeaponCoreAnimation) == 0x000404, "Member 'UFortAIAnimInstance::WeaponCoreAnimation' has a wrong offset!");

// Class FortniteGame.FortDefenderAnimInstance
// 0x0018 (0x0420 - 0x0408)
class UFortDefenderAnimInstance : public UFortAIAnimInstance
{
public:
	EFortCustomGender                             Gender;                                            // 0x0408(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_409[0x3];                                      // 0x0409(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bShouldWalkRightFootForward : 1;                   // 0x040C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_40D[0x3];                                      // 0x040D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpeedAdjustedPlayRate;                             // 0x0410(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AuthoredJogSpeed;                                  // 0x0414(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AuthoredWalkSpeed;                                 // 0x0418(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41C[0x4];                                      // 0x041C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDefenderAnimInstance">();
	}
	static class UFortDefenderAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDefenderAnimInstance>();
	}
};
static_assert(alignof(UFortDefenderAnimInstance) == 0x000008, "Wrong alignment on UFortDefenderAnimInstance");
static_assert(sizeof(UFortDefenderAnimInstance) == 0x000420, "Wrong size on UFortDefenderAnimInstance");
static_assert(offsetof(UFortDefenderAnimInstance, Gender) == 0x000408, "Member 'UFortDefenderAnimInstance::Gender' has a wrong offset!");
static_assert(offsetof(UFortDefenderAnimInstance, SpeedAdjustedPlayRate) == 0x000410, "Member 'UFortDefenderAnimInstance::SpeedAdjustedPlayRate' has a wrong offset!");
static_assert(offsetof(UFortDefenderAnimInstance, AuthoredJogSpeed) == 0x000414, "Member 'UFortDefenderAnimInstance::AuthoredJogSpeed' has a wrong offset!");
static_assert(offsetof(UFortDefenderAnimInstance, AuthoredWalkSpeed) == 0x000418, "Member 'UFortDefenderAnimInstance::AuthoredWalkSpeed' has a wrong offset!");

// Class FortniteGame.BuildingGroup
// 0x0048 (0x0070 - 0x0028)
class UBuildingGroup final : public UDataAsset
{
public:
	class FName                                   GroupName;                                         // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBuildingGroup*                         FallbackGroup;                                     // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBuildingFoundationType                       FoundationType;                                    // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  AllBuildingLevelTags;                              // 0x0040(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FFortMapData>                   BuildingLevelData;                                 // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingGroup">();
	}
	static class UBuildingGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingGroup>();
	}
};
static_assert(alignof(UBuildingGroup) == 0x000008, "Wrong alignment on UBuildingGroup");
static_assert(sizeof(UBuildingGroup) == 0x000070, "Wrong size on UBuildingGroup");
static_assert(offsetof(UBuildingGroup, GroupName) == 0x000028, "Member 'UBuildingGroup::GroupName' has a wrong offset!");
static_assert(offsetof(UBuildingGroup, FallbackGroup) == 0x000030, "Member 'UBuildingGroup::FallbackGroup' has a wrong offset!");
static_assert(offsetof(UBuildingGroup, FoundationType) == 0x000038, "Member 'UBuildingGroup::FoundationType' has a wrong offset!");
static_assert(offsetof(UBuildingGroup, AllBuildingLevelTags) == 0x000040, "Member 'UBuildingGroup::AllBuildingLevelTags' has a wrong offset!");
static_assert(offsetof(UBuildingGroup, BuildingLevelData) == 0x000060, "Member 'UBuildingGroup::BuildingLevelData' has a wrong offset!");

// Class FortniteGame.BuildingTextureData
// 0x0038 (0x0060 - 0x0028)
class UBuildingTextureData final : public UDataAsset
{
public:
	class UTexture2D*                             Diffuse;                                           // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Normal;                                            // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Specular;                                          // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     OverrideMaterial;                                  // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortTextureDataType                          Type;                                              // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortResourceType                             ResourceType;                                      // 0x0049(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x2];                                       // 0x004A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ResourceCost[0x4];                                 // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingTextureData">();
	}
	static class UBuildingTextureData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingTextureData>();
	}
};
static_assert(alignof(UBuildingTextureData) == 0x000008, "Wrong alignment on UBuildingTextureData");
static_assert(sizeof(UBuildingTextureData) == 0x000060, "Wrong size on UBuildingTextureData");
static_assert(offsetof(UBuildingTextureData, Diffuse) == 0x000028, "Member 'UBuildingTextureData::Diffuse' has a wrong offset!");
static_assert(offsetof(UBuildingTextureData, Normal) == 0x000030, "Member 'UBuildingTextureData::Normal' has a wrong offset!");
static_assert(offsetof(UBuildingTextureData, Specular) == 0x000038, "Member 'UBuildingTextureData::Specular' has a wrong offset!");
static_assert(offsetof(UBuildingTextureData, OverrideMaterial) == 0x000040, "Member 'UBuildingTextureData::OverrideMaterial' has a wrong offset!");
static_assert(offsetof(UBuildingTextureData, Type) == 0x000048, "Member 'UBuildingTextureData::Type' has a wrong offset!");
static_assert(offsetof(UBuildingTextureData, ResourceType) == 0x000049, "Member 'UBuildingTextureData::ResourceType' has a wrong offset!");
static_assert(offsetof(UBuildingTextureData, ResourceCost) == 0x00004C, "Member 'UBuildingTextureData::ResourceCost' has a wrong offset!");

// Class FortniteGame.FortNavArea_HuskNull
// 0x0000 (0x0048 - 0x0048)
class UFortNavArea_HuskNull final : public UFortNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_HuskNull">();
	}
	static class UFortNavArea_HuskNull* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_HuskNull>();
	}
};
static_assert(alignof(UFortNavArea_HuskNull) == 0x000008, "Wrong alignment on UFortNavArea_HuskNull");
static_assert(sizeof(UFortNavArea_HuskNull) == 0x000048, "Wrong size on UFortNavArea_HuskNull");

// Class FortniteGame.FortAITetheringBoxBoundsInterface
// 0x0000 (0x0028 - 0x0028)
class IFortAITetheringBoxBoundsInterface final : public IInterface
{
public:
	struct FVector GetTetheredBoxBoundsCenter();
	float GetTetheredBoxBoundsEQSGridSize();
	float GetTetheredBoxBoundsEQSSpaceBetween();
	float GetTetheredBoxBoundsHeight();
	float GetTetheredBoxBoundsWidth();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAITetheringBoxBoundsInterface">();
	}
	static class IFortAITetheringBoxBoundsInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortAITetheringBoxBoundsInterface>();
	}
};
static_assert(alignof(IFortAITetheringBoxBoundsInterface) == 0x000008, "Wrong alignment on IFortAITetheringBoxBoundsInterface");
static_assert(sizeof(IFortAITetheringBoxBoundsInterface) == 0x000028, "Wrong size on IFortAITetheringBoxBoundsInterface");

// Class FortniteGame.BuildingTurretComponent
// 0x0050 (0x0140 - 0x00F0)
class UBuildingTurretComponent : public UActorComponent
{
public:
	UMulticastDelegateProperty_                   OnTurretTargetChanged;                             // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           OnFireTagTrigger;                                  // 0x0100(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FiringInterval;                                    // 0x0108(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentTargetValidationInterval;                   // 0x010C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bPerformPeriodicValidationOnCurrentTarget : 1;     // 0x0110(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    TargetingOverlapComponent;                         // 0x0118(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilitySystemComponent*                OwnerASC;                                          // 0x0120(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 CurrentTarget;                                     // 0x0128(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_130[0x10];                                     // 0x0130(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AttemptSetCurrentTarget(class AActor* NewTarget);
	void OnFiringTimer();
	void OnPerformTargetValidation();
	void OnRep_CurrentTarget(class AActor* OldTarget);
	void OnTargetingBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnTargetingEndOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void SetTargetingOverlapComponent(class UPrimitiveComponent* NewTargetingOverlapComponent);

	class AActor* ChooseBestTarget(TArray<class AActor*>& InOutPotentialTargets) const;
	bool IsValidTarget(class AActor* InTarget) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingTurretComponent">();
	}
	static class UBuildingTurretComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingTurretComponent>();
	}
};
static_assert(alignof(UBuildingTurretComponent) == 0x000008, "Wrong alignment on UBuildingTurretComponent");
static_assert(sizeof(UBuildingTurretComponent) == 0x000140, "Wrong size on UBuildingTurretComponent");
static_assert(offsetof(UBuildingTurretComponent, OnTurretTargetChanged) == 0x0000F0, "Member 'UBuildingTurretComponent::OnTurretTargetChanged' has a wrong offset!");
static_assert(offsetof(UBuildingTurretComponent, OnFireTagTrigger) == 0x000100, "Member 'UBuildingTurretComponent::OnFireTagTrigger' has a wrong offset!");
static_assert(offsetof(UBuildingTurretComponent, FiringInterval) == 0x000108, "Member 'UBuildingTurretComponent::FiringInterval' has a wrong offset!");
static_assert(offsetof(UBuildingTurretComponent, CurrentTargetValidationInterval) == 0x00010C, "Member 'UBuildingTurretComponent::CurrentTargetValidationInterval' has a wrong offset!");
static_assert(offsetof(UBuildingTurretComponent, TargetingOverlapComponent) == 0x000118, "Member 'UBuildingTurretComponent::TargetingOverlapComponent' has a wrong offset!");
static_assert(offsetof(UBuildingTurretComponent, OwnerASC) == 0x000120, "Member 'UBuildingTurretComponent::OwnerASC' has a wrong offset!");
static_assert(offsetof(UBuildingTurretComponent, CurrentTarget) == 0x000128, "Member 'UBuildingTurretComponent::CurrentTarget' has a wrong offset!");

// Class FortniteGame.BuildingTurretComponent_MOBA
// 0x0010 (0x0150 - 0x0140)
class UBuildingTurretComponent_MOBA final : public UBuildingTurretComponent
{
public:
	struct FMOBATurretPrioritySetting             TargetingPriority;                                 // 0x0140(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAllyHarmed(class AActor* InAllyActor, class AActor* InHarmingActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingTurretComponent_MOBA">();
	}
	static class UBuildingTurretComponent_MOBA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingTurretComponent_MOBA>();
	}
};
static_assert(alignof(UBuildingTurretComponent_MOBA) == 0x000008, "Wrong alignment on UBuildingTurretComponent_MOBA");
static_assert(sizeof(UBuildingTurretComponent_MOBA) == 0x000150, "Wrong size on UBuildingTurretComponent_MOBA");
static_assert(offsetof(UBuildingTurretComponent_MOBA, TargetingPriority) == 0x000140, "Member 'UBuildingTurretComponent_MOBA::TargetingPriority' has a wrong offset!");

// Class FortniteGame.FortAITask_FuzzyQueue
// 0x0020 (0x0130 - 0x0110)
class UFortAITask_FuzzyQueue final : public UAITask_MoveTo
{
public:
	uint8                                         Pad_110[0x20];                                     // 0x0110(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAITask_FuzzyQueue">();
	}
	static class UFortAITask_FuzzyQueue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAITask_FuzzyQueue>();
	}
};
static_assert(alignof(UFortAITask_FuzzyQueue) == 0x000008, "Wrong alignment on UFortAITask_FuzzyQueue");
static_assert(sizeof(UFortAITask_FuzzyQueue) == 0x000130, "Wrong size on UFortAITask_FuzzyQueue");

// Class FortniteGame.CustomCharacterPartData
// 0x0000 (0x0028 - 0x0028)
class UCustomCharacterPartData : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomCharacterPartData">();
	}
	static class UCustomCharacterPartData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomCharacterPartData>();
	}
};
static_assert(alignof(UCustomCharacterPartData) == 0x000008, "Wrong alignment on UCustomCharacterPartData");
static_assert(sizeof(UCustomCharacterPartData) == 0x000028, "Wrong size on UCustomCharacterPartData");

// Class FortniteGame.FortClientAnnouncement_ConversationInterface
// 0x0000 (0x0028 - 0x0028)
class IFortClientAnnouncement_ConversationInterface final : public IInterface
{
public:
	void OnConversationFinished(const struct FFortConversationSentence& FinishingSentence, int32 FinishingSentenceSentenceIndex);
	void OnConversationStarted(const struct FFortConversationSentence& StartingSentence, int32 StartingSentenceIndex);
	void OnSentenceFinished(const struct FFortConversationSentence& Sentence, int32 SentenceIndex);
	void OnSentenceStarted(const struct FFortConversationSentence& Sentence, int32 SentenceIndex);

	bool ShouldPlaySentence(const struct FFortConversationSentence& NewSentence) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortClientAnnouncement_ConversationInterface">();
	}
	static class IFortClientAnnouncement_ConversationInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortClientAnnouncement_ConversationInterface>();
	}
};
static_assert(alignof(IFortClientAnnouncement_ConversationInterface) == 0x000008, "Wrong alignment on IFortClientAnnouncement_ConversationInterface");
static_assert(sizeof(IFortClientAnnouncement_ConversationInterface) == 0x000028, "Wrong size on IFortClientAnnouncement_ConversationInterface");

// Class FortniteGame.CustomColorSwatch
// 0x0008 (0x0030 - 0x0028)
class UCustomColorSwatch : public UPrimaryDataAsset
{
public:
	EFortCustomGender                             GenderPermitted;                                   // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EColorSwatchType                              ColorSwatchType;                                   // 0x0029(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomColorSwatch">();
	}
	static class UCustomColorSwatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomColorSwatch>();
	}
};
static_assert(alignof(UCustomColorSwatch) == 0x000008, "Wrong alignment on UCustomColorSwatch");
static_assert(sizeof(UCustomColorSwatch) == 0x000030, "Wrong size on UCustomColorSwatch");
static_assert(offsetof(UCustomColorSwatch, GenderPermitted) == 0x000028, "Member 'UCustomColorSwatch::GenderPermitted' has a wrong offset!");
static_assert(offsetof(UCustomColorSwatch, ColorSwatchType) == 0x000029, "Member 'UCustomColorSwatch::ColorSwatchType' has a wrong offset!");

// Class FortniteGame.FortNavArea_SmashableJump
// 0x0008 (0x0050 - 0x0048)
class UFortNavArea_SmashableJump : public UFortNavArea
{
public:
	int32                                         Strength;                                          // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_SmashableJump">();
	}
	static class UFortNavArea_SmashableJump* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_SmashableJump>();
	}
};
static_assert(alignof(UFortNavArea_SmashableJump) == 0x000008, "Wrong alignment on UFortNavArea_SmashableJump");
static_assert(sizeof(UFortNavArea_SmashableJump) == 0x000050, "Wrong size on UFortNavArea_SmashableJump");
static_assert(offsetof(UFortNavArea_SmashableJump, Strength) == 0x000048, "Member 'UFortNavArea_SmashableJump::Strength' has a wrong offset!");

// Class FortniteGame.CustomCharacterPartAnimInstance
// 0x0030 (0x0410 - 0x03E0)
class UCustomCharacterPartAnimInstance : public UFortAnimInstance
{
public:
	uint8                                         Pad_3E0[0x8];                                      // 0x03E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bUsesDayPhaseChange : 1;                           // 0x03E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanPlayCustomAnimations : 1;                      // 0x03E8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_3E9[0x7];                                      // 0x03E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagAnimations                 GameplayTagAnimations;                             // 0x03F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         bRegisteredForDayPhaseChange : 1;                  // 0x0400(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_401[0x3];                                      // 0x0401(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EFortCustomPartType                           PartType;                                          // 0x0404(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_405[0xB];                                      // 0x0405(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDayPhaseChanged(EFortDayPhase CurrentDayPhase, EFortDayPhase PreviousDayPhase, bool bAtCreation);
	void OnPlayMontageFromGameplayTagQuery(const struct FGameplayTagQuery& MatchingQuery, class UAnimMontage* MontagePlaying);
	void PreDestruction();

	class AFortPlayerPawn* GetAssociatedPlayerPawn() const;
	const EFortCustomPartType GetCharacterPartType() const;
	class USkeletalMeshComponent* GetOwnerSkeletalMeshComponent() const;
	class USkeletalMeshComponent* GetPartSkeletalMeshComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomCharacterPartAnimInstance">();
	}
	static class UCustomCharacterPartAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomCharacterPartAnimInstance>();
	}
};
static_assert(alignof(UCustomCharacterPartAnimInstance) == 0x000008, "Wrong alignment on UCustomCharacterPartAnimInstance");
static_assert(sizeof(UCustomCharacterPartAnimInstance) == 0x000410, "Wrong size on UCustomCharacterPartAnimInstance");
static_assert(offsetof(UCustomCharacterPartAnimInstance, GameplayTagAnimations) == 0x0003F0, "Member 'UCustomCharacterPartAnimInstance::GameplayTagAnimations' has a wrong offset!");
static_assert(offsetof(UCustomCharacterPartAnimInstance, PartType) == 0x000404, "Member 'UCustomCharacterPartAnimInstance::PartType' has a wrong offset!");

// Class FortniteGame.CustomDynamicColorSwatch
// 0x0010 (0x0040 - 0x0030)
class UCustomDynamicColorSwatch : public UCustomColorSwatch
{
public:
	TArray<struct FColorSwatchPair>               ColorPairs;                                        // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomDynamicColorSwatch">();
	}
	static class UCustomDynamicColorSwatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomDynamicColorSwatch>();
	}
};
static_assert(alignof(UCustomDynamicColorSwatch) == 0x000008, "Wrong alignment on UCustomDynamicColorSwatch");
static_assert(sizeof(UCustomDynamicColorSwatch) == 0x000040, "Wrong size on UCustomDynamicColorSwatch");
static_assert(offsetof(UCustomDynamicColorSwatch, ColorPairs) == 0x000030, "Member 'UCustomDynamicColorSwatch::ColorPairs' has a wrong offset!");

// Class FortniteGame.CustomAccessoryColorSwatch
// 0x0030 (0x0070 - 0x0040)
class UCustomAccessoryColorSwatch final : public UCustomDynamicColorSwatch
{
public:
	struct FLinearColor                           AccessoryColors[0x3];                              // 0x0040(0x0010)(Edit, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomAccessoryColorSwatch">();
	}
	static class UCustomAccessoryColorSwatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomAccessoryColorSwatch>();
	}
};
static_assert(alignof(UCustomAccessoryColorSwatch) == 0x000008, "Wrong alignment on UCustomAccessoryColorSwatch");
static_assert(sizeof(UCustomAccessoryColorSwatch) == 0x000070, "Wrong size on UCustomAccessoryColorSwatch");
static_assert(offsetof(UCustomAccessoryColorSwatch, AccessoryColors) == 0x000040, "Member 'UCustomAccessoryColorSwatch::AccessoryColors' has a wrong offset!");

// Class FortniteGame.WorldMapPinManager
// 0x0020 (0x03A8 - 0x0388)
class AWorldMapPinManager : public AActor
{
public:
	uint8                                         Pad_388[0x8];                                      // 0x0388(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortStaticMeshActor*                   WorldMapMesh;                                      // 0x0390(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AWorldMapPin*>                   CurrentPins;                                       // 0x0398(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	class AWorldMapPin* CreateWorldMapPin(const class FString& TheaterId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldMapPinManager">();
	}
	static class AWorldMapPinManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWorldMapPinManager>();
	}
};
static_assert(alignof(AWorldMapPinManager) == 0x000008, "Wrong alignment on AWorldMapPinManager");
static_assert(sizeof(AWorldMapPinManager) == 0x0003A8, "Wrong size on AWorldMapPinManager");
static_assert(offsetof(AWorldMapPinManager, WorldMapMesh) == 0x000390, "Member 'AWorldMapPinManager::WorldMapMesh' has a wrong offset!");
static_assert(offsetof(AWorldMapPinManager, CurrentPins) == 0x000398, "Member 'AWorldMapPinManager::CurrentPins' has a wrong offset!");

// Class FortniteGame.FortCharacter
// 0x0018 (0x0150 - 0x0138)
class UFortCharacter : public UFortAccountItem
{
public:
	class FString                                 squad_id;                                          // 0x0138(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         squad_slot_idx;                                    // 0x0148(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCharacter">();
	}
	static class UFortCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCharacter>();
	}
};
static_assert(alignof(UFortCharacter) == 0x000008, "Wrong alignment on UFortCharacter");
static_assert(sizeof(UFortCharacter) == 0x000150, "Wrong size on UFortCharacter");
static_assert(offsetof(UFortCharacter, squad_id) == 0x000138, "Member 'UFortCharacter::squad_id' has a wrong offset!");
static_assert(offsetof(UFortCharacter, squad_slot_idx) == 0x000148, "Member 'UFortCharacter::squad_slot_idx' has a wrong offset!");

// Class FortniteGame.CustomCharacterAccessoryData
// 0x00B0 (0x00D8 - 0x0028)
class UCustomCharacterAccessoryData : public UCustomCharacterPartData
{
public:
	class FName                                   AttachSocketName;                                  // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UPhysicsAsset>           PhysicsAsset;                                      // 0x0030(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   AnimClass;                                         // 0x0050(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   FrontEndAnimClass;                                 // 0x0070(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   MannequinAnimClass;                                // 0x0090(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UCustomAccessoryColorSwatch> AccessoryColors;                                   // 0x00B0(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomCharacterAccessoryData">();
	}
	static class UCustomCharacterAccessoryData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomCharacterAccessoryData>();
	}
};
static_assert(alignof(UCustomCharacterAccessoryData) == 0x000008, "Wrong alignment on UCustomCharacterAccessoryData");
static_assert(sizeof(UCustomCharacterAccessoryData) == 0x0000D8, "Wrong size on UCustomCharacterAccessoryData");
static_assert(offsetof(UCustomCharacterAccessoryData, AttachSocketName) == 0x000028, "Member 'UCustomCharacterAccessoryData::AttachSocketName' has a wrong offset!");
static_assert(offsetof(UCustomCharacterAccessoryData, PhysicsAsset) == 0x000030, "Member 'UCustomCharacterAccessoryData::PhysicsAsset' has a wrong offset!");
static_assert(offsetof(UCustomCharacterAccessoryData, AnimClass) == 0x000050, "Member 'UCustomCharacterAccessoryData::AnimClass' has a wrong offset!");
static_assert(offsetof(UCustomCharacterAccessoryData, FrontEndAnimClass) == 0x000070, "Member 'UCustomCharacterAccessoryData::FrontEndAnimClass' has a wrong offset!");
static_assert(offsetof(UCustomCharacterAccessoryData, MannequinAnimClass) == 0x000090, "Member 'UCustomCharacterAccessoryData::MannequinAnimClass' has a wrong offset!");
static_assert(offsetof(UCustomCharacterAccessoryData, AccessoryColors) == 0x0000B0, "Member 'UCustomCharacterAccessoryData::AccessoryColors' has a wrong offset!");

// Class FortniteGame.FortWeap_WannaGun
// 0x0060 (0x0D00 - 0x0CA0)
class AFortWeap_WannaGun final : public AFortWeaponRanged
{
public:
	uint8                                         Pad_CA0[0x20];                                     // 0x0CA0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LastHitActorScale;                                 // 0x0CC0(0x000C)(Net, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               LastHitActorRotation;                              // 0x0CCC(0x000C)(Net, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	class UClass*                                 LastHitActorClass;                                 // 0x0CD8(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UBuildingTextureData>    TransparentTextureData;                            // 0x0CE0(0x0020)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_LastHitActorClass();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortWeap_WannaGun">();
	}
	static class AFortWeap_WannaGun* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortWeap_WannaGun>();
	}
};
static_assert(alignof(AFortWeap_WannaGun) == 0x000008, "Wrong alignment on AFortWeap_WannaGun");
static_assert(sizeof(AFortWeap_WannaGun) == 0x000D00, "Wrong size on AFortWeap_WannaGun");
static_assert(offsetof(AFortWeap_WannaGun, LastHitActorScale) == 0x000CC0, "Member 'AFortWeap_WannaGun::LastHitActorScale' has a wrong offset!");
static_assert(offsetof(AFortWeap_WannaGun, LastHitActorRotation) == 0x000CCC, "Member 'AFortWeap_WannaGun::LastHitActorRotation' has a wrong offset!");
static_assert(offsetof(AFortWeap_WannaGun, LastHitActorClass) == 0x000CD8, "Member 'AFortWeap_WannaGun::LastHitActorClass' has a wrong offset!");
static_assert(offsetof(AFortWeap_WannaGun, TransparentTextureData) == 0x000CE0, "Member 'AFortWeap_WannaGun::TransparentTextureData' has a wrong offset!");

// Class FortniteGame.FortClientAnnouncement_Tutorial
// 0x0168 (0x0560 - 0x03F8)
class AFortClientAnnouncement_Tutorial final : public AFortClientAnnouncement
{
public:
	uint8                                         Pad_3F8[0x8];                                      // 0x03F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortClientAnnouncementData_Tutorial   TutorialData;                                      // 0x0400(0x0140)(Edit, BlueprintVisible, Net, RepNotify, ExposeOnSpawn, NativeAccessSpecifierPublic)
	float                                         AutoContinueDelay;                                 // 0x0540(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_544[0x1C];                                     // 0x0544(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_TutorialData(const struct FFortClientAnnouncementData_Tutorial& PreviousTutorialData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortClientAnnouncement_Tutorial">();
	}
	static class AFortClientAnnouncement_Tutorial* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortClientAnnouncement_Tutorial>();
	}
};
static_assert(alignof(AFortClientAnnouncement_Tutorial) == 0x000008, "Wrong alignment on AFortClientAnnouncement_Tutorial");
static_assert(sizeof(AFortClientAnnouncement_Tutorial) == 0x000560, "Wrong size on AFortClientAnnouncement_Tutorial");
static_assert(offsetof(AFortClientAnnouncement_Tutorial, TutorialData) == 0x000400, "Member 'AFortClientAnnouncement_Tutorial::TutorialData' has a wrong offset!");
static_assert(offsetof(AFortClientAnnouncement_Tutorial, AutoContinueDelay) == 0x000540, "Member 'AFortClientAnnouncement_Tutorial::AutoContinueDelay' has a wrong offset!");

// Class FortniteGame.CustomCharacterBackpackData
// 0x0008 (0x00E0 - 0x00D8)
class UCustomCharacterBackpackData final : public UCustomCharacterAccessoryData
{
public:
	class FName                                   LootSocketName;                                    // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomCharacterBackpackData">();
	}
	static class UCustomCharacterBackpackData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomCharacterBackpackData>();
	}
};
static_assert(alignof(UCustomCharacterBackpackData) == 0x000008, "Wrong alignment on UCustomCharacterBackpackData");
static_assert(sizeof(UCustomCharacterBackpackData) == 0x0000E0, "Wrong size on UCustomCharacterBackpackData");
static_assert(offsetof(UCustomCharacterBackpackData, LootSocketName) == 0x0000D8, "Member 'UCustomCharacterBackpackData::LootSocketName' has a wrong offset!");

// Class FortniteGame.FortNavArea_WallCorner
// 0x0000 (0x0048 - 0x0048)
class UFortNavArea_WallCorner final : public UFortNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_WallCorner">();
	}
	static class UFortNavArea_WallCorner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_WallCorner>();
	}
};
static_assert(alignof(UFortNavArea_WallCorner) == 0x000008, "Wrong alignment on UFortNavArea_WallCorner");
static_assert(sizeof(UFortNavArea_WallCorner) == 0x000048, "Wrong size on UFortNavArea_WallCorner");

// Class FortniteGame.FrontEndSettings
// 0x0010 (0x0398 - 0x0388)
class AFrontEndSettings : public AActor
{
public:
	TArray<struct FCameraPair>                    Cameras;                                           // 0x0388(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FrontEndSettings">();
	}
	static class AFrontEndSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFrontEndSettings>();
	}
};
static_assert(alignof(AFrontEndSettings) == 0x000008, "Wrong alignment on AFrontEndSettings");
static_assert(sizeof(AFrontEndSettings) == 0x000398, "Wrong size on AFrontEndSettings");
static_assert(offsetof(AFrontEndSettings, Cameras) == 0x000388, "Member 'AFrontEndSettings::Cameras' has a wrong offset!");

// Class FortniteGame.FortPlayerAnimInstance
// 0x00C0 (0x04A0 - 0x03E0)
class UFortPlayerAnimInstance : public UFortAnimInstance
{
public:
	uint8                                         Pad_3E0[0x8];                                      // 0x03E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AimPitchAdjustment;                                // 0x03E8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimYawAdjustment;                                  // 0x03EC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxAimYawAdjustment;                               // 0x03F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxPitch;                                          // 0x03F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxYaw;                                            // 0x03F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReticleAimDistance;                                // 0x03FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimAdjustmentInterpSpeed;                          // 0x0400(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimTwistCorrectionExponent;                        // 0x0404(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               WeaponAimingFreezeInterpScale;                     // 0x0408(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_414[0x4];                                      // 0x0414(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   WeaponAimingCurveName;                             // 0x0418(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   WeaponAimingFreezeCurveName;                       // 0x0420(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bAimWeaponTowardsReticle : 1;                      // 0x0428(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDebugWeaponAiming : 1;                            // 0x0428(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCachedPawnTransform : 1;                          // 0x0428(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bHasValidWeaponMuzzleSocket : 1;                   // 0x0428(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_429[0x7];                                      // 0x0429(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LastFramePawnTransform;                            // 0x0430(0x0030)(Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   HeadTrackingReticleSocketName;                     // 0x0460(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAxis                                         HeadTrackingReticleSocketLookAtAxis;               // 0x0468(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_469[0x3];                                      // 0x0469(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HeadTrackingReticleInterpSpeed;                    // 0x046C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               HeadTrackingReticleAdjustment;                     // 0x0470(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         HeadTrackingReticlePitchAlpha;                     // 0x047C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HeadTrackingReticleAimDistance;                    // 0x0480(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HeadTrackingReticleAimDistanceDownsights;          // 0x0484(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagAnimations                 GameplayTagAnimations;                             // 0x0488(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_498[0x8];                                      // 0x0498(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AnimNotify_PlayFireFX(const class UAnimNotify* Notify);
	void AnimNotify_PlaySecondaryFireFX(const class UAnimNotify* Notify);
	void AnimNotify_StopFireFX(const class UAnimNotify* Notify);
	void OnPlayMontageFromGameplayTagQuery(const struct FGameplayTagQuery& MatchingQuery, class UAnimMontage* MontagePlaying);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerAnimInstance">();
	}
	static class UFortPlayerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPlayerAnimInstance>();
	}
};
static_assert(alignof(UFortPlayerAnimInstance) == 0x000010, "Wrong alignment on UFortPlayerAnimInstance");
static_assert(sizeof(UFortPlayerAnimInstance) == 0x0004A0, "Wrong size on UFortPlayerAnimInstance");
static_assert(offsetof(UFortPlayerAnimInstance, AimPitchAdjustment) == 0x0003E8, "Member 'UFortPlayerAnimInstance::AimPitchAdjustment' has a wrong offset!");
static_assert(offsetof(UFortPlayerAnimInstance, AimYawAdjustment) == 0x0003EC, "Member 'UFortPlayerAnimInstance::AimYawAdjustment' has a wrong offset!");
static_assert(offsetof(UFortPlayerAnimInstance, MaxAimYawAdjustment) == 0x0003F0, "Member 'UFortPlayerAnimInstance::MaxAimYawAdjustment' has a wrong offset!");
static_assert(offsetof(UFortPlayerAnimInstance, MaxPitch) == 0x0003F4, "Member 'UFortPlayerAnimInstance::MaxPitch' has a wrong offset!");
static_assert(offsetof(UFortPlayerAnimInstance, MaxYaw) == 0x0003F8, "Member 'UFortPlayerAnimInstance::MaxYaw' has a wrong offset!");
static_assert(offsetof(UFortPlayerAnimInstance, ReticleAimDistance) == 0x0003FC, "Member 'UFortPlayerAnimInstance::ReticleAimDistance' has a wrong offset!");
static_assert(offsetof(UFortPlayerAnimInstance, AimAdjustmentInterpSpeed) == 0x000400, "Member 'UFortPlayerAnimInstance::AimAdjustmentInterpSpeed' has a wrong offset!");
static_assert(offsetof(UFortPlayerAnimInstance, AimTwistCorrectionExponent) == 0x000404, "Member 'UFortPlayerAnimInstance::AimTwistCorrectionExponent' has a wrong offset!");
static_assert(offsetof(UFortPlayerAnimInstance, WeaponAimingFreezeInterpScale) == 0x000408, "Member 'UFortPlayerAnimInstance::WeaponAimingFreezeInterpScale' has a wrong offset!");
static_assert(offsetof(UFortPlayerAnimInstance, WeaponAimingCurveName) == 0x000418, "Member 'UFortPlayerAnimInstance::WeaponAimingCurveName' has a wrong offset!");
static_assert(offsetof(UFortPlayerAnimInstance, WeaponAimingFreezeCurveName) == 0x000420, "Member 'UFortPlayerAnimInstance::WeaponAimingFreezeCurveName' has a wrong offset!");
static_assert(offsetof(UFortPlayerAnimInstance, LastFramePawnTransform) == 0x000430, "Member 'UFortPlayerAnimInstance::LastFramePawnTransform' has a wrong offset!");
static_assert(offsetof(UFortPlayerAnimInstance, HeadTrackingReticleSocketName) == 0x000460, "Member 'UFortPlayerAnimInstance::HeadTrackingReticleSocketName' has a wrong offset!");
static_assert(offsetof(UFortPlayerAnimInstance, HeadTrackingReticleSocketLookAtAxis) == 0x000468, "Member 'UFortPlayerAnimInstance::HeadTrackingReticleSocketLookAtAxis' has a wrong offset!");
static_assert(offsetof(UFortPlayerAnimInstance, HeadTrackingReticleInterpSpeed) == 0x00046C, "Member 'UFortPlayerAnimInstance::HeadTrackingReticleInterpSpeed' has a wrong offset!");
static_assert(offsetof(UFortPlayerAnimInstance, HeadTrackingReticleAdjustment) == 0x000470, "Member 'UFortPlayerAnimInstance::HeadTrackingReticleAdjustment' has a wrong offset!");
static_assert(offsetof(UFortPlayerAnimInstance, HeadTrackingReticlePitchAlpha) == 0x00047C, "Member 'UFortPlayerAnimInstance::HeadTrackingReticlePitchAlpha' has a wrong offset!");
static_assert(offsetof(UFortPlayerAnimInstance, HeadTrackingReticleAimDistance) == 0x000480, "Member 'UFortPlayerAnimInstance::HeadTrackingReticleAimDistance' has a wrong offset!");
static_assert(offsetof(UFortPlayerAnimInstance, HeadTrackingReticleAimDistanceDownsights) == 0x000484, "Member 'UFortPlayerAnimInstance::HeadTrackingReticleAimDistanceDownsights' has a wrong offset!");
static_assert(offsetof(UFortPlayerAnimInstance, GameplayTagAnimations) == 0x000488, "Member 'UFortPlayerAnimInstance::GameplayTagAnimations' has a wrong offset!");

// Class FortniteGame.CustomCharacterCharmData
// 0x0008 (0x00E0 - 0x00D8)
class UCustomCharacterCharmData final : public UCustomCharacterAccessoryData
{
public:
	EFortCustomPartType                           PartAttachedToOverride;                            // 0x00D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomCharacterCharmData">();
	}
	static class UCustomCharacterCharmData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomCharacterCharmData>();
	}
};
static_assert(alignof(UCustomCharacterCharmData) == 0x000008, "Wrong alignment on UCustomCharacterCharmData");
static_assert(sizeof(UCustomCharacterCharmData) == 0x0000E0, "Wrong size on UCustomCharacterCharmData");
static_assert(offsetof(UCustomCharacterCharmData, PartAttachedToOverride) == 0x0000D8, "Member 'UCustomCharacterCharmData::PartAttachedToOverride' has a wrong offset!");

// Class FortniteGame.CustomCharacterFaceData
// 0x0008 (0x00E0 - 0x00D8)
class UCustomCharacterFaceData final : public UCustomCharacterAccessoryData
{
public:
	EFortCustomPartType                           PartAttachedToOverride;                            // 0x00D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomCharacterFaceData">();
	}
	static class UCustomCharacterFaceData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomCharacterFaceData>();
	}
};
static_assert(alignof(UCustomCharacterFaceData) == 0x000008, "Wrong alignment on UCustomCharacterFaceData");
static_assert(sizeof(UCustomCharacterFaceData) == 0x0000E0, "Wrong size on UCustomCharacterFaceData");
static_assert(offsetof(UCustomCharacterFaceData, PartAttachedToOverride) == 0x0000D8, "Member 'UCustomCharacterFaceData::PartAttachedToOverride' has a wrong offset!");

// Class FortniteGame.FortClientAnnouncement_Cinematic
// 0x0000 (0x03F8 - 0x03F8)
class AFortClientAnnouncement_Cinematic : public AFortClientAnnouncement
{
public:
	void OnPlayerSkippedCutscene();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortClientAnnouncement_Cinematic">();
	}
	static class AFortClientAnnouncement_Cinematic* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortClientAnnouncement_Cinematic>();
	}
};
static_assert(alignof(AFortClientAnnouncement_Cinematic) == 0x000008, "Wrong alignment on AFortClientAnnouncement_Cinematic");
static_assert(sizeof(AFortClientAnnouncement_Cinematic) == 0x0003F8, "Wrong size on AFortClientAnnouncement_Cinematic");

// Class FortniteGame.CustomCharacterHatData
// 0x0008 (0x00E0 - 0x00D8)
class UCustomCharacterHatData final : public UCustomCharacterAccessoryData
{
public:
	ECustomHatType                                HatType;                                           // 0x00D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomCharacterHatData">();
	}
	static class UCustomCharacterHatData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomCharacterHatData>();
	}
};
static_assert(alignof(UCustomCharacterHatData) == 0x000008, "Wrong alignment on UCustomCharacterHatData");
static_assert(sizeof(UCustomCharacterHatData) == 0x0000E0, "Wrong size on UCustomCharacterHatData");
static_assert(offsetof(UCustomCharacterHatData, HatType) == 0x0000D8, "Member 'UCustomCharacterHatData::HatType' has a wrong offset!");

// Class FortniteGame.CustomCharacterBodyPartData
// 0x0080 (0x00A8 - 0x0028)
class UCustomCharacterBodyPartData : public UCustomCharacterPartData
{
public:
	TSoftClassPtr<class UClass>                   AnimClass;                                         // 0x0028(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   FrontEndAnimClass;                                 // 0x0048(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   MannequinAnimClass;                                // 0x0068(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UCustomAccessoryColorSwatch> AccessoryColors;                                   // 0x0088(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomCharacterBodyPartData">();
	}
	static class UCustomCharacterBodyPartData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomCharacterBodyPartData>();
	}
};
static_assert(alignof(UCustomCharacterBodyPartData) == 0x000008, "Wrong alignment on UCustomCharacterBodyPartData");
static_assert(sizeof(UCustomCharacterBodyPartData) == 0x0000A8, "Wrong size on UCustomCharacterBodyPartData");
static_assert(offsetof(UCustomCharacterBodyPartData, AnimClass) == 0x000028, "Member 'UCustomCharacterBodyPartData::AnimClass' has a wrong offset!");
static_assert(offsetof(UCustomCharacterBodyPartData, FrontEndAnimClass) == 0x000048, "Member 'UCustomCharacterBodyPartData::FrontEndAnimClass' has a wrong offset!");
static_assert(offsetof(UCustomCharacterBodyPartData, MannequinAnimClass) == 0x000068, "Member 'UCustomCharacterBodyPartData::MannequinAnimClass' has a wrong offset!");
static_assert(offsetof(UCustomCharacterBodyPartData, AccessoryColors) == 0x000088, "Member 'UCustomCharacterBodyPartData::AccessoryColors' has a wrong offset!");

// Class FortniteGame.FortMarkActor
// 0x00E0 (0x0468 - 0x0388)
class AFortMarkActor final : public AActor
{
public:
	TWeakObjectPtr<class AFortPlayerStateZone>    OwningPlayer;                                      // 0x0388(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MarkString;                                        // 0x0390(0x0010)(Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   PreapprovedMarkString;                             // 0x03A0(0x0018)(Net, NativeAccessSpecifierPublic)
	bool                                          bFinishedEditing;                                  // 0x03B8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B9[0x7];                                      // 0x03B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 AttachedToActor;                                   // 0x03C0(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AttachmentOffset;                                  // 0x03C8(0x000C)(Net, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D4[0x4];                                      // 0x03D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            MiniMapIconBrush;                                  // 0x03D8(0x0090)(NativeAccessSpecifierPublic)

public:
	void OnRep_AttachedToActor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMarkActor">();
	}
	static class AFortMarkActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortMarkActor>();
	}
};
static_assert(alignof(AFortMarkActor) == 0x000008, "Wrong alignment on AFortMarkActor");
static_assert(sizeof(AFortMarkActor) == 0x000468, "Wrong size on AFortMarkActor");
static_assert(offsetof(AFortMarkActor, OwningPlayer) == 0x000388, "Member 'AFortMarkActor::OwningPlayer' has a wrong offset!");
static_assert(offsetof(AFortMarkActor, MarkString) == 0x000390, "Member 'AFortMarkActor::MarkString' has a wrong offset!");
static_assert(offsetof(AFortMarkActor, PreapprovedMarkString) == 0x0003A0, "Member 'AFortMarkActor::PreapprovedMarkString' has a wrong offset!");
static_assert(offsetof(AFortMarkActor, bFinishedEditing) == 0x0003B8, "Member 'AFortMarkActor::bFinishedEditing' has a wrong offset!");
static_assert(offsetof(AFortMarkActor, AttachedToActor) == 0x0003C0, "Member 'AFortMarkActor::AttachedToActor' has a wrong offset!");
static_assert(offsetof(AFortMarkActor, AttachmentOffset) == 0x0003C8, "Member 'AFortMarkActor::AttachmentOffset' has a wrong offset!");
static_assert(offsetof(AFortMarkActor, MiniMapIconBrush) == 0x0003D8, "Member 'AFortMarkActor::MiniMapIconBrush' has a wrong offset!");

// Class FortniteGame.CustomCharacterHeadData
// 0x0080 (0x0128 - 0x00A8)
class UCustomCharacterHeadData final : public UCustomCharacterBodyPartData
{
public:
	TSoftObjectPtr<class UCustomSkinColorSwatch>  SkinColorSwatch;                                   // 0x00A8(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UCustomHairColorSwatch>  HairColorSwatch;                                   // 0x00C8(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           CapMorphTargets;                                   // 0x00E8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           HelmetMorphTargets;                                // 0x00F8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           MaskMorphTargets;                                  // 0x0108(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           HatMorphTargets;                                   // 0x0118(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomCharacterHeadData">();
	}
	static class UCustomCharacterHeadData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomCharacterHeadData>();
	}
};
static_assert(alignof(UCustomCharacterHeadData) == 0x000008, "Wrong alignment on UCustomCharacterHeadData");
static_assert(sizeof(UCustomCharacterHeadData) == 0x000128, "Wrong size on UCustomCharacterHeadData");
static_assert(offsetof(UCustomCharacterHeadData, SkinColorSwatch) == 0x0000A8, "Member 'UCustomCharacterHeadData::SkinColorSwatch' has a wrong offset!");
static_assert(offsetof(UCustomCharacterHeadData, HairColorSwatch) == 0x0000C8, "Member 'UCustomCharacterHeadData::HairColorSwatch' has a wrong offset!");
static_assert(offsetof(UCustomCharacterHeadData, CapMorphTargets) == 0x0000E8, "Member 'UCustomCharacterHeadData::CapMorphTargets' has a wrong offset!");
static_assert(offsetof(UCustomCharacterHeadData, HelmetMorphTargets) == 0x0000F8, "Member 'UCustomCharacterHeadData::HelmetMorphTargets' has a wrong offset!");
static_assert(offsetof(UCustomCharacterHeadData, MaskMorphTargets) == 0x000108, "Member 'UCustomCharacterHeadData::MaskMorphTargets' has a wrong offset!");
static_assert(offsetof(UCustomCharacterHeadData, HatMorphTargets) == 0x000118, "Member 'UCustomCharacterHeadData::HatMorphTargets' has a wrong offset!");

// Class FortniteGame.CustomCharacterPartModifier
// 0x0010 (0x0398 - 0x0388)
class ACustomCharacterPartModifier final : public AActor
{
public:
	uint8                                         bUsesDayPhaseChange : 1;                           // 0x0388(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bRegisteredForDayPhaseChange : 1;                  // 0x0388(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_389[0x3];                                      // 0x0389(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AFortPlayerPawn>         FortPlayerPawnPtr;                                 // 0x038C(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EFortCustomPartType                           PartType;                                          // 0x0394(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_395[0x3];                                      // 0x0395(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDayPhaseChanged(EFortDayPhase CurrentDayPhase, EFortDayPhase PreviousDayPhase, bool bAtCreation);
	void PreDestruction();

	class AFortPlayerPawn* GetAssociatedPlayerPawn() const;
	const EFortCustomPartType GetCharacterPartType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomCharacterPartModifier">();
	}
	static class ACustomCharacterPartModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACustomCharacterPartModifier>();
	}
};
static_assert(alignof(ACustomCharacterPartModifier) == 0x000008, "Wrong alignment on ACustomCharacterPartModifier");
static_assert(sizeof(ACustomCharacterPartModifier) == 0x000398, "Wrong size on ACustomCharacterPartModifier");
static_assert(offsetof(ACustomCharacterPartModifier, FortPlayerPawnPtr) == 0x00038C, "Member 'ACustomCharacterPartModifier::FortPlayerPawnPtr' has a wrong offset!");
static_assert(offsetof(ACustomCharacterPartModifier, PartType) == 0x000394, "Member 'ACustomCharacterPartModifier::PartType' has a wrong offset!");

// Class FortniteGame.FortAnimNotify_PlayConsumeSound
// 0x0000 (0x0058 - 0x0058)
class UFortAnimNotify_PlayConsumeSound final : public UAnimNotify_PlaySound
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAnimNotify_PlayConsumeSound">();
	}
	static class UFortAnimNotify_PlayConsumeSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAnimNotify_PlayConsumeSound>();
	}
};
static_assert(alignof(UFortAnimNotify_PlayConsumeSound) == 0x000008, "Wrong alignment on UFortAnimNotify_PlayConsumeSound");
static_assert(sizeof(UFortAnimNotify_PlayConsumeSound) == 0x000058, "Wrong size on UFortAnimNotify_PlayConsumeSound");

// Class FortniteGame.FortConsumableItemDefinitionTooltip
// 0x0000 (0x0090 - 0x0090)
class UFortConsumableItemDefinitionTooltip final : public UFortWorldItemDefinitionTooltip
{
public:
	bool GetTextForToken(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, class FText* OutText) const;
	bool GetTokenizedDescriptionText(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, TArray<class FText>* OutDescription) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortConsumableItemDefinitionTooltip">();
	}
	static class UFortConsumableItemDefinitionTooltip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortConsumableItemDefinitionTooltip>();
	}
};
static_assert(alignof(UFortConsumableItemDefinitionTooltip) == 0x000008, "Wrong alignment on UFortConsumableItemDefinitionTooltip");
static_assert(sizeof(UFortConsumableItemDefinitionTooltip) == 0x000090, "Wrong size on UFortConsumableItemDefinitionTooltip");

// Class FortniteGame.CustomCharacterPartOwnerInterface
// 0x0000 (0x0028 - 0x0028)
class ICustomCharacterPartOwnerInterface final : public IInterface
{
public:
	void PlayAnimationsMatchingQuery(const struct FGameplayTagQuery& TagQueryToMatch);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomCharacterPartOwnerInterface">();
	}
	static class ICustomCharacterPartOwnerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICustomCharacterPartOwnerInterface>();
	}
};
static_assert(alignof(ICustomCharacterPartOwnerInterface) == 0x000008, "Wrong alignment on ICustomCharacterPartOwnerInterface");
static_assert(sizeof(ICustomCharacterPartOwnerInterface) == 0x000028, "Wrong size on ICustomCharacterPartOwnerInterface");

// Class FortniteGame.CustomColorComponent
// 0x0010 (0x0038 - 0x0028)
class UCustomColorComponent final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomColorComponent">();
	}
	static class UCustomColorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomColorComponent>();
	}
};
static_assert(alignof(UCustomColorComponent) == 0x000008, "Wrong alignment on UCustomColorComponent");
static_assert(sizeof(UCustomColorComponent) == 0x000038, "Wrong size on UCustomColorComponent");

// Class FortniteGame.FortMatchmakingPolicy
// 0x0150 (0x0178 - 0x0028)
#pragma pack(push, 0x1)
class alignas(0x08) UFortMatchmakingPolicy : public UObject
{
public:
	uint8                                         Pad_28[0x88];                                      // 0x0028(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bMatchmakingInProgress;                            // 0x00B0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SessionName;                                       // 0x00B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMatchmakingParams                     CurrentParams;                                     // 0x00C0(0x0098)(Transient, Protected, NativeAccessSpecifierProtected)
	class UFortSearchPass*                        MMPass;                                            // 0x0158(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ChanceToHostAttempt;                               // 0x0160(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_164[0x14];                                     // 0x0164(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMatchmakingPolicy">();
	}
	static class UFortMatchmakingPolicy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMatchmakingPolicy>();
	}
};
#pragma pack(pop)
static_assert(alignof(UFortMatchmakingPolicy) == 0x000008, "Wrong alignment on UFortMatchmakingPolicy");
static_assert(sizeof(UFortMatchmakingPolicy) == 0x000178, "Wrong size on UFortMatchmakingPolicy");
static_assert(offsetof(UFortMatchmakingPolicy, bMatchmakingInProgress) == 0x0000B0, "Member 'UFortMatchmakingPolicy::bMatchmakingInProgress' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingPolicy, SessionName) == 0x0000B8, "Member 'UFortMatchmakingPolicy::SessionName' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingPolicy, CurrentParams) == 0x0000C0, "Member 'UFortMatchmakingPolicy::CurrentParams' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingPolicy, MMPass) == 0x000158, "Member 'UFortMatchmakingPolicy::MMPass' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingPolicy, ChanceToHostAttempt) == 0x000160, "Member 'UFortMatchmakingPolicy::ChanceToHostAttempt' has a wrong offset!");

// Class FortniteGame.FortMatchmakingCommon
// 0x0018 (0x0190 - 0x0178)
class UFortMatchmakingCommon : public UFortMatchmakingPolicy
{
public:
	uint8                                         Pad_178[0x18];                                     // 0x0178(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMatchmakingCommon">();
	}
	static class UFortMatchmakingCommon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMatchmakingCommon>();
	}
};
static_assert(alignof(UFortMatchmakingCommon) == 0x000008, "Wrong alignment on UFortMatchmakingCommon");
static_assert(sizeof(UFortMatchmakingCommon) == 0x000190, "Wrong size on UFortMatchmakingCommon");

// Class FortniteGame.FortAIDataProvider_Ability
// 0x0048 (0x0070 - 0x0028)
class UFortAIDataProvider_Ability : public UAIDataProvider
{
public:
	struct FGameplayTagContainer                  AbilityTag;                                        // 0x0028(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AbilityBehaviorDistanceTag;                        // 0x0048(0x0020)(Edit, NativeAccessSpecifierPublic)
	float                                         BehaviorDistance;                                  // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTargetSelectionRange;                           // 0x006C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIDataProvider_Ability">();
	}
	static class UFortAIDataProvider_Ability* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIDataProvider_Ability>();
	}
};
static_assert(alignof(UFortAIDataProvider_Ability) == 0x000008, "Wrong alignment on UFortAIDataProvider_Ability");
static_assert(sizeof(UFortAIDataProvider_Ability) == 0x000070, "Wrong size on UFortAIDataProvider_Ability");
static_assert(offsetof(UFortAIDataProvider_Ability, AbilityTag) == 0x000028, "Member 'UFortAIDataProvider_Ability::AbilityTag' has a wrong offset!");
static_assert(offsetof(UFortAIDataProvider_Ability, AbilityBehaviorDistanceTag) == 0x000048, "Member 'UFortAIDataProvider_Ability::AbilityBehaviorDistanceTag' has a wrong offset!");
static_assert(offsetof(UFortAIDataProvider_Ability, BehaviorDistance) == 0x000068, "Member 'UFortAIDataProvider_Ability::BehaviorDistance' has a wrong offset!");
static_assert(offsetof(UFortAIDataProvider_Ability, MaxTargetSelectionRange) == 0x00006C, "Member 'UFortAIDataProvider_Ability::MaxTargetSelectionRange' has a wrong offset!");

// Class FortniteGame.FortTestControllerBootTest
// 0x0000 (0x0030 - 0x0030)
class UFortTestControllerBootTest final : public UGauntletTestControllerBootTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTestControllerBootTest">();
	}
	static class UFortTestControllerBootTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortTestControllerBootTest>();
	}
};
static_assert(alignof(UFortTestControllerBootTest) == 0x000008, "Wrong alignment on UFortTestControllerBootTest");
static_assert(sizeof(UFortTestControllerBootTest) == 0x000030, "Wrong size on UFortTestControllerBootTest");

// Class FortniteGame.CustomClothingColorSwatch
// 0x0020 (0x0050 - 0x0030)
class UCustomClothingColorSwatch final : public UCustomColorSwatch
{
public:
	struct FLinearColor                           AccessoryColors[0x2];                              // 0x0030(0x0010)(Edit, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomClothingColorSwatch">();
	}
	static class UCustomClothingColorSwatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomClothingColorSwatch>();
	}
};
static_assert(alignof(UCustomClothingColorSwatch) == 0x000008, "Wrong alignment on UCustomClothingColorSwatch");
static_assert(sizeof(UCustomClothingColorSwatch) == 0x000050, "Wrong size on UCustomClothingColorSwatch");
static_assert(offsetof(UCustomClothingColorSwatch, AccessoryColors) == 0x000030, "Member 'UCustomClothingColorSwatch::AccessoryColors' has a wrong offset!");

// Class FortniteGame.CustomHairColorSwatch
// 0x0000 (0x0040 - 0x0040)
class UCustomHairColorSwatch final : public UCustomDynamicColorSwatch
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomHairColorSwatch">();
	}
	static class UCustomHairColorSwatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomHairColorSwatch>();
	}
};
static_assert(alignof(UCustomHairColorSwatch) == 0x000008, "Wrong alignment on UCustomHairColorSwatch");
static_assert(sizeof(UCustomHairColorSwatch) == 0x000040, "Wrong size on UCustomHairColorSwatch");

// Class FortniteGame.CustomSkinColorSwatch
// 0x0000 (0x0040 - 0x0040)
class UCustomSkinColorSwatch final : public UCustomDynamicColorSwatch
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomSkinColorSwatch">();
	}
	static class UCustomSkinColorSwatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomSkinColorSwatch>();
	}
};
static_assert(alignof(UCustomSkinColorSwatch) == 0x000008, "Wrong alignment on UCustomSkinColorSwatch");
static_assert(sizeof(UCustomSkinColorSwatch) == 0x000040, "Wrong size on UCustomSkinColorSwatch");

// Class FortniteGame.CustomPlayerComponent
// 0x0028 (0x0050 - 0x0028)
class UCustomPlayerComponent final : public UObject
{
public:
	uint8                                         Pad_28[0x28];                                      // 0x0028(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomPlayerComponent">();
	}
	static class UCustomPlayerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomPlayerComponent>();
	}
};
static_assert(alignof(UCustomPlayerComponent) == 0x000008, "Wrong alignment on UCustomPlayerComponent");
static_assert(sizeof(UCustomPlayerComponent) == 0x000050, "Wrong size on UCustomPlayerComponent");

// Class FortniteGame.FortMatchmakingMissionCommon
// 0x0018 (0x0190 - 0x0178)
class UFortMatchmakingMissionCommon : public UFortMatchmakingPolicy
{
public:
	uint8                                         Pad_178[0x18];                                     // 0x0178(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMatchmakingMissionCommon">();
	}
	static class UFortMatchmakingMissionCommon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMatchmakingMissionCommon>();
	}
};
static_assert(alignof(UFortMatchmakingMissionCommon) == 0x000008, "Wrong alignment on UFortMatchmakingMissionCommon");
static_assert(sizeof(UFortMatchmakingMissionCommon) == 0x000190, "Wrong size on UFortMatchmakingMissionCommon");

// Class FortniteGame.FortMatchmakingCriticalMission
// 0x0000 (0x0190 - 0x0190)
class UFortMatchmakingCriticalMission final : public UFortMatchmakingMissionCommon
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMatchmakingCriticalMission">();
	}
	static class UFortMatchmakingCriticalMission* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMatchmakingCriticalMission>();
	}
};
static_assert(alignof(UFortMatchmakingCriticalMission) == 0x000008, "Wrong alignment on UFortMatchmakingCriticalMission");
static_assert(sizeof(UFortMatchmakingCriticalMission) == 0x000190, "Wrong size on UFortMatchmakingCriticalMission");

// Class FortniteGame.FortAbilityKit
// 0x01B8 (0x0208 - 0x0050)
class UFortAbilityKit final : public UFortAbilitySet
{
public:
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, AssetRegistrySearchable, NativeAccessSpecifierPublic)
	TArray<class FText>                           Description;                                       // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, AssetRegistrySearchable, NativeAccessSpecifierPublic)
	class FText                                   TooltipDescription;                                // 0x0080(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, AssetRegistrySearchable, NativeAccessSpecifierPublic)
	struct FSlateBrush                            IconBrush;                                         // 0x0098(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSlateBrush                            PrimaryTraitIconBrushOverride;                     // 0x0128(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UFortGadgetItemDefinition>> Gadgets;                                           // 0x01B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FAbilityKitItem>                Items;                                             // 0x01C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UFortSchematicItemDefinition*>   AddedSchematics;                                   // 0x01D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UFortSchematicItemDefinition*>   RemovedSchematics;                                 // 0x01E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSubclassOf<class UFortTooltip>               Tooltip;                                           // 0x01F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortTooltipDisplayStatsList*           StatList;                                          // 0x0200(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BP_GetGadgets(TArray<class UFortGadgetItemDefinition*>* GadgetItemDefinitions);

	TArray<class FText> GetDescription(const class UObject* WorldContextObject) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAbilityKit">();
	}
	static class UFortAbilityKit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAbilityKit>();
	}
};
static_assert(alignof(UFortAbilityKit) == 0x000008, "Wrong alignment on UFortAbilityKit");
static_assert(sizeof(UFortAbilityKit) == 0x000208, "Wrong size on UFortAbilityKit");
static_assert(offsetof(UFortAbilityKit, DisplayName) == 0x000058, "Member 'UFortAbilityKit::DisplayName' has a wrong offset!");
static_assert(offsetof(UFortAbilityKit, Description) == 0x000070, "Member 'UFortAbilityKit::Description' has a wrong offset!");
static_assert(offsetof(UFortAbilityKit, TooltipDescription) == 0x000080, "Member 'UFortAbilityKit::TooltipDescription' has a wrong offset!");
static_assert(offsetof(UFortAbilityKit, IconBrush) == 0x000098, "Member 'UFortAbilityKit::IconBrush' has a wrong offset!");
static_assert(offsetof(UFortAbilityKit, PrimaryTraitIconBrushOverride) == 0x000128, "Member 'UFortAbilityKit::PrimaryTraitIconBrushOverride' has a wrong offset!");
static_assert(offsetof(UFortAbilityKit, Gadgets) == 0x0001B8, "Member 'UFortAbilityKit::Gadgets' has a wrong offset!");
static_assert(offsetof(UFortAbilityKit, Items) == 0x0001C8, "Member 'UFortAbilityKit::Items' has a wrong offset!");
static_assert(offsetof(UFortAbilityKit, AddedSchematics) == 0x0001D8, "Member 'UFortAbilityKit::AddedSchematics' has a wrong offset!");
static_assert(offsetof(UFortAbilityKit, RemovedSchematics) == 0x0001E8, "Member 'UFortAbilityKit::RemovedSchematics' has a wrong offset!");
static_assert(offsetof(UFortAbilityKit, Tooltip) == 0x0001F8, "Member 'UFortAbilityKit::Tooltip' has a wrong offset!");
static_assert(offsetof(UFortAbilityKit, StatList) == 0x000200, "Member 'UFortAbilityKit::StatList' has a wrong offset!");

// Class FortniteGame.FortAbilitySystemComponentAbilityGivenListenerInterface
// 0x0000 (0x0028 - 0x0028)
class IFortAbilitySystemComponentAbilityGivenListenerInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAbilitySystemComponentAbilityGivenListenerInterface">();
	}
	static class IFortAbilitySystemComponentAbilityGivenListenerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortAbilitySystemComponentAbilityGivenListenerInterface>();
	}
};
static_assert(alignof(IFortAbilitySystemComponentAbilityGivenListenerInterface) == 0x000008, "Wrong alignment on IFortAbilitySystemComponentAbilityGivenListenerInterface");
static_assert(sizeof(IFortAbilitySystemComponentAbilityGivenListenerInterface) == 0x000028, "Wrong size on IFortAbilitySystemComponentAbilityGivenListenerInterface");

// Class FortniteGame.FortAbilitySystemComponent
// 0x0200 (0x17E0 - 0x15E0)
class UFortAbilitySystemComponent : public UAbilitySystemComponent
{
public:
	uint8                                         Pad_15E0[0x178];                                   // 0x15E0(0x0178)(Fixing Size After Last Property [ Dumper-7 ])
	struct FReplicatedMontagePair                 LandingMontagePair;                                // 0x1758(0x0028)(Net, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1780[0x60];                                    // 0x1780(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NetMulticast_RefreshActiveGameplayEffectCueEvents();
	void SetLandingMontageReplication(class UAnimMontage* Montage1, class FName Section1, class UAnimMontage* Montage2, class FName Section2);

	bool CanActivateAbilityWithMatchingTag(const struct FGameplayTagContainer& GameplayAbilityTags) const;
	struct FAttributeInfo FindAttributeInformation(const class FString& AttributeName) const;
	float GetAttributeMagnitude(const struct FAttributeInfo& Info) const;
	bool HasActiveAbilityWithAnyMatchingTag(const struct FGameplayTagContainer& Tags) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAbilitySystemComponent">();
	}
	static class UFortAbilitySystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAbilitySystemComponent>();
	}
};
static_assert(alignof(UFortAbilitySystemComponent) == 0x000010, "Wrong alignment on UFortAbilitySystemComponent");
static_assert(sizeof(UFortAbilitySystemComponent) == 0x0017E0, "Wrong size on UFortAbilitySystemComponent");
static_assert(offsetof(UFortAbilitySystemComponent, LandingMontagePair) == 0x001758, "Member 'UFortAbilitySystemComponent::LandingMontagePair' has a wrong offset!");

// Class FortniteGame.FortPlayerPawn
// 0x07A0 (0x1680 - 0x0EE0)
class AFortPlayerPawn : public AFortPawn
{
public:
	uint8                                         Pad_EE0[0x18];                                     // 0x0EE0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            SelfReviveGameplayEffect;                          // 0x0EF8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            TeammateReviveGameplayEffect;                      // 0x0F00(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FScalableFloat                         SetByCallerReviveHealth;                           // 0x0F08(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FName                                   DBNOInteractionCollisionProfile;                   // 0x0F30(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                DBNOInteractionBoxExtent;                          // 0x0F38(0x000C)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DBNODeferTime;                                     // 0x0F44(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          DBNOInteractCollisionComponent;                    // 0x0F48(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           EventReviveTag;                                    // 0x0F50(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortPawnStasisMode                           StasisMode;                                        // 0x0F58(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortPawnStasisMode                           PreviousStasisMode;                                // 0x0F59(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSprintJump;                                     // 0x0F5A(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F5B[0x1];                                      // 0x0F5B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SprintCancelTime;                                  // 0x0F5C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanPredictJumpApex;                               // 0x0F60(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F61[0x7F];                                     // 0x0F61(0x007F)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           UnableToPerformActionMontage;                      // 0x0FE0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoveSoundStimulusBroadcastInterval;                // 0x0FE8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FEC[0x5D];                                     // 0x0FEC(0x005D)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShowingOverdriveEffect;                           // 0x1049(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortBuildingState                            BuildingState;                                     // 0x104A(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTargeting;                                      // 0x104B(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104C[0x84];                                    // 0x104C(0x0084)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  LastEquippedWeaponGUID;                            // 0x10D0(0x0010)(Net, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimMontage*                           BluePrintPlaceAnimation;                           // 0x10E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           BluePrintEditAnimation;                            // 0x10E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPartChanged;                                     // 0x10F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               BlueprintPaperMID;                                 // 0x1100(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1108[0x8];                                     // 0x1108(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimeline                              BlueprintPaperPulseTimeline;                       // 0x1110(0x00E0)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UCustomColorComponent*                  AccessoryColorSwatchHandler[0x6];                  // 0x11F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UFortHero>               Hero;                                              // 0x1220(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCustomPlayerComponent*                 HACK_CustomPRIComponent;                           // 0x1228(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EFortCustomGender                             CharacterGender;                                   // 0x1230(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EFortCustomBodyType                           CharacterBodyType;                                 // 0x1231(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1232[0x6];                                     // 0x1232(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UCustomCharacterPart*                   CharacterParts[0x6];                               // 0x1238(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCustomColorSwatch*                     CharacterColorSwatches[0x2];                       // 0x1268(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCustomColorSwatch*                     CharacterPartColorSwatches[0x6];                   // 0x1278(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCharacterPartsCastIndirectShadows;                // 0x12A8(0x0001)(ZeroConstructor, Transient, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_12A9[0x7];                                     // 0x12A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 CharacterPartSkeletalMeshComponents[0x6];          // 0x12B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCustomCharacterPart*                   PreviousCharacterParts[0x6];                       // 0x12E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACustomCharacterPartModifier*           CharacterPartModifiers[0x6];                       // 0x1310(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFortCharacterPartsRepMontageInfo      RepCharPartAnimMontageInfo;                        // 0x1340(0x0020)(Net, Transient, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1360[0x8];                                     // 0x1360(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CarriedObjectAttachmentSocket;                     // 0x1368(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateBrush                            MiniMapIconBrush;                                  // 0x1370(0x0090)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            AboveBelowMiniMapIconBrush;                        // 0x1400(0x0090)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            FarOffMiniMapIconBrush;                            // 0x1490(0x0090)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            DBNOMiniMapIconBrush;                              // 0x1520(0x0090)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FLinearColor                           MinimapIconColorSelf;                              // 0x15B0(0x0010)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           MinimapIconColorTeammate;                          // 0x15C0(0x0010)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           MinimapIconColorEnemy;                             // 0x15D0(0x0010)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxIndicatorVisibilityDistForEnemies;              // 0x15E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxIndicatorVisibilityDistForAllies;               // 0x15E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        SpawnParticles;                                    // 0x15E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             SpawnSound;                                        // 0x15F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NumSecondsOnGroundBeforeStoppingRagdoll;           // 0x15F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15FC[0x4];                                     // 0x15FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         BitPad_1600_0 : 1;                                 // 0x1600(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bIsLocalPlayer : 1;                                // 0x1600(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDamagedEnemy : 1;                                 // 0x1600(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1601[0x17];                                    // 0x1601(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        PlayerStatus;                                      // 0x1618(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        AccelerationPack;                                  // 0x161C(0x0002)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_161E[0x2];                                     // 0x161E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UFortAnimNotifyState_RootMotionInterrupt*> RootMotionInterruptNotifyStack;                    // 0x1620(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UAnimMontage*>                   RootMotionInterruptMontageStack;                   // 0x1630(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1640[0x28];                                    // 0x1640(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortVisibilityComponent*               VisibilityComponent;                               // 0x1668(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPostProcessComponent*                  BlendablesPostProcessComp;                         // 0x1670(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1678[0x8];                                     // 0x1678(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanPredictJumpApex();
	void ClientNotifyAbilityFailed(const class UGameplayAbility* FailedAbility, const struct FGameplayTagContainer& FailedReason);
	void HandleInStasis();
	void InternalServerSetTargeting(bool bNewTargeting);
	void OnCharacterPartsReinitialized();
	void OnRep_AccelerationPack();
	void OnRep_CharPartAnimMontageInfo();
	void OnRep_IsDBNO();
	void OnRep_IsTargeting();
	void RandomizeCharacter(const class FString& GenderString);
	void ReviveFromDBNO(class AController* EventInstigator);
	void ServerChooseGender(EFortCustomGender Gender);
	void ServerChoosePart(EFortCustomPartType Part, class UCustomCharacterPart* ChosenCharacterPart);
	void ServerCycleAccessoryColorSwatch(EFortCustomPartType Part, bool bNext);
	void ServerCycleColorSwatch(EColorSwatchType SwatchType, bool bNext);
	void ServerCyclePart(EFortCustomPartType Part, bool bNextPart);
	void ServerHandlePickup(class AFortPickup* Pickup, float InFlyTime, const struct FVector& InStartDirection, bool bPlayPickupSound);
	void ServerPlayUnableToPerformActionMontage();
	void ServerRespawnFromDBNO();
	void ServerReviveFromDBNO(class AController* EventInstigator);
	void ServerRootMotionInterruptNotifyStopMontage(class UAnimMontage* MontageToStop);
	void ServerToggleBodyType();
	void ServerToggleGender();
	void SetFirstPersonCamera(bool bNewUseFirstPersonCamera);
	void SetHomeActor(class AActor* NewActor);
	void SetStasisMode(EFortPawnStasisMode InStasisMode);
	void SwitchToNextPart(const class FString& PartName);
	void SwitchToPreviousPart(const class FString& PartName);
	void ToggleBodyType();
	void ToggleGender();

	EFortCustomBodyType GetCharacterBodyType() const;
	EFortCustomGender GetCharacterGender() const;
	int32 GetExtraLives() const;
	void GetGender(bool* IsMale, bool* IsFemale) const;
	class AActor* GetHomeActor() const;
	float GetMaxStamina() const;
	class USkeletalMeshComponent* GetSkeletalMeshForPartType(EFortCustomPartType PartType) const;
	float GetStamina() const;
	EFortPawnStasisMode GetStasisMode() const;
	bool IsSprinting() const;
	void ListCharacterParts(const class FString& GenderAndOrPartString) const;
	float TimeFromJumpApex() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerPawn">();
	}
	static class AFortPlayerPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerPawn>();
	}
};
static_assert(alignof(AFortPlayerPawn) == 0x000010, "Wrong alignment on AFortPlayerPawn");
static_assert(sizeof(AFortPlayerPawn) == 0x001680, "Wrong size on AFortPlayerPawn");
static_assert(offsetof(AFortPlayerPawn, SelfReviveGameplayEffect) == 0x000EF8, "Member 'AFortPlayerPawn::SelfReviveGameplayEffect' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, TeammateReviveGameplayEffect) == 0x000F00, "Member 'AFortPlayerPawn::TeammateReviveGameplayEffect' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, SetByCallerReviveHealth) == 0x000F08, "Member 'AFortPlayerPawn::SetByCallerReviveHealth' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, DBNOInteractionCollisionProfile) == 0x000F30, "Member 'AFortPlayerPawn::DBNOInteractionCollisionProfile' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, DBNOInteractionBoxExtent) == 0x000F38, "Member 'AFortPlayerPawn::DBNOInteractionBoxExtent' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, DBNODeferTime) == 0x000F44, "Member 'AFortPlayerPawn::DBNODeferTime' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, DBNOInteractCollisionComponent) == 0x000F48, "Member 'AFortPlayerPawn::DBNOInteractCollisionComponent' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, EventReviveTag) == 0x000F50, "Member 'AFortPlayerPawn::EventReviveTag' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, StasisMode) == 0x000F58, "Member 'AFortPlayerPawn::StasisMode' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, PreviousStasisMode) == 0x000F59, "Member 'AFortPlayerPawn::PreviousStasisMode' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, bIsSprintJump) == 0x000F5A, "Member 'AFortPlayerPawn::bIsSprintJump' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, SprintCancelTime) == 0x000F5C, "Member 'AFortPlayerPawn::SprintCancelTime' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, bCanPredictJumpApex) == 0x000F60, "Member 'AFortPlayerPawn::bCanPredictJumpApex' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, UnableToPerformActionMontage) == 0x000FE0, "Member 'AFortPlayerPawn::UnableToPerformActionMontage' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, MoveSoundStimulusBroadcastInterval) == 0x000FE8, "Member 'AFortPlayerPawn::MoveSoundStimulusBroadcastInterval' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, bShowingOverdriveEffect) == 0x001049, "Member 'AFortPlayerPawn::bShowingOverdriveEffect' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, BuildingState) == 0x00104A, "Member 'AFortPlayerPawn::BuildingState' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, bIsTargeting) == 0x00104B, "Member 'AFortPlayerPawn::bIsTargeting' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, LastEquippedWeaponGUID) == 0x0010D0, "Member 'AFortPlayerPawn::LastEquippedWeaponGUID' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, BluePrintPlaceAnimation) == 0x0010E0, "Member 'AFortPlayerPawn::BluePrintPlaceAnimation' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, BluePrintEditAnimation) == 0x0010E8, "Member 'AFortPlayerPawn::BluePrintEditAnimation' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, OnPartChanged) == 0x0010F0, "Member 'AFortPlayerPawn::OnPartChanged' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, BlueprintPaperMID) == 0x001100, "Member 'AFortPlayerPawn::BlueprintPaperMID' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, BlueprintPaperPulseTimeline) == 0x001110, "Member 'AFortPlayerPawn::BlueprintPaperPulseTimeline' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, AccessoryColorSwatchHandler) == 0x0011F0, "Member 'AFortPlayerPawn::AccessoryColorSwatchHandler' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, Hero) == 0x001220, "Member 'AFortPlayerPawn::Hero' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, HACK_CustomPRIComponent) == 0x001228, "Member 'AFortPlayerPawn::HACK_CustomPRIComponent' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, CharacterGender) == 0x001230, "Member 'AFortPlayerPawn::CharacterGender' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, CharacterBodyType) == 0x001231, "Member 'AFortPlayerPawn::CharacterBodyType' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, CharacterParts) == 0x001238, "Member 'AFortPlayerPawn::CharacterParts' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, CharacterColorSwatches) == 0x001268, "Member 'AFortPlayerPawn::CharacterColorSwatches' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, CharacterPartColorSwatches) == 0x001278, "Member 'AFortPlayerPawn::CharacterPartColorSwatches' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, bCharacterPartsCastIndirectShadows) == 0x0012A8, "Member 'AFortPlayerPawn::bCharacterPartsCastIndirectShadows' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, CharacterPartSkeletalMeshComponents) == 0x0012B0, "Member 'AFortPlayerPawn::CharacterPartSkeletalMeshComponents' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, PreviousCharacterParts) == 0x0012E0, "Member 'AFortPlayerPawn::PreviousCharacterParts' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, CharacterPartModifiers) == 0x001310, "Member 'AFortPlayerPawn::CharacterPartModifiers' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, RepCharPartAnimMontageInfo) == 0x001340, "Member 'AFortPlayerPawn::RepCharPartAnimMontageInfo' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, CarriedObjectAttachmentSocket) == 0x001368, "Member 'AFortPlayerPawn::CarriedObjectAttachmentSocket' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, MiniMapIconBrush) == 0x001370, "Member 'AFortPlayerPawn::MiniMapIconBrush' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, AboveBelowMiniMapIconBrush) == 0x001400, "Member 'AFortPlayerPawn::AboveBelowMiniMapIconBrush' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, FarOffMiniMapIconBrush) == 0x001490, "Member 'AFortPlayerPawn::FarOffMiniMapIconBrush' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, DBNOMiniMapIconBrush) == 0x001520, "Member 'AFortPlayerPawn::DBNOMiniMapIconBrush' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, MinimapIconColorSelf) == 0x0015B0, "Member 'AFortPlayerPawn::MinimapIconColorSelf' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, MinimapIconColorTeammate) == 0x0015C0, "Member 'AFortPlayerPawn::MinimapIconColorTeammate' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, MinimapIconColorEnemy) == 0x0015D0, "Member 'AFortPlayerPawn::MinimapIconColorEnemy' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, MaxIndicatorVisibilityDistForEnemies) == 0x0015E0, "Member 'AFortPlayerPawn::MaxIndicatorVisibilityDistForEnemies' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, MaxIndicatorVisibilityDistForAllies) == 0x0015E4, "Member 'AFortPlayerPawn::MaxIndicatorVisibilityDistForAllies' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, SpawnParticles) == 0x0015E8, "Member 'AFortPlayerPawn::SpawnParticles' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, SpawnSound) == 0x0015F0, "Member 'AFortPlayerPawn::SpawnSound' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, NumSecondsOnGroundBeforeStoppingRagdoll) == 0x0015F8, "Member 'AFortPlayerPawn::NumSecondsOnGroundBeforeStoppingRagdoll' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, PlayerStatus) == 0x001618, "Member 'AFortPlayerPawn::PlayerStatus' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, AccelerationPack) == 0x00161C, "Member 'AFortPlayerPawn::AccelerationPack' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, RootMotionInterruptNotifyStack) == 0x001620, "Member 'AFortPlayerPawn::RootMotionInterruptNotifyStack' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, RootMotionInterruptMontageStack) == 0x001630, "Member 'AFortPlayerPawn::RootMotionInterruptMontageStack' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, VisibilityComponent) == 0x001668, "Member 'AFortPlayerPawn::VisibilityComponent' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, BlendablesPostProcessComp) == 0x001670, "Member 'AFortPlayerPawn::BlendablesPostProcessComp' has a wrong offset!");

// Class FortniteGame.FortAbilitySystemComponentAthena
// 0x0000 (0x17E0 - 0x17E0)
class UFortAbilitySystemComponentAthena final : public UFortAbilitySystemComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAbilitySystemComponentAthena">();
	}
	static class UFortAbilitySystemComponentAthena* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAbilitySystemComponentAthena>();
	}
};
static_assert(alignof(UFortAbilitySystemComponentAthena) == 0x000010, "Wrong alignment on UFortAbilitySystemComponentAthena");
static_assert(sizeof(UFortAbilitySystemComponentAthena) == 0x0017E0, "Wrong size on UFortAbilitySystemComponentAthena");

// Class FortniteGame.FortAbilitySystemGlobals
// 0x0000 (0x0310 - 0x0310)
class UFortAbilitySystemGlobals final : public UAbilitySystemGlobals
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAbilitySystemGlobals">();
	}
	static class UFortAbilitySystemGlobals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAbilitySystemGlobals>();
	}
};
static_assert(alignof(UFortAbilitySystemGlobals) == 0x000008, "Wrong alignment on UFortAbilitySystemGlobals");
static_assert(sizeof(UFortAbilitySystemGlobals) == 0x000310, "Wrong size on UFortAbilitySystemGlobals");

// Class FortniteGame.FortAttributeLookupTable
// 0x0060 (0x0088 - 0x0028)
class UFortAttributeLookupTable final : public UDataAsset
{
public:
	TArray<struct FFortAttributeInfo>             AttributeInfoList;                                 // 0x0028(0x0010)(Edit, EditFixedSize, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAttributeLookupTable">();
	}
	static class UFortAttributeLookupTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAttributeLookupTable>();
	}
};
static_assert(alignof(UFortAttributeLookupTable) == 0x000008, "Wrong alignment on UFortAttributeLookupTable");
static_assert(sizeof(UFortAttributeLookupTable) == 0x000088, "Wrong size on UFortAttributeLookupTable");
static_assert(offsetof(UFortAttributeLookupTable, AttributeInfoList) == 0x000028, "Member 'UFortAttributeLookupTable::AttributeInfoList' has a wrong offset!");

// Class FortniteGame.FortUpdateManager
// 0x0000 (0x0270 - 0x0270)
class UFortUpdateManager final : public UUpdateManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortUpdateManager">();
	}
	static class UFortUpdateManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortUpdateManager>();
	}
};
static_assert(alignof(UFortUpdateManager) == 0x000008, "Wrong alignment on UFortUpdateManager");
static_assert(sizeof(UFortUpdateManager) == 0x000270, "Wrong size on UFortUpdateManager");

// Class FortniteGame.FortAbilitySystemUI
// 0x0050 (0x0078 - 0x0028)
class UFortAbilitySystemUI final : public UObject
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGameplayEffect* GetDefaultObjectOfGameplayEffectType(TSubclassOf<class UGameplayEffect> EffectType);
	static struct FFortGameplayEffectDescription GetStaticGameplayEffectDescription(const class UGameplayEffect* Effect, float Level);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAbilitySystemUI">();
	}
	static class UFortAbilitySystemUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAbilitySystemUI>();
	}
};
static_assert(alignof(UFortAbilitySystemUI) == 0x000008, "Wrong alignment on UFortAbilitySystemUI");
static_assert(sizeof(UFortAbilitySystemUI) == 0x000078, "Wrong size on UFortAbilitySystemUI");

// Class FortniteGame.FortAbilityTask_CommitAccountCosts
// 0x0048 (0x00C8 - 0x0080)
class UFortAbilityTask_CommitAccountCosts final : public UAbilityTask
{
public:
	UMulticastDelegateProperty_                   OnCommitted;                                       // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFailed;                                          // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bWasCancellable;                                   // 0x00A0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRequestPending;                                   // 0x00A1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCommittedLocally;                                 // 0x00A2(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A3[0x5];                                       // 0x00A3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PlayerName;                                        // 0x00A8(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 AbilityName;                                       // 0x00B8(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UFortAbilityTask_CommitAccountCosts* CommitAccountCosts(class UGameplayAbility* OwningAbility);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAbilityTask_CommitAccountCosts">();
	}
	static class UFortAbilityTask_CommitAccountCosts* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAbilityTask_CommitAccountCosts>();
	}
};
static_assert(alignof(UFortAbilityTask_CommitAccountCosts) == 0x000008, "Wrong alignment on UFortAbilityTask_CommitAccountCosts");
static_assert(sizeof(UFortAbilityTask_CommitAccountCosts) == 0x0000C8, "Wrong size on UFortAbilityTask_CommitAccountCosts");
static_assert(offsetof(UFortAbilityTask_CommitAccountCosts, OnCommitted) == 0x000080, "Member 'UFortAbilityTask_CommitAccountCosts::OnCommitted' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_CommitAccountCosts, OnFailed) == 0x000090, "Member 'UFortAbilityTask_CommitAccountCosts::OnFailed' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_CommitAccountCosts, bWasCancellable) == 0x0000A0, "Member 'UFortAbilityTask_CommitAccountCosts::bWasCancellable' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_CommitAccountCosts, bRequestPending) == 0x0000A1, "Member 'UFortAbilityTask_CommitAccountCosts::bRequestPending' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_CommitAccountCosts, bCommittedLocally) == 0x0000A2, "Member 'UFortAbilityTask_CommitAccountCosts::bCommittedLocally' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_CommitAccountCosts, PlayerName) == 0x0000A8, "Member 'UFortAbilityTask_CommitAccountCosts::PlayerName' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_CommitAccountCosts, AbilityName) == 0x0000B8, "Member 'UFortAbilityTask_CommitAccountCosts::AbilityName' has a wrong offset!");

// Class FortniteGame.FortAnimNotify_PlayWindParticleEffect
// 0x0000 (0x0080 - 0x0080)
class UFortAnimNotify_PlayWindParticleEffect final : public UAnimNotify_PlayParticleEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAnimNotify_PlayWindParticleEffect">();
	}
	static class UFortAnimNotify_PlayWindParticleEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAnimNotify_PlayWindParticleEffect>();
	}
};
static_assert(alignof(UFortAnimNotify_PlayWindParticleEffect) == 0x000008, "Wrong alignment on UFortAnimNotify_PlayWindParticleEffect");
static_assert(sizeof(UFortAnimNotify_PlayWindParticleEffect) == 0x000080, "Wrong size on UFortAnimNotify_PlayWindParticleEffect");

// Class FortniteGame.FortAbilityTask_DirectedMovement
// 0x0070 (0x00F0 - 0x0080)
class UFortAbilityTask_DirectedMovement final : public UAbilityTask
{
public:
	UMulticastDelegateProperty_                   OnMovementComplete;                                // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMovementCancelled;                               // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x1C];                                      // 0x00A0(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TargetLocation;                                    // 0x00BC(0x000C)(Net, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        TargetComponent;                                   // 0x00C8(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovementDistance;                                  // 0x00D0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IdealArrivalDistance;                              // 0x00D4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DurationOfMovement;                                // 0x00D8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bModifyZ;                                          // 0x00DC(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCancelOnFalling;                                  // 0x00DD(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DE[0x2];                                       // 0x00DE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterMovementComponent*            MovementComponent;                                 // 0x00E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UFortAbilityTask_DirectedMovement* DirectedMovement(class UGameplayAbility* OwningAbility, const struct FVector& MovementDirection, EFortDirectedMovementSpace MovementSpaceType, float MovementDistance_0, float MovementDuration, float IdealDistance, bool ModifyZ, bool bCancelOnFalling_0);
	static class UFortAbilityTask_DirectedMovement* DirectedMovementToActor(class UGameplayAbility* OwningAbility, class AActor* TargetActor, float MaxMovementDistance, float MovementDuration, float IdealDistance, bool ModifyZ, bool bCancelOnFalling_0);
	static class UFortAbilityTask_DirectedMovement* DirectedMovementToComponent(class UGameplayAbility* OwningAbility, class USceneComponent* TargetComponent_0, float MaxMovementDistance, float MovementDuration, float IdealDistance, bool ModifyZ, bool bCancelOnFalling_0);
	static class UFortAbilityTask_DirectedMovement* DirectedMovementToLocation(class UGameplayAbility* OwningAbility, const struct FVector& MovementTargetLocation, EFortDirectedMovementSpace MovementSpaceType, float MovementDuration, float CloseEnoughDistance, bool ModifyZ, bool bCancelOnFalling_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAbilityTask_DirectedMovement">();
	}
	static class UFortAbilityTask_DirectedMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAbilityTask_DirectedMovement>();
	}
};
static_assert(alignof(UFortAbilityTask_DirectedMovement) == 0x000008, "Wrong alignment on UFortAbilityTask_DirectedMovement");
static_assert(sizeof(UFortAbilityTask_DirectedMovement) == 0x0000F0, "Wrong size on UFortAbilityTask_DirectedMovement");
static_assert(offsetof(UFortAbilityTask_DirectedMovement, OnMovementComplete) == 0x000080, "Member 'UFortAbilityTask_DirectedMovement::OnMovementComplete' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_DirectedMovement, OnMovementCancelled) == 0x000090, "Member 'UFortAbilityTask_DirectedMovement::OnMovementCancelled' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_DirectedMovement, TargetLocation) == 0x0000BC, "Member 'UFortAbilityTask_DirectedMovement::TargetLocation' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_DirectedMovement, TargetComponent) == 0x0000C8, "Member 'UFortAbilityTask_DirectedMovement::TargetComponent' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_DirectedMovement, MovementDistance) == 0x0000D0, "Member 'UFortAbilityTask_DirectedMovement::MovementDistance' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_DirectedMovement, IdealArrivalDistance) == 0x0000D4, "Member 'UFortAbilityTask_DirectedMovement::IdealArrivalDistance' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_DirectedMovement, DurationOfMovement) == 0x0000D8, "Member 'UFortAbilityTask_DirectedMovement::DurationOfMovement' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_DirectedMovement, bModifyZ) == 0x0000DC, "Member 'UFortAbilityTask_DirectedMovement::bModifyZ' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_DirectedMovement, bCancelOnFalling) == 0x0000DD, "Member 'UFortAbilityTask_DirectedMovement::bCancelOnFalling' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_DirectedMovement, MovementComponent) == 0x0000E0, "Member 'UFortAbilityTask_DirectedMovement::MovementComponent' has a wrong offset!");

// Class FortniteGame.FortAbilityTask_WaitTargetSelection
// 0x0040 (0x00C0 - 0x0080)
class UFortAbilityTask_WaitTargetSelection final : public UAbilityTask
{
public:
	UMulticastDelegateProperty_                   Targeted;                                          // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   Cancelled;                                         // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EGameplayTargetingConfirmation                ConfirmationType;                                  // 0x00A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bForceTargetingOnServer;                           // 0x00A1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A2[0x6];                                       // 0x00A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           InstantTargetTag;                                  // 0x00A8(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UFortAbilityTask_WaitTargetSelection* WaitTargetSelection(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, const struct FGameplayTag& InApplicationTag, bool bForceTargetingOnServer_0);

	void OnTargetDataCancelledCallback();
	void OnTargetDataReadyCallback(const struct FGameplayAbilityTargetDataHandle& TargetData, const struct FGameplayTag& ApplicationTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAbilityTask_WaitTargetSelection">();
	}
	static class UFortAbilityTask_WaitTargetSelection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAbilityTask_WaitTargetSelection>();
	}
};
static_assert(alignof(UFortAbilityTask_WaitTargetSelection) == 0x000008, "Wrong alignment on UFortAbilityTask_WaitTargetSelection");
static_assert(sizeof(UFortAbilityTask_WaitTargetSelection) == 0x0000C0, "Wrong size on UFortAbilityTask_WaitTargetSelection");
static_assert(offsetof(UFortAbilityTask_WaitTargetSelection, Targeted) == 0x000080, "Member 'UFortAbilityTask_WaitTargetSelection::Targeted' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_WaitTargetSelection, Cancelled) == 0x000090, "Member 'UFortAbilityTask_WaitTargetSelection::Cancelled' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_WaitTargetSelection, ConfirmationType) == 0x0000A0, "Member 'UFortAbilityTask_WaitTargetSelection::ConfirmationType' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_WaitTargetSelection, bForceTargetingOnServer) == 0x0000A1, "Member 'UFortAbilityTask_WaitTargetSelection::bForceTargetingOnServer' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_WaitTargetSelection, InstantTargetTag) == 0x0000A8, "Member 'UFortAbilityTask_WaitTargetSelection::InstantTargetTag' has a wrong offset!");

// Class FortniteGame.FortKeepDefenseManager
// 0x00D0 (0x0458 - 0x0388)
class AFortKeepDefenseManager final : public AActor
{
public:
	UMulticastDelegateProperty_                   OnEventStarted;                                    // 0x0388(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnWarmupEnded;                                     // 0x0398(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnEncounterTimeout;                                // 0x03A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnEventEnded;                                      // 0x03B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnEventStopped;                                    // 0x03C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnAllEnemiesKilled;                                // 0x03D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnEncounterStarted;                                // 0x03E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnEncounterEnded;                                  // 0x03F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnDefenseStateChanged;                             // 0x0408(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_418[0x10];                                     // 0x0418(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAIEncounterInfo*                   ActiveAIEncounter;                                 // 0x0428(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortAISpawnGroupProgressionInfo*       ActiveAISpawnGroup;                                // 0x0430(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_438[0x20];                                     // 0x0438(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetNumberAliveEnemies();
	class FText GetWaveDescription();
	void GoToNextWave();
	void SkipWarmup();
	class UFortAIEncounterInfo* StartAIEncounter(TSubclassOf<class UFortAIEncounterInfo> EncounterTemplate, class AActor* TargetActor, class UFortAISpawnGroupProgressionInfo* SpawnGroupProgressionInfo, int32 ActivationDelay, int32 EncounterDifficultyLevel, float AliveMultiplier);
	void StartEvent(class UFortKeepEventInfo* EventTemplate, int32 DifficultyLevelOffset);
	void StartEventFromList(class UFortKeepEventList* EventList, int32 EventNumber);
	void StopEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortKeepDefenseManager">();
	}
	static class AFortKeepDefenseManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortKeepDefenseManager>();
	}
};
static_assert(alignof(AFortKeepDefenseManager) == 0x000008, "Wrong alignment on AFortKeepDefenseManager");
static_assert(sizeof(AFortKeepDefenseManager) == 0x000458, "Wrong size on AFortKeepDefenseManager");
static_assert(offsetof(AFortKeepDefenseManager, OnEventStarted) == 0x000388, "Member 'AFortKeepDefenseManager::OnEventStarted' has a wrong offset!");
static_assert(offsetof(AFortKeepDefenseManager, OnWarmupEnded) == 0x000398, "Member 'AFortKeepDefenseManager::OnWarmupEnded' has a wrong offset!");
static_assert(offsetof(AFortKeepDefenseManager, OnEncounterTimeout) == 0x0003A8, "Member 'AFortKeepDefenseManager::OnEncounterTimeout' has a wrong offset!");
static_assert(offsetof(AFortKeepDefenseManager, OnEventEnded) == 0x0003B8, "Member 'AFortKeepDefenseManager::OnEventEnded' has a wrong offset!");
static_assert(offsetof(AFortKeepDefenseManager, OnEventStopped) == 0x0003C8, "Member 'AFortKeepDefenseManager::OnEventStopped' has a wrong offset!");
static_assert(offsetof(AFortKeepDefenseManager, OnAllEnemiesKilled) == 0x0003D8, "Member 'AFortKeepDefenseManager::OnAllEnemiesKilled' has a wrong offset!");
static_assert(offsetof(AFortKeepDefenseManager, OnEncounterStarted) == 0x0003E8, "Member 'AFortKeepDefenseManager::OnEncounterStarted' has a wrong offset!");
static_assert(offsetof(AFortKeepDefenseManager, OnEncounterEnded) == 0x0003F8, "Member 'AFortKeepDefenseManager::OnEncounterEnded' has a wrong offset!");
static_assert(offsetof(AFortKeepDefenseManager, OnDefenseStateChanged) == 0x000408, "Member 'AFortKeepDefenseManager::OnDefenseStateChanged' has a wrong offset!");
static_assert(offsetof(AFortKeepDefenseManager, ActiveAIEncounter) == 0x000428, "Member 'AFortKeepDefenseManager::ActiveAIEncounter' has a wrong offset!");
static_assert(offsetof(AFortKeepDefenseManager, ActiveAISpawnGroup) == 0x000430, "Member 'AFortKeepDefenseManager::ActiveAISpawnGroup' has a wrong offset!");

// Class FortniteGame.FortAbilityTask_PlayMontageWaitTarget
// 0x00B0 (0x0130 - 0x0080)
class UFortAbilityTask_PlayMontageWaitTarget final : public UAbilityTask
{
public:
	UMulticastDelegateProperty_                   Triggered;                                         // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   Cancelled;                                         // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   Completed;                                         // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FFortGameplayAbilityMontageInfo        MontageInfo;                                       // 0x00B0(0x0060)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_110[0x20];                                     // 0x0110(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UFortAbilityTask_PlayMontageWaitTarget* PlayMontageInfoAndWaitForTrigger(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, const struct FFortGameplayAbilityMontageInfo& MontageInfo_0);
	static class UFortAbilityTask_PlayMontageWaitTarget* PlayMontageWaitTarget(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, class UAnimMontage* MontageToPlay, float AnimPlayRate, EFortGameplayAbilityMontageSectionToPlay SectionToPlay, class FName OverrideSection, float AnimRootMotionTranslationScale);
	static class UFortAbilityTask_PlayMontageWaitTarget* PlayMontageWithCharPartsWait(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, class UAnimMontage* MontageToPlay, const TArray<struct FFortCharacterPartMontageInfo>& CharacterPartMontages, float AnimPlayRate, EFortGameplayAbilityMontageSectionToPlay SectionToPlay, class FName OverrideSection, float AnimRootMotionTranslationScale);

	void EnableScalingWithRateOfFire();
	void OnTargetDataCancelledCallback();
	void OnTargetDataReadyCallback(const struct FGameplayAbilityTargetDataHandle& TargetData, const struct FGameplayTag& ApplicationTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAbilityTask_PlayMontageWaitTarget">();
	}
	static class UFortAbilityTask_PlayMontageWaitTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAbilityTask_PlayMontageWaitTarget>();
	}
};
static_assert(alignof(UFortAbilityTask_PlayMontageWaitTarget) == 0x000008, "Wrong alignment on UFortAbilityTask_PlayMontageWaitTarget");
static_assert(sizeof(UFortAbilityTask_PlayMontageWaitTarget) == 0x000130, "Wrong size on UFortAbilityTask_PlayMontageWaitTarget");
static_assert(offsetof(UFortAbilityTask_PlayMontageWaitTarget, Triggered) == 0x000080, "Member 'UFortAbilityTask_PlayMontageWaitTarget::Triggered' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_PlayMontageWaitTarget, Cancelled) == 0x000090, "Member 'UFortAbilityTask_PlayMontageWaitTarget::Cancelled' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_PlayMontageWaitTarget, Completed) == 0x0000A0, "Member 'UFortAbilityTask_PlayMontageWaitTarget::Completed' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_PlayMontageWaitTarget, MontageInfo) == 0x0000B0, "Member 'UFortAbilityTask_PlayMontageWaitTarget::MontageInfo' has a wrong offset!");

// Class FortniteGame.FortAbilityTask_SetNextMontageSectionAndWait
// 0x0030 (0x00B0 - 0x0080)
class UFortAbilityTask_SetNextMontageSectionAndWait final : public UAbilityTask
{
public:
	UMulticastDelegateProperty_                   OnComplete;                                        // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnInterrupted;                                     // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UFortAbilityTask_SetNextMontageSectionAndWait* SetNextMontageSectionAndWait(class UGameplayAbility* OwningAbility, class UAnimMontage* PlayingMontage, class FName NextMontageSection);

	void OnMontageBlendingOut(class UAnimMontage* Montage, bool bInterrupted);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAbilityTask_SetNextMontageSectionAndWait">();
	}
	static class UFortAbilityTask_SetNextMontageSectionAndWait* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAbilityTask_SetNextMontageSectionAndWait>();
	}
};
static_assert(alignof(UFortAbilityTask_SetNextMontageSectionAndWait) == 0x000008, "Wrong alignment on UFortAbilityTask_SetNextMontageSectionAndWait");
static_assert(sizeof(UFortAbilityTask_SetNextMontageSectionAndWait) == 0x0000B0, "Wrong size on UFortAbilityTask_SetNextMontageSectionAndWait");
static_assert(offsetof(UFortAbilityTask_SetNextMontageSectionAndWait, OnComplete) == 0x000080, "Member 'UFortAbilityTask_SetNextMontageSectionAndWait::OnComplete' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_SetNextMontageSectionAndWait, OnInterrupted) == 0x000090, "Member 'UFortAbilityTask_SetNextMontageSectionAndWait::OnInterrupted' has a wrong offset!");

// Class FortniteGame.FortSpawnContextObjectInterface
// 0x0000 (0x0028 - 0x0028)
class IFortSpawnContextObjectInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortSpawnContextObjectInterface">();
	}
	static class IFortSpawnContextObjectInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortSpawnContextObjectInterface>();
	}
};
static_assert(alignof(IFortSpawnContextObjectInterface) == 0x000008, "Wrong alignment on IFortSpawnContextObjectInterface");
static_assert(sizeof(IFortSpawnContextObjectInterface) == 0x000028, "Wrong size on IFortSpawnContextObjectInterface");

// Class FortniteGame.FortGameplayEffectDeliveryActor
// 0x02F8 (0x0680 - 0x0388)
class AFortGameplayEffectDeliveryActor : public AActor
{
public:
	uint8                                         Pad_388[0x20];                                     // 0x0388(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortGameplayEffectContainerSpec       EffectContainerSpecToApplyOnTouch;                 // 0x03A8(0x0080)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bKillOnExplode;                                    // 0x0428(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_429[0x7];                                      // 0x0429(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortGameplayEffectContainerSpec       EffectContainerSpecToApplyOnExplode;               // 0x0430(0x0080)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         LifespanAfterKill;                                 // 0x04B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TouchingActorsEffectApplicationUpdateTime;         // 0x04B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsBeingKilled : 1;                                // 0x04B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIgnoreInstigatorCollision : 1;                    // 0x04B8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAddHitResultToTouchApplication : 1;               // 0x04B8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_4B9[0x7];                                      // 0x04B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    CollisionComponent;                                // 0x04C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFortSpawnContext                      SpawnContext;                                      // 0x04C8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Net, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4F0[0x170];                                    // 0x04F0(0x0170)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bDoExplosionReentrancyGuard : 1;                   // 0x0660(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_661[0x1F];                                     // 0x0661(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastExplosion(const TArray<class AActor*>& HitActors, const TArray<struct FHitResult>& HitResults);
	void DoExplosion();
	void Kill();
	void KillTimerExpired();
	void OnComponentOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnComponentTouch(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnExploded(const TArray<class AActor*>& HitActors, const TArray<struct FHitResult>& HitResults);
	void OnRep_IsBeingKilled();
	void OnTouched(class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FHitResult& HitResult, bool bIsOverlap);
	void SetCollisionComponent(class UPrimitiveComponent* NewCollisionComponent);
	void SetIgnoreInstigatorCollision(bool bShouldIgnore);

	class UPrimitiveComponent* GetCollisionComponent() const;
	bool IsBeingKilled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameplayEffectDeliveryActor">();
	}
	static class AFortGameplayEffectDeliveryActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGameplayEffectDeliveryActor>();
	}
};
static_assert(alignof(AFortGameplayEffectDeliveryActor) == 0x000008, "Wrong alignment on AFortGameplayEffectDeliveryActor");
static_assert(sizeof(AFortGameplayEffectDeliveryActor) == 0x000680, "Wrong size on AFortGameplayEffectDeliveryActor");
static_assert(offsetof(AFortGameplayEffectDeliveryActor, EffectContainerSpecToApplyOnTouch) == 0x0003A8, "Member 'AFortGameplayEffectDeliveryActor::EffectContainerSpecToApplyOnTouch' has a wrong offset!");
static_assert(offsetof(AFortGameplayEffectDeliveryActor, bKillOnExplode) == 0x000428, "Member 'AFortGameplayEffectDeliveryActor::bKillOnExplode' has a wrong offset!");
static_assert(offsetof(AFortGameplayEffectDeliveryActor, EffectContainerSpecToApplyOnExplode) == 0x000430, "Member 'AFortGameplayEffectDeliveryActor::EffectContainerSpecToApplyOnExplode' has a wrong offset!");
static_assert(offsetof(AFortGameplayEffectDeliveryActor, LifespanAfterKill) == 0x0004B0, "Member 'AFortGameplayEffectDeliveryActor::LifespanAfterKill' has a wrong offset!");
static_assert(offsetof(AFortGameplayEffectDeliveryActor, TouchingActorsEffectApplicationUpdateTime) == 0x0004B4, "Member 'AFortGameplayEffectDeliveryActor::TouchingActorsEffectApplicationUpdateTime' has a wrong offset!");
static_assert(offsetof(AFortGameplayEffectDeliveryActor, CollisionComponent) == 0x0004C0, "Member 'AFortGameplayEffectDeliveryActor::CollisionComponent' has a wrong offset!");
static_assert(offsetof(AFortGameplayEffectDeliveryActor, SpawnContext) == 0x0004C8, "Member 'AFortGameplayEffectDeliveryActor::SpawnContext' has a wrong offset!");

// Class FortniteGame.FortAsyncAction_EnsureClientQuestLogin
// 0x0028 (0x0050 - 0x0028)
class UFortAsyncAction_EnsureClientQuestLogin final : public UBlueprintAsyncActionBase
{
public:
	UMulticastDelegateProperty_                   OnSuccess;                                         // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFailure;                                         // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UFortQuestManager*                      QuestManager;                                      // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UFortAsyncAction_EnsureClientQuestLogin* SendEnsureClientQuestLogin(class UFortQuestManager* QuestManager_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAsyncAction_EnsureClientQuestLogin">();
	}
	static class UFortAsyncAction_EnsureClientQuestLogin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAsyncAction_EnsureClientQuestLogin>();
	}
};
static_assert(alignof(UFortAsyncAction_EnsureClientQuestLogin) == 0x000008, "Wrong alignment on UFortAsyncAction_EnsureClientQuestLogin");
static_assert(sizeof(UFortAsyncAction_EnsureClientQuestLogin) == 0x000050, "Wrong size on UFortAsyncAction_EnsureClientQuestLogin");
static_assert(offsetof(UFortAsyncAction_EnsureClientQuestLogin, OnSuccess) == 0x000028, "Member 'UFortAsyncAction_EnsureClientQuestLogin::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_EnsureClientQuestLogin, OnFailure) == 0x000038, "Member 'UFortAsyncAction_EnsureClientQuestLogin::OnFailure' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_EnsureClientQuestLogin, QuestManager) == 0x000048, "Member 'UFortAsyncAction_EnsureClientQuestLogin::QuestManager' has a wrong offset!");

// Class FortniteGame.FortProjectileBase
// 0x0178 (0x07F8 - 0x0680)
#pragma pack(push, 0x1)
class alignas(0x08) AFortProjectileBase : public AFortGameplayEffectDeliveryActor
{
public:
	uint8                                         Pad_680[0x8];                                      // 0x0680(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCurveTableRowHandle                   VerticleFireOffset;                                // 0x0688(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FCurveTableRowHandle                   InitialSpeed;                                      // 0x0698(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FCurveTableRowHandle                   MaxSpeed;                                          // 0x06A8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ReplicatedMaxSpeed;                                // 0x06B8(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravityScale;                                      // 0x06BC(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChargePercent;                                     // 0x06C0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MomentumTransfer;                                  // 0x06C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddOwnerVelocity;                                 // 0x06C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnPointCanBeUsedByOtherPlayers;                // 0x06C9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6CA[0x2];                                      // 0x06CA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayerSpawnOffset;                                 // 0x06CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCapsuleComponent*                      CapsuleComponent;                                  // 0x06D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProjectileMovementComponent*           ProjectileMovementComponent;                       // 0x06D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStopSimulatingOnHit;                              // 0x06E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6E1[0x7];                                      // 0x06E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	EFortBaseWeaponDamage                         WeaponResponseType;                                // 0x06E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6E9[0xE7];                                     // 0x06E9(0x00E7)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  DefaultTags;                                       // 0x07D0(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_7F0[0x8];                                      // 0x07F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AFortPlayerController* GetOwnerPlayerController();
	void OnBounce(const struct FHitResult& Hit);
	void OnBounceCallback(const struct FHitResult& Hit, const struct FVector& ImpactVelocity);
	void OnRep_GravityScale();
	void OnRep_ReplicatedMaxSpeed();
	void OnShot(const struct FHitResult& Hit);
	void OnStop(const struct FHitResult& Hit);
	void OnStopCallback(const struct FHitResult& Hit);
	void OnStoppedOnServer();
	void SetGravityScale(float InitialGravityScale);

	float GetGravityScale() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortProjectileBase">();
	}
	static class AFortProjectileBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortProjectileBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(AFortProjectileBase) == 0x000008, "Wrong alignment on AFortProjectileBase");
static_assert(sizeof(AFortProjectileBase) == 0x0007F8, "Wrong size on AFortProjectileBase");
static_assert(offsetof(AFortProjectileBase, VerticleFireOffset) == 0x000688, "Member 'AFortProjectileBase::VerticleFireOffset' has a wrong offset!");
static_assert(offsetof(AFortProjectileBase, InitialSpeed) == 0x000698, "Member 'AFortProjectileBase::InitialSpeed' has a wrong offset!");
static_assert(offsetof(AFortProjectileBase, MaxSpeed) == 0x0006A8, "Member 'AFortProjectileBase::MaxSpeed' has a wrong offset!");
static_assert(offsetof(AFortProjectileBase, ReplicatedMaxSpeed) == 0x0006B8, "Member 'AFortProjectileBase::ReplicatedMaxSpeed' has a wrong offset!");
static_assert(offsetof(AFortProjectileBase, GravityScale) == 0x0006BC, "Member 'AFortProjectileBase::GravityScale' has a wrong offset!");
static_assert(offsetof(AFortProjectileBase, ChargePercent) == 0x0006C0, "Member 'AFortProjectileBase::ChargePercent' has a wrong offset!");
static_assert(offsetof(AFortProjectileBase, MomentumTransfer) == 0x0006C4, "Member 'AFortProjectileBase::MomentumTransfer' has a wrong offset!");
static_assert(offsetof(AFortProjectileBase, bAddOwnerVelocity) == 0x0006C8, "Member 'AFortProjectileBase::bAddOwnerVelocity' has a wrong offset!");
static_assert(offsetof(AFortProjectileBase, bSpawnPointCanBeUsedByOtherPlayers) == 0x0006C9, "Member 'AFortProjectileBase::bSpawnPointCanBeUsedByOtherPlayers' has a wrong offset!");
static_assert(offsetof(AFortProjectileBase, PlayerSpawnOffset) == 0x0006CC, "Member 'AFortProjectileBase::PlayerSpawnOffset' has a wrong offset!");
static_assert(offsetof(AFortProjectileBase, CapsuleComponent) == 0x0006D0, "Member 'AFortProjectileBase::CapsuleComponent' has a wrong offset!");
static_assert(offsetof(AFortProjectileBase, ProjectileMovementComponent) == 0x0006D8, "Member 'AFortProjectileBase::ProjectileMovementComponent' has a wrong offset!");
static_assert(offsetof(AFortProjectileBase, bStopSimulatingOnHit) == 0x0006E0, "Member 'AFortProjectileBase::bStopSimulatingOnHit' has a wrong offset!");
static_assert(offsetof(AFortProjectileBase, WeaponResponseType) == 0x0006E8, "Member 'AFortProjectileBase::WeaponResponseType' has a wrong offset!");
static_assert(offsetof(AFortProjectileBase, DefaultTags) == 0x0007D0, "Member 'AFortProjectileBase::DefaultTags' has a wrong offset!");

// Class FortniteGame.FortAbilityTask_SpawnProjectileAndWait
// 0x01A8 (0x0228 - 0x0080)
class UFortAbilityTask_SpawnProjectileAndWait final : public UAbilityTask
{
public:
	UMulticastDelegateProperty_                   Created;                                           // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   Touched;                                           // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   Bounced;                                           // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   Stopped;                                           // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   Exploded;                                          // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   Destroyed;                                         // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AFortProjectileBase>     SpawnedProj;                                       // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 RequestedBy;                                       // 0x00E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SpawnLocation;                                     // 0x00F0(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               SpawnRotation;                                     // 0x00FC(0x000C)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               SpawnDirection;                                    // 0x0108(0x000C)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         InitialSpeed;                                      // 0x0114(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFortGameplayEffectContainerSpec       EffectContainerSpecToApplyOnHit;                   // 0x0118(0x0080)(NativeAccessSpecifierPublic)
	struct FFortGameplayEffectContainerSpec       EffectContainerSpecToApplyOnExplode;               // 0x0198(0x0080)(NativeAccessSpecifierPublic)
	float                                         GravityScale;                                      // 0x0218(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21C[0x4];                                      // 0x021C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 HomingTarget;                                      // 0x0220(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UFortAbilityTask_SpawnProjectileAndWait* SpawnProjectileAndWait(class UGameplayAbility* OwningAbility, TSubclassOf<class AFortProjectileBase> Class_0, class AActor* RequestedBy_0, const struct FVector& SpawnLocation_0, const struct FRotator& SpawnRotation_0, const struct FRotator& SpawnDirection_0, float InitialSpeed_0, const struct FFortGameplayEffectContainerSpec& EffectContainerSpecToApplyOnHit_0, const struct FFortGameplayEffectContainerSpec& EffectContainerSpecToApplyOnExplode_0, float GravityScale_0, class AActor* HomingTarget_0);

	bool BeginSpawningActor(class UGameplayAbility* OwningAbility, TSubclassOf<class AFortProjectileBase> Class_0, class AFortProjectileBase** SpawnedActor);
	void FinishSpawningActor(class UGameplayAbility* OwningAbility, class AFortProjectileBase* SpawnedActor);
	void OnProjectileDestroyed(class AActor* DestroyedActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAbilityTask_SpawnProjectileAndWait">();
	}
	static class UFortAbilityTask_SpawnProjectileAndWait* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAbilityTask_SpawnProjectileAndWait>();
	}
};
static_assert(alignof(UFortAbilityTask_SpawnProjectileAndWait) == 0x000008, "Wrong alignment on UFortAbilityTask_SpawnProjectileAndWait");
static_assert(sizeof(UFortAbilityTask_SpawnProjectileAndWait) == 0x000228, "Wrong size on UFortAbilityTask_SpawnProjectileAndWait");
static_assert(offsetof(UFortAbilityTask_SpawnProjectileAndWait, Created) == 0x000080, "Member 'UFortAbilityTask_SpawnProjectileAndWait::Created' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_SpawnProjectileAndWait, Touched) == 0x000090, "Member 'UFortAbilityTask_SpawnProjectileAndWait::Touched' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_SpawnProjectileAndWait, Bounced) == 0x0000A0, "Member 'UFortAbilityTask_SpawnProjectileAndWait::Bounced' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_SpawnProjectileAndWait, Stopped) == 0x0000B0, "Member 'UFortAbilityTask_SpawnProjectileAndWait::Stopped' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_SpawnProjectileAndWait, Exploded) == 0x0000C0, "Member 'UFortAbilityTask_SpawnProjectileAndWait::Exploded' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_SpawnProjectileAndWait, Destroyed) == 0x0000D0, "Member 'UFortAbilityTask_SpawnProjectileAndWait::Destroyed' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_SpawnProjectileAndWait, SpawnedProj) == 0x0000E0, "Member 'UFortAbilityTask_SpawnProjectileAndWait::SpawnedProj' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_SpawnProjectileAndWait, RequestedBy) == 0x0000E8, "Member 'UFortAbilityTask_SpawnProjectileAndWait::RequestedBy' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_SpawnProjectileAndWait, SpawnLocation) == 0x0000F0, "Member 'UFortAbilityTask_SpawnProjectileAndWait::SpawnLocation' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_SpawnProjectileAndWait, SpawnRotation) == 0x0000FC, "Member 'UFortAbilityTask_SpawnProjectileAndWait::SpawnRotation' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_SpawnProjectileAndWait, SpawnDirection) == 0x000108, "Member 'UFortAbilityTask_SpawnProjectileAndWait::SpawnDirection' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_SpawnProjectileAndWait, InitialSpeed) == 0x000114, "Member 'UFortAbilityTask_SpawnProjectileAndWait::InitialSpeed' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_SpawnProjectileAndWait, EffectContainerSpecToApplyOnHit) == 0x000118, "Member 'UFortAbilityTask_SpawnProjectileAndWait::EffectContainerSpecToApplyOnHit' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_SpawnProjectileAndWait, EffectContainerSpecToApplyOnExplode) == 0x000198, "Member 'UFortAbilityTask_SpawnProjectileAndWait::EffectContainerSpecToApplyOnExplode' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_SpawnProjectileAndWait, GravityScale) == 0x000218, "Member 'UFortAbilityTask_SpawnProjectileAndWait::GravityScale' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_SpawnProjectileAndWait, HomingTarget) == 0x000220, "Member 'UFortAbilityTask_SpawnProjectileAndWait::HomingTarget' has a wrong offset!");

// Class FortniteGame.FortAbilityTask_Sprint
// 0x0010 (0x0090 - 0x0080)
class UFortAbilityTask_Sprint final : public UAbilityTask
{
public:
	UMulticastDelegateProperty_                   OnTargetLocationReached;                           // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAbilityTask_Sprint">();
	}
	static class UFortAbilityTask_Sprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAbilityTask_Sprint>();
	}
};
static_assert(alignof(UFortAbilityTask_Sprint) == 0x000008, "Wrong alignment on UFortAbilityTask_Sprint");
static_assert(sizeof(UFortAbilityTask_Sprint) == 0x000090, "Wrong size on UFortAbilityTask_Sprint");
static_assert(offsetof(UFortAbilityTask_Sprint, OnTargetLocationReached) == 0x000080, "Member 'UFortAbilityTask_Sprint::OnTargetLocationReached' has a wrong offset!");

// Class FortniteGame.FortAccountStatProxyInstance
// 0x0028 (0x0050 - 0x0028)
class UFortAccountStatProxyInstance final : public UObject
{
public:
	class FString                                 StatName;                                          // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   CachedDisplayName;                                 // 0x0038(0x0018)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAccountStatProxyInstance">();
	}
	static class UFortAccountStatProxyInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAccountStatProxyInstance>();
	}
};
static_assert(alignof(UFortAccountStatProxyInstance) == 0x000008, "Wrong alignment on UFortAccountStatProxyInstance");
static_assert(sizeof(UFortAccountStatProxyInstance) == 0x000050, "Wrong size on UFortAccountStatProxyInstance");
static_assert(offsetof(UFortAccountStatProxyInstance, StatName) == 0x000028, "Member 'UFortAccountStatProxyInstance::StatName' has a wrong offset!");
static_assert(offsetof(UFortAccountStatProxyInstance, CachedDisplayName) == 0x000038, "Member 'UFortAccountStatProxyInstance::CachedDisplayName' has a wrong offset!");

// Class FortniteGame.FortGameMode
// 0x0308 (0x0778 - 0x0470)
#pragma pack(push, 0x1)
class alignas(0x08) AFortGameMode : public AGameMode
{
public:
	uint8                                         bDisableCloudStorage : 1;                          // 0x0470(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTravelInitiated : 1;                              // 0x0470(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTeamGame : 1;                                     // 0x0470(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_471[0x7];                                      // 0x0471(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CurrentWUID;                                       // 0x0478(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentPlaylistId;                                 // 0x0488(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48C[0x4];                                      // 0x048C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MatchmakingRegionId;                               // 0x0490(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MatchmakingGroupId;                                // 0x04A0(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CurrentZoneInstanceId;                             // 0x04B0(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C0[0x4];                                      // 0x04C0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ZoneIndex;                                         // 0x04C4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bPlayersInvincible : 1;                            // 0x04C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_4C9[0x3];                                      // 0x04C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bKickIdlers;                                       // 0x04CC(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4CD[0x3];                                      // 0x04CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxIdleTime;                                       // 0x04D0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableNotifications;                              // 0x04D4(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D5[0x3];                                      // 0x04D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UFortGameDeathPenalty>   DeathPenaltyData;                                  // 0x04D8(0x0020)(Edit, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F8[0x8];                                      // 0x04F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortGameSession*                       FortGameSession;                                   // 0x0500(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GameModeSessionString;                             // 0x0508(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsAutomatedTest : 1;                              // 0x0518(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_519[0x7];                                      // 0x0519(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   DefaultPawnClassStringRef;                         // 0x0520(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AFortMissionManager>        MissionManagerClass;                               // 0x0540(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnExplorationActorsAtWorldInitialization;      // 0x0548(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_549[0x17];                                     // 0x0549(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bOverrideRotationOnRestartPlayer;                  // 0x0560(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortGameplayState                            PendingTimerState;                                 // 0x0561(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_562[0x6];                                      // 0x0562(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bWorldIsReady : 1;                                 // 0x0568(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bTheaterDataIsReady : 1;                           // 0x0568(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_569[0x3];                                      // 0x0569(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TheaterSlot;                                       // 0x056C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GameplayServerHitchThreshold;                      // 0x0570(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovementTimeDiscrepancyHitchCooldown;              // 0x0574(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AbilityRefireHitchCooldown;                        // 0x0578(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_57C[0x4];                                      // 0x057C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMatchHeartbeatManager*                 MatchHeartbeatManager;                             // 0x0580(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_588[0x10];                                     // 0x0588(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  GameContextTags;                                   // 0x0598(0x0020)(Transient, Protected, NativeAccessSpecifierProtected)
	class UFortSharedMissionLists*                SharedMissionLists;                                // 0x05B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C0[0x10];                                     // 0x05C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AFortTeamInfo>              TeamInfoClass;                                     // 0x05D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D8[0x88];                                     // 0x05D8(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortMissionGenerationManager*          MissionGenerationManager;                          // 0x0660(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_668[0xE8];                                     // 0x0668(0x00E8)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bOverrideQuickBars;                                // 0x0750(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_751[0x7];                                      // 0x0751(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuickBarData                          QuickBarDefinitions[0x2];                          // 0x0758(0x0010)(Edit, NativeAccessSpecifierPublic)

public:
	void OnEndOfDay();

	void DumpReservations() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameMode">();
	}
	static class AFortGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGameMode>();
	}
};
#pragma pack(pop)
static_assert(alignof(AFortGameMode) == 0x000008, "Wrong alignment on AFortGameMode");
static_assert(sizeof(AFortGameMode) == 0x000778, "Wrong size on AFortGameMode");
static_assert(offsetof(AFortGameMode, CurrentWUID) == 0x000478, "Member 'AFortGameMode::CurrentWUID' has a wrong offset!");
static_assert(offsetof(AFortGameMode, CurrentPlaylistId) == 0x000488, "Member 'AFortGameMode::CurrentPlaylistId' has a wrong offset!");
static_assert(offsetof(AFortGameMode, MatchmakingRegionId) == 0x000490, "Member 'AFortGameMode::MatchmakingRegionId' has a wrong offset!");
static_assert(offsetof(AFortGameMode, MatchmakingGroupId) == 0x0004A0, "Member 'AFortGameMode::MatchmakingGroupId' has a wrong offset!");
static_assert(offsetof(AFortGameMode, CurrentZoneInstanceId) == 0x0004B0, "Member 'AFortGameMode::CurrentZoneInstanceId' has a wrong offset!");
static_assert(offsetof(AFortGameMode, ZoneIndex) == 0x0004C4, "Member 'AFortGameMode::ZoneIndex' has a wrong offset!");
static_assert(offsetof(AFortGameMode, bKickIdlers) == 0x0004CC, "Member 'AFortGameMode::bKickIdlers' has a wrong offset!");
static_assert(offsetof(AFortGameMode, MaxIdleTime) == 0x0004D0, "Member 'AFortGameMode::MaxIdleTime' has a wrong offset!");
static_assert(offsetof(AFortGameMode, bEnableNotifications) == 0x0004D4, "Member 'AFortGameMode::bEnableNotifications' has a wrong offset!");
static_assert(offsetof(AFortGameMode, DeathPenaltyData) == 0x0004D8, "Member 'AFortGameMode::DeathPenaltyData' has a wrong offset!");
static_assert(offsetof(AFortGameMode, FortGameSession) == 0x000500, "Member 'AFortGameMode::FortGameSession' has a wrong offset!");
static_assert(offsetof(AFortGameMode, GameModeSessionString) == 0x000508, "Member 'AFortGameMode::GameModeSessionString' has a wrong offset!");
static_assert(offsetof(AFortGameMode, DefaultPawnClassStringRef) == 0x000520, "Member 'AFortGameMode::DefaultPawnClassStringRef' has a wrong offset!");
static_assert(offsetof(AFortGameMode, MissionManagerClass) == 0x000540, "Member 'AFortGameMode::MissionManagerClass' has a wrong offset!");
static_assert(offsetof(AFortGameMode, bSpawnExplorationActorsAtWorldInitialization) == 0x000548, "Member 'AFortGameMode::bSpawnExplorationActorsAtWorldInitialization' has a wrong offset!");
static_assert(offsetof(AFortGameMode, bOverrideRotationOnRestartPlayer) == 0x000560, "Member 'AFortGameMode::bOverrideRotationOnRestartPlayer' has a wrong offset!");
static_assert(offsetof(AFortGameMode, PendingTimerState) == 0x000561, "Member 'AFortGameMode::PendingTimerState' has a wrong offset!");
static_assert(offsetof(AFortGameMode, TheaterSlot) == 0x00056C, "Member 'AFortGameMode::TheaterSlot' has a wrong offset!");
static_assert(offsetof(AFortGameMode, GameplayServerHitchThreshold) == 0x000570, "Member 'AFortGameMode::GameplayServerHitchThreshold' has a wrong offset!");
static_assert(offsetof(AFortGameMode, MovementTimeDiscrepancyHitchCooldown) == 0x000574, "Member 'AFortGameMode::MovementTimeDiscrepancyHitchCooldown' has a wrong offset!");
static_assert(offsetof(AFortGameMode, AbilityRefireHitchCooldown) == 0x000578, "Member 'AFortGameMode::AbilityRefireHitchCooldown' has a wrong offset!");
static_assert(offsetof(AFortGameMode, MatchHeartbeatManager) == 0x000580, "Member 'AFortGameMode::MatchHeartbeatManager' has a wrong offset!");
static_assert(offsetof(AFortGameMode, GameContextTags) == 0x000598, "Member 'AFortGameMode::GameContextTags' has a wrong offset!");
static_assert(offsetof(AFortGameMode, SharedMissionLists) == 0x0005B8, "Member 'AFortGameMode::SharedMissionLists' has a wrong offset!");
static_assert(offsetof(AFortGameMode, TeamInfoClass) == 0x0005D0, "Member 'AFortGameMode::TeamInfoClass' has a wrong offset!");
static_assert(offsetof(AFortGameMode, MissionGenerationManager) == 0x000660, "Member 'AFortGameMode::MissionGenerationManager' has a wrong offset!");
static_assert(offsetof(AFortGameMode, bOverrideQuickBars) == 0x000750, "Member 'AFortGameMode::bOverrideQuickBars' has a wrong offset!");
static_assert(offsetof(AFortGameMode, QuickBarDefinitions) == 0x000758, "Member 'AFortGameMode::QuickBarDefinitions' has a wrong offset!");

// Class FortniteGame.FortGameModeZone
// 0x00B0 (0x0828 - 0x0778)
#pragma pack(push, 0x1)
class alignas(0x08) AFortGameModeZone : public AFortGameMode
{
public:
	uint8                                         bSpawnAllStuff : 1;                                // 0x0778(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisableAI : 1;                                    // 0x0778(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInitBeaconAtInitGame : 1;                         // 0x0778(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_779[0x3];                                      // 0x0779(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OverrideAIDirectorIndex;                           // 0x077C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABuildingSMActor*                       ActiveSpawnPad;                                    // 0x0780(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AFortAIDirector*                        AIDirector;                                        // 0x0788(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortAIGoalManager*                     AIGoalManager;                                     // 0x0790(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         EndOfZoneRemainTime;                               // 0x0798(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_79C[0x4];                                      // 0x079C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortTaggedActorsManager*               TaggedActorsManager;                               // 0x07A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABuildingConnectivityManager*           ConnectivityManager;                               // 0x07A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseAllSocketsInSpawnPad;                          // 0x07B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7B1[0x7];                                      // 0x07B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AFortVisibilityManager>     VisibilityManagerClass;                            // 0x07B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCriticalMissionEligible;                          // 0x07C0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C1[0x17];                                     // 0x07C1(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FItemAndCount>                  StartingItems;                                     // 0x07D8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnHandleZonePeriodicReport;                        // 0x07E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnHandleMatchHasStarted;                           // 0x07F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	bool                                          bTrustXboxPlatformId;                              // 0x0808(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESubGame                                      AssociatedSubGame;                                 // 0x0809(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_80A[0x1];                                      // 0x080A(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShouldCheckHwHandle;                              // 0x080B(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldCheckIp;                                    // 0x080C(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldCheckSIP;                                   // 0x080D(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldCheckNetQOS;                                // 0x080E(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldCheckBehavior;                              // 0x080F(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldCheckAbility;                               // 0x0810(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldCheckMT;                                    // 0x0811(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_812[0x2];                                      // 0x0812(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InGameConnectionTimeOutPVP;                        // 0x0814(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBCActionInfo>                  MapBCAction;                                       // 0x0818(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)

public:
	void OnEveningReached();
	void OnMorningReached();
	void ReplicateHealthAndShield();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameModeZone">();
	}
	static class AFortGameModeZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGameModeZone>();
	}
};
#pragma pack(pop)
static_assert(alignof(AFortGameModeZone) == 0x000008, "Wrong alignment on AFortGameModeZone");
static_assert(sizeof(AFortGameModeZone) == 0x000828, "Wrong size on AFortGameModeZone");
static_assert(offsetof(AFortGameModeZone, OverrideAIDirectorIndex) == 0x00077C, "Member 'AFortGameModeZone::OverrideAIDirectorIndex' has a wrong offset!");
static_assert(offsetof(AFortGameModeZone, ActiveSpawnPad) == 0x000780, "Member 'AFortGameModeZone::ActiveSpawnPad' has a wrong offset!");
static_assert(offsetof(AFortGameModeZone, AIDirector) == 0x000788, "Member 'AFortGameModeZone::AIDirector' has a wrong offset!");
static_assert(offsetof(AFortGameModeZone, AIGoalManager) == 0x000790, "Member 'AFortGameModeZone::AIGoalManager' has a wrong offset!");
static_assert(offsetof(AFortGameModeZone, EndOfZoneRemainTime) == 0x000798, "Member 'AFortGameModeZone::EndOfZoneRemainTime' has a wrong offset!");
static_assert(offsetof(AFortGameModeZone, TaggedActorsManager) == 0x0007A0, "Member 'AFortGameModeZone::TaggedActorsManager' has a wrong offset!");
static_assert(offsetof(AFortGameModeZone, ConnectivityManager) == 0x0007A8, "Member 'AFortGameModeZone::ConnectivityManager' has a wrong offset!");
static_assert(offsetof(AFortGameModeZone, bUseAllSocketsInSpawnPad) == 0x0007B0, "Member 'AFortGameModeZone::bUseAllSocketsInSpawnPad' has a wrong offset!");
static_assert(offsetof(AFortGameModeZone, VisibilityManagerClass) == 0x0007B8, "Member 'AFortGameModeZone::VisibilityManagerClass' has a wrong offset!");
static_assert(offsetof(AFortGameModeZone, bCriticalMissionEligible) == 0x0007C0, "Member 'AFortGameModeZone::bCriticalMissionEligible' has a wrong offset!");
static_assert(offsetof(AFortGameModeZone, StartingItems) == 0x0007D8, "Member 'AFortGameModeZone::StartingItems' has a wrong offset!");
static_assert(offsetof(AFortGameModeZone, OnHandleZonePeriodicReport) == 0x0007E8, "Member 'AFortGameModeZone::OnHandleZonePeriodicReport' has a wrong offset!");
static_assert(offsetof(AFortGameModeZone, OnHandleMatchHasStarted) == 0x0007F8, "Member 'AFortGameModeZone::OnHandleMatchHasStarted' has a wrong offset!");
static_assert(offsetof(AFortGameModeZone, bTrustXboxPlatformId) == 0x000808, "Member 'AFortGameModeZone::bTrustXboxPlatformId' has a wrong offset!");
static_assert(offsetof(AFortGameModeZone, AssociatedSubGame) == 0x000809, "Member 'AFortGameModeZone::AssociatedSubGame' has a wrong offset!");
static_assert(offsetof(AFortGameModeZone, bShouldCheckHwHandle) == 0x00080B, "Member 'AFortGameModeZone::bShouldCheckHwHandle' has a wrong offset!");
static_assert(offsetof(AFortGameModeZone, bShouldCheckIp) == 0x00080C, "Member 'AFortGameModeZone::bShouldCheckIp' has a wrong offset!");
static_assert(offsetof(AFortGameModeZone, bShouldCheckSIP) == 0x00080D, "Member 'AFortGameModeZone::bShouldCheckSIP' has a wrong offset!");
static_assert(offsetof(AFortGameModeZone, bShouldCheckNetQOS) == 0x00080E, "Member 'AFortGameModeZone::bShouldCheckNetQOS' has a wrong offset!");
static_assert(offsetof(AFortGameModeZone, bShouldCheckBehavior) == 0x00080F, "Member 'AFortGameModeZone::bShouldCheckBehavior' has a wrong offset!");
static_assert(offsetof(AFortGameModeZone, bShouldCheckAbility) == 0x000810, "Member 'AFortGameModeZone::bShouldCheckAbility' has a wrong offset!");
static_assert(offsetof(AFortGameModeZone, bShouldCheckMT) == 0x000811, "Member 'AFortGameModeZone::bShouldCheckMT' has a wrong offset!");
static_assert(offsetof(AFortGameModeZone, InGameConnectionTimeOutPVP) == 0x000814, "Member 'AFortGameModeZone::InGameConnectionTimeOutPVP' has a wrong offset!");
static_assert(offsetof(AFortGameModeZone, MapBCAction) == 0x000818, "Member 'AFortGameModeZone::MapBCAction' has a wrong offset!");

// Class FortniteGame.FortGamePvPBase
// 0x0068 (0x0890 - 0x0828)
class AFortGamePvPBase : public AFortGameModeZone
{
public:
	uint8                                         NumTeams;                                          // 0x0828(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_829[0x3];                                      // 0x0829(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RoundTimeLimit;                                    // 0x082C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RoundTimeRemainingCriticalThreshold;               // 0x0830(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         StalemateTimeLimit;                                // 0x0834(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RestartTimeLimit;                                  // 0x0838(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FOBFinalizationLimit;                              // 0x083C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bUsingFOBs : 1;                                    // 0x0840(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bFOBInitRequested : 1;                             // 0x0840(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAllFOBConfigActorsInitialized : 1;                // 0x0840(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bFinishedSpawningFOBConfigActors : 1;              // 0x0840(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_841[0x3];                                      // 0x0841(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumFOBConfigActorsPerTeam;                         // 0x0844(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FTeamFOBRequiredTags>           FOBRequiredTags;                                   // 0x0848(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class ABuildingFOBConfigActor>    FOBConfigActorClass;                               // 0x0858(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FCachedPlayerFOBInformation>    CachedFOBInfo;                                     // 0x0860(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class ABuildingFOBConfigActor*>        SpawnedFOBConfigActors;                            // 0x0870(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class ABuildingFOBConfigActor*>        SpawnedFOBConfigActorsToFinalize;                  // 0x0880(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGamePvPBase">();
	}
	static class AFortGamePvPBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGamePvPBase>();
	}
};
static_assert(alignof(AFortGamePvPBase) == 0x000008, "Wrong alignment on AFortGamePvPBase");
static_assert(sizeof(AFortGamePvPBase) == 0x000890, "Wrong size on AFortGamePvPBase");
static_assert(offsetof(AFortGamePvPBase, NumTeams) == 0x000828, "Member 'AFortGamePvPBase::NumTeams' has a wrong offset!");
static_assert(offsetof(AFortGamePvPBase, RoundTimeLimit) == 0x00082C, "Member 'AFortGamePvPBase::RoundTimeLimit' has a wrong offset!");
static_assert(offsetof(AFortGamePvPBase, RoundTimeRemainingCriticalThreshold) == 0x000830, "Member 'AFortGamePvPBase::RoundTimeRemainingCriticalThreshold' has a wrong offset!");
static_assert(offsetof(AFortGamePvPBase, StalemateTimeLimit) == 0x000834, "Member 'AFortGamePvPBase::StalemateTimeLimit' has a wrong offset!");
static_assert(offsetof(AFortGamePvPBase, RestartTimeLimit) == 0x000838, "Member 'AFortGamePvPBase::RestartTimeLimit' has a wrong offset!");
static_assert(offsetof(AFortGamePvPBase, FOBFinalizationLimit) == 0x00083C, "Member 'AFortGamePvPBase::FOBFinalizationLimit' has a wrong offset!");
static_assert(offsetof(AFortGamePvPBase, NumFOBConfigActorsPerTeam) == 0x000844, "Member 'AFortGamePvPBase::NumFOBConfigActorsPerTeam' has a wrong offset!");
static_assert(offsetof(AFortGamePvPBase, FOBRequiredTags) == 0x000848, "Member 'AFortGamePvPBase::FOBRequiredTags' has a wrong offset!");
static_assert(offsetof(AFortGamePvPBase, FOBConfigActorClass) == 0x000858, "Member 'AFortGamePvPBase::FOBConfigActorClass' has a wrong offset!");
static_assert(offsetof(AFortGamePvPBase, CachedFOBInfo) == 0x000860, "Member 'AFortGamePvPBase::CachedFOBInfo' has a wrong offset!");
static_assert(offsetof(AFortGamePvPBase, SpawnedFOBConfigActors) == 0x000870, "Member 'AFortGamePvPBase::SpawnedFOBConfigActors' has a wrong offset!");
static_assert(offsetof(AFortGamePvPBase, SpawnedFOBConfigActorsToFinalize) == 0x000880, "Member 'AFortGamePvPBase::SpawnedFOBConfigActorsToFinalize' has a wrong offset!");

// Class FortniteGame.FortGamePvPBaseDestruction
// 0x0000 (0x0890 - 0x0890)
class AFortGamePvPBaseDestruction final : public AFortGamePvPBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGamePvPBaseDestruction">();
	}
	static class AFortGamePvPBaseDestruction* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGamePvPBaseDestruction>();
	}
};
static_assert(alignof(AFortGamePvPBaseDestruction) == 0x000008, "Wrong alignment on AFortGamePvPBaseDestruction");
static_assert(sizeof(AFortGamePvPBaseDestruction) == 0x000890, "Wrong size on AFortGamePvPBaseDestruction");

// Class FortniteGame.FortAIEncounterInfoOwnerInterface
// 0x0000 (0x0028 - 0x0028)
class IFortAIEncounterInfoOwnerInterface final : public IInterface
{
public:
	class UFortAIEncounterInfo* GetEncounterInfo() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIEncounterInfoOwnerInterface">();
	}
	static class IFortAIEncounterInfoOwnerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortAIEncounterInfoOwnerInterface>();
	}
};
static_assert(alignof(IFortAIEncounterInfoOwnerInterface) == 0x000008, "Wrong alignment on IFortAIEncounterInfoOwnerInterface");
static_assert(sizeof(IFortAIEncounterInfoOwnerInterface) == 0x000028, "Wrong size on IFortAIEncounterInfoOwnerInterface");

// Class FortniteGame.FortAIAssignment
// 0x00B0 (0x00D8 - 0x0028)
class UFortAIAssignment final : public UObject
{
public:
	struct FFortAIAssignmentIdentifier            AssignmentIdentifier;                              // 0x0028(0x0030)(Protected, NativeAccessSpecifierProtected)
	class UFortAIAssignmentSettings*              AssignmentSettings;                                // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortAIGoalProvider*                    GoalProvider;                                      // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AFortAIController*>              ControllersOnAssignment;                           // 0x0068(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_78[0x50];                                      // 0x0078(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFortAIGoal>                    Goals;                                             // 0x00C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIAssignment">();
	}
	static class UFortAIAssignment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIAssignment>();
	}
};
static_assert(alignof(UFortAIAssignment) == 0x000008, "Wrong alignment on UFortAIAssignment");
static_assert(sizeof(UFortAIAssignment) == 0x0000D8, "Wrong size on UFortAIAssignment");
static_assert(offsetof(UFortAIAssignment, AssignmentIdentifier) == 0x000028, "Member 'UFortAIAssignment::AssignmentIdentifier' has a wrong offset!");
static_assert(offsetof(UFortAIAssignment, AssignmentSettings) == 0x000058, "Member 'UFortAIAssignment::AssignmentSettings' has a wrong offset!");
static_assert(offsetof(UFortAIAssignment, GoalProvider) == 0x000060, "Member 'UFortAIAssignment::GoalProvider' has a wrong offset!");
static_assert(offsetof(UFortAIAssignment, ControllersOnAssignment) == 0x000068, "Member 'UFortAIAssignment::ControllersOnAssignment' has a wrong offset!");
static_assert(offsetof(UFortAIAssignment, Goals) == 0x0000C8, "Member 'UFortAIAssignment::Goals' has a wrong offset!");

// Class FortniteGame.FortGameplayAbility_Action
// 0x0008 (0x0A48 - 0x0A40)
#pragma pack(push, 0x1)
class alignas(0x08) UFortGameplayAbility_Action : public UFortGameplayAbility
{
public:
	class FName                                   ActionName;                                        // 0x0A40(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameplayAbility_Action">();
	}
	static class UFortGameplayAbility_Action* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGameplayAbility_Action>();
	}
};
#pragma pack(pop)
static_assert(alignof(UFortGameplayAbility_Action) == 0x000008, "Wrong alignment on UFortGameplayAbility_Action");
static_assert(sizeof(UFortGameplayAbility_Action) == 0x000A48, "Wrong size on UFortGameplayAbility_Action");
static_assert(offsetof(UFortGameplayAbility_Action, ActionName) == 0x000A40, "Member 'UFortGameplayAbility_Action::ActionName' has a wrong offset!");

// Class FortniteGame.FortGameplayAbility_Jump
// 0x0008 (0x0A50 - 0x0A48)
class UFortGameplayAbility_Jump final : public UFortGameplayAbility_Action
{
public:
	uint8                                         Pad_A48[0x8];                                      // 0x0A48(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameplayAbility_Jump">();
	}
	static class UFortGameplayAbility_Jump* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGameplayAbility_Jump>();
	}
};
static_assert(alignof(UFortGameplayAbility_Jump) == 0x000008, "Wrong alignment on UFortGameplayAbility_Jump");
static_assert(sizeof(UFortGameplayAbility_Jump) == 0x000A50, "Wrong size on UFortGameplayAbility_Jump");

// Class FortniteGame.FortPathFollowingComponent
// 0x0138 (0x0530 - 0x03F8)
class UFortPathFollowingComponent final : public UCrowdFollowingComponent
{
public:
	class AFortAIController*                      MyAI;                                              // 0x03F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_400[0x80];                                     // 0x0400(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MovementBlockBumpFrustration;                      // 0x0480(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MovementBlockFrustrationCooldownSpeed;             // 0x0484(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MovementBlockFrustrationThreshold;                 // 0x0488(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48C[0xA4];                                     // 0x048C(0x00A4)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPathFollowingComponent">();
	}
	static class UFortPathFollowingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPathFollowingComponent>();
	}
};
static_assert(alignof(UFortPathFollowingComponent) == 0x000008, "Wrong alignment on UFortPathFollowingComponent");
static_assert(sizeof(UFortPathFollowingComponent) == 0x000530, "Wrong size on UFortPathFollowingComponent");
static_assert(offsetof(UFortPathFollowingComponent, MyAI) == 0x0003F8, "Member 'UFortPathFollowingComponent::MyAI' has a wrong offset!");
static_assert(offsetof(UFortPathFollowingComponent, MovementBlockBumpFrustration) == 0x000480, "Member 'UFortPathFollowingComponent::MovementBlockBumpFrustration' has a wrong offset!");
static_assert(offsetof(UFortPathFollowingComponent, MovementBlockFrustrationCooldownSpeed) == 0x000484, "Member 'UFortPathFollowingComponent::MovementBlockFrustrationCooldownSpeed' has a wrong offset!");
static_assert(offsetof(UFortPathFollowingComponent, MovementBlockFrustrationThreshold) == 0x000488, "Member 'UFortPathFollowingComponent::MovementBlockFrustrationThreshold' has a wrong offset!");

// Class FortniteGame.FortGameplayAbility_Land
// 0x0000 (0x0A40 - 0x0A40)
class UFortGameplayAbility_Land final : public UFortGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameplayAbility_Land">();
	}
	static class UFortGameplayAbility_Land* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGameplayAbility_Land>();
	}
};
static_assert(alignof(UFortGameplayAbility_Land) == 0x000008, "Wrong alignment on UFortGameplayAbility_Land");
static_assert(sizeof(UFortGameplayAbility_Land) == 0x000A40, "Wrong size on UFortGameplayAbility_Land");

// Class FortniteGame.FortFeedbackManager
// 0x0120 (0x04A8 - 0x0388)
class AFortFeedbackManager : public AActor
{
public:
	TArray<struct FFortFeedbackEventData>         FeedbackEvents;                                    // 0x0388(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class AFortPawn_FeedbackAnnouncer> AnnouncerPawnClass;                                // 0x0398(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AFortPawn_FeedbackAnnouncer*            Announcer;                                         // 0x03A0(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class AController>>     SuppressedControllers;                             // 0x03A8(0x0010)(Net, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B8[0xF0];                                     // 0x03B8(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class AFortPawn_FeedbackAnnouncer* GetAnnouncerPawn(class UObject* WorldContextObject);
	static class AFortFeedbackManager* GetFeedbackManager(class UObject* WorldContextObject);

	void SuppressProceduralFeedback(const TArray<class AController*>& ControllersToSuppress);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortFeedbackManager">();
	}
	static class AFortFeedbackManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortFeedbackManager>();
	}
};
static_assert(alignof(AFortFeedbackManager) == 0x000008, "Wrong alignment on AFortFeedbackManager");
static_assert(sizeof(AFortFeedbackManager) == 0x0004A8, "Wrong size on AFortFeedbackManager");
static_assert(offsetof(AFortFeedbackManager, FeedbackEvents) == 0x000388, "Member 'AFortFeedbackManager::FeedbackEvents' has a wrong offset!");
static_assert(offsetof(AFortFeedbackManager, AnnouncerPawnClass) == 0x000398, "Member 'AFortFeedbackManager::AnnouncerPawnClass' has a wrong offset!");
static_assert(offsetof(AFortFeedbackManager, Announcer) == 0x0003A0, "Member 'AFortFeedbackManager::Announcer' has a wrong offset!");
static_assert(offsetof(AFortFeedbackManager, SuppressedControllers) == 0x0003A8, "Member 'AFortFeedbackManager::SuppressedControllers' has a wrong offset!");

// Class FortniteGame.FortHealthSet
// 0x0498 (0x04C8 - 0x0030)
#pragma pack(push, 0x1)
class alignas(0x08) UFortHealthSet : public UFortAttributeSet
{
public:
	struct FFortGameplayAttributeData             Health;                                            // 0x0030(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             MaxHealth;                                         // 0x0050(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             CurrentShield;                                     // 0x0070(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             Shield;                                            // 0x0090(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             DamageResistance;                                  // 0x00B0(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             DamageVulnerability;                               // 0x00D0(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             ReflectDamageAbsolute;                             // 0x00F0(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             ReflectDamageFromSource;                           // 0x0110(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             Armour;                                            // 0x0130(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             HealingSourceBaseMultiplier;                       // 0x0150(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             Damage;                                            // 0x0170(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             ShieldDamage;                                      // 0x0190(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             HealingSource;                                     // 0x01B0(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             HealingBonusTarget;                                // 0x01D0(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             Healing;                                           // 0x01F0(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_210[0x2B8];                                    // 0x0210(0x02B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_CurrentShield();
	void OnRep_Health();
	void OnRep_MaxHealth();
	void OnRep_Shield();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortHealthSet">();
	}
	static class UFortHealthSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortHealthSet>();
	}
};
#pragma pack(pop)
static_assert(alignof(UFortHealthSet) == 0x000008, "Wrong alignment on UFortHealthSet");
static_assert(sizeof(UFortHealthSet) == 0x0004C8, "Wrong size on UFortHealthSet");
static_assert(offsetof(UFortHealthSet, Health) == 0x000030, "Member 'UFortHealthSet::Health' has a wrong offset!");
static_assert(offsetof(UFortHealthSet, MaxHealth) == 0x000050, "Member 'UFortHealthSet::MaxHealth' has a wrong offset!");
static_assert(offsetof(UFortHealthSet, CurrentShield) == 0x000070, "Member 'UFortHealthSet::CurrentShield' has a wrong offset!");
static_assert(offsetof(UFortHealthSet, Shield) == 0x000090, "Member 'UFortHealthSet::Shield' has a wrong offset!");
static_assert(offsetof(UFortHealthSet, DamageResistance) == 0x0000B0, "Member 'UFortHealthSet::DamageResistance' has a wrong offset!");
static_assert(offsetof(UFortHealthSet, DamageVulnerability) == 0x0000D0, "Member 'UFortHealthSet::DamageVulnerability' has a wrong offset!");
static_assert(offsetof(UFortHealthSet, ReflectDamageAbsolute) == 0x0000F0, "Member 'UFortHealthSet::ReflectDamageAbsolute' has a wrong offset!");
static_assert(offsetof(UFortHealthSet, ReflectDamageFromSource) == 0x000110, "Member 'UFortHealthSet::ReflectDamageFromSource' has a wrong offset!");
static_assert(offsetof(UFortHealthSet, Armour) == 0x000130, "Member 'UFortHealthSet::Armour' has a wrong offset!");
static_assert(offsetof(UFortHealthSet, HealingSourceBaseMultiplier) == 0x000150, "Member 'UFortHealthSet::HealingSourceBaseMultiplier' has a wrong offset!");
static_assert(offsetof(UFortHealthSet, Damage) == 0x000170, "Member 'UFortHealthSet::Damage' has a wrong offset!");
static_assert(offsetof(UFortHealthSet, ShieldDamage) == 0x000190, "Member 'UFortHealthSet::ShieldDamage' has a wrong offset!");
static_assert(offsetof(UFortHealthSet, HealingSource) == 0x0001B0, "Member 'UFortHealthSet::HealingSource' has a wrong offset!");
static_assert(offsetof(UFortHealthSet, HealingBonusTarget) == 0x0001D0, "Member 'UFortHealthSet::HealingBonusTarget' has a wrong offset!");
static_assert(offsetof(UFortHealthSet, Healing) == 0x0001F0, "Member 'UFortHealthSet::Healing' has a wrong offset!");

// Class FortniteGame.FortRegenHealthSet
// 0x00D8 (0x05A0 - 0x04C8)
class UFortRegenHealthSet final : public UFortHealthSet
{
public:
	uint8                                         Pad_4C8[0x8];                                      // 0x04C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortGameplayAttributeData             HealthRegenRate;                                   // 0x04D0(0x0020)(BlueprintVisible, Net, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             HealthRegenDelay;                                  // 0x04F0(0x0020)(BlueprintVisible, Net, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             HealthRegenThreshold;                              // 0x0510(0x0020)(BlueprintVisible, Net, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             ShieldRegenRate;                                   // 0x0530(0x0020)(BlueprintVisible, Net, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             ShieldRegenDelay;                                  // 0x0550(0x0020)(BlueprintVisible, Net, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             ShieldRegenThreshold;                              // 0x0570(0x0020)(BlueprintVisible, Net, NativeAccessSpecifierPublic)
	uint8                                         Pad_590[0x10];                                     // 0x0590(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortRegenHealthSet">();
	}
	static class UFortRegenHealthSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortRegenHealthSet>();
	}
};
static_assert(alignof(UFortRegenHealthSet) == 0x000008, "Wrong alignment on UFortRegenHealthSet");
static_assert(sizeof(UFortRegenHealthSet) == 0x0005A0, "Wrong size on UFortRegenHealthSet");
static_assert(offsetof(UFortRegenHealthSet, HealthRegenRate) == 0x0004D0, "Member 'UFortRegenHealthSet::HealthRegenRate' has a wrong offset!");
static_assert(offsetof(UFortRegenHealthSet, HealthRegenDelay) == 0x0004F0, "Member 'UFortRegenHealthSet::HealthRegenDelay' has a wrong offset!");
static_assert(offsetof(UFortRegenHealthSet, HealthRegenThreshold) == 0x000510, "Member 'UFortRegenHealthSet::HealthRegenThreshold' has a wrong offset!");
static_assert(offsetof(UFortRegenHealthSet, ShieldRegenRate) == 0x000530, "Member 'UFortRegenHealthSet::ShieldRegenRate' has a wrong offset!");
static_assert(offsetof(UFortRegenHealthSet, ShieldRegenDelay) == 0x000550, "Member 'UFortRegenHealthSet::ShieldRegenDelay' has a wrong offset!");
static_assert(offsetof(UFortRegenHealthSet, ShieldRegenThreshold) == 0x000570, "Member 'UFortRegenHealthSet::ShieldRegenThreshold' has a wrong offset!");

// Class FortniteGame.FortSpline
// 0x0040 (0x0068 - 0x0028)
class UFortSpline final : public UObject
{
public:
	bool                                          bConstantVelocity;                                 // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortCatmullRomSpline                  Spline;                                            // 0x0030(0x0020)(NativeAccessSpecifierPrivate)
	struct FInterpCurveFloat                      SplineLookupTable;                                 // 0x0050(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AddControlPoint(const struct FVector& Point, int32 Index_0);
	void ClearSpline();
	void DrawDebugSpline(class UObject* WorldContextObject, int32 Steps, float LifeTime, float Thickness, bool bPersistent, bool bJustDrawSpline, float BasisLength);
	void EnableConstantVelocity(bool ConstVelEnabled);
	void SetDuration(float InDuration);
	void SetupSpline(const TArray<struct FVector>& ControlPoints, float InDuration);

	struct FVector GetBinormalFromTime(float Time) const;
	float GetDuration() const;
	struct FVector GetEndPoint() const;
	struct FVector GetNormalFromTime(float Time) const;
	struct FVector GetPositionFromTime(float Time) const;
	float GetSplineLength(float StepSize) const;
	float GetSplineLengthAtTime(float Time, float StepSize) const;
	struct FVector GetStartPoint() const;
	struct FVector GetTangentFromTime(float Time) const;
	float GetVelocityCorrectedTime(float Time) const;
	bool IsValid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortSpline">();
	}
	static class UFortSpline* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortSpline>();
	}
};
static_assert(alignof(UFortSpline) == 0x000008, "Wrong alignment on UFortSpline");
static_assert(sizeof(UFortSpline) == 0x000068, "Wrong size on UFortSpline");
static_assert(offsetof(UFortSpline, bConstantVelocity) == 0x000028, "Member 'UFortSpline::bConstantVelocity' has a wrong offset!");
static_assert(offsetof(UFortSpline, Spline) == 0x000030, "Member 'UFortSpline::Spline' has a wrong offset!");
static_assert(offsetof(UFortSpline, SplineLookupTable) == 0x000050, "Member 'UFortSpline::SplineLookupTable' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionCategory
// 0x0008 (0x0030 - 0x0028)
class UFortDifficultyOptionCategory : public UDataAsset
{
public:
	bool                                          bIsRequired;                                       // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsStatic;                                         // 0x0029(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasValueRange;                                    // 0x002A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B[0x5];                                       // 0x002B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionCategory">();
	}
	static class UFortDifficultyOptionCategory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionCategory>();
	}
};
static_assert(alignof(UFortDifficultyOptionCategory) == 0x000008, "Wrong alignment on UFortDifficultyOptionCategory");
static_assert(sizeof(UFortDifficultyOptionCategory) == 0x000030, "Wrong size on UFortDifficultyOptionCategory");
static_assert(offsetof(UFortDifficultyOptionCategory, bIsRequired) == 0x000028, "Member 'UFortDifficultyOptionCategory::bIsRequired' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionCategory, bIsStatic) == 0x000029, "Member 'UFortDifficultyOptionCategory::bIsStatic' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionCategory, bHasValueRange) == 0x00002A, "Member 'UFortDifficultyOptionCategory::bHasValueRange' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionCategoryEncounter
// 0x0000 (0x0030 - 0x0030)
class UFortDifficultyOptionCategoryEncounter : public UFortDifficultyOptionCategory
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionCategoryEncounter">();
	}
	static class UFortDifficultyOptionCategoryEncounter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionCategoryEncounter>();
	}
};
static_assert(alignof(UFortDifficultyOptionCategoryEncounter) == 0x000008, "Wrong alignment on UFortDifficultyOptionCategoryEncounter");
static_assert(sizeof(UFortDifficultyOptionCategoryEncounter) == 0x000030, "Wrong size on UFortDifficultyOptionCategoryEncounter");

// Class FortniteGame.FortDifficultyOptionCategoryEncounter_Time
// 0x0010 (0x0040 - 0x0030)
class UFortDifficultyOptionCategoryEncounter_Time final : public UFortDifficultyOptionCategoryEncounter
{
public:
	TArray<TSubclassOf<class UFortDifficultyOptionEncounter_Time>> Options;                                           // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionCategoryEncounter_Time">();
	}
	static class UFortDifficultyOptionCategoryEncounter_Time* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionCategoryEncounter_Time>();
	}
};
static_assert(alignof(UFortDifficultyOptionCategoryEncounter_Time) == 0x000008, "Wrong alignment on UFortDifficultyOptionCategoryEncounter_Time");
static_assert(sizeof(UFortDifficultyOptionCategoryEncounter_Time) == 0x000040, "Wrong size on UFortDifficultyOptionCategoryEncounter_Time");
static_assert(offsetof(UFortDifficultyOptionCategoryEncounter_Time, Options) == 0x000030, "Member 'UFortDifficultyOptionCategoryEncounter_Time::Options' has a wrong offset!");

// Class FortniteGame.FortHUDTargetUnderReticleInterface
// 0x0000 (0x0028 - 0x0028)
class IFortHUDTargetUnderReticleInterface final : public IInterface
{
public:
	float GetHUDTargetDifficultyRating();
	TArray<class FText> GetHUDTargetDisplayModifiers();
	class FText GetHUDTargetDisplayName();
	float GetHUDTargetHealthPercentage();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortHUDTargetUnderReticleInterface">();
	}
	static class IFortHUDTargetUnderReticleInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortHUDTargetUnderReticleInterface>();
	}
};
static_assert(alignof(IFortHUDTargetUnderReticleInterface) == 0x000008, "Wrong alignment on IFortHUDTargetUnderReticleInterface");
static_assert(sizeof(IFortHUDTargetUnderReticleInterface) == 0x000028, "Wrong size on IFortHUDTargetUnderReticleInterface");

// Class FortniteGame.FortAIDataProvider_GoalProviderAbility
// 0x0000 (0x0070 - 0x0070)
class UFortAIDataProvider_GoalProviderAbility final : public UFortAIDataProvider_Ability
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIDataProvider_GoalProviderAbility">();
	}
	static class UFortAIDataProvider_GoalProviderAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIDataProvider_GoalProviderAbility>();
	}
};
static_assert(alignof(UFortAIDataProvider_GoalProviderAbility) == 0x000008, "Wrong alignment on UFortAIDataProvider_GoalProviderAbility");
static_assert(sizeof(UFortAIDataProvider_GoalProviderAbility) == 0x000070, "Wrong size on UFortAIDataProvider_GoalProviderAbility");

// Class FortniteGame.FortDecoPreview
// 0x01A8 (0x0530 - 0x0388)
class AFortDecoPreview : public AActor
{
public:
	EBuildingAttachmentType                       FallbackAttachmentType;                            // 0x0388(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlacementType                                FallbackPlacementType;                             // 0x0389(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38A[0x6];                                      // 0x038A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UMaterialInterface>      PreviewPlacementMaterial;                          // 0x0390(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UCurveFloat>             MotionBounceCurve;                                 // 0x03B0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CanBePlacedMaterialScalarParam;                    // 0x03D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ValidPlacementScalarParam;                         // 0x03D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InvalidPlacementScalarParam;                       // 0x03DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   InverseMovementVectorMaterialParam;                // 0x03E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovementEffectScale;                               // 0x03E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3EC[0x4];                                      // 0x03EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   InverseOuterScaleVectorParam;                      // 0x03F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   InverseInnerScaleVectorParam;                      // 0x03F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   WorldSpacePivotVectorParam;                        // 0x0400(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DiffuseTextureParam;                               // 0x0408(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FreePlacementOffset;                               // 0x0410(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_414[0xC];                                      // 0x0414(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimeline                              BounceTimeline;                                    // 0x0420(0x00E0)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UMaterialInstanceDynamic*>       PreviewMIDs;                                       // 0x0500(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                DirectionChange;                                   // 0x0510(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                WorldSpacePivot;                                   // 0x051C(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortDecoHelper*                        ParentDecoHelper;                                  // 0x0528(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UMaterialInstanceDynamic* CreatePreviewMID(class UMaterialInterface* OverrideParentMaterial);
	class UTexture* GetTextureParameterValueFromMeshComponent(class UMeshComponent* MeshComp, int32 ElementIdx, class FName ParamName);
	void OnBounceMotionUpdate(float VectorScale);
	void OnInitializeDecoPreview(const class ABuildingActor* NewBuildingActor, const class UFortDecoItemDefinition* NewDecoItemDefinition);
	void OnUpdateScale(float Scale, const struct FVector& InWorldSpacePivot);
	void OnUpdateVisuals(float DeltaSeconds, bool bSafeToPlace);
	void SetScalarParameterValueOnAllPreviewMIDs(class FName ParamName, float ParamValue);
	void SetVectorParameterValueOnAllPreviewMIDs(class FName ParamName, const struct FLinearColor& ParamValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDecoPreview">();
	}
	static class AFortDecoPreview* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortDecoPreview>();
	}
};
static_assert(alignof(AFortDecoPreview) == 0x000010, "Wrong alignment on AFortDecoPreview");
static_assert(sizeof(AFortDecoPreview) == 0x000530, "Wrong size on AFortDecoPreview");
static_assert(offsetof(AFortDecoPreview, FallbackAttachmentType) == 0x000388, "Member 'AFortDecoPreview::FallbackAttachmentType' has a wrong offset!");
static_assert(offsetof(AFortDecoPreview, FallbackPlacementType) == 0x000389, "Member 'AFortDecoPreview::FallbackPlacementType' has a wrong offset!");
static_assert(offsetof(AFortDecoPreview, PreviewPlacementMaterial) == 0x000390, "Member 'AFortDecoPreview::PreviewPlacementMaterial' has a wrong offset!");
static_assert(offsetof(AFortDecoPreview, MotionBounceCurve) == 0x0003B0, "Member 'AFortDecoPreview::MotionBounceCurve' has a wrong offset!");
static_assert(offsetof(AFortDecoPreview, CanBePlacedMaterialScalarParam) == 0x0003D0, "Member 'AFortDecoPreview::CanBePlacedMaterialScalarParam' has a wrong offset!");
static_assert(offsetof(AFortDecoPreview, ValidPlacementScalarParam) == 0x0003D8, "Member 'AFortDecoPreview::ValidPlacementScalarParam' has a wrong offset!");
static_assert(offsetof(AFortDecoPreview, InvalidPlacementScalarParam) == 0x0003DC, "Member 'AFortDecoPreview::InvalidPlacementScalarParam' has a wrong offset!");
static_assert(offsetof(AFortDecoPreview, InverseMovementVectorMaterialParam) == 0x0003E0, "Member 'AFortDecoPreview::InverseMovementVectorMaterialParam' has a wrong offset!");
static_assert(offsetof(AFortDecoPreview, MovementEffectScale) == 0x0003E8, "Member 'AFortDecoPreview::MovementEffectScale' has a wrong offset!");
static_assert(offsetof(AFortDecoPreview, InverseOuterScaleVectorParam) == 0x0003F0, "Member 'AFortDecoPreview::InverseOuterScaleVectorParam' has a wrong offset!");
static_assert(offsetof(AFortDecoPreview, InverseInnerScaleVectorParam) == 0x0003F8, "Member 'AFortDecoPreview::InverseInnerScaleVectorParam' has a wrong offset!");
static_assert(offsetof(AFortDecoPreview, WorldSpacePivotVectorParam) == 0x000400, "Member 'AFortDecoPreview::WorldSpacePivotVectorParam' has a wrong offset!");
static_assert(offsetof(AFortDecoPreview, DiffuseTextureParam) == 0x000408, "Member 'AFortDecoPreview::DiffuseTextureParam' has a wrong offset!");
static_assert(offsetof(AFortDecoPreview, FreePlacementOffset) == 0x000410, "Member 'AFortDecoPreview::FreePlacementOffset' has a wrong offset!");
static_assert(offsetof(AFortDecoPreview, BounceTimeline) == 0x000420, "Member 'AFortDecoPreview::BounceTimeline' has a wrong offset!");
static_assert(offsetof(AFortDecoPreview, PreviewMIDs) == 0x000500, "Member 'AFortDecoPreview::PreviewMIDs' has a wrong offset!");
static_assert(offsetof(AFortDecoPreview, DirectionChange) == 0x000510, "Member 'AFortDecoPreview::DirectionChange' has a wrong offset!");
static_assert(offsetof(AFortDecoPreview, WorldSpacePivot) == 0x00051C, "Member 'AFortDecoPreview::WorldSpacePivot' has a wrong offset!");
static_assert(offsetof(AFortDecoPreview, ParentDecoHelper) == 0x000528, "Member 'AFortDecoPreview::ParentDecoHelper' has a wrong offset!");

// Class FortniteGame.FortDecoPreview_GenericBuildingSMActor
// 0x0010 (0x0540 - 0x0530)
#pragma pack(push, 0x1)
class alignas(0x10) AFortDecoPreview_GenericBuildingSMActor : public AFortDecoPreview
{
public:
	class UStaticMeshComponent*                   PrimaryMeshComponent;                              // 0x0530(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDecoPreview_GenericBuildingSMActor">();
	}
	static class AFortDecoPreview_GenericBuildingSMActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortDecoPreview_GenericBuildingSMActor>();
	}
};
#pragma pack(pop)
static_assert(alignof(AFortDecoPreview_GenericBuildingSMActor) == 0x000010, "Wrong alignment on AFortDecoPreview_GenericBuildingSMActor");
static_assert(sizeof(AFortDecoPreview_GenericBuildingSMActor) == 0x000540, "Wrong size on AFortDecoPreview_GenericBuildingSMActor");
static_assert(offsetof(AFortDecoPreview_GenericBuildingSMActor, PrimaryMeshComponent) == 0x000530, "Member 'AFortDecoPreview_GenericBuildingSMActor::PrimaryMeshComponent' has a wrong offset!");

// Class FortniteGame.FortDecoPreview_GenericTrap
// 0x0000 (0x0540 - 0x0540)
class AFortDecoPreview_GenericTrap final : public AFortDecoPreview_GenericBuildingSMActor
{
public:
	class UStaticMeshComponent*                   TrapRangeMeshComponent;                            // 0x0538(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDecoPreview_GenericTrap">();
	}
	static class AFortDecoPreview_GenericTrap* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortDecoPreview_GenericTrap>();
	}
};
static_assert(alignof(AFortDecoPreview_GenericTrap) == 0x000010, "Wrong alignment on AFortDecoPreview_GenericTrap");
static_assert(sizeof(AFortDecoPreview_GenericTrap) == 0x000540, "Wrong size on AFortDecoPreview_GenericTrap");
static_assert(offsetof(AFortDecoPreview_GenericTrap, TrapRangeMeshComponent) == 0x000538, "Member 'AFortDecoPreview_GenericTrap::TrapRangeMeshComponent' has a wrong offset!");

// Class FortniteGame.FortAIDataProvider_Pawn
// 0x0030 (0x0058 - 0x0028)
class UFortAIDataProvider_Pawn final : public UAIDataProvider
{
public:
	float                                         SightRadius;                                       // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HearingRadius;                                     // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewLocationOffsetFromGround;                      // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxStepHeight;                                     // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TetheredBoxCenterLocation;                         // 0x0038(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TetheredBoxWidth;                                  // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TetheredBoxHeight;                                 // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TetheredBoxEQSGridSize;                            // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TetheredBoxEQSSpaceBetween;                        // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIDataProvider_Pawn">();
	}
	static class UFortAIDataProvider_Pawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIDataProvider_Pawn>();
	}
};
static_assert(alignof(UFortAIDataProvider_Pawn) == 0x000008, "Wrong alignment on UFortAIDataProvider_Pawn");
static_assert(sizeof(UFortAIDataProvider_Pawn) == 0x000058, "Wrong size on UFortAIDataProvider_Pawn");
static_assert(offsetof(UFortAIDataProvider_Pawn, SightRadius) == 0x000028, "Member 'UFortAIDataProvider_Pawn::SightRadius' has a wrong offset!");
static_assert(offsetof(UFortAIDataProvider_Pawn, HearingRadius) == 0x00002C, "Member 'UFortAIDataProvider_Pawn::HearingRadius' has a wrong offset!");
static_assert(offsetof(UFortAIDataProvider_Pawn, ViewLocationOffsetFromGround) == 0x000030, "Member 'UFortAIDataProvider_Pawn::ViewLocationOffsetFromGround' has a wrong offset!");
static_assert(offsetof(UFortAIDataProvider_Pawn, MaxStepHeight) == 0x000034, "Member 'UFortAIDataProvider_Pawn::MaxStepHeight' has a wrong offset!");
static_assert(offsetof(UFortAIDataProvider_Pawn, TetheredBoxCenterLocation) == 0x000038, "Member 'UFortAIDataProvider_Pawn::TetheredBoxCenterLocation' has a wrong offset!");
static_assert(offsetof(UFortAIDataProvider_Pawn, TetheredBoxWidth) == 0x000044, "Member 'UFortAIDataProvider_Pawn::TetheredBoxWidth' has a wrong offset!");
static_assert(offsetof(UFortAIDataProvider_Pawn, TetheredBoxHeight) == 0x000048, "Member 'UFortAIDataProvider_Pawn::TetheredBoxHeight' has a wrong offset!");
static_assert(offsetof(UFortAIDataProvider_Pawn, TetheredBoxEQSGridSize) == 0x00004C, "Member 'UFortAIDataProvider_Pawn::TetheredBoxEQSGridSize' has a wrong offset!");
static_assert(offsetof(UFortAIDataProvider_Pawn, TetheredBoxEQSSpaceBetween) == 0x000050, "Member 'UFortAIDataProvider_Pawn::TetheredBoxEQSSpaceBetween' has a wrong offset!");

// Class FortniteGame.FortUserCloudHelperComponent
// 0x0080 (0x0170 - 0x00F0)
class UFortUserCloudHelperComponent final : public UActorComponent
{
public:
	uint64                                        LastIssuedRequestHandle;                           // 0x00F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F8[0x78];                                      // 0x00F8(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortUserCloudHelperComponent">();
	}
	static class UFortUserCloudHelperComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortUserCloudHelperComponent>();
	}
};
static_assert(alignof(UFortUserCloudHelperComponent) == 0x000008, "Wrong alignment on UFortUserCloudHelperComponent");
static_assert(sizeof(UFortUserCloudHelperComponent) == 0x000170, "Wrong size on UFortUserCloudHelperComponent");
static_assert(offsetof(UFortUserCloudHelperComponent, LastIssuedRequestHandle) == 0x0000F0, "Member 'UFortUserCloudHelperComponent::LastIssuedRequestHandle' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionEncounter_UtilitiesFree
// 0x0008 (0x0050 - 0x0048)
class UFortDifficultyOptionEncounter_UtilitiesFree final : public UFortDifficultyOptionEncounter
{
public:
	int32                                         NumFreeUtilitySlots;                               // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionEncounter_UtilitiesFree">();
	}
	static class UFortDifficultyOptionEncounter_UtilitiesFree* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionEncounter_UtilitiesFree>();
	}
};
static_assert(alignof(UFortDifficultyOptionEncounter_UtilitiesFree) == 0x000008, "Wrong alignment on UFortDifficultyOptionEncounter_UtilitiesFree");
static_assert(sizeof(UFortDifficultyOptionEncounter_UtilitiesFree) == 0x000050, "Wrong size on UFortDifficultyOptionEncounter_UtilitiesFree");
static_assert(offsetof(UFortDifficultyOptionEncounter_UtilitiesFree, NumFreeUtilitySlots) == 0x000048, "Member 'UFortDifficultyOptionEncounter_UtilitiesFree::NumFreeUtilitySlots' has a wrong offset!");

// Class FortniteGame.FortAIDirector
// 0x08B8 (0x0C40 - 0x0388)
class AFortAIDirector final : public AActor
{
public:
	uint8                                         Pad_388[0x10];                                     // 0x0388(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCurveTableRowHandle                   MaxAliveCurve;                                     // 0x0398(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FCurveTableRowHandle                   MinAliveCurve;                                     // 0x03A8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FIntensityData                         IntensityInfo;                                     // 0x03B8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FFortAIEncounterPIDController          AIDirectorPIDController;                           // 0x03E8(0x0068)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FFortAIEncounterPIDControllerSettings  PIDControllerSettings;                             // 0x0450(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FUtilityData                           UtilityContributionData[0x10];                     // 0x0480(0x0040)(Edit, NativeAccessSpecifierPublic)
	float                                         UnreachableLocationPathCost;                       // 0x0880(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_884[0x4];                                      // 0x0884(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortPlayerPerformanceEstimateSettings PlayerPerformanceEstimateSettings;                 // 0x0888(0x0040)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bUsePrototypeEnemies : 1;                          // 0x08C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_8C9[0x7];                                      // 0x08C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EFortEncounterDirection>               DebugEncounterDirections;                          // 0x08D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  DebugSpawnAIGroupTags;                             // 0x08E0(0x0020)(Transient, NativeAccessSpecifierPublic)
	float                                         BurstSpawnThreatVisualsEndDelay;                   // 0x0900(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_904[0x4];                                      // 0x0904(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFortAIEncounterSpawnGroupCapsProfile> EncounterSpawnGroupCapSettings;                    // 0x0908(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortAIEncounterSpawnPointsProfile> EncounterSpawnPointsSettings;                      // 0x0918(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortAIEncounterPawnDifficultyLevelModifier> EncounterPawnDifficultyLevelModifiers;             // 0x0928(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortAISpawnGroupUpgrade>       SpawnGroupUpgrades;                                // 0x0938(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         DiscreteEncounterUtilityDesireMappings[0x4];       // 0x0948(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortAIUtility                                InitialDynamicUtilities[0x4];                      // 0x0958(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_95C[0x4];                                      // 0x095C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEncounterEnvironmentQueryInfo         SpawnLocationPlacementQueries[0x4];                // 0x0960(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UFortAIDirectorDataTrackingSettings*    DataTrackingSettings;                              // 0x0A00(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bDebugEncounterQueries : 1;                        // 0x0A08(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_A09[0x7];                                      // 0x0A09(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortEncounterPawnNumberCaps           DefaultEncounterPawnCaps;                          // 0x0A10(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A28[0x8];                                      // 0x0A28(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UReporterGraph*                         IntensityGraph;                                    // 0x0A30(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReporterGraph*                         UtilitiesGraph;                                    // 0x0A38(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReporterGraph*                         PIDValuesGraph;                                    // 0x0A40(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReporterGraph*                         PIDContributionsGraph;                             // 0x0A48(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bNightActive : 1;                                  // 0x0A50(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAIDisabled : 1;                                   // 0x0A50(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRegisteredForDayPhaseChange : 1;                  // 0x0A50(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseSpawnCap : 1;                                  // 0x0A50(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A51[0x3];                                      // 0x0A51(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NightCount;                                        // 0x0A54(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ABuildingRift*>                  RiftSpawnPoints;                                   // 0x0A58(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         NightEncounterFailureBreatherTime;                 // 0x0A68(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EncounterPawnSpawnInterval;                        // 0x0A6C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UFortAIEncounterInfo>       DefaultNightEncounter;                             // 0x0A70(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UFortAIEncounterInfo>       DummyDebugEncounter;                               // 0x0A78(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UFortAIEncounterInfo>       BaseEncounterClass;                                // 0x0A80(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxActiveAlive;                                    // 0x0A88(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumActiveAlive;                                    // 0x0A8C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumPendingCapRelevantAI;                           // 0x0A90(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A94[0x54];                                     // 0x0A94(0x0054)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPendingSpawnInfo>              PendingSpawns;                                     // 0x0AE8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class AFortAIPawn>>     PendingDespawns;                                   // 0x0AF8(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	int32                                         NumWorldSubdivides;                                // 0x0B08(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinAISpawnDistanceFromPlayers;                     // 0x0B0C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AmbientThreatPreferredPlacementActorTags;          // 0x0B10(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  AmbientThreatRequiredPlacementActorTags;           // 0x0B30(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TArray<class UFortAIEncounterInfo*>           ActiveEncounters;                                  // 0x0B50(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UFortAIEncounterInfo*                   ActiveDefaultEncounter;                            // 0x0B60(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortAIEncounterInfo*                   ActiveDummyDebugEncounter;                         // 0x0B68(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UFortAIEncounterSequence*>       EncounterSequences;                                // 0x0B70(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UEQSRenderingComponent*                 EQSRenderingComp;                                  // 0x0B80(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         DebugGraphUpdateFrequency;                         // 0x0B88(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxNormalLODDistanceToPlayer;                      // 0x0B8C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AIRelevantDistanceToPlayer;                        // 0x0B90(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EncounterRelevantDistanceToPlayer;                 // 0x0B94(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EncounterRelevantDistanceToDefender;               // 0x0B98(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9C[0x54];                                     // 0x0B9C(0x0054)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TScriptInterface<class IFortPatrolWardInterface>> PatrolWards;                                       // 0x0BF0(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C00[0x4];                                      // 0x0C00(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxTotalActiveAliveAI;                             // 0x0C04(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxEncounterActiveAliveAI;                         // 0x0C08(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSPUsed;                                         // 0x0C0C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C10[0x8];                                      // 0x0C10(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUtilityTypeFloatPair>          DebugEncounterTopUtilityPercentages;               // 0x0C18(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UCurveFloat*>                    DebugEncounterSpawnPointsCurves;                   // 0x0C28(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bDebugAllowEncounterModifierTags : 1;              // 0x0C38(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_C39[0x3];                                      // 0x0C39(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SimulatedNumberOfPlayersForAIEncounters;           // 0x0C3C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static TArray<EFortEncounterDirection> ConvertInvalidDirectionsToValidDirections(const TArray<EFortEncounterDirection>& InvalidDirections);
	static EFortEncounterDirection GetEncounterDirectionFromVector(const struct FVector& DirectionVector);
	static struct FVector GetVectorFromEncounterDirection(EFortEncounterDirection Direction);

	void Activate();
	void Deactivate();
	int32 GetNumPlayers();
	void OnDayPhaseChanged(EFortDayPhase CurrentDayPhase, EFortDayPhase PreviousDayPhase, bool bAtCreation);
	void OnDirectorDeactivated();
	void OnFadeStarted();
	void OnPawnDied(class AFortAIPawn* KilledPawn);
	void OnPeakStarted();
	void OnPlayerDied(class AFortPlayerPawn* PlayerPawn);
	void OnPlayerSpawn(class AFortPlayerPawn* PlayerPawn);
	void OnRampStarted();
	void OnRestStarted();
	void PostDayPhaseChanged(EFortDayPhase CurrentDayPhase, EFortDayPhase PreviousDayPhase, bool bAtCreation);
	void ReceivePawnSpawned(class AFortPawn* SpawnedPawn);
	void RegisterPatrolWard(TScriptInterface<class IFortPatrolWardInterface> PatrolWard);
	void UnregisterPatrolWard(TScriptInterface<class IFortPatrolWardInterface> PatrolWard);

	void GetAmbientThreatEncounterSpawnLocations(TArray<struct FVector>* AmbientThreatEncounterSpawnLocations) const;
	TArray<class ABuildingRift*> GetRiftsFromClosestActiveEncounterTo(class AActor* Target) const;
	bool IsAnyActiveEncounterRelevantToDefender(class AFortAIPawn* Defender) const;
	bool IsAnyActiveEncounterRelevantToPlayer(class AFortPlayerPawn* Player) const;
	bool IsAnyAIRelevantToPlayer(class AFortPlayerPawn* Player) const;
	bool IsAnyEncounterGoalWithinDistanceOfPoint(const struct FVector& Point, float Distance, bool bOnlyActiveEncounters) const;
	bool IsLineTooCloseToPatrolWards(const struct FVector& LineStart, const struct FVector& LineEnd) const;
	bool IsPointTooCloseToPatrolWards(const struct FVector& Point, const EWardAffectType WardEffectTypeFilter) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIDirector">();
	}
	static class AFortAIDirector* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAIDirector>();
	}
};
static_assert(alignof(AFortAIDirector) == 0x000008, "Wrong alignment on AFortAIDirector");
static_assert(sizeof(AFortAIDirector) == 0x000C40, "Wrong size on AFortAIDirector");
static_assert(offsetof(AFortAIDirector, MaxAliveCurve) == 0x000398, "Member 'AFortAIDirector::MaxAliveCurve' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, MinAliveCurve) == 0x0003A8, "Member 'AFortAIDirector::MinAliveCurve' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, IntensityInfo) == 0x0003B8, "Member 'AFortAIDirector::IntensityInfo' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, AIDirectorPIDController) == 0x0003E8, "Member 'AFortAIDirector::AIDirectorPIDController' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, PIDControllerSettings) == 0x000450, "Member 'AFortAIDirector::PIDControllerSettings' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, UtilityContributionData) == 0x000480, "Member 'AFortAIDirector::UtilityContributionData' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, UnreachableLocationPathCost) == 0x000880, "Member 'AFortAIDirector::UnreachableLocationPathCost' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, PlayerPerformanceEstimateSettings) == 0x000888, "Member 'AFortAIDirector::PlayerPerformanceEstimateSettings' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, DebugEncounterDirections) == 0x0008D0, "Member 'AFortAIDirector::DebugEncounterDirections' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, DebugSpawnAIGroupTags) == 0x0008E0, "Member 'AFortAIDirector::DebugSpawnAIGroupTags' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, BurstSpawnThreatVisualsEndDelay) == 0x000900, "Member 'AFortAIDirector::BurstSpawnThreatVisualsEndDelay' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, EncounterSpawnGroupCapSettings) == 0x000908, "Member 'AFortAIDirector::EncounterSpawnGroupCapSettings' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, EncounterSpawnPointsSettings) == 0x000918, "Member 'AFortAIDirector::EncounterSpawnPointsSettings' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, EncounterPawnDifficultyLevelModifiers) == 0x000928, "Member 'AFortAIDirector::EncounterPawnDifficultyLevelModifiers' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, SpawnGroupUpgrades) == 0x000938, "Member 'AFortAIDirector::SpawnGroupUpgrades' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, DiscreteEncounterUtilityDesireMappings) == 0x000948, "Member 'AFortAIDirector::DiscreteEncounterUtilityDesireMappings' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, InitialDynamicUtilities) == 0x000958, "Member 'AFortAIDirector::InitialDynamicUtilities' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, SpawnLocationPlacementQueries) == 0x000960, "Member 'AFortAIDirector::SpawnLocationPlacementQueries' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, DataTrackingSettings) == 0x000A00, "Member 'AFortAIDirector::DataTrackingSettings' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, DefaultEncounterPawnCaps) == 0x000A10, "Member 'AFortAIDirector::DefaultEncounterPawnCaps' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, IntensityGraph) == 0x000A30, "Member 'AFortAIDirector::IntensityGraph' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, UtilitiesGraph) == 0x000A38, "Member 'AFortAIDirector::UtilitiesGraph' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, PIDValuesGraph) == 0x000A40, "Member 'AFortAIDirector::PIDValuesGraph' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, PIDContributionsGraph) == 0x000A48, "Member 'AFortAIDirector::PIDContributionsGraph' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, NightCount) == 0x000A54, "Member 'AFortAIDirector::NightCount' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, RiftSpawnPoints) == 0x000A58, "Member 'AFortAIDirector::RiftSpawnPoints' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, NightEncounterFailureBreatherTime) == 0x000A68, "Member 'AFortAIDirector::NightEncounterFailureBreatherTime' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, EncounterPawnSpawnInterval) == 0x000A6C, "Member 'AFortAIDirector::EncounterPawnSpawnInterval' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, DefaultNightEncounter) == 0x000A70, "Member 'AFortAIDirector::DefaultNightEncounter' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, DummyDebugEncounter) == 0x000A78, "Member 'AFortAIDirector::DummyDebugEncounter' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, BaseEncounterClass) == 0x000A80, "Member 'AFortAIDirector::BaseEncounterClass' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, MaxActiveAlive) == 0x000A88, "Member 'AFortAIDirector::MaxActiveAlive' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, NumActiveAlive) == 0x000A8C, "Member 'AFortAIDirector::NumActiveAlive' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, NumPendingCapRelevantAI) == 0x000A90, "Member 'AFortAIDirector::NumPendingCapRelevantAI' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, PendingSpawns) == 0x000AE8, "Member 'AFortAIDirector::PendingSpawns' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, PendingDespawns) == 0x000AF8, "Member 'AFortAIDirector::PendingDespawns' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, NumWorldSubdivides) == 0x000B08, "Member 'AFortAIDirector::NumWorldSubdivides' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, MinAISpawnDistanceFromPlayers) == 0x000B0C, "Member 'AFortAIDirector::MinAISpawnDistanceFromPlayers' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, AmbientThreatPreferredPlacementActorTags) == 0x000B10, "Member 'AFortAIDirector::AmbientThreatPreferredPlacementActorTags' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, AmbientThreatRequiredPlacementActorTags) == 0x000B30, "Member 'AFortAIDirector::AmbientThreatRequiredPlacementActorTags' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, ActiveEncounters) == 0x000B50, "Member 'AFortAIDirector::ActiveEncounters' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, ActiveDefaultEncounter) == 0x000B60, "Member 'AFortAIDirector::ActiveDefaultEncounter' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, ActiveDummyDebugEncounter) == 0x000B68, "Member 'AFortAIDirector::ActiveDummyDebugEncounter' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, EncounterSequences) == 0x000B70, "Member 'AFortAIDirector::EncounterSequences' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, EQSRenderingComp) == 0x000B80, "Member 'AFortAIDirector::EQSRenderingComp' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, DebugGraphUpdateFrequency) == 0x000B88, "Member 'AFortAIDirector::DebugGraphUpdateFrequency' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, MaxNormalLODDistanceToPlayer) == 0x000B8C, "Member 'AFortAIDirector::MaxNormalLODDistanceToPlayer' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, AIRelevantDistanceToPlayer) == 0x000B90, "Member 'AFortAIDirector::AIRelevantDistanceToPlayer' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, EncounterRelevantDistanceToPlayer) == 0x000B94, "Member 'AFortAIDirector::EncounterRelevantDistanceToPlayer' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, EncounterRelevantDistanceToDefender) == 0x000B98, "Member 'AFortAIDirector::EncounterRelevantDistanceToDefender' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, PatrolWards) == 0x000BF0, "Member 'AFortAIDirector::PatrolWards' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, MaxTotalActiveAliveAI) == 0x000C04, "Member 'AFortAIDirector::MaxTotalActiveAliveAI' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, MaxEncounterActiveAliveAI) == 0x000C08, "Member 'AFortAIDirector::MaxEncounterActiveAliveAI' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, MaxSPUsed) == 0x000C0C, "Member 'AFortAIDirector::MaxSPUsed' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, DebugEncounterTopUtilityPercentages) == 0x000C18, "Member 'AFortAIDirector::DebugEncounterTopUtilityPercentages' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, DebugEncounterSpawnPointsCurves) == 0x000C28, "Member 'AFortAIDirector::DebugEncounterSpawnPointsCurves' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, SimulatedNumberOfPlayersForAIEncounters) == 0x000C3C, "Member 'AFortAIDirector::SimulatedNumberOfPlayersForAIEncounters' has a wrong offset!");

// Class FortniteGame.FortMissionWeightedRewards
// 0x0010 (0x0038 - 0x0028)
class UFortMissionWeightedRewards final : public UDataAsset
{
public:
	TArray<struct FFortMissionWeightedReward>     Rewards;                                           // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMissionWeightedRewards">();
	}
	static class UFortMissionWeightedRewards* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMissionWeightedRewards>();
	}
};
static_assert(alignof(UFortMissionWeightedRewards) == 0x000008, "Wrong alignment on UFortMissionWeightedRewards");
static_assert(sizeof(UFortMissionWeightedRewards) == 0x000038, "Wrong size on UFortMissionWeightedRewards");
static_assert(offsetof(UFortMissionWeightedRewards, Rewards) == 0x000028, "Member 'UFortMissionWeightedRewards::Rewards' has a wrong offset!");

// Class FortniteGame.FortAIDirectorDataTrackingSettings
// 0x0010 (0x0038 - 0x0028)
class UFortAIDirectorDataTrackingSettings final : public UDataAsset
{
public:
	TSubclassOf<class AFortAIDirectorDataManager> PlayerDataManager;                                 // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AFortAIDirectorDataManager> EncounterDataManager;                              // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIDirectorDataTrackingSettings">();
	}
	static class UFortAIDirectorDataTrackingSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIDirectorDataTrackingSettings>();
	}
};
static_assert(alignof(UFortAIDirectorDataTrackingSettings) == 0x000008, "Wrong alignment on UFortAIDirectorDataTrackingSettings");
static_assert(sizeof(UFortAIDirectorDataTrackingSettings) == 0x000038, "Wrong size on UFortAIDirectorDataTrackingSettings");
static_assert(offsetof(UFortAIDirectorDataTrackingSettings, PlayerDataManager) == 0x000028, "Member 'UFortAIDirectorDataTrackingSettings::PlayerDataManager' has a wrong offset!");
static_assert(offsetof(UFortAIDirectorDataTrackingSettings, EncounterDataManager) == 0x000030, "Member 'UFortAIDirectorDataTrackingSettings::EncounterDataManager' has a wrong offset!");

// Class FortniteGame.FortAIEncounterGoalSelectionTable
// 0x0010 (0x0038 - 0x0028)
class UFortAIEncounterGoalSelectionTable final : public UDataAsset
{
public:
	TArray<struct FEncounterGoalSelectionTableEntry> EncounterGoalSelectionCriteria;                    // 0x0028(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIEncounterGoalSelectionTable">();
	}
	static class UFortAIEncounterGoalSelectionTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIEncounterGoalSelectionTable>();
	}
};
static_assert(alignof(UFortAIEncounterGoalSelectionTable) == 0x000008, "Wrong alignment on UFortAIEncounterGoalSelectionTable");
static_assert(sizeof(UFortAIEncounterGoalSelectionTable) == 0x000038, "Wrong size on UFortAIEncounterGoalSelectionTable");
static_assert(offsetof(UFortAIEncounterGoalSelectionTable, EncounterGoalSelectionCriteria) == 0x000028, "Member 'UFortAIEncounterGoalSelectionTable::EncounterGoalSelectionCriteria' has a wrong offset!");

// Class FortniteGame.FortObjectiveBase
// 0x0098 (0x0450 - 0x03B8)
class AFortObjectiveBase : public AFortMissionState
{
public:
	class UFortBadgeItemDefinition*               ObjectiveRewardBadge;                              // 0x03B8(0x0008)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UFortWorldItemDefinition*>       ItemsToGiveOnObjectiveStart;                       // 0x03C0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bStartPlayingOnMissionStart;                       // 0x03D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAcceptsMissionEventsWhenFinished;                 // 0x03D1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D2[0x6];                                      // 0x03D2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  ObjectiveHandle;                                   // 0x03D8(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, SaveGame, NativeAccessSpecifierPublic)
	class FString                                 ObjectiveAnalyticsName;                            // 0x03F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortObjectiveRequirement                     MissionRequirement;                                // 0x0408(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_409[0x1];                                      // 0x0409(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsObjectiveVisible;                               // 0x040A(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, SaveGame, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortMissionVisibilityOverride                VisibilityOverride;                                // 0x040B(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, SaveGame, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsProgressBarHidden;                              // 0x040C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortMissionAudibility                        ObjectiveAudiblity;                                // 0x040D(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRelevantToSpecificTeam;                           // 0x040E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortTeam                                     RelevantTeam;                                      // 0x040F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortObjectiveStatus                          ObjectiveStatus;                                   // 0x0410(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, SaveGame, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_411[0x7];                                      // 0x0411(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortMissionTimerComponent*             TimerComponent;                                    // 0x0418(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnObjectiveStatusChanged;                          // 0x0420(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnObjectiveVisibilityChanged;                      // 0x0430(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnObjectiveVisibilityOverrideChanged;              // 0x0440(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void AttemptMissionSave(const class FString& OptionalSaveName);
	void BlueprintOnActivated();
	void BlueprintOnObjectiveEnd(EFortObjectiveStatus Status);
	void BlueprintOnStartPlaying();
	void BlueprintPostObjectiveLoad();
	void ClearObjectiveTimer();
	void DrawAttentionToUI();
	void EnableTick(bool bEnabled);
	void GetRewardItemsByTag(const struct FGameplayTag& RewardTag, TArray<class UFortWorldItemDefinition*>* OutRewardItems);
	void GrantRewardsByTag(const struct FGameplayTag& RewardTag, EFortRewardType RewardType);
	void OnGenericObjectiveEvent();
	void OnRep_bIsObjectiveVisible();
	void OnRep_ObjectiveStatus();
	void OnRep_ObjectiveVisibilityOverride();
	void PauseObjectiveTimer();
	void SetObjectiveTimer(const class FString& FunctionName, float TimerLength, bool bStartPaused);
	void SetUiVisibility(bool bInIsObjectiveVisible);
	void SetUIVisibilityOverride(EFortMissionVisibilityOverride InVisibilityOverride);
	bool StartPlayingObjective();
	void StopObjective(EFortObjectiveStatus Status, const class FString& Description, class UFortBadgeItemDefinition* ExtraBadgeToGrant);
	void UnpauseObjectiveTimer();

	int32 BlueprintGetNumProgressBars() const;
	class FText BlueprintGetObjectiveDisplayText() const;
	struct FLinearColor BlueprintGetProgressBarColor(int32 ProgressBarIdx) const;
	float BlueprintGetProgressBarPercentage(int32 ProgressBarIdx) const;
	class FText BlueprintGetProgressBarText(int32 ProgressBarIdx) const;
	class AFortMission* GetMission() const;
	struct FGuid GetMissionGuid() const;
	class FText GetObjectiveDisplayString() const;
	float GetObjectiveTimerTimeRemaining() const;
	class UFortMissionTimerComponent* GetTimerComponent() const;
	bool IsObjectiveTimerPaused() const;
	bool IsRelevantToASpecificTeam() const;
	bool IsRelevantToTeam(EFortTeam Team) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortObjectiveBase">();
	}
	static class AFortObjectiveBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortObjectiveBase>();
	}
};
static_assert(alignof(AFortObjectiveBase) == 0x000008, "Wrong alignment on AFortObjectiveBase");
static_assert(sizeof(AFortObjectiveBase) == 0x000450, "Wrong size on AFortObjectiveBase");
static_assert(offsetof(AFortObjectiveBase, ObjectiveRewardBadge) == 0x0003B8, "Member 'AFortObjectiveBase::ObjectiveRewardBadge' has a wrong offset!");
static_assert(offsetof(AFortObjectiveBase, ItemsToGiveOnObjectiveStart) == 0x0003C0, "Member 'AFortObjectiveBase::ItemsToGiveOnObjectiveStart' has a wrong offset!");
static_assert(offsetof(AFortObjectiveBase, bStartPlayingOnMissionStart) == 0x0003D0, "Member 'AFortObjectiveBase::bStartPlayingOnMissionStart' has a wrong offset!");
static_assert(offsetof(AFortObjectiveBase, bAcceptsMissionEventsWhenFinished) == 0x0003D1, "Member 'AFortObjectiveBase::bAcceptsMissionEventsWhenFinished' has a wrong offset!");
static_assert(offsetof(AFortObjectiveBase, ObjectiveHandle) == 0x0003D8, "Member 'AFortObjectiveBase::ObjectiveHandle' has a wrong offset!");
static_assert(offsetof(AFortObjectiveBase, ObjectiveAnalyticsName) == 0x0003F8, "Member 'AFortObjectiveBase::ObjectiveAnalyticsName' has a wrong offset!");
static_assert(offsetof(AFortObjectiveBase, MissionRequirement) == 0x000408, "Member 'AFortObjectiveBase::MissionRequirement' has a wrong offset!");
static_assert(offsetof(AFortObjectiveBase, bIsObjectiveVisible) == 0x00040A, "Member 'AFortObjectiveBase::bIsObjectiveVisible' has a wrong offset!");
static_assert(offsetof(AFortObjectiveBase, VisibilityOverride) == 0x00040B, "Member 'AFortObjectiveBase::VisibilityOverride' has a wrong offset!");
static_assert(offsetof(AFortObjectiveBase, bIsProgressBarHidden) == 0x00040C, "Member 'AFortObjectiveBase::bIsProgressBarHidden' has a wrong offset!");
static_assert(offsetof(AFortObjectiveBase, ObjectiveAudiblity) == 0x00040D, "Member 'AFortObjectiveBase::ObjectiveAudiblity' has a wrong offset!");
static_assert(offsetof(AFortObjectiveBase, bRelevantToSpecificTeam) == 0x00040E, "Member 'AFortObjectiveBase::bRelevantToSpecificTeam' has a wrong offset!");
static_assert(offsetof(AFortObjectiveBase, RelevantTeam) == 0x00040F, "Member 'AFortObjectiveBase::RelevantTeam' has a wrong offset!");
static_assert(offsetof(AFortObjectiveBase, ObjectiveStatus) == 0x000410, "Member 'AFortObjectiveBase::ObjectiveStatus' has a wrong offset!");
static_assert(offsetof(AFortObjectiveBase, TimerComponent) == 0x000418, "Member 'AFortObjectiveBase::TimerComponent' has a wrong offset!");
static_assert(offsetof(AFortObjectiveBase, OnObjectiveStatusChanged) == 0x000420, "Member 'AFortObjectiveBase::OnObjectiveStatusChanged' has a wrong offset!");
static_assert(offsetof(AFortObjectiveBase, OnObjectiveVisibilityChanged) == 0x000430, "Member 'AFortObjectiveBase::OnObjectiveVisibilityChanged' has a wrong offset!");
static_assert(offsetof(AFortObjectiveBase, OnObjectiveVisibilityOverrideChanged) == 0x000440, "Member 'AFortObjectiveBase::OnObjectiveVisibilityOverrideChanged' has a wrong offset!");

// Class FortniteGame.GameplayMutatorObserverInterface
// 0x0000 (0x0028 - 0x0028)
class IGameplayMutatorObserverInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayMutatorObserverInterface">();
	}
	static class IGameplayMutatorObserverInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGameplayMutatorObserverInterface>();
	}
};
static_assert(alignof(IGameplayMutatorObserverInterface) == 0x000008, "Wrong alignment on IGameplayMutatorObserverInterface");
static_assert(sizeof(IGameplayMutatorObserverInterface) == 0x000028, "Wrong size on IGameplayMutatorObserverInterface");

// Class FortniteGame.FortAIPawnVariant
// 0x0048 (0x0070 - 0x0028)
class UFortAIPawnVariant final : public UObject
{
public:
	TArray<TSubclassOf<class AFortAIPawn>>        PawnClasses;                                       // 0x0028(0x0010)(ZeroConstructor, Deprecated, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FFortAIPawnVariantDefinition>   PawnVariantDefinitions;                            // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         MinPlayersToSpawnVariant;                          // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    SpawnPointValueHandle;                             // 0x0050(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	int32                                         CachedSpawnPointValue;                             // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EncounterExpectedLifespan;                         // 0x0064(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         VersionNum;                                        // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIPawnVariant">();
	}
	static class UFortAIPawnVariant* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIPawnVariant>();
	}
};
static_assert(alignof(UFortAIPawnVariant) == 0x000008, "Wrong alignment on UFortAIPawnVariant");
static_assert(sizeof(UFortAIPawnVariant) == 0x000070, "Wrong size on UFortAIPawnVariant");
static_assert(offsetof(UFortAIPawnVariant, PawnClasses) == 0x000028, "Member 'UFortAIPawnVariant::PawnClasses' has a wrong offset!");
static_assert(offsetof(UFortAIPawnVariant, PawnVariantDefinitions) == 0x000038, "Member 'UFortAIPawnVariant::PawnVariantDefinitions' has a wrong offset!");
static_assert(offsetof(UFortAIPawnVariant, MinPlayersToSpawnVariant) == 0x000048, "Member 'UFortAIPawnVariant::MinPlayersToSpawnVariant' has a wrong offset!");
static_assert(offsetof(UFortAIPawnVariant, SpawnPointValueHandle) == 0x000050, "Member 'UFortAIPawnVariant::SpawnPointValueHandle' has a wrong offset!");
static_assert(offsetof(UFortAIPawnVariant, CachedSpawnPointValue) == 0x000060, "Member 'UFortAIPawnVariant::CachedSpawnPointValue' has a wrong offset!");
static_assert(offsetof(UFortAIPawnVariant, EncounterExpectedLifespan) == 0x000064, "Member 'UFortAIPawnVariant::EncounterExpectedLifespan' has a wrong offset!");
static_assert(offsetof(UFortAIPawnVariant, VersionNum) == 0x000068, "Member 'UFortAIPawnVariant::VersionNum' has a wrong offset!");

// Class FortniteGame.FortThreatParticleActor
// 0x0008 (0x0390 - 0x0388)
class AFortThreatParticleActor : public AActor
{
public:
	uint8                                         Pad_388[0x8];                                      // 0x0388(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnThreatCloudsChanged(const TArray<struct FThreatLocationInfo>& ThreatLocationInfo);
	void OnWorldReady();

	TArray<struct FThreatLocationInfo> GetThreatClouds() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortThreatParticleActor">();
	}
	static class AFortThreatParticleActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortThreatParticleActor>();
	}
};
static_assert(alignof(AFortThreatParticleActor) == 0x000008, "Wrong alignment on AFortThreatParticleActor");
static_assert(sizeof(AFortThreatParticleActor) == 0x000390, "Wrong size on AFortThreatParticleActor");

// Class FortniteGame.FortAISpawnGroup
// 0x0098 (0x00C0 - 0x0028)
class UFortAISpawnGroup final : public UPrimaryDataAsset
{
public:
	float                                         EnemyUtilities[0x10];                              // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSpawnGroupEnemy>               EnemiesToSpawn;                                    // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsPrototype;                                      // 0x0078(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsValidForEnemySpawners;                          // 0x0079(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsLargeSpawnGroup;                                // 0x007A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7B[0x1];                                       // 0x007B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDiscountRatio;                                  // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   MaxGroupCategoryPopulationDensityCurve;            // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortSpawnGroupEncounterTypeData> EncounterTypeData;                                 // 0x0090(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  SpawnGroupGameplayTags;                            // 0x00A0(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	TSubclassOf<class UFortAIPawnVariant> GetEnemy(int32 EnemyIndex) const;
	int32 GetNumberOfEnemies() const;
	bool IsLargeSpawnGroup() const;
	bool IsPrototype() const;
	bool IsValidForEnemySpawners() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAISpawnGroup">();
	}
	static class UFortAISpawnGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAISpawnGroup>();
	}
};
static_assert(alignof(UFortAISpawnGroup) == 0x000008, "Wrong alignment on UFortAISpawnGroup");
static_assert(sizeof(UFortAISpawnGroup) == 0x0000C0, "Wrong size on UFortAISpawnGroup");
static_assert(offsetof(UFortAISpawnGroup, EnemyUtilities) == 0x000028, "Member 'UFortAISpawnGroup::EnemyUtilities' has a wrong offset!");
static_assert(offsetof(UFortAISpawnGroup, EnemiesToSpawn) == 0x000068, "Member 'UFortAISpawnGroup::EnemiesToSpawn' has a wrong offset!");
static_assert(offsetof(UFortAISpawnGroup, bIsPrototype) == 0x000078, "Member 'UFortAISpawnGroup::bIsPrototype' has a wrong offset!");
static_assert(offsetof(UFortAISpawnGroup, bIsValidForEnemySpawners) == 0x000079, "Member 'UFortAISpawnGroup::bIsValidForEnemySpawners' has a wrong offset!");
static_assert(offsetof(UFortAISpawnGroup, bIsLargeSpawnGroup) == 0x00007A, "Member 'UFortAISpawnGroup::bIsLargeSpawnGroup' has a wrong offset!");
static_assert(offsetof(UFortAISpawnGroup, MaxDiscountRatio) == 0x00007C, "Member 'UFortAISpawnGroup::MaxDiscountRatio' has a wrong offset!");
static_assert(offsetof(UFortAISpawnGroup, MaxGroupCategoryPopulationDensityCurve) == 0x000080, "Member 'UFortAISpawnGroup::MaxGroupCategoryPopulationDensityCurve' has a wrong offset!");
static_assert(offsetof(UFortAISpawnGroup, EncounterTypeData) == 0x000090, "Member 'UFortAISpawnGroup::EncounterTypeData' has a wrong offset!");
static_assert(offsetof(UFortAISpawnGroup, SpawnGroupGameplayTags) == 0x0000A0, "Member 'UFortAISpawnGroup::SpawnGroupGameplayTags' has a wrong offset!");

// Class FortniteGame.FortAIEncounterRiftManager
// 0x01E0 (0x0208 - 0x0028)
class UFortAIEncounterRiftManager final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAIEncounterInfo*                   MyEncounter;                                       // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AFortAIDirector*                        AIDirector;                                        // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFortAIEncounterSpawnArea              CurrentSpawnArea;                                  // 0x0048(0x0048)(NativeAccessSpecifierPublic)
	struct FFortAIEncounterSpawnArea              FutureSpawnArea;                                   // 0x0090(0x0048)(NativeAccessSpecifierPublic)
	float                                         UpdateIntervalTimeSeconds;                         // 0x00D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumRiftsToUse;                                     // 0x00DC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinRiftsToUse;                                     // 0x00E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortEncounterSettings                 EncounterSettings;                                 // 0x00E8(0x0058)(NativeAccessSpecifierPublic)
	float                                         ExtraSpawnLocationPercentage;                      // 0x0140(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_144[0x4];                                      // 0x0144(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEncounterEnvironmentQueryInfo         CurrentEnvironmentQueryInfo;                       // 0x0148(0x0028)(NativeAccessSpecifierPublic)
	struct FEncounterEnvironmentQueryInfo         FallbackEnvironmentQueryInfo;                      // 0x0170(0x0028)(NativeAccessSpecifierPublic)
	struct FFortAIEncounterQueryDirectionTracker  EncounterQueryDirectionTracker;                    // 0x0198(0x0048)(NativeAccessSpecifierPublic)
	TSubclassOf<class ABuildingRift>              RiftClassTemplate;                                 // 0x01E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastObjectiveBatchPathCostUpdateTime;              // 0x01E8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastPlayerBatchPathCostUpdateTime;                 // 0x01EC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F0[0x18];                                     // 0x01F0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AFortMission* GetAssociatedMission() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIEncounterRiftManager">();
	}
	static class UFortAIEncounterRiftManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIEncounterRiftManager>();
	}
};
static_assert(alignof(UFortAIEncounterRiftManager) == 0x000008, "Wrong alignment on UFortAIEncounterRiftManager");
static_assert(sizeof(UFortAIEncounterRiftManager) == 0x000208, "Wrong size on UFortAIEncounterRiftManager");
static_assert(offsetof(UFortAIEncounterRiftManager, MyEncounter) == 0x000038, "Member 'UFortAIEncounterRiftManager::MyEncounter' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterRiftManager, AIDirector) == 0x000040, "Member 'UFortAIEncounterRiftManager::AIDirector' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterRiftManager, CurrentSpawnArea) == 0x000048, "Member 'UFortAIEncounterRiftManager::CurrentSpawnArea' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterRiftManager, FutureSpawnArea) == 0x000090, "Member 'UFortAIEncounterRiftManager::FutureSpawnArea' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterRiftManager, UpdateIntervalTimeSeconds) == 0x0000D8, "Member 'UFortAIEncounterRiftManager::UpdateIntervalTimeSeconds' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterRiftManager, NumRiftsToUse) == 0x0000DC, "Member 'UFortAIEncounterRiftManager::NumRiftsToUse' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterRiftManager, MinRiftsToUse) == 0x0000E0, "Member 'UFortAIEncounterRiftManager::MinRiftsToUse' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterRiftManager, EncounterSettings) == 0x0000E8, "Member 'UFortAIEncounterRiftManager::EncounterSettings' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterRiftManager, ExtraSpawnLocationPercentage) == 0x000140, "Member 'UFortAIEncounterRiftManager::ExtraSpawnLocationPercentage' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterRiftManager, CurrentEnvironmentQueryInfo) == 0x000148, "Member 'UFortAIEncounterRiftManager::CurrentEnvironmentQueryInfo' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterRiftManager, FallbackEnvironmentQueryInfo) == 0x000170, "Member 'UFortAIEncounterRiftManager::FallbackEnvironmentQueryInfo' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterRiftManager, EncounterQueryDirectionTracker) == 0x000198, "Member 'UFortAIEncounterRiftManager::EncounterQueryDirectionTracker' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterRiftManager, RiftClassTemplate) == 0x0001E0, "Member 'UFortAIEncounterRiftManager::RiftClassTemplate' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterRiftManager, LastObjectiveBatchPathCostUpdateTime) == 0x0001E8, "Member 'UFortAIEncounterRiftManager::LastObjectiveBatchPathCostUpdateTime' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterRiftManager, LastPlayerBatchPathCostUpdateTime) == 0x0001EC, "Member 'UFortAIEncounterRiftManager::LastPlayerBatchPathCostUpdateTime' has a wrong offset!");

// Class FortniteGame.FortGameModeManor
// 0x0028 (0x0850 - 0x0828)
class AFortGameModeManor final : public AFortGameModeZone
{
public:
	uint8                                         Pad_828[0x28];                                     // 0x0828(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameModeManor">();
	}
	static class AFortGameModeManor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGameModeManor>();
	}
};
static_assert(alignof(AFortGameModeManor) == 0x000008, "Wrong alignment on AFortGameModeManor");
static_assert(sizeof(AFortGameModeManor) == 0x000850, "Wrong size on AFortGameModeManor");

// Class FortniteGame.FortAIEncounterTargetInterface
// 0x0000 (0x0028 - 0x0028)
class IFortAIEncounterTargetInterface final : public IInterface
{
public:
	float GetObjectiveCompletionPercentage();
	bool IsFloatingTarget();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIEncounterTargetInterface">();
	}
	static class IFortAIEncounterTargetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortAIEncounterTargetInterface>();
	}
};
static_assert(alignof(IFortAIEncounterTargetInterface) == 0x000008, "Wrong alignment on IFortAIEncounterTargetInterface");
static_assert(sizeof(IFortAIEncounterTargetInterface) == 0x000028, "Wrong size on IFortAIEncounterTargetInterface");

// Class FortniteGame.FortAIGoalManager
// 0x0118 (0x04A0 - 0x0388)
class AFortAIGoalManager : public AActor
{
public:
	uint8                                         Pad_388[0x8];                                      // 0x0388(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UFortAIAssignment*>              WorldAssignments;                                  // 0x0390(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UFortAIAssignment*>              WorldEnemyAssignments;                             // 0x03A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UFortAIAssignment*                      DefaultAttackPlayersAssignment;                    // 0x03B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B8[0x60];                                     // 0x03B8(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UEnvQuery*>                      CombinedQueries;                                   // 0x0418(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_428[0x50];                                     // 0x0428(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAIAssignmentSettings*              DefaultEncounterAssignmentSettings;                // 0x0478(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortAIAssignmentSettings*              DefaultEnemyAssignmentSettings;                    // 0x0480(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FPawnGoalSelectionTableEntry>   PawnGoalSelectionTable;                            // 0x0488(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_498[0x8];                                      // 0x0498(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void AddGoalsToWorldAssignment(class UObject* WorldContextObject, const struct FFortAIAssignmentIdentifier& AssignmentIdentifier, const TArray<struct FFortAIGoalInfo>& GoalInfos);
	static void AddGoalToWorldAssignment(class UObject* WorldContextObject, const struct FFortAIAssignmentIdentifier& AssignmentIdentifier, const struct FFortAIGoalInfo& GoalInfo);
	static void CreateWorldAssignment(class UObject* WorldContextObject, const struct FFortAIAssignmentIdentifier& WorldAssignmentIdentifier, class UFortAIAssignmentSettings* AssignmentSettings, TSubclassOf<class UFortAIGoalProvider> GoalProvider, struct FFortAIAssignmentIdentifier* AssignmentIdentifier, EAssignmentCreationResult* CreationResult);
	static void MakeGoalFromActor(struct FFortAIGoalInfo* Goal, const class UObject* WorldContextObject, const class AActor*& GoalActor, bool bActorAlwaysPerceived, bool bGoalActorAllowsUndermining);
	static void MakeGoalFromLocation(struct FFortAIGoalInfo* Goal, const class UObject* WorldContextObject, const struct FVector& GoalLocation);
	static void MakeGoalsFromActors(TArray<struct FFortAIGoalInfo>* Goals, const class UObject* WorldContextObject, const TArray<class AActor*>& GoalActors, bool bActorsAlwaysPerceived, bool bGoalActorsAllowUndermining);
	static void MakeGoalsFromLocations(TArray<struct FFortAIGoalInfo>* Goals, const class UObject* WorldContextObject, const TArray<struct FVector>& GoalLocations);
	static void MakeGoalsFromLocationsAndActor(TArray<struct FFortAIGoalInfo>* Goals, const class UObject* WorldContextObject, const TArray<struct FVector>& GoalLocations, const class AActor* GoalActor);
	static void RemoveGoalFromWorldAssignment(class UObject* WorldContextObject, const struct FFortAIAssignmentIdentifier& AssignmentIdentifier, const struct FFortAIGoalInfo& GoalInfo);
	static void RemoveGoalsFromWorldAssignment(class UObject* WorldContextObject, const struct FFortAIAssignmentIdentifier& AssignmentIdentifier, const TArray<struct FFortAIGoalInfo>& GoalInfos);
	static void RemoveWorldAssignment(const class UObject* WorldContextObject, const struct FFortAIAssignmentIdentifier& AssignmentIdentifier);
	static void SetCurrentGoalDiscouragement(class UObject* WorldContext, class AFortAIController* AI);

	void AddGoal(class AActor* GoalActor, class UFortAIAssignmentSettings* GoalSettings);
	void AddGoalActorToAssignment(class UFortAIAssignment* Assignment, class AActor* GoalActor);
	class UFortAIAssignment* AddWorldAssignment(class UFortAIAssignmentSettings* AssignmentSettings, class AActor* GoalActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIGoalManager">();
	}
	static class AFortAIGoalManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAIGoalManager>();
	}
};
static_assert(alignof(AFortAIGoalManager) == 0x000008, "Wrong alignment on AFortAIGoalManager");
static_assert(sizeof(AFortAIGoalManager) == 0x0004A0, "Wrong size on AFortAIGoalManager");
static_assert(offsetof(AFortAIGoalManager, WorldAssignments) == 0x000390, "Member 'AFortAIGoalManager::WorldAssignments' has a wrong offset!");
static_assert(offsetof(AFortAIGoalManager, WorldEnemyAssignments) == 0x0003A0, "Member 'AFortAIGoalManager::WorldEnemyAssignments' has a wrong offset!");
static_assert(offsetof(AFortAIGoalManager, DefaultAttackPlayersAssignment) == 0x0003B0, "Member 'AFortAIGoalManager::DefaultAttackPlayersAssignment' has a wrong offset!");
static_assert(offsetof(AFortAIGoalManager, CombinedQueries) == 0x000418, "Member 'AFortAIGoalManager::CombinedQueries' has a wrong offset!");
static_assert(offsetof(AFortAIGoalManager, DefaultEncounterAssignmentSettings) == 0x000478, "Member 'AFortAIGoalManager::DefaultEncounterAssignmentSettings' has a wrong offset!");
static_assert(offsetof(AFortAIGoalManager, DefaultEnemyAssignmentSettings) == 0x000480, "Member 'AFortAIGoalManager::DefaultEnemyAssignmentSettings' has a wrong offset!");
static_assert(offsetof(AFortAIGoalManager, PawnGoalSelectionTable) == 0x000488, "Member 'AFortAIGoalManager::PawnGoalSelectionTable' has a wrong offset!");

// Class FortniteGame.FortAIGoalProvider_EnvQuery
// 0x0088 (0x00D0 - 0x0048)
class UFortAIGoalProvider_EnvQuery : public UFortAIGoalProvider
{
public:
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UEnvQuery*                              GoalQuery;                                         // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AutomaticUpdatePeriodInSeconds;                    // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortAIAssignmentIdentifier            SpecificAssignmentContext;                         // 0x0060(0x0030)(Edit, Protected, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   AIPawnContext;                                     // 0x0090(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B0[0x20];                                      // 0x00B0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIGoalProvider_EnvQuery">();
	}
	static class UFortAIGoalProvider_EnvQuery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIGoalProvider_EnvQuery>();
	}
};
static_assert(alignof(UFortAIGoalProvider_EnvQuery) == 0x000008, "Wrong alignment on UFortAIGoalProvider_EnvQuery");
static_assert(sizeof(UFortAIGoalProvider_EnvQuery) == 0x0000D0, "Wrong size on UFortAIGoalProvider_EnvQuery");
static_assert(offsetof(UFortAIGoalProvider_EnvQuery, GoalQuery) == 0x000050, "Member 'UFortAIGoalProvider_EnvQuery::GoalQuery' has a wrong offset!");
static_assert(offsetof(UFortAIGoalProvider_EnvQuery, AutomaticUpdatePeriodInSeconds) == 0x000058, "Member 'UFortAIGoalProvider_EnvQuery::AutomaticUpdatePeriodInSeconds' has a wrong offset!");
static_assert(offsetof(UFortAIGoalProvider_EnvQuery, SpecificAssignmentContext) == 0x000060, "Member 'UFortAIGoalProvider_EnvQuery::SpecificAssignmentContext' has a wrong offset!");
static_assert(offsetof(UFortAIGoalProvider_EnvQuery, AIPawnContext) == 0x000090, "Member 'UFortAIGoalProvider_EnvQuery::AIPawnContext' has a wrong offset!");

// Class FortniteGame.FortAIProxyActor
// 0x0038 (0x03C0 - 0x0388)
class AFortAIProxyActor final : public AActor
{
public:
	uint8                                         Pad_388[0x10];                                     // 0x0388(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortHealthSet*                         HealthSet;                                         // 0x0398(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortDamageSet*                         DamageSet;                                         // 0x03A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortMovementSet*                       MovementSet;                                       // 0x03A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortAbilitySystemComponent*            AbilitySystemComponent;                            // 0x03B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPhysicalSurface                              PrimaryPhysicalSurface;                            // 0x03B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EFortBaseWeaponDamage                         BaseWeaponDamageResponseType;                      // 0x03B9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3BA[0x6];                                      // 0x03BA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIProxyActor">();
	}
	static class AFortAIProxyActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAIProxyActor>();
	}
};
static_assert(alignof(AFortAIProxyActor) == 0x000008, "Wrong alignment on AFortAIProxyActor");
static_assert(sizeof(AFortAIProxyActor) == 0x0003C0, "Wrong size on AFortAIProxyActor");
static_assert(offsetof(AFortAIProxyActor, HealthSet) == 0x000398, "Member 'AFortAIProxyActor::HealthSet' has a wrong offset!");
static_assert(offsetof(AFortAIProxyActor, DamageSet) == 0x0003A0, "Member 'AFortAIProxyActor::DamageSet' has a wrong offset!");
static_assert(offsetof(AFortAIProxyActor, MovementSet) == 0x0003A8, "Member 'AFortAIProxyActor::MovementSet' has a wrong offset!");
static_assert(offsetof(AFortAIProxyActor, AbilitySystemComponent) == 0x0003B0, "Member 'AFortAIProxyActor::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(AFortAIProxyActor, PrimaryPhysicalSurface) == 0x0003B8, "Member 'AFortAIProxyActor::PrimaryPhysicalSurface' has a wrong offset!");
static_assert(offsetof(AFortAIProxyActor, BaseWeaponDamageResponseType) == 0x0003B9, "Member 'AFortAIProxyActor::BaseWeaponDamageResponseType' has a wrong offset!");

// Class FortniteGame.FortAISpawnGroupProgressionInfo
// 0x0010 (0x0038 - 0x0028)
class UFortAISpawnGroupProgressionInfo final : public UDataAsset
{
public:
	TArray<struct FSpawnGroupProgression>         SpawnGroups;                                       // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAISpawnGroupProgressionInfo">();
	}
	static class UFortAISpawnGroupProgressionInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAISpawnGroupProgressionInfo>();
	}
};
static_assert(alignof(UFortAISpawnGroupProgressionInfo) == 0x000008, "Wrong alignment on UFortAISpawnGroupProgressionInfo");
static_assert(sizeof(UFortAISpawnGroupProgressionInfo) == 0x000038, "Wrong size on UFortAISpawnGroupProgressionInfo");
static_assert(offsetof(UFortAISpawnGroupProgressionInfo, SpawnGroups) == 0x000028, "Member 'UFortAISpawnGroupProgressionInfo::SpawnGroups' has a wrong offset!");

// Class FortniteGame.FortAISystem
// 0x0090 (0x01A0 - 0x0110)
class UFortAISystem final : public UAISystem
{
public:
	TArray<class UFortQueryTwoPointSolver*>       TwoPointSolvers;                                   // 0x0110(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class UFortInfluenceMap*                      InfluenceMap;                                      // 0x0120(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortBotMissionManager*                 BotManager;                                        // 0x0128(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_130[0x10];                                     // 0x0130(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UFortRiftBlockerComponent*>      ActiveRiftBlockers;                                // 0x0140(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_150[0x50];                                     // 0x0150(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool IsInCone2D(const struct FVector& ConeOrigin, const struct FVector& ConeDirection, float HalfAngle, const struct FVector& LocationToCheck);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAISystem">();
	}
	static class UFortAISystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAISystem>();
	}
};
static_assert(alignof(UFortAISystem) == 0x000008, "Wrong alignment on UFortAISystem");
static_assert(sizeof(UFortAISystem) == 0x0001A0, "Wrong size on UFortAISystem");
static_assert(offsetof(UFortAISystem, TwoPointSolvers) == 0x000110, "Member 'UFortAISystem::TwoPointSolvers' has a wrong offset!");
static_assert(offsetof(UFortAISystem, InfluenceMap) == 0x000120, "Member 'UFortAISystem::InfluenceMap' has a wrong offset!");
static_assert(offsetof(UFortAISystem, BotManager) == 0x000128, "Member 'UFortAISystem::BotManager' has a wrong offset!");
static_assert(offsetof(UFortAISystem, ActiveRiftBlockers) == 0x000140, "Member 'UFortAISystem::ActiveRiftBlockers' has a wrong offset!");

// Class FortniteGame.FortAITask_AdjustToSlot
// 0x0030 (0x00A0 - 0x0070)
class UFortAITask_AdjustToSlot final : public UAITask
{
public:
	struct FVector                                SlotLocation;                                      // 0x0070(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SlotDirection;                                     // 0x007C(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x18];                                      // 0x0088(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAITask_AdjustToSlot">();
	}
	static class UFortAITask_AdjustToSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAITask_AdjustToSlot>();
	}
};
static_assert(alignof(UFortAITask_AdjustToSlot) == 0x000008, "Wrong alignment on UFortAITask_AdjustToSlot");
static_assert(sizeof(UFortAITask_AdjustToSlot) == 0x0000A0, "Wrong size on UFortAITask_AdjustToSlot");
static_assert(offsetof(UFortAITask_AdjustToSlot, SlotLocation) == 0x000070, "Member 'UFortAITask_AdjustToSlot::SlotLocation' has a wrong offset!");
static_assert(offsetof(UFortAITask_AdjustToSlot, SlotDirection) == 0x00007C, "Member 'UFortAITask_AdjustToSlot::SlotDirection' has a wrong offset!");

// Class FortniteGame.FortHomebaseNodeGameplayEffectDataTable
// 0x0010 (0x0098 - 0x0088)
class UFortHomebaseNodeGameplayEffectDataTable final : public UDataTable
{
public:
	TArray<TSubclassOf<class UGameplayEffect>>    TemplateAttributeGEs;                              // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortHomebaseNodeGameplayEffectDataTable">();
	}
	static class UFortHomebaseNodeGameplayEffectDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortHomebaseNodeGameplayEffectDataTable>();
	}
};
static_assert(alignof(UFortHomebaseNodeGameplayEffectDataTable) == 0x000008, "Wrong alignment on UFortHomebaseNodeGameplayEffectDataTable");
static_assert(sizeof(UFortHomebaseNodeGameplayEffectDataTable) == 0x000098, "Wrong size on UFortHomebaseNodeGameplayEffectDataTable");
static_assert(offsetof(UFortHomebaseNodeGameplayEffectDataTable, TemplateAttributeGEs) == 0x000088, "Member 'UFortHomebaseNodeGameplayEffectDataTable::TemplateAttributeGEs' has a wrong offset!");

// Class FortniteGame.FortMiniMapPingIndicator
// 0x0088 (0x03A0 - 0x0318)
class UFortMiniMapPingIndicator : public UFortMiniMapIndicator
{
public:
	uint8                                         Pad_318[0x88];                                     // 0x0318(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMiniMapPingIndicator">();
	}
	static class UFortMiniMapPingIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMiniMapPingIndicator>();
	}
};
static_assert(alignof(UFortMiniMapPingIndicator) == 0x000008, "Wrong alignment on UFortMiniMapPingIndicator");
static_assert(sizeof(UFortMiniMapPingIndicator) == 0x0003A0, "Wrong size on UFortMiniMapPingIndicator");

// Class FortniteGame.FortAITask_StepAside
// 0x0030 (0x0178 - 0x0148)
class UFortAITask_StepAside final : public UFortAITask_Move
{
public:
	uint8                                         Pad_148[0x10];                                     // 0x0148(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 GoalActor;                                         // 0x0158(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_160[0x18];                                     // 0x0160(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAITask_StepAside">();
	}
	static class UFortAITask_StepAside* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAITask_StepAside>();
	}
};
static_assert(alignof(UFortAITask_StepAside) == 0x000008, "Wrong alignment on UFortAITask_StepAside");
static_assert(sizeof(UFortAITask_StepAside) == 0x000178, "Wrong size on UFortAITask_StepAside");
static_assert(offsetof(UFortAITask_StepAside, GoalActor) == 0x000158, "Member 'UFortAITask_StepAside::GoalActor' has a wrong offset!");

// Class FortniteGame.FortAITask_RotateToFace
// 0x0020 (0x0090 - 0x0070)
class UFortAITask_RotateToFace final : public UAITask
{
public:
	class AActor*                                 FocusTarget;                                       // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FocalPoint;                                        // 0x0078(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0xC];                                       // 0x0084(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAITask_RotateToFace">();
	}
	static class UFortAITask_RotateToFace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAITask_RotateToFace>();
	}
};
static_assert(alignof(UFortAITask_RotateToFace) == 0x000008, "Wrong alignment on UFortAITask_RotateToFace");
static_assert(sizeof(UFortAITask_RotateToFace) == 0x000090, "Wrong size on UFortAITask_RotateToFace");
static_assert(offsetof(UFortAITask_RotateToFace, FocusTarget) == 0x000070, "Member 'UFortAITask_RotateToFace::FocusTarget' has a wrong offset!");
static_assert(offsetof(UFortAITask_RotateToFace, FocalPoint) == 0x000078, "Member 'UFortAITask_RotateToFace::FocalPoint' has a wrong offset!");

// Class FortniteGame.FortSlateHUDIndicator
// 0x0038 (0x0088 - 0x0050)
class UFortSlateHUDIndicator : public UFortIndicator
{
public:
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bClampToScreen;                                    // 0x0058(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowClampToScreenArrow;                           // 0x0059(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x2E];                                      // 0x005A(0x002E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortSlateHUDIndicator">();
	}
	static class UFortSlateHUDIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortSlateHUDIndicator>();
	}
};
static_assert(alignof(UFortSlateHUDIndicator) == 0x000008, "Wrong alignment on UFortSlateHUDIndicator");
static_assert(sizeof(UFortSlateHUDIndicator) == 0x000088, "Wrong size on UFortSlateHUDIndicator");
static_assert(offsetof(UFortSlateHUDIndicator, bClampToScreen) == 0x000058, "Member 'UFortSlateHUDIndicator::bClampToScreen' has a wrong offset!");
static_assert(offsetof(UFortSlateHUDIndicator, bShowClampToScreenArrow) == 0x000059, "Member 'UFortSlateHUDIndicator::bShowClampToScreenArrow' has a wrong offset!");

// Class FortniteGame.FortHealthBarIndicator
// 0x0078 (0x0100 - 0x0088)
class UFortHealthBarIndicator final : public UFortSlateHUDIndicator
{
public:
	uint8                                         Pad_88[0x78];                                      // 0x0088(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortHealthBarIndicator">();
	}
	static class UFortHealthBarIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortHealthBarIndicator>();
	}
};
static_assert(alignof(UFortHealthBarIndicator) == 0x000008, "Wrong alignment on UFortHealthBarIndicator");
static_assert(sizeof(UFortHealthBarIndicator) == 0x000100, "Wrong size on UFortHealthBarIndicator");

// Class FortniteGame.FortPlayMontageForGameplayTagQueryInterface
// 0x0000 (0x0028 - 0x0028)
class IFortPlayMontageForGameplayTagQueryInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayMontageForGameplayTagQueryInterface">();
	}
	static class IFortPlayMontageForGameplayTagQueryInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortPlayMontageForGameplayTagQueryInterface>();
	}
};
static_assert(alignof(IFortPlayMontageForGameplayTagQueryInterface) == 0x000008, "Wrong alignment on IFortPlayMontageForGameplayTagQueryInterface");
static_assert(sizeof(IFortPlayMontageForGameplayTagQueryInterface) == 0x000028, "Wrong size on IFortPlayMontageForGameplayTagQueryInterface");

// Class FortniteGame.FortQueryGenerator_Enemies
// 0x0038 (0x0088 - 0x0050)
class UFortQueryGenerator_Enemies final : public UEnvQueryGenerator
{
public:
	bool                                          bPerceivedEnemiesOnly;                             // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSleepCapableAIUsePerceivedEnemiesOnly;            // 0x0051(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIgnoreSleepingAIs;                                // 0x0052(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_53[0x5];                                       // 0x0053(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIDataProviderFloatValue              MaxTimeSincePerceived;                             // 0x0058(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_Enemies">();
	}
	static class UFortQueryGenerator_Enemies* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_Enemies>();
	}
};
static_assert(alignof(UFortQueryGenerator_Enemies) == 0x000008, "Wrong alignment on UFortQueryGenerator_Enemies");
static_assert(sizeof(UFortQueryGenerator_Enemies) == 0x000088, "Wrong size on UFortQueryGenerator_Enemies");
static_assert(offsetof(UFortQueryGenerator_Enemies, bPerceivedEnemiesOnly) == 0x000050, "Member 'UFortQueryGenerator_Enemies::bPerceivedEnemiesOnly' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_Enemies, bSleepCapableAIUsePerceivedEnemiesOnly) == 0x000051, "Member 'UFortQueryGenerator_Enemies::bSleepCapableAIUsePerceivedEnemiesOnly' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_Enemies, bIgnoreSleepingAIs) == 0x000052, "Member 'UFortQueryGenerator_Enemies::bIgnoreSleepingAIs' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_Enemies, MaxTimeSincePerceived) == 0x000058, "Member 'UFortQueryGenerator_Enemies::MaxTimeSincePerceived' has a wrong offset!");

// Class FortniteGame.FortHuskAnimInstance
// 0x0048 (0x0450 - 0x0408)
class UFortHuskAnimInstance final : public UFortAIAnimInstance
{
public:
	EFortHuskAnimType                             HuskAnimType;                                      // 0x0408(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_409[0xB];                                      // 0x0409(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FallAsleepAnimDuration;                            // 0x0414(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AltFallAsleepAnimDuration;                         // 0x0418(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WakeUpAnimDuration;                                // 0x041C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FallAsleepToSleepingCrossfade;                     // 0x0420(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WakeUpToIdleCrossfade;                             // 0x0424(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DefaultToDwarfScaleRatio;                          // 0x0428(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LookAtAlpha;                                       // 0x042C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LookAtInterpSpeed;                                 // 0x0430(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AdjustedLowerBodyWeight;                           // 0x0434(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AdjustedLowerBodyInterpSpeed;                      // 0x0438(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RunPlayRate;                                       // 0x043C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RunStartPosition;                                  // 0x0440(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AuthoredJogSpeed;                                  // 0x0444(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MovementStyleIsWalking;                            // 0x0448(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bForceFullBodyMontage : 1;                         // 0x044C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsDwarf : 1;                                      // 0x044C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         StateTransition_IdleToMove : 1;                    // 0x044C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         StateTransition_IdleToFallAsleep : 1;              // 0x044C(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         StateTransition_IdleToStunned : 1;                 // 0x044C(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         StateTransition_IdleToKnockedbackDown : 1;         // 0x044C(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         StateTransition_IdleToKnockedbackUp : 1;           // 0x044C(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         StateTransition_MoveToIdle : 1;                    // 0x044C(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         StateTransition_FallAsleepToSleeping : 1;          // 0x044D(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         StateTransition_SleepingToWakeUp : 1;              // 0x044D(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         StateTransition_WakeUpToIdle : 1;                  // 0x044D(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         StateTransition_StunnedToIdle : 1;                 // 0x044D(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         StateTransition_KnockedbackDownToIdle : 1;         // 0x044D(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         StateTransition_KnockedbackUpToKnockedbackDown : 1; // 0x044D(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_44E[0x2];                                      // 0x044E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AnimNotify_SleepingFullyBlended(const class UAnimNotify* Notify);
	void SetHuskAnimType(EFortHuskAnimType NewHuskAnimType);

	EFortHuskAnimType GetHuskAnimType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortHuskAnimInstance">();
	}
	static class UFortHuskAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortHuskAnimInstance>();
	}
};
static_assert(alignof(UFortHuskAnimInstance) == 0x000008, "Wrong alignment on UFortHuskAnimInstance");
static_assert(sizeof(UFortHuskAnimInstance) == 0x000450, "Wrong size on UFortHuskAnimInstance");
static_assert(offsetof(UFortHuskAnimInstance, HuskAnimType) == 0x000408, "Member 'UFortHuskAnimInstance::HuskAnimType' has a wrong offset!");
static_assert(offsetof(UFortHuskAnimInstance, FallAsleepAnimDuration) == 0x000414, "Member 'UFortHuskAnimInstance::FallAsleepAnimDuration' has a wrong offset!");
static_assert(offsetof(UFortHuskAnimInstance, AltFallAsleepAnimDuration) == 0x000418, "Member 'UFortHuskAnimInstance::AltFallAsleepAnimDuration' has a wrong offset!");
static_assert(offsetof(UFortHuskAnimInstance, WakeUpAnimDuration) == 0x00041C, "Member 'UFortHuskAnimInstance::WakeUpAnimDuration' has a wrong offset!");
static_assert(offsetof(UFortHuskAnimInstance, FallAsleepToSleepingCrossfade) == 0x000420, "Member 'UFortHuskAnimInstance::FallAsleepToSleepingCrossfade' has a wrong offset!");
static_assert(offsetof(UFortHuskAnimInstance, WakeUpToIdleCrossfade) == 0x000424, "Member 'UFortHuskAnimInstance::WakeUpToIdleCrossfade' has a wrong offset!");
static_assert(offsetof(UFortHuskAnimInstance, DefaultToDwarfScaleRatio) == 0x000428, "Member 'UFortHuskAnimInstance::DefaultToDwarfScaleRatio' has a wrong offset!");
static_assert(offsetof(UFortHuskAnimInstance, LookAtAlpha) == 0x00042C, "Member 'UFortHuskAnimInstance::LookAtAlpha' has a wrong offset!");
static_assert(offsetof(UFortHuskAnimInstance, LookAtInterpSpeed) == 0x000430, "Member 'UFortHuskAnimInstance::LookAtInterpSpeed' has a wrong offset!");
static_assert(offsetof(UFortHuskAnimInstance, AdjustedLowerBodyWeight) == 0x000434, "Member 'UFortHuskAnimInstance::AdjustedLowerBodyWeight' has a wrong offset!");
static_assert(offsetof(UFortHuskAnimInstance, AdjustedLowerBodyInterpSpeed) == 0x000438, "Member 'UFortHuskAnimInstance::AdjustedLowerBodyInterpSpeed' has a wrong offset!");
static_assert(offsetof(UFortHuskAnimInstance, RunPlayRate) == 0x00043C, "Member 'UFortHuskAnimInstance::RunPlayRate' has a wrong offset!");
static_assert(offsetof(UFortHuskAnimInstance, RunStartPosition) == 0x000440, "Member 'UFortHuskAnimInstance::RunStartPosition' has a wrong offset!");
static_assert(offsetof(UFortHuskAnimInstance, AuthoredJogSpeed) == 0x000444, "Member 'UFortHuskAnimInstance::AuthoredJogSpeed' has a wrong offset!");
static_assert(offsetof(UFortHuskAnimInstance, MovementStyleIsWalking) == 0x000448, "Member 'UFortHuskAnimInstance::MovementStyleIsWalking' has a wrong offset!");

// Class FortniteGame.FortProjectileAthena
// 0x0018 (0x0810 - 0x07F8)
class AFortProjectileAthena final : public AFortProjectileBase
{
public:
	struct FVector_NetQuantize                    FireStartLoc;                                      // 0x07F8(0x000C)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bDelayPawnGameplayTouchEffectsOnServer;            // 0x0804(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_805[0xB];                                      // 0x0805(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_FireStart();
	void ServerNotifyPawnHit(const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortProjectileAthena">();
	}
	static class AFortProjectileAthena* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortProjectileAthena>();
	}
};
static_assert(alignof(AFortProjectileAthena) == 0x000008, "Wrong alignment on AFortProjectileAthena");
static_assert(sizeof(AFortProjectileAthena) == 0x000810, "Wrong size on AFortProjectileAthena");
static_assert(offsetof(AFortProjectileAthena, FireStartLoc) == 0x0007F8, "Member 'AFortProjectileAthena::FireStartLoc' has a wrong offset!");
static_assert(offsetof(AFortProjectileAthena, bDelayPawnGameplayTouchEffectsOnServer) == 0x000804, "Member 'AFortProjectileAthena::bDelayPawnGameplayTouchEffectsOnServer' has a wrong offset!");

// Class FortniteGame.FortQueryGenerator_Buildings
// 0x0158 (0x01A8 - 0x0050)
class UFortQueryGenerator_Buildings final : public UEnvQueryGenerator
{
public:
	TSubclassOf<class UEnvQueryContext>           BuildingGridVolumeCenter;                          // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FAIDataProviderIntValue                HorizontalBuildingCellRadius;                      // 0x0058(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderIntValue                BuildingCellsAbove;                                // 0x0088(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderIntValue                BuildingCellsBelow;                                // 0x00B8(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderBoolValue               bIncludeWalls;                                     // 0x00E8(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderBoolValue               bIncludeFloors;                                    // 0x0118(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderBoolValue               bIncludeCenterCell;                                // 0x0148(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderIntValue                MaxBuildingActorsPerVolumeCenterToCollect;         // 0x0178(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_Buildings">();
	}
	static class UFortQueryGenerator_Buildings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_Buildings>();
	}
};
static_assert(alignof(UFortQueryGenerator_Buildings) == 0x000008, "Wrong alignment on UFortQueryGenerator_Buildings");
static_assert(sizeof(UFortQueryGenerator_Buildings) == 0x0001A8, "Wrong size on UFortQueryGenerator_Buildings");
static_assert(offsetof(UFortQueryGenerator_Buildings, BuildingGridVolumeCenter) == 0x000050, "Member 'UFortQueryGenerator_Buildings::BuildingGridVolumeCenter' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_Buildings, HorizontalBuildingCellRadius) == 0x000058, "Member 'UFortQueryGenerator_Buildings::HorizontalBuildingCellRadius' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_Buildings, BuildingCellsAbove) == 0x000088, "Member 'UFortQueryGenerator_Buildings::BuildingCellsAbove' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_Buildings, BuildingCellsBelow) == 0x0000B8, "Member 'UFortQueryGenerator_Buildings::BuildingCellsBelow' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_Buildings, bIncludeWalls) == 0x0000E8, "Member 'UFortQueryGenerator_Buildings::bIncludeWalls' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_Buildings, bIncludeFloors) == 0x000118, "Member 'UFortQueryGenerator_Buildings::bIncludeFloors' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_Buildings, bIncludeCenterCell) == 0x000148, "Member 'UFortQueryGenerator_Buildings::bIncludeCenterCell' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_Buildings, MaxBuildingActorsPerVolumeCenterToCollect) == 0x000178, "Member 'UFortQueryGenerator_Buildings::MaxBuildingActorsPerVolumeCenterToCollect' has a wrong offset!");

// Class FortniteGame.FortWorkerType
// 0x00A0 (0x0310 - 0x0270)
class UFortWorkerType : public UFortCharacterType
{
public:
	EFortCustomGender                             Gender;                                            // 0x0270(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_271[0x7];                                      // 0x0271(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UFortItemIconDefinition> FixedPortrait;                                     // 0x0278(0x0020)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsManager;                                        // 0x0298(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_299[0x7];                                      // 0x0299(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  ManagerSynergyTag;                                 // 0x02A0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  FixedPersonalityTag;                               // 0x02C0(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  FixedSetBonusTag;                                  // 0x02E0(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	int32                                         MatchingPersonalityBonus;                          // 0x0300(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MismatchingPersonalityPenalty;                     // 0x0304(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_308[0x8];                                      // 0x0308(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortWorkerType">();
	}
	static class UFortWorkerType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortWorkerType>();
	}
};
static_assert(alignof(UFortWorkerType) == 0x000010, "Wrong alignment on UFortWorkerType");
static_assert(sizeof(UFortWorkerType) == 0x000310, "Wrong size on UFortWorkerType");
static_assert(offsetof(UFortWorkerType, Gender) == 0x000270, "Member 'UFortWorkerType::Gender' has a wrong offset!");
static_assert(offsetof(UFortWorkerType, FixedPortrait) == 0x000278, "Member 'UFortWorkerType::FixedPortrait' has a wrong offset!");
static_assert(offsetof(UFortWorkerType, bIsManager) == 0x000298, "Member 'UFortWorkerType::bIsManager' has a wrong offset!");
static_assert(offsetof(UFortWorkerType, ManagerSynergyTag) == 0x0002A0, "Member 'UFortWorkerType::ManagerSynergyTag' has a wrong offset!");
static_assert(offsetof(UFortWorkerType, FixedPersonalityTag) == 0x0002C0, "Member 'UFortWorkerType::FixedPersonalityTag' has a wrong offset!");
static_assert(offsetof(UFortWorkerType, FixedSetBonusTag) == 0x0002E0, "Member 'UFortWorkerType::FixedSetBonusTag' has a wrong offset!");
static_assert(offsetof(UFortWorkerType, MatchingPersonalityBonus) == 0x000300, "Member 'UFortWorkerType::MatchingPersonalityBonus' has a wrong offset!");
static_assert(offsetof(UFortWorkerType, MismatchingPersonalityPenalty) == 0x000304, "Member 'UFortWorkerType::MismatchingPersonalityPenalty' has a wrong offset!");

// Class FortniteGame.FrontendAnimInstance
// 0x0078 (0x03D0 - 0x0358)
class UFrontendAnimInstance : public UAnimInstance
{
public:
	uint8                                         Pad_358[0x8];                                      // 0x0358(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EFortDisplayGender                            Gender;                                            // 0x0360(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_361[0x7];                                      // 0x0361(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           IntroAnimation_Female;                             // 0x0368(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           IntroAnimation_Male;                               // 0x0370(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           OutroAnimation_Female;                             // 0x0378(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           OutroAnimation_Male;                               // 0x0380(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           SelectedAnimation_Female;                          // 0x0388(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           SelectedAnimation_Male;                            // 0x0390(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bCanPlayCustomAnimations : 1;                      // 0x0398(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_399[0x7];                                      // 0x0399(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagAnimations                 GameplayTagAnimations;                             // 0x03A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagAnimations                 FemaleGameplayTagAnimations;                       // 0x03B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagAnimations                 MaleGameplayTagAnimations;                         // 0x03C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	void OnPlayMontageFromGameplayTagQuery(const struct FGameplayTagQuery& MatchingQuery, class UAnimMontage* MontagePlaying);
	void PlayIntro();
	void PlayOutro();
	void PlaySelected();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FrontendAnimInstance">();
	}
	static class UFrontendAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFrontendAnimInstance>();
	}
};
static_assert(alignof(UFrontendAnimInstance) == 0x000008, "Wrong alignment on UFrontendAnimInstance");
static_assert(sizeof(UFrontendAnimInstance) == 0x0003D0, "Wrong size on UFrontendAnimInstance");
static_assert(offsetof(UFrontendAnimInstance, Gender) == 0x000360, "Member 'UFrontendAnimInstance::Gender' has a wrong offset!");
static_assert(offsetof(UFrontendAnimInstance, IntroAnimation_Female) == 0x000368, "Member 'UFrontendAnimInstance::IntroAnimation_Female' has a wrong offset!");
static_assert(offsetof(UFrontendAnimInstance, IntroAnimation_Male) == 0x000370, "Member 'UFrontendAnimInstance::IntroAnimation_Male' has a wrong offset!");
static_assert(offsetof(UFrontendAnimInstance, OutroAnimation_Female) == 0x000378, "Member 'UFrontendAnimInstance::OutroAnimation_Female' has a wrong offset!");
static_assert(offsetof(UFrontendAnimInstance, OutroAnimation_Male) == 0x000380, "Member 'UFrontendAnimInstance::OutroAnimation_Male' has a wrong offset!");
static_assert(offsetof(UFrontendAnimInstance, SelectedAnimation_Female) == 0x000388, "Member 'UFrontendAnimInstance::SelectedAnimation_Female' has a wrong offset!");
static_assert(offsetof(UFrontendAnimInstance, SelectedAnimation_Male) == 0x000390, "Member 'UFrontendAnimInstance::SelectedAnimation_Male' has a wrong offset!");
static_assert(offsetof(UFrontendAnimInstance, GameplayTagAnimations) == 0x0003A0, "Member 'UFrontendAnimInstance::GameplayTagAnimations' has a wrong offset!");
static_assert(offsetof(UFrontendAnimInstance, FemaleGameplayTagAnimations) == 0x0003B0, "Member 'UFrontendAnimInstance::FemaleGameplayTagAnimations' has a wrong offset!");
static_assert(offsetof(UFrontendAnimInstance, MaleGameplayTagAnimations) == 0x0003C0, "Member 'UFrontendAnimInstance::MaleGameplayTagAnimations' has a wrong offset!");

// Class FortniteGame.FortGameplayEffectExecutionCalculation
// 0x0000 (0x0040 - 0x0040)
class UFortGameplayEffectExecutionCalculation : public UGameplayEffectExecutionCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameplayEffectExecutionCalculation">();
	}
	static class UFortGameplayEffectExecutionCalculation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGameplayEffectExecutionCalculation>();
	}
};
static_assert(alignof(UFortGameplayEffectExecutionCalculation) == 0x000008, "Wrong alignment on UFortGameplayEffectExecutionCalculation");
static_assert(sizeof(UFortGameplayEffectExecutionCalculation) == 0x000040, "Wrong size on UFortGameplayEffectExecutionCalculation");

// Class FortniteGame.FortActiveDurationExecutionCalculation
// 0x0000 (0x0040 - 0x0040)
class UFortActiveDurationExecutionCalculation final : public UFortGameplayEffectExecutionCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortActiveDurationExecutionCalculation">();
	}
	static class UFortActiveDurationExecutionCalculation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortActiveDurationExecutionCalculation>();
	}
};
static_assert(alignof(UFortActiveDurationExecutionCalculation) == 0x000008, "Wrong alignment on UFortActiveDurationExecutionCalculation");
static_assert(sizeof(UFortActiveDurationExecutionCalculation) == 0x000040, "Wrong size on UFortActiveDurationExecutionCalculation");

// Class FortniteGame.FortQueryGenerator_PointsFromNavGraph
// 0x0128 (0x01A8 - 0x0080)
class UFortQueryGenerator_PointsFromNavGraph final : public UEnvQueryGenerator_ProjectedPoints
{
public:
	struct FAIDataProviderFloatValue              MinPathDistance;                                   // 0x0080(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              MaxPathDistance;                                   // 0x00B0(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderIntValue                Density;                                           // 0x00E0(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              ExploreDirectionYaw;                               // 0x0110(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FEnvDirection                          ExploreDirection;                                  // 0x0140(0x0020)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ExploreAngleDot;                                   // 0x0160(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_164[0x4];                                      // 0x0164(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIDataProviderFloatValue              ExploreInnerRadius;                                // 0x0168(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bLimitExplorationDirection : 1;                    // 0x0198(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOnlyFlatSurface : 1;                              // 0x0198(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseParameterizedDirection : 1;                    // 0x0198(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFilterAllowTerrain : 1;                           // 0x0198(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFilterAllowBuildings : 1;                         // 0x0198(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFilterAllowDropdown : 1;                          // 0x0198(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFilterAllowClimbup : 1;                           // 0x0198(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFilterAllowSmash : 1;                             // 0x0198(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_199[0x3];                                      // 0x0199(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EFortPointsFromNavGraphGoalPathDistanceFilterOperator PathDistanceFilterOperator;                        // 0x019C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19D[0x3];                                      // 0x019D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UEnvQueryContext>           GenerateAround;                                    // 0x01A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_PointsFromNavGraph">();
	}
	static class UFortQueryGenerator_PointsFromNavGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_PointsFromNavGraph>();
	}
};
static_assert(alignof(UFortQueryGenerator_PointsFromNavGraph) == 0x000008, "Wrong alignment on UFortQueryGenerator_PointsFromNavGraph");
static_assert(sizeof(UFortQueryGenerator_PointsFromNavGraph) == 0x0001A8, "Wrong size on UFortQueryGenerator_PointsFromNavGraph");
static_assert(offsetof(UFortQueryGenerator_PointsFromNavGraph, MinPathDistance) == 0x000080, "Member 'UFortQueryGenerator_PointsFromNavGraph::MinPathDistance' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsFromNavGraph, MaxPathDistance) == 0x0000B0, "Member 'UFortQueryGenerator_PointsFromNavGraph::MaxPathDistance' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsFromNavGraph, Density) == 0x0000E0, "Member 'UFortQueryGenerator_PointsFromNavGraph::Density' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsFromNavGraph, ExploreDirectionYaw) == 0x000110, "Member 'UFortQueryGenerator_PointsFromNavGraph::ExploreDirectionYaw' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsFromNavGraph, ExploreDirection) == 0x000140, "Member 'UFortQueryGenerator_PointsFromNavGraph::ExploreDirection' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsFromNavGraph, ExploreAngleDot) == 0x000160, "Member 'UFortQueryGenerator_PointsFromNavGraph::ExploreAngleDot' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsFromNavGraph, ExploreInnerRadius) == 0x000168, "Member 'UFortQueryGenerator_PointsFromNavGraph::ExploreInnerRadius' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsFromNavGraph, PathDistanceFilterOperator) == 0x00019C, "Member 'UFortQueryGenerator_PointsFromNavGraph::PathDistanceFilterOperator' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsFromNavGraph, GenerateAround) == 0x0001A0, "Member 'UFortQueryGenerator_PointsFromNavGraph::GenerateAround' has a wrong offset!");

// Class FortniteGame.FortHeroSpecialization
// 0x0248 (0x0270 - 0x0028)
class UFortHeroSpecialization final : public UPrimaryDataAsset
{
public:
	TArray<struct FFortSpecializationSlot>        SpecializationSlots;                               // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<struct FFortSpecializationSlot>        TacticalAbilitySlots;                              // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<struct FFortSpecializationSlot>        SupportAbilitySlots;                               // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UFortCharacterCosmeticItemDefinition> CosmeticItem;                                      // 0x0058(0x0020)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSoftObjectPtr<class UCustomCharacterPart>> CharacterParts;                                    // 0x0078(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	EFortAlteration                               AlterationType;                                    // 0x0088(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHeroSpecializationAttributeRequirement> AttributeRequirements;                             // 0x0090(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  RequiredTags;                                      // 0x00A0(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FSlateBrush                            CardIconBrush[0x3];                                // 0x00C0(0x0090)(Edit, EditConst, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortHeroSpecialization">();
	}
	static class UFortHeroSpecialization* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortHeroSpecialization>();
	}
};
static_assert(alignof(UFortHeroSpecialization) == 0x000008, "Wrong alignment on UFortHeroSpecialization");
static_assert(sizeof(UFortHeroSpecialization) == 0x000270, "Wrong size on UFortHeroSpecialization");
static_assert(offsetof(UFortHeroSpecialization, SpecializationSlots) == 0x000028, "Member 'UFortHeroSpecialization::SpecializationSlots' has a wrong offset!");
static_assert(offsetof(UFortHeroSpecialization, TacticalAbilitySlots) == 0x000038, "Member 'UFortHeroSpecialization::TacticalAbilitySlots' has a wrong offset!");
static_assert(offsetof(UFortHeroSpecialization, SupportAbilitySlots) == 0x000048, "Member 'UFortHeroSpecialization::SupportAbilitySlots' has a wrong offset!");
static_assert(offsetof(UFortHeroSpecialization, CosmeticItem) == 0x000058, "Member 'UFortHeroSpecialization::CosmeticItem' has a wrong offset!");
static_assert(offsetof(UFortHeroSpecialization, CharacterParts) == 0x000078, "Member 'UFortHeroSpecialization::CharacterParts' has a wrong offset!");
static_assert(offsetof(UFortHeroSpecialization, AlterationType) == 0x000088, "Member 'UFortHeroSpecialization::AlterationType' has a wrong offset!");
static_assert(offsetof(UFortHeroSpecialization, AttributeRequirements) == 0x000090, "Member 'UFortHeroSpecialization::AttributeRequirements' has a wrong offset!");
static_assert(offsetof(UFortHeroSpecialization, RequiredTags) == 0x0000A0, "Member 'UFortHeroSpecialization::RequiredTags' has a wrong offset!");
static_assert(offsetof(UFortHeroSpecialization, CardIconBrush) == 0x0000C0, "Member 'UFortHeroSpecialization::CardIconBrush' has a wrong offset!");

// Class FortniteGame.FortHeroType
// 0x0140 (0x0450 - 0x0310)
class UFortHeroType final : public UFortWorkerType
{
public:
	uint8                                         Pad_310[0x20];                                     // 0x0310(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UFortHeroSpecialization>> Specializations;                                   // 0x0330(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<struct FHeroAbilityKit>                AbilityKits;                                       // 0x0340(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGameplayEffectApplicationInfo> CombinedStatGEs;                                   // 0x0350(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FHeroItem>                      HeroItems;                                         // 0x0360(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  RequiredGPTags;                                    // 0x0370(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFortFeedbackBank>       MaleOverrideFeedback;                              // 0x0390(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFortFeedbackBank>       FemaleOverrideFeedback;                            // 0x03B0(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   OverridePawnClass;                                 // 0x03D0(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   FrontEndAnimClass;                                 // 0x03F0(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   SubType;                                           // 0x0410(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FFortAttributeInitializationKey        AttributeInitKey;                                  // 0x0428(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FDataTableRowHandle                    LegacyStatHandle;                                  // 0x0438(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_448[0x8];                                      // 0x0448(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UFortFeedbackBank* GetFemaleOverrideFeedback() const;
	TSubclassOf<class UFrontendAnimInstance> GetFrontendAnimClass() const;
	class UFortFeedbackBank* GetMaleOverrideFeedback() const;
	class FText GetSubType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortHeroType">();
	}
	static class UFortHeroType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortHeroType>();
	}
};
static_assert(alignof(UFortHeroType) == 0x000010, "Wrong alignment on UFortHeroType");
static_assert(sizeof(UFortHeroType) == 0x000450, "Wrong size on UFortHeroType");
static_assert(offsetof(UFortHeroType, Specializations) == 0x000330, "Member 'UFortHeroType::Specializations' has a wrong offset!");
static_assert(offsetof(UFortHeroType, AbilityKits) == 0x000340, "Member 'UFortHeroType::AbilityKits' has a wrong offset!");
static_assert(offsetof(UFortHeroType, CombinedStatGEs) == 0x000350, "Member 'UFortHeroType::CombinedStatGEs' has a wrong offset!");
static_assert(offsetof(UFortHeroType, HeroItems) == 0x000360, "Member 'UFortHeroType::HeroItems' has a wrong offset!");
static_assert(offsetof(UFortHeroType, RequiredGPTags) == 0x000370, "Member 'UFortHeroType::RequiredGPTags' has a wrong offset!");
static_assert(offsetof(UFortHeroType, MaleOverrideFeedback) == 0x000390, "Member 'UFortHeroType::MaleOverrideFeedback' has a wrong offset!");
static_assert(offsetof(UFortHeroType, FemaleOverrideFeedback) == 0x0003B0, "Member 'UFortHeroType::FemaleOverrideFeedback' has a wrong offset!");
static_assert(offsetof(UFortHeroType, OverridePawnClass) == 0x0003D0, "Member 'UFortHeroType::OverridePawnClass' has a wrong offset!");
static_assert(offsetof(UFortHeroType, FrontEndAnimClass) == 0x0003F0, "Member 'UFortHeroType::FrontEndAnimClass' has a wrong offset!");
static_assert(offsetof(UFortHeroType, SubType) == 0x000410, "Member 'UFortHeroType::SubType' has a wrong offset!");
static_assert(offsetof(UFortHeroType, AttributeInitKey) == 0x000428, "Member 'UFortHeroType::AttributeInitKey' has a wrong offset!");
static_assert(offsetof(UFortHeroType, LegacyStatHandle) == 0x000438, "Member 'UFortHeroType::LegacyStatHandle' has a wrong offset!");

// Class FortniteGame.FortWorker
// 0x00C8 (0x0218 - 0x0150)
#pragma pack(push, 0x1)
class alignas(0x08) UFortWorker : public UFortCharacter
{
public:
	class FString                                 slotted_building_id;                               // 0x0150(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         building_slot_used;                                // 0x0160(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gender;                                            // 0x0164(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 personality;                                       // 0x0168(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 set_bonus;                                         // 0x0178(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Portrait;                                          // 0x0188(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  PersonalityTag;                                    // 0x0198(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  SetBonusTag;                                       // 0x01B8(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              SmallPreviewImageOverride;                         // 0x01D8(0x0020)(Edit, Transient, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UTexture2D>              LargePreviewImageOverride;                         // 0x01F8(0x0020)(Edit, Transient, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool GetSecondaryCategory(class FText* ItemCategoryText, struct FSlateBrush* ItemCategoryBrush, EFortBrushSize BrushSize) const;
	bool GetTertiaryCategory(class FText* ItemCategoryText, struct FSlateBrush* ItemCategoryBrush, EFortBrushSize BrushSize) const;
	class UFortWorkerType* GetWorkerTypeBP() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortWorker">();
	}
	static class UFortWorker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortWorker>();
	}
};
#pragma pack(pop)
static_assert(alignof(UFortWorker) == 0x000008, "Wrong alignment on UFortWorker");
static_assert(sizeof(UFortWorker) == 0x000218, "Wrong size on UFortWorker");
static_assert(offsetof(UFortWorker, slotted_building_id) == 0x000150, "Member 'UFortWorker::slotted_building_id' has a wrong offset!");
static_assert(offsetof(UFortWorker, building_slot_used) == 0x000160, "Member 'UFortWorker::building_slot_used' has a wrong offset!");
static_assert(offsetof(UFortWorker, Gender) == 0x000164, "Member 'UFortWorker::Gender' has a wrong offset!");
static_assert(offsetof(UFortWorker, personality) == 0x000168, "Member 'UFortWorker::personality' has a wrong offset!");
static_assert(offsetof(UFortWorker, set_bonus) == 0x000178, "Member 'UFortWorker::set_bonus' has a wrong offset!");
static_assert(offsetof(UFortWorker, Portrait) == 0x000188, "Member 'UFortWorker::Portrait' has a wrong offset!");
static_assert(offsetof(UFortWorker, PersonalityTag) == 0x000198, "Member 'UFortWorker::PersonalityTag' has a wrong offset!");
static_assert(offsetof(UFortWorker, SetBonusTag) == 0x0001B8, "Member 'UFortWorker::SetBonusTag' has a wrong offset!");
static_assert(offsetof(UFortWorker, SmallPreviewImageOverride) == 0x0001D8, "Member 'UFortWorker::SmallPreviewImageOverride' has a wrong offset!");
static_assert(offsetof(UFortWorker, LargePreviewImageOverride) == 0x0001F8, "Member 'UFortWorker::LargePreviewImageOverride' has a wrong offset!");

// Class FortniteGame.FortGameplayEffectUIData
// 0x0040 (0x0068 - 0x0028)
class UFortGameplayEffectUIData final : public UGameplayEffectUIData
{
public:
	class FText                                   DisplayName;                                       // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FString                                 TooltipName;                                       // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameplayEffectUIData">();
	}
	static class UFortGameplayEffectUIData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGameplayEffectUIData>();
	}
};
static_assert(alignof(UFortGameplayEffectUIData) == 0x000008, "Wrong alignment on UFortGameplayEffectUIData");
static_assert(sizeof(UFortGameplayEffectUIData) == 0x000068, "Wrong size on UFortGameplayEffectUIData");
static_assert(offsetof(UFortGameplayEffectUIData, DisplayName) == 0x000028, "Member 'UFortGameplayEffectUIData::DisplayName' has a wrong offset!");
static_assert(offsetof(UFortGameplayEffectUIData, Description) == 0x000040, "Member 'UFortGameplayEffectUIData::Description' has a wrong offset!");
static_assert(offsetof(UFortGameplayEffectUIData, TooltipName) == 0x000058, "Member 'UFortGameplayEffectUIData::TooltipName' has a wrong offset!");

// Class FortniteGame.MovementComp_Tracer
// 0x0008 (0x0140 - 0x0138)
class UMovementComp_Tracer final : public UMovementComponent
{
public:
	float                                         Speed;                                             // 0x0138(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovementComp_Tracer">();
	}
	static class UMovementComp_Tracer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovementComp_Tracer>();
	}
};
static_assert(alignof(UMovementComp_Tracer) == 0x000008, "Wrong alignment on UMovementComp_Tracer");
static_assert(sizeof(UMovementComp_Tracer) == 0x000140, "Wrong size on UMovementComp_Tracer");
static_assert(offsetof(UMovementComp_Tracer, Speed) == 0x000138, "Member 'UMovementComp_Tracer::Speed' has a wrong offset!");

// Class FortniteGame.FortHero
// 0x0078 (0x0290 - 0x0218)
class UFortHero final : public UFortWorker
{
public:
	class FString                                 hero_name;                                         // 0x0218(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         equipped_cosmetics;                                // 0x0228(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FFortSavedModeLoadout>          mode_loadouts;                                     // 0x0238(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UFortHeroSpecialization*>        Specializations;                                   // 0x0248(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UFortAbilityKit*>                SpecializationAbilityKits;                         // 0x0258(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UFortCharacterCosmeticItem*             CosmeticItem;                                      // 0x0268(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UCustomCharacterPart*>           CharacterParts;                                    // 0x0270(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_280[0x10];                                     // 0x0280(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FText GetDisplayName() const;
	class UFortHeroType* GetHeroTypeBP() const;
	int32 GetUnclampedLevel() const;
	bool IsLevelClamped() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortHero">();
	}
	static class UFortHero* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortHero>();
	}
};
static_assert(alignof(UFortHero) == 0x000008, "Wrong alignment on UFortHero");
static_assert(sizeof(UFortHero) == 0x000290, "Wrong size on UFortHero");
static_assert(offsetof(UFortHero, hero_name) == 0x000218, "Member 'UFortHero::hero_name' has a wrong offset!");
static_assert(offsetof(UFortHero, equipped_cosmetics) == 0x000228, "Member 'UFortHero::equipped_cosmetics' has a wrong offset!");
static_assert(offsetof(UFortHero, mode_loadouts) == 0x000238, "Member 'UFortHero::mode_loadouts' has a wrong offset!");
static_assert(offsetof(UFortHero, Specializations) == 0x000248, "Member 'UFortHero::Specializations' has a wrong offset!");
static_assert(offsetof(UFortHero, SpecializationAbilityKits) == 0x000258, "Member 'UFortHero::SpecializationAbilityKits' has a wrong offset!");
static_assert(offsetof(UFortHero, CosmeticItem) == 0x000268, "Member 'UFortHero::CosmeticItem' has a wrong offset!");
static_assert(offsetof(UFortHero, CharacterParts) == 0x000270, "Member 'UFortHero::CharacterParts' has a wrong offset!");

// Class FortniteGame.FortGameDeathPenalty
// 0x0078 (0x00A0 - 0x0028)
class UFortGameDeathPenalty final : public UDataAsset
{
public:
	float                                         PercentResourcesToDrop;                            // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PercentWeaponsToDrop;                              // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PercentCraftingIngredientsToDrop;                  // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PercentConsumablesToDrop;                          // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PercentAmmoToDrop;                                 // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PercentResourcesToRecover;                         // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PercentWeaponsToRecover;                           // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PercentCraftingIngredientsToRecover;               // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PercentConsumablesToRecover;                       // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PercentAmmoToRecover;                              // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinResourcesToKeep;                                // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinWeaponsToKeep;                                  // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinCraftingIngredientsToKeep;                      // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinConsumablesToKeep;                              // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinAmmoToKeep;                                     // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCurveTableRowHandle                   RespawnDelays;                                     // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            RespawnDelayOverTime;                              // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxRespawnDelay;                                   // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinSelfResurrectDelay;                             // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseRegenHealthOnRespawn;                          // 0x0088(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PercentHealthOnRespawn;                            // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PercentStaminaOnRespawn;                           // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RespawnDurabilityPenalty;                          // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SelfResurrectDurabilityPenalty;                    // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TeammateResurrectDurabilityPenalty;                // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameDeathPenalty">();
	}
	static class UFortGameDeathPenalty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGameDeathPenalty>();
	}
};
static_assert(alignof(UFortGameDeathPenalty) == 0x000008, "Wrong alignment on UFortGameDeathPenalty");
static_assert(sizeof(UFortGameDeathPenalty) == 0x0000A0, "Wrong size on UFortGameDeathPenalty");
static_assert(offsetof(UFortGameDeathPenalty, PercentResourcesToDrop) == 0x000028, "Member 'UFortGameDeathPenalty::PercentResourcesToDrop' has a wrong offset!");
static_assert(offsetof(UFortGameDeathPenalty, PercentWeaponsToDrop) == 0x00002C, "Member 'UFortGameDeathPenalty::PercentWeaponsToDrop' has a wrong offset!");
static_assert(offsetof(UFortGameDeathPenalty, PercentCraftingIngredientsToDrop) == 0x000030, "Member 'UFortGameDeathPenalty::PercentCraftingIngredientsToDrop' has a wrong offset!");
static_assert(offsetof(UFortGameDeathPenalty, PercentConsumablesToDrop) == 0x000034, "Member 'UFortGameDeathPenalty::PercentConsumablesToDrop' has a wrong offset!");
static_assert(offsetof(UFortGameDeathPenalty, PercentAmmoToDrop) == 0x000038, "Member 'UFortGameDeathPenalty::PercentAmmoToDrop' has a wrong offset!");
static_assert(offsetof(UFortGameDeathPenalty, PercentResourcesToRecover) == 0x00003C, "Member 'UFortGameDeathPenalty::PercentResourcesToRecover' has a wrong offset!");
static_assert(offsetof(UFortGameDeathPenalty, PercentWeaponsToRecover) == 0x000040, "Member 'UFortGameDeathPenalty::PercentWeaponsToRecover' has a wrong offset!");
static_assert(offsetof(UFortGameDeathPenalty, PercentCraftingIngredientsToRecover) == 0x000044, "Member 'UFortGameDeathPenalty::PercentCraftingIngredientsToRecover' has a wrong offset!");
static_assert(offsetof(UFortGameDeathPenalty, PercentConsumablesToRecover) == 0x000048, "Member 'UFortGameDeathPenalty::PercentConsumablesToRecover' has a wrong offset!");
static_assert(offsetof(UFortGameDeathPenalty, PercentAmmoToRecover) == 0x00004C, "Member 'UFortGameDeathPenalty::PercentAmmoToRecover' has a wrong offset!");
static_assert(offsetof(UFortGameDeathPenalty, MinResourcesToKeep) == 0x000050, "Member 'UFortGameDeathPenalty::MinResourcesToKeep' has a wrong offset!");
static_assert(offsetof(UFortGameDeathPenalty, MinWeaponsToKeep) == 0x000054, "Member 'UFortGameDeathPenalty::MinWeaponsToKeep' has a wrong offset!");
static_assert(offsetof(UFortGameDeathPenalty, MinCraftingIngredientsToKeep) == 0x000058, "Member 'UFortGameDeathPenalty::MinCraftingIngredientsToKeep' has a wrong offset!");
static_assert(offsetof(UFortGameDeathPenalty, MinConsumablesToKeep) == 0x00005C, "Member 'UFortGameDeathPenalty::MinConsumablesToKeep' has a wrong offset!");
static_assert(offsetof(UFortGameDeathPenalty, MinAmmoToKeep) == 0x000060, "Member 'UFortGameDeathPenalty::MinAmmoToKeep' has a wrong offset!");
static_assert(offsetof(UFortGameDeathPenalty, RespawnDelays) == 0x000068, "Member 'UFortGameDeathPenalty::RespawnDelays' has a wrong offset!");
static_assert(offsetof(UFortGameDeathPenalty, RespawnDelayOverTime) == 0x000078, "Member 'UFortGameDeathPenalty::RespawnDelayOverTime' has a wrong offset!");
static_assert(offsetof(UFortGameDeathPenalty, MaxRespawnDelay) == 0x000080, "Member 'UFortGameDeathPenalty::MaxRespawnDelay' has a wrong offset!");
static_assert(offsetof(UFortGameDeathPenalty, MinSelfResurrectDelay) == 0x000084, "Member 'UFortGameDeathPenalty::MinSelfResurrectDelay' has a wrong offset!");
static_assert(offsetof(UFortGameDeathPenalty, bUseRegenHealthOnRespawn) == 0x000088, "Member 'UFortGameDeathPenalty::bUseRegenHealthOnRespawn' has a wrong offset!");
static_assert(offsetof(UFortGameDeathPenalty, PercentHealthOnRespawn) == 0x00008C, "Member 'UFortGameDeathPenalty::PercentHealthOnRespawn' has a wrong offset!");
static_assert(offsetof(UFortGameDeathPenalty, PercentStaminaOnRespawn) == 0x000090, "Member 'UFortGameDeathPenalty::PercentStaminaOnRespawn' has a wrong offset!");
static_assert(offsetof(UFortGameDeathPenalty, RespawnDurabilityPenalty) == 0x000094, "Member 'UFortGameDeathPenalty::RespawnDurabilityPenalty' has a wrong offset!");
static_assert(offsetof(UFortGameDeathPenalty, SelfResurrectDurabilityPenalty) == 0x000098, "Member 'UFortGameDeathPenalty::SelfResurrectDurabilityPenalty' has a wrong offset!");
static_assert(offsetof(UFortGameDeathPenalty, TeammateResurrectDurabilityPenalty) == 0x00009C, "Member 'UFortGameDeathPenalty::TeammateResurrectDurabilityPenalty' has a wrong offset!");

// Class FortniteGame.FortQueryGenerator_MissionPlacementActors
// 0x0048 (0x0098 - 0x0050)
class UFortQueryGenerator_MissionPlacementActors final : public UEnvQueryGenerator
{
public:
	struct FGameplayTagQuery                      MissionPlacementActorTagQuery;                     // 0x0050(0x0048)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_MissionPlacementActors">();
	}
	static class UFortQueryGenerator_MissionPlacementActors* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_MissionPlacementActors>();
	}
};
static_assert(alignof(UFortQueryGenerator_MissionPlacementActors) == 0x000008, "Wrong alignment on UFortQueryGenerator_MissionPlacementActors");
static_assert(sizeof(UFortQueryGenerator_MissionPlacementActors) == 0x000098, "Wrong size on UFortQueryGenerator_MissionPlacementActors");
static_assert(offsetof(UFortQueryGenerator_MissionPlacementActors, MissionPlacementActorTagQuery) == 0x000050, "Member 'UFortQueryGenerator_MissionPlacementActors::MissionPlacementActorTagQuery' has a wrong offset!");

// Class FortniteGame.FortPlayerPawnAthena
// 0x0410 (0x1A90 - 0x1680)
class AFortPlayerPawnAthena : public AFortPlayerPawn
{
public:
	uint8                                         Pad_1680[0x8];                                     // 0x1680(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EFortGliderType                               GliderType;                                        // 0x1688(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1689[0x7];                                     // 0x1689(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortAthenaSimpleCar*                   Vehicle;                                           // 0x1690(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             OnParachuteOpen;                                   // 0x1698(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             OnParachuteClose;                                  // 0x16A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             OnUmbrellaOpen;                                    // 0x16A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             OnUmbrellaClose;                                   // 0x16B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             OnSkydivingLoop;                                   // 0x16B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             OnParachutingLoop;                                 // 0x16C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             OnReviveSound;                                     // 0x16C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchMeshOffset;                                  // 0x16D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReviveFromDBNOTime;                                // 0x16D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DBNOStartTime;                                     // 0x16D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DBNOInvulnerableTime;                              // 0x16DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DBNORevivalStacking;                               // 0x16E0(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16E1[0x7];                                     // 0x16E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            DirectionalSpeedMultiplierCurve;                   // 0x16E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ParachuteDirectionalSpeedMultiplierCurve;          // 0x16F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SkydivingDirectionalSpeedMultiplierCurve;          // 0x16F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1700[0x8];                                     // 0x1700(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnUIGameplayCue;                                   // 0x1708(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnDBNOStateChanged;                                // 0x1718(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class UAnimBlueprint*                         DrivingAnimBP;                                     // 0x1728(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAnimInstance>              PreDrivingAnimBP;                                  // 0x1730(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityRepAnimMontage         RepAnimMontageInfo;                                // 0x1738(0x0030)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	struct FReplicatedMontagePair                 LandingMontagePair;                                // 0x1768(0x0028)(Net, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1790[0x1];                                     // 0x1790(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          WeaponActivated;                                   // 0x1791(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1792[0x2];                                     // 0x1792(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PickupSpeedMultiplier;                             // 0x1794(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             DefaultCrouchedFootstepSound;                      // 0x1798(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             DefaultCrouchSprintFootstepSound;                  // 0x17A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOutsideSafeZone;                                // 0x17A8(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17A9[0x7];                                     // 0x17A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  KillerForSpectatorRotation;                        // 0x17B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPlayerPawnReady;                                // 0x17B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSkydiving;                                      // 0x17B9(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsParachuteOpen;                                  // 0x17BA(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsParachuteForcedOpen;                            // 0x17BB(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsBelowAutoDeployTestHeight;                      // 0x17BC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_17BD[0x43];                                    // 0x17BD(0x0043)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 MeshParachuteOpen;                                 // 0x1800(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMesh*                          MeshUmbrella;                                      // 0x1808(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstance*                      FounderUmbrellaMaterial;                           // 0x1810(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstance*                      FounderGliderMaterial;                             // 0x1818(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAnimInstance>              UmbrellaAnimClass;                                 // 0x1820(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ParachuteAttachSocket;                             // 0x1828(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FScalableFloat                         ParachuteDeployTraceForGroundDistance;             // 0x1830(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         ParachuteDeployVelocityBlend;                      // 0x1858(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	float                                         ParachuteCooldownToOpen;                           // 0x1880(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ParachuteCooldownToClose;                          // 0x1884(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bParachuteDeployFixedVerticalDistance;             // 0x1888(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1889[0x3];                                     // 0x1889(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OutsideSafeZoneBlendSpeed;                         // 0x188C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentOutsideSafeZonePPVBlend;                    // 0x1890(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetOutsideSafeZonePPVBlend;                     // 0x1894(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPostProcessComponent*                  OutsideSafeZonePPComponent;                        // 0x1898(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            SafeZoneAppliedGE;                                 // 0x18A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        ParachuteAudioLoop;                                // 0x18A8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        SkydiveAudioLoop;                                  // 0x18B0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        ConsumableUseAudio;                                // 0x18B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAthenaBatchedDamageGameplayCues       AccumulatedBatchData;                              // 0x18C0(0x0058)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCueParameters                 BatchedGameplayCueParameters;                      // 0x1918(0x00B8)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_19D0[0x70];                                    // 0x19D0(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastHealthPostProcessWeight;                       // 0x1A40(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HealthPostProcessStartTime;                        // 0x1A44(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HealthPostProcessMuteTime;                         // 0x1A48(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A4C[0x4];                                     // 0x1A4C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 MeshParachuteClosed;                               // 0x1A50(0x0008)(ExportObject, ZeroConstructor, InstancedReference, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   ParachuteMeshClosed;                               // 0x1A58(0x0008)(ExportObject, ZeroConstructor, InstancedReference, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   ParachuteMeshOpen;                                 // 0x1A60(0x0008)(ExportObject, ZeroConstructor, InstancedReference, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A68[0x28];                                    // 0x1A68(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MarkSafe(TSubclassOf<class UGameplayEffect> GEtoApply);
	void NetMulticast_Athena_BatchedDamageCues(const struct FAthenaBatchedDamageGameplayCues& BatchData);
	void NetMulticast_InvokeGameplayCueAdded(const struct FGameplayTag& GameplayCueTag, const struct FPredictionKey& PredictionKey, const struct FGameplayEffectContextHandle& EffectContext);
	void NetMulticast_InvokeGameplayCueAdded_WithParams(const struct FGameplayTag& GameplayCueTag, const struct FPredictionKey& PredictionKey, const struct FGameplayCueParameters& Parameters);
	void NetMulticast_InvokeGameplayCueAddedAndWhileActive_FromSpec(const struct FGameplayEffectSpecForRPC& Spec, const struct FPredictionKey& PredictionKey);
	void NetMulticast_InvokeGameplayCueAddedAndWhileActive_WithParams(const struct FGameplayTag& GameplayCueTag, const struct FPredictionKey& PredictionKey, const struct FGameplayCueParameters& GameplayCueParameters);
	void NetMulticast_InvokeGameplayCueExecuted(const struct FGameplayTag& GameplayCueTag, const struct FPredictionKey& PredictionKey, const struct FGameplayEffectContextHandle& EffectContext);
	void NetMulticast_InvokeGameplayCueExecuted_FromSpec(const struct FGameplayEffectSpecForRPC& Spec, const struct FPredictionKey& PredictionKey);
	void NetMulticast_InvokeGameplayCueExecuted_WithParams(const struct FGameplayTag& GameplayCueTag, const struct FPredictionKey& PredictionKey, const struct FGameplayCueParameters& GameplayCueParameters);
	void NetMulticast_InvokeGameplayCuesAddedAndWhileActive_WithParams(const struct FGameplayTagContainer& GameplayCueTags, const struct FPredictionKey& PredictionKey, const struct FGameplayCueParameters& GameplayCueParameters);
	void NetMulticast_InvokeGameplayCuesExecuted(const struct FGameplayTagContainer& GameplayCueTags, const struct FPredictionKey& PredictionKey, const struct FGameplayEffectContextHandle& EffectContext);
	void NetMulticast_InvokeGameplayCuesExecuted_WithParams(const struct FGameplayTagContainer& GameplayCueTags, const struct FPredictionKey& PredictionKey, const struct FGameplayCueParameters& GameplayCueParameters);
	void OnCapsuleBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnRep_DrivingCar();
	void OnRep_GliderType();
	void OnRep_IsOutsideSafeZone();
	void OnRep_IsParachuteOpen(bool bPreviousState);
	void OnRep_IsSkydiving(bool bPreviousState);
	void OnRep_ReplicatedAnimMontage();
	void OnRep_WeaponActivated();
	void SafeZoneStatusChanged();
	void StartConsumableUseAudio(class USoundBase* Sound);
	void StopConsumableUseAudio();

	bool IsActivelySkydiving() const;
	bool IsActivelyStrafingInAir() const;
	bool IsDrivingCar() const;
	bool IsParachuteForcedOpen() const;
	bool IsParachuteOpen() const;
	bool IsPassivelySkydiving() const;
	bool IsSkydiving() const;
	bool IsUsingUmbrella() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerPawnAthena">();
	}
	static class AFortPlayerPawnAthena* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerPawnAthena>();
	}
};
static_assert(alignof(AFortPlayerPawnAthena) == 0x000010, "Wrong alignment on AFortPlayerPawnAthena");
static_assert(sizeof(AFortPlayerPawnAthena) == 0x001A90, "Wrong size on AFortPlayerPawnAthena");
static_assert(offsetof(AFortPlayerPawnAthena, GliderType) == 0x001688, "Member 'AFortPlayerPawnAthena::GliderType' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, Vehicle) == 0x001690, "Member 'AFortPlayerPawnAthena::Vehicle' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, OnParachuteOpen) == 0x001698, "Member 'AFortPlayerPawnAthena::OnParachuteOpen' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, OnParachuteClose) == 0x0016A0, "Member 'AFortPlayerPawnAthena::OnParachuteClose' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, OnUmbrellaOpen) == 0x0016A8, "Member 'AFortPlayerPawnAthena::OnUmbrellaOpen' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, OnUmbrellaClose) == 0x0016B0, "Member 'AFortPlayerPawnAthena::OnUmbrellaClose' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, OnSkydivingLoop) == 0x0016B8, "Member 'AFortPlayerPawnAthena::OnSkydivingLoop' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, OnParachutingLoop) == 0x0016C0, "Member 'AFortPlayerPawnAthena::OnParachutingLoop' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, OnReviveSound) == 0x0016C8, "Member 'AFortPlayerPawnAthena::OnReviveSound' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, CrouchMeshOffset) == 0x0016D0, "Member 'AFortPlayerPawnAthena::CrouchMeshOffset' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, ReviveFromDBNOTime) == 0x0016D4, "Member 'AFortPlayerPawnAthena::ReviveFromDBNOTime' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, DBNOStartTime) == 0x0016D8, "Member 'AFortPlayerPawnAthena::DBNOStartTime' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, DBNOInvulnerableTime) == 0x0016DC, "Member 'AFortPlayerPawnAthena::DBNOInvulnerableTime' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, DBNORevivalStacking) == 0x0016E0, "Member 'AFortPlayerPawnAthena::DBNORevivalStacking' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, DirectionalSpeedMultiplierCurve) == 0x0016E8, "Member 'AFortPlayerPawnAthena::DirectionalSpeedMultiplierCurve' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, ParachuteDirectionalSpeedMultiplierCurve) == 0x0016F0, "Member 'AFortPlayerPawnAthena::ParachuteDirectionalSpeedMultiplierCurve' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, SkydivingDirectionalSpeedMultiplierCurve) == 0x0016F8, "Member 'AFortPlayerPawnAthena::SkydivingDirectionalSpeedMultiplierCurve' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, OnUIGameplayCue) == 0x001708, "Member 'AFortPlayerPawnAthena::OnUIGameplayCue' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, OnDBNOStateChanged) == 0x001718, "Member 'AFortPlayerPawnAthena::OnDBNOStateChanged' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, DrivingAnimBP) == 0x001728, "Member 'AFortPlayerPawnAthena::DrivingAnimBP' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, PreDrivingAnimBP) == 0x001730, "Member 'AFortPlayerPawnAthena::PreDrivingAnimBP' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, RepAnimMontageInfo) == 0x001738, "Member 'AFortPlayerPawnAthena::RepAnimMontageInfo' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, LandingMontagePair) == 0x001768, "Member 'AFortPlayerPawnAthena::LandingMontagePair' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, WeaponActivated) == 0x001791, "Member 'AFortPlayerPawnAthena::WeaponActivated' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, PickupSpeedMultiplier) == 0x001794, "Member 'AFortPlayerPawnAthena::PickupSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, DefaultCrouchedFootstepSound) == 0x001798, "Member 'AFortPlayerPawnAthena::DefaultCrouchedFootstepSound' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, DefaultCrouchSprintFootstepSound) == 0x0017A0, "Member 'AFortPlayerPawnAthena::DefaultCrouchSprintFootstepSound' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, bIsOutsideSafeZone) == 0x0017A8, "Member 'AFortPlayerPawnAthena::bIsOutsideSafeZone' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, KillerForSpectatorRotation) == 0x0017B0, "Member 'AFortPlayerPawnAthena::KillerForSpectatorRotation' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, bIsPlayerPawnReady) == 0x0017B8, "Member 'AFortPlayerPawnAthena::bIsPlayerPawnReady' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, bIsSkydiving) == 0x0017B9, "Member 'AFortPlayerPawnAthena::bIsSkydiving' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, bIsParachuteOpen) == 0x0017BA, "Member 'AFortPlayerPawnAthena::bIsParachuteOpen' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, bIsParachuteForcedOpen) == 0x0017BB, "Member 'AFortPlayerPawnAthena::bIsParachuteForcedOpen' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, bIsBelowAutoDeployTestHeight) == 0x0017BC, "Member 'AFortPlayerPawnAthena::bIsBelowAutoDeployTestHeight' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, MeshParachuteOpen) == 0x001800, "Member 'AFortPlayerPawnAthena::MeshParachuteOpen' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, MeshUmbrella) == 0x001808, "Member 'AFortPlayerPawnAthena::MeshUmbrella' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, FounderUmbrellaMaterial) == 0x001810, "Member 'AFortPlayerPawnAthena::FounderUmbrellaMaterial' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, FounderGliderMaterial) == 0x001818, "Member 'AFortPlayerPawnAthena::FounderGliderMaterial' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, UmbrellaAnimClass) == 0x001820, "Member 'AFortPlayerPawnAthena::UmbrellaAnimClass' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, ParachuteAttachSocket) == 0x001828, "Member 'AFortPlayerPawnAthena::ParachuteAttachSocket' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, ParachuteDeployTraceForGroundDistance) == 0x001830, "Member 'AFortPlayerPawnAthena::ParachuteDeployTraceForGroundDistance' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, ParachuteDeployVelocityBlend) == 0x001858, "Member 'AFortPlayerPawnAthena::ParachuteDeployVelocityBlend' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, ParachuteCooldownToOpen) == 0x001880, "Member 'AFortPlayerPawnAthena::ParachuteCooldownToOpen' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, ParachuteCooldownToClose) == 0x001884, "Member 'AFortPlayerPawnAthena::ParachuteCooldownToClose' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, bParachuteDeployFixedVerticalDistance) == 0x001888, "Member 'AFortPlayerPawnAthena::bParachuteDeployFixedVerticalDistance' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, OutsideSafeZoneBlendSpeed) == 0x00188C, "Member 'AFortPlayerPawnAthena::OutsideSafeZoneBlendSpeed' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, CurrentOutsideSafeZonePPVBlend) == 0x001890, "Member 'AFortPlayerPawnAthena::CurrentOutsideSafeZonePPVBlend' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, TargetOutsideSafeZonePPVBlend) == 0x001894, "Member 'AFortPlayerPawnAthena::TargetOutsideSafeZonePPVBlend' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, OutsideSafeZonePPComponent) == 0x001898, "Member 'AFortPlayerPawnAthena::OutsideSafeZonePPComponent' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, SafeZoneAppliedGE) == 0x0018A0, "Member 'AFortPlayerPawnAthena::SafeZoneAppliedGE' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, ParachuteAudioLoop) == 0x0018A8, "Member 'AFortPlayerPawnAthena::ParachuteAudioLoop' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, SkydiveAudioLoop) == 0x0018B0, "Member 'AFortPlayerPawnAthena::SkydiveAudioLoop' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, ConsumableUseAudio) == 0x0018B8, "Member 'AFortPlayerPawnAthena::ConsumableUseAudio' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, AccumulatedBatchData) == 0x0018C0, "Member 'AFortPlayerPawnAthena::AccumulatedBatchData' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, BatchedGameplayCueParameters) == 0x001918, "Member 'AFortPlayerPawnAthena::BatchedGameplayCueParameters' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, LastHealthPostProcessWeight) == 0x001A40, "Member 'AFortPlayerPawnAthena::LastHealthPostProcessWeight' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, HealthPostProcessStartTime) == 0x001A44, "Member 'AFortPlayerPawnAthena::HealthPostProcessStartTime' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, HealthPostProcessMuteTime) == 0x001A48, "Member 'AFortPlayerPawnAthena::HealthPostProcessMuteTime' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, MeshParachuteClosed) == 0x001A50, "Member 'AFortPlayerPawnAthena::MeshParachuteClosed' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, ParachuteMeshClosed) == 0x001A58, "Member 'AFortPlayerPawnAthena::ParachuteMeshClosed' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawnAthena, ParachuteMeshOpen) == 0x001A60, "Member 'AFortPlayerPawnAthena::ParachuteMeshOpen' has a wrong offset!");

// Class FortniteGame.FortExhibitActor
// 0x0048 (0x03D0 - 0x0388)
#pragma pack(push, 0x1)
class alignas(0x10) AFortExhibitActor : public AActor
{
public:
	uint8                                         Pad_388[0x8];                                      // 0x0388(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             CameraOffset;                                      // 0x0390(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         CameraFOV;                                         // 0x03C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C4[0x4];                                      // 0x03C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortExhibitActor">();
	}
	static class AFortExhibitActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortExhibitActor>();
	}
};
#pragma pack(pop)
static_assert(alignof(AFortExhibitActor) == 0x000010, "Wrong alignment on AFortExhibitActor");
static_assert(sizeof(AFortExhibitActor) == 0x0003D0, "Wrong size on AFortExhibitActor");
static_assert(offsetof(AFortExhibitActor, CameraOffset) == 0x000390, "Member 'AFortExhibitActor::CameraOffset' has a wrong offset!");
static_assert(offsetof(AFortExhibitActor, CameraFOV) == 0x0003C0, "Member 'AFortExhibitActor::CameraFOV' has a wrong offset!");

// Class FortniteGame.FortHeroExhibitActor
// 0x0010 (0x03E0 - 0x03D0)
class AFortHeroExhibitActor final : public AFortExhibitActor
{
public:
	class UFortHeroType*                          HeroType;                                          // 0x03C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortPlayerPawn*                        HeroExhibitPawn;                                   // 0x03D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D8[0x8];                                      // 0x03D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortHeroExhibitActor">();
	}
	static class AFortHeroExhibitActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortHeroExhibitActor>();
	}
};
static_assert(alignof(AFortHeroExhibitActor) == 0x000010, "Wrong alignment on AFortHeroExhibitActor");
static_assert(sizeof(AFortHeroExhibitActor) == 0x0003E0, "Wrong size on AFortHeroExhibitActor");
static_assert(offsetof(AFortHeroExhibitActor, HeroType) == 0x0003C8, "Member 'AFortHeroExhibitActor::HeroType' has a wrong offset!");
static_assert(offsetof(AFortHeroExhibitActor, HeroExhibitPawn) == 0x0003D0, "Member 'AFortHeroExhibitActor::HeroExhibitPawn' has a wrong offset!");

// Class FortniteGame.FortAnimNotify_PlayEmoteMusic
// 0x0000 (0x0058 - 0x0058)
class UFortAnimNotify_PlayEmoteMusic final : public UAnimNotify_PlaySound
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAnimNotify_PlayEmoteMusic">();
	}
	static class UFortAnimNotify_PlayEmoteMusic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAnimNotify_PlayEmoteMusic>();
	}
};
static_assert(alignof(UFortAnimNotify_PlayEmoteMusic) == 0x000008, "Wrong alignment on UFortAnimNotify_PlayEmoteMusic");
static_assert(sizeof(UFortAnimNotify_PlayEmoteMusic) == 0x000058, "Wrong size on UFortAnimNotify_PlayEmoteMusic");

// Class FortniteGame.FortFeedbackBank
// 0x00C0 (0x00E8 - 0x0028)
class UFortFeedbackBank final : public UPrimaryDataAsset
{
public:
	TArray<struct FFortFeedbackActionBankDefined> BankDefinedFeedbackEvents;                         // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FFortFeedbackAction>            FeedbackEvents;                                    // 0x0038(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0xA0];                                      // 0x0048(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortFeedbackBank">();
	}
	static class UFortFeedbackBank* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortFeedbackBank>();
	}
};
static_assert(alignof(UFortFeedbackBank) == 0x000008, "Wrong alignment on UFortFeedbackBank");
static_assert(sizeof(UFortFeedbackBank) == 0x0000E8, "Wrong size on UFortFeedbackBank");
static_assert(offsetof(UFortFeedbackBank, BankDefinedFeedbackEvents) == 0x000028, "Member 'UFortFeedbackBank::BankDefinedFeedbackEvents' has a wrong offset!");
static_assert(offsetof(UFortFeedbackBank, FeedbackEvents) == 0x000038, "Member 'UFortFeedbackBank::FeedbackEvents' has a wrong offset!");

// Class FortniteGame.FortAnimNotify_PlaySoundLocalOnly
// 0x0000 (0x0058 - 0x0058)
class UFortAnimNotify_PlaySoundLocalOnly final : public UAnimNotify_PlaySound
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAnimNotify_PlaySoundLocalOnly">();
	}
	static class UFortAnimNotify_PlaySoundLocalOnly* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAnimNotify_PlaySoundLocalOnly>();
	}
};
static_assert(alignof(UFortAnimNotify_PlaySoundLocalOnly) == 0x000008, "Wrong alignment on UFortAnimNotify_PlaySoundLocalOnly");
static_assert(sizeof(UFortAnimNotify_PlaySoundLocalOnly) == 0x000058, "Wrong size on UFortAnimNotify_PlaySoundLocalOnly");

// Class FortniteGame.FortAbilityKitTooltip
// 0x0000 (0x0090 - 0x0090)
class UFortAbilityKitTooltip final : public UFortTooltip
{
public:
	bool GetTextForToken(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, class FText* OutText) const;
	bool GetTokenizedDescriptionText(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, TArray<class FText>* OutDescription) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAbilityKitTooltip">();
	}
	static class UFortAbilityKitTooltip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAbilityKitTooltip>();
	}
};
static_assert(alignof(UFortAbilityKitTooltip) == 0x000008, "Wrong alignment on UFortAbilityKitTooltip");
static_assert(sizeof(UFortAbilityKitTooltip) == 0x000090, "Wrong size on UFortAbilityKitTooltip");

// Class FortniteGame.FortAnimNotify_TriggerGameplayAbility
// 0x0018 (0x0050 - 0x0038)
class UFortAnimNotify_TriggerGameplayAbility final : public UAnimNotify
{
public:
	struct FGameplayTag                           ApplicationTag;                                    // 0x0038(0x0008)(Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MontageSectionIfBlocked;                           // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetNextSectionIfBlocked;                          // 0x0048(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAnimNotify_TriggerGameplayAbility">();
	}
	static class UFortAnimNotify_TriggerGameplayAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAnimNotify_TriggerGameplayAbility>();
	}
};
static_assert(alignof(UFortAnimNotify_TriggerGameplayAbility) == 0x000008, "Wrong alignment on UFortAnimNotify_TriggerGameplayAbility");
static_assert(sizeof(UFortAnimNotify_TriggerGameplayAbility) == 0x000050, "Wrong size on UFortAnimNotify_TriggerGameplayAbility");
static_assert(offsetof(UFortAnimNotify_TriggerGameplayAbility, ApplicationTag) == 0x000038, "Member 'UFortAnimNotify_TriggerGameplayAbility::ApplicationTag' has a wrong offset!");
static_assert(offsetof(UFortAnimNotify_TriggerGameplayAbility, MontageSectionIfBlocked) == 0x000040, "Member 'UFortAnimNotify_TriggerGameplayAbility::MontageSectionIfBlocked' has a wrong offset!");
static_assert(offsetof(UFortAnimNotify_TriggerGameplayAbility, bSetNextSectionIfBlocked) == 0x000048, "Member 'UFortAnimNotify_TriggerGameplayAbility::bSetNextSectionIfBlocked' has a wrong offset!");

// Class FortniteGame.FortAnimNotifyState_AbilityDecisionWindow
// 0x0048 (0x0078 - 0x0030)
class UFortAnimNotifyState_AbilityDecisionWindow final : public UAnimNotifyState
{
public:
	struct FFortMontageInputAction                PrimaryInput;                                      // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FFortMontageInputAction                SecondaryInput;                                    // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   DefaultNextSection;                                // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrimaryInputStrikeAngle;                           // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondaryInputStrikeAngle;                         // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ComboCounter;                                      // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAnimNotifyState_AbilityDecisionWindow">();
	}
	static class UFortAnimNotifyState_AbilityDecisionWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAnimNotifyState_AbilityDecisionWindow>();
	}
};
static_assert(alignof(UFortAnimNotifyState_AbilityDecisionWindow) == 0x000008, "Wrong alignment on UFortAnimNotifyState_AbilityDecisionWindow");
static_assert(sizeof(UFortAnimNotifyState_AbilityDecisionWindow) == 0x000078, "Wrong size on UFortAnimNotifyState_AbilityDecisionWindow");
static_assert(offsetof(UFortAnimNotifyState_AbilityDecisionWindow, PrimaryInput) == 0x000030, "Member 'UFortAnimNotifyState_AbilityDecisionWindow::PrimaryInput' has a wrong offset!");
static_assert(offsetof(UFortAnimNotifyState_AbilityDecisionWindow, SecondaryInput) == 0x000048, "Member 'UFortAnimNotifyState_AbilityDecisionWindow::SecondaryInput' has a wrong offset!");
static_assert(offsetof(UFortAnimNotifyState_AbilityDecisionWindow, DefaultNextSection) == 0x000060, "Member 'UFortAnimNotifyState_AbilityDecisionWindow::DefaultNextSection' has a wrong offset!");
static_assert(offsetof(UFortAnimNotifyState_AbilityDecisionWindow, PrimaryInputStrikeAngle) == 0x000068, "Member 'UFortAnimNotifyState_AbilityDecisionWindow::PrimaryInputStrikeAngle' has a wrong offset!");
static_assert(offsetof(UFortAnimNotifyState_AbilityDecisionWindow, SecondaryInputStrikeAngle) == 0x00006C, "Member 'UFortAnimNotifyState_AbilityDecisionWindow::SecondaryInputStrikeAngle' has a wrong offset!");
static_assert(offsetof(UFortAnimNotifyState_AbilityDecisionWindow, ComboCounter) == 0x000070, "Member 'UFortAnimNotifyState_AbilityDecisionWindow::ComboCounter' has a wrong offset!");

// Class FortniteGame.FortAnimNotifyState_AllowBlockedActions
// 0x0000 (0x0030 - 0x0030)
class UFortAnimNotifyState_AllowBlockedActions final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAnimNotifyState_AllowBlockedActions">();
	}
	static class UFortAnimNotifyState_AllowBlockedActions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAnimNotifyState_AllowBlockedActions>();
	}
};
static_assert(alignof(UFortAnimNotifyState_AllowBlockedActions) == 0x000008, "Wrong alignment on UFortAnimNotifyState_AllowBlockedActions");
static_assert(sizeof(UFortAnimNotifyState_AllowBlockedActions) == 0x000030, "Wrong size on UFortAnimNotifyState_AllowBlockedActions");

// Class FortniteGame.FortAnimNotifyState_RootMotionInterrupt
// 0x0008 (0x0038 - 0x0030)
class UFortAnimNotifyState_RootMotionInterrupt final : public UAnimNotifyState
{
public:
	EMontageInterrupt                             MontageInterrupt;                                  // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bAllowMoveInput : 1;                               // 0x0034(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAnimNotifyState_RootMotionInterrupt">();
	}
	static class UFortAnimNotifyState_RootMotionInterrupt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAnimNotifyState_RootMotionInterrupt>();
	}
};
static_assert(alignof(UFortAnimNotifyState_RootMotionInterrupt) == 0x000008, "Wrong alignment on UFortAnimNotifyState_RootMotionInterrupt");
static_assert(sizeof(UFortAnimNotifyState_RootMotionInterrupt) == 0x000038, "Wrong size on UFortAnimNotifyState_RootMotionInterrupt");
static_assert(offsetof(UFortAnimNotifyState_RootMotionInterrupt, MontageInterrupt) == 0x000030, "Member 'UFortAnimNotifyState_RootMotionInterrupt::MontageInterrupt' has a wrong offset!");

// Class FortniteGame.FortAssetManager
// 0x01C0 (0x0570 - 0x03B0)
class UFortAssetManager final : public UAssetManager
{
public:
	TMap<class UObject*, class FName>             GCPreventionPool;                                  // 0x03B0(0x0050)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_400[0x10];                                     // 0x0400(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           DefaultBundleState;                                // 0x0410(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class FName>                           PlatformBundleState;                               // 0x0420(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UFortGameData*                          GameData;                                          // 0x0430(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 GameDataName;                                      // 0x0438(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 FastCookTheaterPath;                               // 0x0448(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 ActiveTheaterListPath;                             // 0x0458(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 TestTheaterListPath;                               // 0x0468(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bForceLoadConstructorReferencesAtStartup;          // 0x0478(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_479[0xF7];                                     // 0x0479(0x00F7)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAssetManager">();
	}
	static class UFortAssetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAssetManager>();
	}
};
static_assert(alignof(UFortAssetManager) == 0x000008, "Wrong alignment on UFortAssetManager");
static_assert(sizeof(UFortAssetManager) == 0x000570, "Wrong size on UFortAssetManager");
static_assert(offsetof(UFortAssetManager, GCPreventionPool) == 0x0003B0, "Member 'UFortAssetManager::GCPreventionPool' has a wrong offset!");
static_assert(offsetof(UFortAssetManager, DefaultBundleState) == 0x000410, "Member 'UFortAssetManager::DefaultBundleState' has a wrong offset!");
static_assert(offsetof(UFortAssetManager, PlatformBundleState) == 0x000420, "Member 'UFortAssetManager::PlatformBundleState' has a wrong offset!");
static_assert(offsetof(UFortAssetManager, GameData) == 0x000430, "Member 'UFortAssetManager::GameData' has a wrong offset!");
static_assert(offsetof(UFortAssetManager, GameDataName) == 0x000438, "Member 'UFortAssetManager::GameDataName' has a wrong offset!");
static_assert(offsetof(UFortAssetManager, FastCookTheaterPath) == 0x000448, "Member 'UFortAssetManager::FastCookTheaterPath' has a wrong offset!");
static_assert(offsetof(UFortAssetManager, ActiveTheaterListPath) == 0x000458, "Member 'UFortAssetManager::ActiveTheaterListPath' has a wrong offset!");
static_assert(offsetof(UFortAssetManager, TestTheaterListPath) == 0x000468, "Member 'UFortAssetManager::TestTheaterListPath' has a wrong offset!");
static_assert(offsetof(UFortAssetManager, bForceLoadConstructorReferencesAtStartup) == 0x000478, "Member 'UFortAssetManager::bForceLoadConstructorReferencesAtStartup' has a wrong offset!");

// Class FortniteGame.FortAsyncAction_AbandonSession
// 0x0030 (0x0058 - 0x0028)
class UFortAsyncAction_AbandonSession final : public UBlueprintAsyncActionBase
{
public:
	UMulticastDelegateProperty_                   OnSuccess;                                         // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFailure;                                         // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AFortPlayerController*                  PlayerController;                                  // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UFortAsyncAction_AbandonSession* AbandonSession(class AFortPlayerController* PlayerController_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAsyncAction_AbandonSession">();
	}
	static class UFortAsyncAction_AbandonSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAsyncAction_AbandonSession>();
	}
};
static_assert(alignof(UFortAsyncAction_AbandonSession) == 0x000008, "Wrong alignment on UFortAsyncAction_AbandonSession");
static_assert(sizeof(UFortAsyncAction_AbandonSession) == 0x000058, "Wrong size on UFortAsyncAction_AbandonSession");
static_assert(offsetof(UFortAsyncAction_AbandonSession, OnSuccess) == 0x000028, "Member 'UFortAsyncAction_AbandonSession::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_AbandonSession, OnFailure) == 0x000038, "Member 'UFortAsyncAction_AbandonSession::OnFailure' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_AbandonSession, PlayerController) == 0x000048, "Member 'UFortAsyncAction_AbandonSession::PlayerController' has a wrong offset!");

// Class FortniteGame.FortGameState
// 0x0450 (0x0838 - 0x03E8)
#pragma pack(push, 0x1)
class alignas(0x08) AFortGameState : public AGameState
{
public:
	class FString                                 CurrentWUID;                                       // 0x03E8(0x0010)(Net, ZeroConstructor, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ParTime;                                           // 0x03F8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WorldLevel;                                        // 0x03FC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CraftingBonus;                                     // 0x0400(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentReadyToContinueTimer;                       // 0x0404(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamCount;                                         // 0x0408(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamSize;                                          // 0x040C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_410[0x18];                                     // 0x0410(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bSkipWorldSave;                                    // 0x0428(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_429[0x77];                                     // 0x0429(0x0077)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         WorldDaysElapsed;                                  // 0x04A0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A4[0x7C];                                     // 0x04A4(0x007C)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortFeedbackManager*                   FeedbackManager;                                   // 0x0520(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortMissionManager*                    MissionManager;                                    // 0x0528(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortClientAnnouncementManager*         AnnouncementManager;                               // 0x0530(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortScriptedActionManager*             ScriptedActionManager;                             // 0x0538(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortLobbyBeaconState*                  LobbyGameState;                                    // 0x0540(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortWorldManager*                      WorldManager;                                      // 0x0548(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortTimeOfDayManager*                  FortTimeOfDayManager;                              // 0x0550(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortGameplayState                            GameplayState;                                     // 0x0558(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_559[0x7];                                      // 0x0559(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 GameSessionID;                                     // 0x0560(0x0010)(Net, ZeroConstructor, RepNotify, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UFortMovementComp_Character*>    ManagedCharMovementComponents;                     // 0x0570(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class AFortAIPawn*>                    ManagedAnimPawns;                                  // 0x0580(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UFortMovementComp_Character*>    ManagedCharMovementComponentsCopy;                 // 0x0590(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FOnTimeHitInfo>                 TimeOfDayCallbacks;                                // 0x05A0(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class AFortVisibilityManager*                 VisibilityManager;                                 // 0x05B0(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortFXManager*                         FXManager;                                         // 0x05B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFortWindManager*                       WindManager;                                       // 0x05C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AFortTeamInfo*>                  Teams;                                             // 0x05C8(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	bool                                          bSkipTeamReplication;                              // 0x05D8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D9[0x7];                                      // 0x05D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTeamChangeRequest>             PendingTeamChangeRequests;                         // 0x05E0(0x0010)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bAllowPendingTeamChangeRequests;                   // 0x05F0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F1[0x15F];                                    // 0x05F1(0x015F)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortGlobalAbilityTargetingActor*       GlobalAbilityTargetingActor;                       // 0x0750(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_758[0x50];                                     // 0x0758(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAppliedHomebaseData>           AppliedHomebaseDataArray;                          // 0x07A8(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_7B8[0x80];                                     // 0x07B8(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_InitiateEndOfDayRecap(const struct FEndOfDayRecap& EndOfDayRecap);
	void DemoEndOfDayRecap();
	void OnRep_AnnouncementManager();
	void OnRep_CurrentWUID();
	void OnRep_FeedbackManager();
	void OnRep_GameplayState();
	void OnRep_GameSessionID();
	void OnRep_MissionManager();
	void OnRep_Teams();
	void OnRep_TimeOfDayManager();
	void OnRep_WorldDaysElapsed();
	void OnRep_WorldManager();

	EFortGameplayState GetGameplayState() const;
	class AFortTimeOfDayManager* GetTimeOfDayManager() const;
	int32 GetWorldDaysElapsed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameState">();
	}
	static class AFortGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGameState>();
	}
};
#pragma pack(pop)
static_assert(alignof(AFortGameState) == 0x000008, "Wrong alignment on AFortGameState");
static_assert(sizeof(AFortGameState) == 0x000838, "Wrong size on AFortGameState");
static_assert(offsetof(AFortGameState, CurrentWUID) == 0x0003E8, "Member 'AFortGameState::CurrentWUID' has a wrong offset!");
static_assert(offsetof(AFortGameState, ParTime) == 0x0003F8, "Member 'AFortGameState::ParTime' has a wrong offset!");
static_assert(offsetof(AFortGameState, WorldLevel) == 0x0003FC, "Member 'AFortGameState::WorldLevel' has a wrong offset!");
static_assert(offsetof(AFortGameState, CraftingBonus) == 0x000400, "Member 'AFortGameState::CraftingBonus' has a wrong offset!");
static_assert(offsetof(AFortGameState, CurrentReadyToContinueTimer) == 0x000404, "Member 'AFortGameState::CurrentReadyToContinueTimer' has a wrong offset!");
static_assert(offsetof(AFortGameState, TeamCount) == 0x000408, "Member 'AFortGameState::TeamCount' has a wrong offset!");
static_assert(offsetof(AFortGameState, TeamSize) == 0x00040C, "Member 'AFortGameState::TeamSize' has a wrong offset!");
static_assert(offsetof(AFortGameState, bSkipWorldSave) == 0x000428, "Member 'AFortGameState::bSkipWorldSave' has a wrong offset!");
static_assert(offsetof(AFortGameState, WorldDaysElapsed) == 0x0004A0, "Member 'AFortGameState::WorldDaysElapsed' has a wrong offset!");
static_assert(offsetof(AFortGameState, FeedbackManager) == 0x000520, "Member 'AFortGameState::FeedbackManager' has a wrong offset!");
static_assert(offsetof(AFortGameState, MissionManager) == 0x000528, "Member 'AFortGameState::MissionManager' has a wrong offset!");
static_assert(offsetof(AFortGameState, AnnouncementManager) == 0x000530, "Member 'AFortGameState::AnnouncementManager' has a wrong offset!");
static_assert(offsetof(AFortGameState, ScriptedActionManager) == 0x000538, "Member 'AFortGameState::ScriptedActionManager' has a wrong offset!");
static_assert(offsetof(AFortGameState, LobbyGameState) == 0x000540, "Member 'AFortGameState::LobbyGameState' has a wrong offset!");
static_assert(offsetof(AFortGameState, WorldManager) == 0x000548, "Member 'AFortGameState::WorldManager' has a wrong offset!");
static_assert(offsetof(AFortGameState, FortTimeOfDayManager) == 0x000550, "Member 'AFortGameState::FortTimeOfDayManager' has a wrong offset!");
static_assert(offsetof(AFortGameState, GameplayState) == 0x000558, "Member 'AFortGameState::GameplayState' has a wrong offset!");
static_assert(offsetof(AFortGameState, GameSessionID) == 0x000560, "Member 'AFortGameState::GameSessionID' has a wrong offset!");
static_assert(offsetof(AFortGameState, ManagedCharMovementComponents) == 0x000570, "Member 'AFortGameState::ManagedCharMovementComponents' has a wrong offset!");
static_assert(offsetof(AFortGameState, ManagedAnimPawns) == 0x000580, "Member 'AFortGameState::ManagedAnimPawns' has a wrong offset!");
static_assert(offsetof(AFortGameState, ManagedCharMovementComponentsCopy) == 0x000590, "Member 'AFortGameState::ManagedCharMovementComponentsCopy' has a wrong offset!");
static_assert(offsetof(AFortGameState, TimeOfDayCallbacks) == 0x0005A0, "Member 'AFortGameState::TimeOfDayCallbacks' has a wrong offset!");
static_assert(offsetof(AFortGameState, VisibilityManager) == 0x0005B0, "Member 'AFortGameState::VisibilityManager' has a wrong offset!");
static_assert(offsetof(AFortGameState, FXManager) == 0x0005B8, "Member 'AFortGameState::FXManager' has a wrong offset!");
static_assert(offsetof(AFortGameState, WindManager) == 0x0005C0, "Member 'AFortGameState::WindManager' has a wrong offset!");
static_assert(offsetof(AFortGameState, Teams) == 0x0005C8, "Member 'AFortGameState::Teams' has a wrong offset!");
static_assert(offsetof(AFortGameState, bSkipTeamReplication) == 0x0005D8, "Member 'AFortGameState::bSkipTeamReplication' has a wrong offset!");
static_assert(offsetof(AFortGameState, PendingTeamChangeRequests) == 0x0005E0, "Member 'AFortGameState::PendingTeamChangeRequests' has a wrong offset!");
static_assert(offsetof(AFortGameState, bAllowPendingTeamChangeRequests) == 0x0005F0, "Member 'AFortGameState::bAllowPendingTeamChangeRequests' has a wrong offset!");
static_assert(offsetof(AFortGameState, GlobalAbilityTargetingActor) == 0x000750, "Member 'AFortGameState::GlobalAbilityTargetingActor' has a wrong offset!");
static_assert(offsetof(AFortGameState, AppliedHomebaseDataArray) == 0x0007A8, "Member 'AFortGameState::AppliedHomebaseDataArray' has a wrong offset!");

// Class FortniteGame.FortGameStateFrontEnd
// 0x0008 (0x0840 - 0x0838)
class AFortGameStateFrontEnd final : public AFortGameState
{
public:
	uint8                                         Pad_838[0x8];                                      // 0x0838(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameStateFrontEnd">();
	}
	static class AFortGameStateFrontEnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGameStateFrontEnd>();
	}
};
static_assert(alignof(AFortGameStateFrontEnd) == 0x000008, "Wrong alignment on AFortGameStateFrontEnd");
static_assert(sizeof(AFortGameStateFrontEnd) == 0x000840, "Wrong size on AFortGameStateFrontEnd");

// Class FortniteGame.FortAsyncAction_CheckForUpdate
// 0x0038 (0x0060 - 0x0028)
class UFortAsyncAction_CheckForUpdate final : public UBlueprintAsyncActionBase
{
public:
	UMulticastDelegateProperty_                   OnUpToDate;                                        // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnUpdateRequired;                                  // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UObject*                                WorldContextObject;                                // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShowDialogOnFailure;                              // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_51[0xF];                                       // 0x0051(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UFortAsyncAction_CheckForUpdate* CheckForUpdate(class UObject* InWorldContextObject, bool InShowDialogOnFailure);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAsyncAction_CheckForUpdate">();
	}
	static class UFortAsyncAction_CheckForUpdate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAsyncAction_CheckForUpdate>();
	}
};
static_assert(alignof(UFortAsyncAction_CheckForUpdate) == 0x000008, "Wrong alignment on UFortAsyncAction_CheckForUpdate");
static_assert(sizeof(UFortAsyncAction_CheckForUpdate) == 0x000060, "Wrong size on UFortAsyncAction_CheckForUpdate");
static_assert(offsetof(UFortAsyncAction_CheckForUpdate, OnUpToDate) == 0x000028, "Member 'UFortAsyncAction_CheckForUpdate::OnUpToDate' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_CheckForUpdate, OnUpdateRequired) == 0x000038, "Member 'UFortAsyncAction_CheckForUpdate::OnUpdateRequired' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_CheckForUpdate, WorldContextObject) == 0x000048, "Member 'UFortAsyncAction_CheckForUpdate::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_CheckForUpdate, bShowDialogOnFailure) == 0x000050, "Member 'UFortAsyncAction_CheckForUpdate::bShowDialogOnFailure' has a wrong offset!");

// Class FortniteGame.FortGameStateZone
// 0x09D8 (0x1210 - 0x0838)
class AFortGameStateZone : public AFortGameState
{
public:
	int32                                         PawnIDCount;                                       // 0x0838(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WaitingToLeaveZoneTimeLeft;                        // 0x083C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HostilityMeterPercent;                             // 0x0840(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IntensityPercent;                                  // 0x0844(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpawnPointsCap;                                    // 0x0848(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpawnPointsAllocated;                              // 0x084C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTotalAI;                                        // 0x0850(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxEncounterAI;                                    // 0x0854(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxEncounterSP;                                    // 0x0858(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerBuildingSkillLevel;                          // 0x085C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<float>                                 PlayerSharedMaxTrapAttributes;                     // 0x0860(0x0010)(Net, ZeroConstructor, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	TArray<class UObject*>                        GameplayMutatorObservers;                          // 0x0870(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_880[0x180];                                    // 0x0880(0x0180)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  ExplicitGloballyBlockedAbilityTags;                // 0x0A00(0x0020)(Net, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A20[0x264];                                    // 0x0A20(0x0264)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TotalPlayerStructures;                             // 0x0C84(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxPlayerStructures;                               // 0x0C88(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8C[0x74];                                     // 0x0C8C(0x0074)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortGlobalEnvironmentAbilityActor*     GlobalEnvironmentAbilityActor;                     // 0x0D00(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UFortAbilitySystemComponent*>    GlobalGameplayEventListeners;                      // 0x0D08(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FActiveGameplayModifierArray           ActiveGameplayModifiers;                           // 0x0D18(0x00C8)(Net, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	bool                                          bSupportRuntimeShutdownOfGameplayModifiers;        // 0x0DE0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DE1[0x7];                                      // 0x0DE1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBuildingStructuralSupportSystem*       StructuralSupportSystem;                           // 0x0DE8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDataTableRowHandle                    ZoneDifficultyInfoRow;                             // 0x0DF0(0x0010)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UFortZoneTheme*                         ZoneTheme;                                         // 0x0E00(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   MissionGeneratorClass;                             // 0x0E08(0x0020)(Net, Transient, RepNotify, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FFortItemQuantityPair>          MissionRewards;                                    // 0x0E28(0x0010)(Net, ZeroConstructor, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortItemQuantityPair>          MissionAlertRewards;                               // 0x0E38(0x0010)(Net, ZeroConstructor, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_E48[0x158];                                    // 0x0E48(0x0158)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortThreatVisualsManager*              ThreatVisualsManager;                              // 0x0FA0(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFortThreatParticleActor*               ThreatParticleActor;                               // 0x0FA8(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDrawRunVariationDebug;                            // 0x0FB0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FB1[0x7];                                      // 0x0FB1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AFortAIPawn*>                    PawnVariationList;                                 // 0x0FB8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	int32                                         VariationIndex;                                    // 0x0FC8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         GameDifficulty;                                    // 0x0FCC(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FD0[0x4];                                      // 0x0FD0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsGroupContent;                                   // 0x0FD4(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FD5[0x3];                                      // 0x0FD5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bAllowedToUpdateBackendDifficulty : 1;             // 0x0FD8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_FD9[0x17];                                     // 0x0FD9(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayerBuildableClassContainer         PlayerBuildableClasses[0x4];                       // 0x0FF0(0x0010)(Transient, Protected, NativeAccessSpecifierProtected)
	class AFortInGameMapManager*                  UIMapManager;                                      // 0x1030(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnScoreTotalsChanged;                              // 0x1038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FName                                   ScoringTableRowName;                               // 0x1048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TotalCombatScore;                                  // 0x1050(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TotalBuildingScore;                                // 0x1054(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TotalUtilityScore;                                 // 0x1058(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_105C[0x4];                                     // 0x105C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TheaterUniqueId;                                   // 0x1060(0x0010)(Net, ZeroConstructor, RepNotify, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 MissionLogDebugString;                             // 0x1070(0x0010)(Net, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1080[0x70];                                    // 0x1080(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bAllowBuildingCostMods : 1;                        // 0x10F0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bFreeBuildingRepairs : 1;                          // 0x10F0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_10F1[0x3];                                     // 0x10F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAllowBuildingAtLayoutRequirements;                // 0x10F4(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowBuildingWithoutLayoutRequirements;           // 0x10F5(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10F6[0x2];                                     // 0x10F6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AFortAIPawn*>                    DeployedDefenders;                                 // 0x10F8(0x0010)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1108[0x50];                                    // 0x1108(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumSurvivorsSpawned;                               // 0x1158(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumSurvivorsDead;                                  // 0x115C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumSurvivorsRescued;                               // 0x1160(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1164[0x4];                                     // 0x1164(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnNumSurvivorsRescuedChangedDelegate;              // 0x1168(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1178[0x18];                                    // 0x1178(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UnplayableHitchThresholdInMs;                      // 0x1190(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MaxUnplayableHitchesToTolerate;                    // 0x1194(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1198[0x28];                                    // 0x1198(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnGameplayVotes;                                   // 0x11C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnGameplayVoteBeginning;                           // 0x11D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnGameplayVoteEnded;                               // 0x11E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TArray<struct FVoter>                         GameplayVotes;                                     // 0x11F0(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1200[0x10];                                    // 0x1200(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyPlayerAbilityRestriction();
	void BeginGameplayVote();
	void EndGameplayVote();
	class AFortInGameMapManager* GetUIMapManager();
	void GloballyBlockAbilitiesWithTags(const struct FGameplayTagContainer& TagsToBlock);
	void GloballyUnblockAbilitiesWithTags(const struct FGameplayTagContainer& TagsToUnblock);
	void NotifyBeginGameplayVote();
	void NotifyEndGameplayVote();
	void NotifySurvivorDead();
	void NotifySurvivorRescued(class AFortPlayerController* Rescuer, const class FString& SurvivorName);
	void NotifySurvivorSpawned();
	void OnDefenderDeployed(class AFortAIPawn* Defender);
	void OnDefenderRemoved(class AFortAIPawn* Defender);
	void OnRep_ActiveGameplayModifiers();
	void OnRep_GameDifficulty();
	void OnRep_GameplayVotes();
	void OnRep_MissionAlertRewards();
	void OnRep_MissionGenerator();
	void OnRep_MissionRewards();
	void OnRep_NumSurvivorsRescued();
	void OnRep_PlayerBuildingSkillLevel();
	void OnRep_PlayerSharedTrapAttributes();
	void OnRep_PlayerStructuresChanged();
	void OnRep_TheaterUniqueId();
	void OnRep_ZoneDifficultyInfoRow();
	void OnWaveBasedModifiersAppliedMulticast(const TArray<class UFortGameplayModifierItemDefinition*>& ModifiersApplied);
	void OnWaveEncounterStarted(const struct FTieredWaveSetData& WaveData, const class FText& LevelText, int32 Level, const class FText& WaveText, int32 WaveNum);
	void OnWaveStart(const class FText& LevelText, int32 Level, const class FText& WaveText, int32 WaveNum);
	struct FActiveGameplayModifierHandle RegisterGameplayModifier(const class UFortGameplayModifierItemDefinition* InModifierToRegister, int32 Expiration);
	void RemovePlayerAbilityRestriction();
	void RunPerfMemCheatScript(bool bStartStatFiles);
	void ServerFireAIDirectorEvent(EFortAIDirectorEvent Event, class UObject* EventSource, class UObject* EventTarget, float EventMultiplier);
	void ServerFireAIDirectorEventBatch(const TArray<struct FFortAIDirectorEvent>& Payload);
	void SetBuildingAllowed(bool bBuildingAtLayoutRequirementsAllowed, bool bBuildingWithoutLayoutRequirementsAllowed);
	void SubmitGameplayVote(int32 VoteDecision);
	void UnregisterGameplayModifier(const struct FActiveGameplayModifierHandle& InHandleToUnregister);

	bool CanSpawnDefender(class AFortPlayerStateZone* PlayerCausingRemoval, const class FName& RemoveFromDefenderSquadId, class AFortAIPawn** OutDefenderToBeRemoved) const;
	void GetActiveModifiers(TArray<class UFortGameplayModifierItemDefinition*>* OutActiveModifiers) const;
	float GetGameDifficulty() const;
	TArray<struct FUniqueNetIdRepl> GetGameplayVotesForChoice(int32 VoteDecision) const;
	int32 GetNumSurvivorsDead() const;
	int32 GetNumSurvivorsRescued() const;
	int32 GetNumSurvivorsSpawned() const;
	int32 GetTotalScore(EStatCategory ScoreCategory) const;
	bool HasActiveGameplayModifiers() const;
	bool IsBuildingAtLayoutRequirementsAllowed() const;
	bool IsBuildingWithoutLayoutRequirementsAllowed() const;
	bool IsDefenderItemDeployed(class UFortItem* DefenderItem, class AFortPlayerStateZone* RequestingPlayer) const;
	bool ShouldDisablePlayerTeleportingDuringMissionResults() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameStateZone">();
	}
	static class AFortGameStateZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGameStateZone>();
	}
};
static_assert(alignof(AFortGameStateZone) == 0x000008, "Wrong alignment on AFortGameStateZone");
static_assert(sizeof(AFortGameStateZone) == 0x001210, "Wrong size on AFortGameStateZone");
static_assert(offsetof(AFortGameStateZone, PawnIDCount) == 0x000838, "Member 'AFortGameStateZone::PawnIDCount' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, WaitingToLeaveZoneTimeLeft) == 0x00083C, "Member 'AFortGameStateZone::WaitingToLeaveZoneTimeLeft' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, HostilityMeterPercent) == 0x000840, "Member 'AFortGameStateZone::HostilityMeterPercent' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, IntensityPercent) == 0x000844, "Member 'AFortGameStateZone::IntensityPercent' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, SpawnPointsCap) == 0x000848, "Member 'AFortGameStateZone::SpawnPointsCap' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, SpawnPointsAllocated) == 0x00084C, "Member 'AFortGameStateZone::SpawnPointsAllocated' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, MaxTotalAI) == 0x000850, "Member 'AFortGameStateZone::MaxTotalAI' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, MaxEncounterAI) == 0x000854, "Member 'AFortGameStateZone::MaxEncounterAI' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, MaxEncounterSP) == 0x000858, "Member 'AFortGameStateZone::MaxEncounterSP' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, PlayerBuildingSkillLevel) == 0x00085C, "Member 'AFortGameStateZone::PlayerBuildingSkillLevel' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, PlayerSharedMaxTrapAttributes) == 0x000860, "Member 'AFortGameStateZone::PlayerSharedMaxTrapAttributes' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, GameplayMutatorObservers) == 0x000870, "Member 'AFortGameStateZone::GameplayMutatorObservers' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, ExplicitGloballyBlockedAbilityTags) == 0x000A00, "Member 'AFortGameStateZone::ExplicitGloballyBlockedAbilityTags' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, TotalPlayerStructures) == 0x000C84, "Member 'AFortGameStateZone::TotalPlayerStructures' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, MaxPlayerStructures) == 0x000C88, "Member 'AFortGameStateZone::MaxPlayerStructures' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, GlobalEnvironmentAbilityActor) == 0x000D00, "Member 'AFortGameStateZone::GlobalEnvironmentAbilityActor' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, GlobalGameplayEventListeners) == 0x000D08, "Member 'AFortGameStateZone::GlobalGameplayEventListeners' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, ActiveGameplayModifiers) == 0x000D18, "Member 'AFortGameStateZone::ActiveGameplayModifiers' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, bSupportRuntimeShutdownOfGameplayModifiers) == 0x000DE0, "Member 'AFortGameStateZone::bSupportRuntimeShutdownOfGameplayModifiers' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, StructuralSupportSystem) == 0x000DE8, "Member 'AFortGameStateZone::StructuralSupportSystem' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, ZoneDifficultyInfoRow) == 0x000DF0, "Member 'AFortGameStateZone::ZoneDifficultyInfoRow' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, ZoneTheme) == 0x000E00, "Member 'AFortGameStateZone::ZoneTheme' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, MissionGeneratorClass) == 0x000E08, "Member 'AFortGameStateZone::MissionGeneratorClass' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, MissionRewards) == 0x000E28, "Member 'AFortGameStateZone::MissionRewards' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, MissionAlertRewards) == 0x000E38, "Member 'AFortGameStateZone::MissionAlertRewards' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, ThreatVisualsManager) == 0x000FA0, "Member 'AFortGameStateZone::ThreatVisualsManager' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, ThreatParticleActor) == 0x000FA8, "Member 'AFortGameStateZone::ThreatParticleActor' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, bDrawRunVariationDebug) == 0x000FB0, "Member 'AFortGameStateZone::bDrawRunVariationDebug' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, PawnVariationList) == 0x000FB8, "Member 'AFortGameStateZone::PawnVariationList' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, VariationIndex) == 0x000FC8, "Member 'AFortGameStateZone::VariationIndex' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, GameDifficulty) == 0x000FCC, "Member 'AFortGameStateZone::GameDifficulty' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, bIsGroupContent) == 0x000FD4, "Member 'AFortGameStateZone::bIsGroupContent' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, PlayerBuildableClasses) == 0x000FF0, "Member 'AFortGameStateZone::PlayerBuildableClasses' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, UIMapManager) == 0x001030, "Member 'AFortGameStateZone::UIMapManager' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, OnScoreTotalsChanged) == 0x001038, "Member 'AFortGameStateZone::OnScoreTotalsChanged' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, ScoringTableRowName) == 0x001048, "Member 'AFortGameStateZone::ScoringTableRowName' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, TotalCombatScore) == 0x001050, "Member 'AFortGameStateZone::TotalCombatScore' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, TotalBuildingScore) == 0x001054, "Member 'AFortGameStateZone::TotalBuildingScore' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, TotalUtilityScore) == 0x001058, "Member 'AFortGameStateZone::TotalUtilityScore' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, TheaterUniqueId) == 0x001060, "Member 'AFortGameStateZone::TheaterUniqueId' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, MissionLogDebugString) == 0x001070, "Member 'AFortGameStateZone::MissionLogDebugString' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, bAllowBuildingAtLayoutRequirements) == 0x0010F4, "Member 'AFortGameStateZone::bAllowBuildingAtLayoutRequirements' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, bAllowBuildingWithoutLayoutRequirements) == 0x0010F5, "Member 'AFortGameStateZone::bAllowBuildingWithoutLayoutRequirements' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, DeployedDefenders) == 0x0010F8, "Member 'AFortGameStateZone::DeployedDefenders' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, NumSurvivorsSpawned) == 0x001158, "Member 'AFortGameStateZone::NumSurvivorsSpawned' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, NumSurvivorsDead) == 0x00115C, "Member 'AFortGameStateZone::NumSurvivorsDead' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, NumSurvivorsRescued) == 0x001160, "Member 'AFortGameStateZone::NumSurvivorsRescued' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, OnNumSurvivorsRescuedChangedDelegate) == 0x001168, "Member 'AFortGameStateZone::OnNumSurvivorsRescuedChangedDelegate' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, UnplayableHitchThresholdInMs) == 0x001190, "Member 'AFortGameStateZone::UnplayableHitchThresholdInMs' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, MaxUnplayableHitchesToTolerate) == 0x001194, "Member 'AFortGameStateZone::MaxUnplayableHitchesToTolerate' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, OnGameplayVotes) == 0x0011C0, "Member 'AFortGameStateZone::OnGameplayVotes' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, OnGameplayVoteBeginning) == 0x0011D0, "Member 'AFortGameStateZone::OnGameplayVoteBeginning' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, OnGameplayVoteEnded) == 0x0011E0, "Member 'AFortGameStateZone::OnGameplayVoteEnded' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, GameplayVotes) == 0x0011F0, "Member 'AFortGameStateZone::GameplayVotes' has a wrong offset!");

// Class FortniteGame.FortGameStateKeep
// 0x0050 (0x1260 - 0x1210)
class AFortGameStateKeep final : public AFortGameStateZone
{
public:
	struct FPermaniteBoundariesInfo               PermaniteBoundariesData;                           // 0x1210(0x0014)(Net, IsPlainOldData, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1224[0x3C];                                    // 0x1224(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_PermaniteBoundariesInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameStateKeep">();
	}
	static class AFortGameStateKeep* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGameStateKeep>();
	}
};
static_assert(alignof(AFortGameStateKeep) == 0x000008, "Wrong alignment on AFortGameStateKeep");
static_assert(sizeof(AFortGameStateKeep) == 0x001260, "Wrong size on AFortGameStateKeep");
static_assert(offsetof(AFortGameStateKeep, PermaniteBoundariesData) == 0x001210, "Member 'AFortGameStateKeep::PermaniteBoundariesData' has a wrong offset!");

// Class FortniteGame.FortHomebaseBannerIconItemDefinition
// 0x0000 (0x0270 - 0x0270)
class UFortHomebaseBannerIconItemDefinition final : public UFortAccountItemDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortHomebaseBannerIconItemDefinition">();
	}
	static class UFortHomebaseBannerIconItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortHomebaseBannerIconItemDefinition>();
	}
};
static_assert(alignof(UFortHomebaseBannerIconItemDefinition) == 0x000010, "Wrong alignment on UFortHomebaseBannerIconItemDefinition");
static_assert(sizeof(UFortHomebaseBannerIconItemDefinition) == 0x000270, "Wrong size on UFortHomebaseBannerIconItemDefinition");

// Class FortniteGame.FortHomebaseManager
// 0x0278 (0x02A0 - 0x0028)
class UFortHomebaseManager final : public UDataAsset
{
public:
	class FName                                   EarlyGameStartingNodePageId;                       // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EarlyGameStartingNodeId;                           // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredNumberOfNodesToLeaveEarlyGame;             // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   StartingNodePageId;                                // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StartingNodeId;                                    // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             HomebaseNodePageDataTable;                         // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             HomebaseNodeDataTable;                             // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortHomebaseNodeGameplayEffectDataTable* HomebaseNodeGameplayEffectDataTable;               // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateColor                            QuestNodeTintColour;                               // 0x0068(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UDataTable*                             HomebaseSquadDataTable;                            // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             ExpeditionSlotsDataTable;                          // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveTable*                            ManagerSquadSynergyBonusTable;                     // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            SquadGE;                                           // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FWorkerPersonalityData>         WorkerPersonalities;                               // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FWorkerSetBonusData>            WorkerSetBonuses;                                  // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FManagerSynergyData>            ManagerSynergies;                                  // 0x00D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0[0x100];                                     // 0x00E0(0x0100)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UDataTable>              HomebaseBannerIconData;                            // 0x01E0(0x0020)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UDataTable>              HomebaseBannerIconCategoryData;                    // 0x0200(0x0020)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UDataTable>              HomebaseBannerColorData;                           // 0x0220(0x0020)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UDataTable>              HomebaseBannerColorCategoryData;                   // 0x0240(0x0020)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UFortHomebaseBannerColorMap> HomebaseBannerColorMap;                            // 0x0260(0x0020)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UFortHomebaseBannerIconItemDefinition> DefaultHomebaseBannerIconItemDefinition;           // 0x0280(0x0020)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class FString GetHomebaseName(const class UFortMcpProfileAccount* McpProfile);

	bool AreNodeCostsMet(class FName NodeID, class UFortMcpProfileAccount* McpProfile);
	bool AreNodePrereqsMet(class FName NodeID, class UFortMcpProfileAccount* McpProfile);
	bool AreNodeQuestReqsMet(class FName NodeID, class UFortMcpProfileAccount* McpProfile);
	int32 GetNumAccountInventoryBonusTokens(class UFortMcpProfileAccount* McpProfile);
	int32 GetNumAccountLimitedItems(class UFortMcpProfileAccount* McpProfile);
	int32 GetNumWorldInventoryBonusTokens(class UFortMcpProfileAccount* McpProfile);
	bool GetSquadCopyById(class FName SquadId, struct FHomebaseSquad* OutSquad);

	class FString GetNodeInstanceIdByNodeId(class FName NodeID, const class UFortMcpProfileAccount* McpProfile) const;
	int32 GetNumOwnedNodesInPage(class FName NodePageId, class UFortMcpProfileAccount* McpProfile, EPrereqNodeType NodeType) const;
	TArray<class FName> GetOwnedNodes(const class UFortMcpProfileAccount* McpProfile) const;
	class FText GetPrereqNodeTypeName(EPrereqNodeType NodeType) const;
	void GetSquadPopulation(class FName SquadId, const class UFortMcpProfileAccount* McpProfile, TArray<class UFortWorker*>* OutSquadMembers) const;
	class UFortWorker* GetWorkerInSquadSlot(class FName SquadId, int32 SlotIdx, const class UFortMcpProfileAccount* McpProfile) const;
	bool IsNodeOwned(class FName NodeID, const class UFortMcpProfileAccount* McpProfile) const;
	bool IsSquadSlotUnlocked(class FName SquadId, int32 SlotIdx, const class UFortMcpProfileAccount* McpProfile) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortHomebaseManager">();
	}
	static class UFortHomebaseManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortHomebaseManager>();
	}
};
static_assert(alignof(UFortHomebaseManager) == 0x000008, "Wrong alignment on UFortHomebaseManager");
static_assert(sizeof(UFortHomebaseManager) == 0x0002A0, "Wrong size on UFortHomebaseManager");
static_assert(offsetof(UFortHomebaseManager, EarlyGameStartingNodePageId) == 0x000028, "Member 'UFortHomebaseManager::EarlyGameStartingNodePageId' has a wrong offset!");
static_assert(offsetof(UFortHomebaseManager, EarlyGameStartingNodeId) == 0x000030, "Member 'UFortHomebaseManager::EarlyGameStartingNodeId' has a wrong offset!");
static_assert(offsetof(UFortHomebaseManager, RequiredNumberOfNodesToLeaveEarlyGame) == 0x000038, "Member 'UFortHomebaseManager::RequiredNumberOfNodesToLeaveEarlyGame' has a wrong offset!");
static_assert(offsetof(UFortHomebaseManager, StartingNodePageId) == 0x000040, "Member 'UFortHomebaseManager::StartingNodePageId' has a wrong offset!");
static_assert(offsetof(UFortHomebaseManager, StartingNodeId) == 0x000048, "Member 'UFortHomebaseManager::StartingNodeId' has a wrong offset!");
static_assert(offsetof(UFortHomebaseManager, HomebaseNodePageDataTable) == 0x000050, "Member 'UFortHomebaseManager::HomebaseNodePageDataTable' has a wrong offset!");
static_assert(offsetof(UFortHomebaseManager, HomebaseNodeDataTable) == 0x000058, "Member 'UFortHomebaseManager::HomebaseNodeDataTable' has a wrong offset!");
static_assert(offsetof(UFortHomebaseManager, HomebaseNodeGameplayEffectDataTable) == 0x000060, "Member 'UFortHomebaseManager::HomebaseNodeGameplayEffectDataTable' has a wrong offset!");
static_assert(offsetof(UFortHomebaseManager, QuestNodeTintColour) == 0x000068, "Member 'UFortHomebaseManager::QuestNodeTintColour' has a wrong offset!");
static_assert(offsetof(UFortHomebaseManager, HomebaseSquadDataTable) == 0x000090, "Member 'UFortHomebaseManager::HomebaseSquadDataTable' has a wrong offset!");
static_assert(offsetof(UFortHomebaseManager, ExpeditionSlotsDataTable) == 0x000098, "Member 'UFortHomebaseManager::ExpeditionSlotsDataTable' has a wrong offset!");
static_assert(offsetof(UFortHomebaseManager, ManagerSquadSynergyBonusTable) == 0x0000A0, "Member 'UFortHomebaseManager::ManagerSquadSynergyBonusTable' has a wrong offset!");
static_assert(offsetof(UFortHomebaseManager, SquadGE) == 0x0000A8, "Member 'UFortHomebaseManager::SquadGE' has a wrong offset!");
static_assert(offsetof(UFortHomebaseManager, WorkerPersonalities) == 0x0000B0, "Member 'UFortHomebaseManager::WorkerPersonalities' has a wrong offset!");
static_assert(offsetof(UFortHomebaseManager, WorkerSetBonuses) == 0x0000C0, "Member 'UFortHomebaseManager::WorkerSetBonuses' has a wrong offset!");
static_assert(offsetof(UFortHomebaseManager, ManagerSynergies) == 0x0000D0, "Member 'UFortHomebaseManager::ManagerSynergies' has a wrong offset!");
static_assert(offsetof(UFortHomebaseManager, HomebaseBannerIconData) == 0x0001E0, "Member 'UFortHomebaseManager::HomebaseBannerIconData' has a wrong offset!");
static_assert(offsetof(UFortHomebaseManager, HomebaseBannerIconCategoryData) == 0x000200, "Member 'UFortHomebaseManager::HomebaseBannerIconCategoryData' has a wrong offset!");
static_assert(offsetof(UFortHomebaseManager, HomebaseBannerColorData) == 0x000220, "Member 'UFortHomebaseManager::HomebaseBannerColorData' has a wrong offset!");
static_assert(offsetof(UFortHomebaseManager, HomebaseBannerColorCategoryData) == 0x000240, "Member 'UFortHomebaseManager::HomebaseBannerColorCategoryData' has a wrong offset!");
static_assert(offsetof(UFortHomebaseManager, HomebaseBannerColorMap) == 0x000260, "Member 'UFortHomebaseManager::HomebaseBannerColorMap' has a wrong offset!");
static_assert(offsetof(UFortHomebaseManager, DefaultHomebaseBannerIconItemDefinition) == 0x000280, "Member 'UFortHomebaseManager::DefaultHomebaseBannerIconItemDefinition' has a wrong offset!");

// Class FortniteGame.FortGameStatePvP
// 0x0140 (0x1350 - 0x1210)
class AFortGameStatePvP : public AFortGameStateZone
{
public:
	int32                                         RoundTimeLimit;                                    // 0x1210(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RoundTimeAccumulated;                              // 0x1214(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1218[0x4];                                     // 0x1218(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RoundTimeCriticalThreshold;                        // 0x121C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RoundTimeRemaining;                                // 0x1220(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         StalemateTimeLimit;                                // 0x1224(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         StalemateTimeRemaining;                            // 0x1228(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RestartTimeRemaining;                              // 0x122C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FOBFinalizationTimeRemaining;                      // 0x1230(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1234[0x4];                                     // 0x1234(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnFinalizationFOBTimerExpired;                     // 0x1238(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class USoundBase>              RoundTimeExpiringSound;                            // 0x1248(0x0020)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class USoundBase>              StalemateTimeExpiringSound;                        // 0x1268(0x0020)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ABuildingCapturePointActor*>     CapturePoints;                                     // 0x1288(0x0010)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class ABuildingItemCollectorActor*            ItemCollector;                                     // 0x1298(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         StartMatchDelayTimer;                              // 0x12A0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bGateCraftingOnTeamLevel : 1;                      // 0x12A4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_12A5[0x7B];                                    // 0x12A5(0x007B)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            MatchLevelCurve;                                   // 0x1320(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MatchLevel;                                        // 0x1328(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_132C[0x4];                                     // 0x132C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnHandleMatchLevelChanged;                         // 0x1330(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	int32                                         TotalHomebaseRating;                               // 0x1340(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AverageHomebaseRating;                             // 0x1344(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseExperimentalCraftingFeature;                   // 0x1348(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1349[0x7];                                     // 0x1349(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ABuildingItemCollectorActor* GetItemCollector();
	void OnRep_ItemCollector();
	void OnRep_MatchLevel();
	void OnRep_RoundTimeRemaining();
	void OnRep_StalemateTimeRemaining();
	void SetGameDifficultyRow(const struct FDataTableRowHandle& GameDifficultyInfo);
	void SetMatchLevel(int32 InMatchLevel);

	int32 GetAverageHomebaseRating() const;
	int32 GetFOBFinalizationTimeRemaining() const;
	int32 GetMatchLevel() const;
	int32 GetRoundTimeAccumulated() const;
	int32 GetStartMatchDelayTimer() const;
	int32 GetTotalHomebaseRating() const;
	bool IsExperimentalCraftingFeatureActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameStatePvP">();
	}
	static class AFortGameStatePvP* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGameStatePvP>();
	}
};
static_assert(alignof(AFortGameStatePvP) == 0x000008, "Wrong alignment on AFortGameStatePvP");
static_assert(sizeof(AFortGameStatePvP) == 0x001350, "Wrong size on AFortGameStatePvP");
static_assert(offsetof(AFortGameStatePvP, RoundTimeLimit) == 0x001210, "Member 'AFortGameStatePvP::RoundTimeLimit' has a wrong offset!");
static_assert(offsetof(AFortGameStatePvP, RoundTimeAccumulated) == 0x001214, "Member 'AFortGameStatePvP::RoundTimeAccumulated' has a wrong offset!");
static_assert(offsetof(AFortGameStatePvP, RoundTimeCriticalThreshold) == 0x00121C, "Member 'AFortGameStatePvP::RoundTimeCriticalThreshold' has a wrong offset!");
static_assert(offsetof(AFortGameStatePvP, RoundTimeRemaining) == 0x001220, "Member 'AFortGameStatePvP::RoundTimeRemaining' has a wrong offset!");
static_assert(offsetof(AFortGameStatePvP, StalemateTimeLimit) == 0x001224, "Member 'AFortGameStatePvP::StalemateTimeLimit' has a wrong offset!");
static_assert(offsetof(AFortGameStatePvP, StalemateTimeRemaining) == 0x001228, "Member 'AFortGameStatePvP::StalemateTimeRemaining' has a wrong offset!");
static_assert(offsetof(AFortGameStatePvP, RestartTimeRemaining) == 0x00122C, "Member 'AFortGameStatePvP::RestartTimeRemaining' has a wrong offset!");
static_assert(offsetof(AFortGameStatePvP, FOBFinalizationTimeRemaining) == 0x001230, "Member 'AFortGameStatePvP::FOBFinalizationTimeRemaining' has a wrong offset!");
static_assert(offsetof(AFortGameStatePvP, OnFinalizationFOBTimerExpired) == 0x001238, "Member 'AFortGameStatePvP::OnFinalizationFOBTimerExpired' has a wrong offset!");
static_assert(offsetof(AFortGameStatePvP, RoundTimeExpiringSound) == 0x001248, "Member 'AFortGameStatePvP::RoundTimeExpiringSound' has a wrong offset!");
static_assert(offsetof(AFortGameStatePvP, StalemateTimeExpiringSound) == 0x001268, "Member 'AFortGameStatePvP::StalemateTimeExpiringSound' has a wrong offset!");
static_assert(offsetof(AFortGameStatePvP, CapturePoints) == 0x001288, "Member 'AFortGameStatePvP::CapturePoints' has a wrong offset!");
static_assert(offsetof(AFortGameStatePvP, ItemCollector) == 0x001298, "Member 'AFortGameStatePvP::ItemCollector' has a wrong offset!");
static_assert(offsetof(AFortGameStatePvP, StartMatchDelayTimer) == 0x0012A0, "Member 'AFortGameStatePvP::StartMatchDelayTimer' has a wrong offset!");
static_assert(offsetof(AFortGameStatePvP, MatchLevelCurve) == 0x001320, "Member 'AFortGameStatePvP::MatchLevelCurve' has a wrong offset!");
static_assert(offsetof(AFortGameStatePvP, MatchLevel) == 0x001328, "Member 'AFortGameStatePvP::MatchLevel' has a wrong offset!");
static_assert(offsetof(AFortGameStatePvP, OnHandleMatchLevelChanged) == 0x001330, "Member 'AFortGameStatePvP::OnHandleMatchLevelChanged' has a wrong offset!");
static_assert(offsetof(AFortGameStatePvP, TotalHomebaseRating) == 0x001340, "Member 'AFortGameStatePvP::TotalHomebaseRating' has a wrong offset!");
static_assert(offsetof(AFortGameStatePvP, AverageHomebaseRating) == 0x001344, "Member 'AFortGameStatePvP::AverageHomebaseRating' has a wrong offset!");
static_assert(offsetof(AFortGameStatePvP, bUseExperimentalCraftingFeature) == 0x001348, "Member 'AFortGameStatePvP::bUseExperimentalCraftingFeature' has a wrong offset!");

// Class FortniteGame.FortGameStateAthena
// 0x0190 (0x14E0 - 0x1350)
class AFortGameStateAthena : public AFortGameStatePvP
{
public:
	TArray<TSubclassOf<class ABuildingActor>>     BuildingActorClasses;                              // 0x1350(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   WinnerAnnounced;                                   // 0x1360(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   WinningTeamAnnounced;                              // 0x1370(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   GamePhaseChanged;                                  // 0x1380(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   GamePhaseStepChanged;                              // 0x1390(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         WarmupCountdownStartTime;                          // 0x13A0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WarmupCountdownEndTime;                            // 0x13A4(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AircraftStartTime;                                 // 0x13A8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SafeZonesStartTime;                                // 0x13AC(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndGameStartTime;                                  // 0x13B0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndGameKickPlayerTime;                             // 0x13B4(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayersLeft;                                       // 0x13B8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamsLeft;                                         // 0x13BC(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentPlaylistId;                                 // 0x13C0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C4[0x4];                                     // 0x13C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 WinningPlayerName;                                 // 0x13C8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WinningTeam;                                       // 0x13D8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13DC[0x4];                                     // 0x13DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FText>                           KillFeedEntry;                                     // 0x13E0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_13F0[0x10];                                    // 0x13F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   KillFeedUpdated;                                   // 0x1400(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AFortSafeZoneIndicator*                 SafeZoneIndicator;                                 // 0x1410(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateBrush                            MinimapBackgroundBrush;                            // 0x1418(0x0090)(Transient, Protected, NativeAccessSpecifierProtected)
	class UTexture2D*                             MinimapBackgroundImage;                            // 0x14A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               MinimapBackgroundMID;                              // 0x14B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     MiniMapBackgroundDrawingMaterial;                  // 0x14B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortAthenaMapInfo*                     MapInfo;                                           // 0x14C0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAthenaGamePhase                              GamePhase;                                         // 0x14C8(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         SafeZonePhase;                                     // 0x14C9(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAthenaGamePhaseStep                          GamePhaseStep;                                     // 0x14CA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14CB[0x1];                                     // 0x14CB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GamePhaseStepTimeRemaining;                        // 0x14CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortAthenaAircraft*                    Aircraft;                                          // 0x14D0(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bAircraftIsLocked : 1;                             // 0x14D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_14D9[0x7];                                     // 0x14D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Aircraft();
	void OnRep_GamePhase(EAthenaGamePhase OldGamePhase);
	void OnRep_WinningPlayerName();
	void OnRep_WinningTeam();

	EAthenaAerialPhase GetAerialPhase(class AFortPlayerControllerAthena* PlayerController) const;
	class AFortAthenaAircraft* GetAircraft() const;
	class AFortSafeZoneIndicator* GetSafeZoneIndicator() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameStateAthena">();
	}
	static class AFortGameStateAthena* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGameStateAthena>();
	}
};
static_assert(alignof(AFortGameStateAthena) == 0x000008, "Wrong alignment on AFortGameStateAthena");
static_assert(sizeof(AFortGameStateAthena) == 0x0014E0, "Wrong size on AFortGameStateAthena");
static_assert(offsetof(AFortGameStateAthena, BuildingActorClasses) == 0x001350, "Member 'AFortGameStateAthena::BuildingActorClasses' has a wrong offset!");
static_assert(offsetof(AFortGameStateAthena, WinnerAnnounced) == 0x001360, "Member 'AFortGameStateAthena::WinnerAnnounced' has a wrong offset!");
static_assert(offsetof(AFortGameStateAthena, WinningTeamAnnounced) == 0x001370, "Member 'AFortGameStateAthena::WinningTeamAnnounced' has a wrong offset!");
static_assert(offsetof(AFortGameStateAthena, GamePhaseChanged) == 0x001380, "Member 'AFortGameStateAthena::GamePhaseChanged' has a wrong offset!");
static_assert(offsetof(AFortGameStateAthena, GamePhaseStepChanged) == 0x001390, "Member 'AFortGameStateAthena::GamePhaseStepChanged' has a wrong offset!");
static_assert(offsetof(AFortGameStateAthena, WarmupCountdownStartTime) == 0x0013A0, "Member 'AFortGameStateAthena::WarmupCountdownStartTime' has a wrong offset!");
static_assert(offsetof(AFortGameStateAthena, WarmupCountdownEndTime) == 0x0013A4, "Member 'AFortGameStateAthena::WarmupCountdownEndTime' has a wrong offset!");
static_assert(offsetof(AFortGameStateAthena, AircraftStartTime) == 0x0013A8, "Member 'AFortGameStateAthena::AircraftStartTime' has a wrong offset!");
static_assert(offsetof(AFortGameStateAthena, SafeZonesStartTime) == 0x0013AC, "Member 'AFortGameStateAthena::SafeZonesStartTime' has a wrong offset!");
static_assert(offsetof(AFortGameStateAthena, EndGameStartTime) == 0x0013B0, "Member 'AFortGameStateAthena::EndGameStartTime' has a wrong offset!");
static_assert(offsetof(AFortGameStateAthena, EndGameKickPlayerTime) == 0x0013B4, "Member 'AFortGameStateAthena::EndGameKickPlayerTime' has a wrong offset!");
static_assert(offsetof(AFortGameStateAthena, PlayersLeft) == 0x0013B8, "Member 'AFortGameStateAthena::PlayersLeft' has a wrong offset!");
static_assert(offsetof(AFortGameStateAthena, TeamsLeft) == 0x0013BC, "Member 'AFortGameStateAthena::TeamsLeft' has a wrong offset!");
static_assert(offsetof(AFortGameStateAthena, CurrentPlaylistId) == 0x0013C0, "Member 'AFortGameStateAthena::CurrentPlaylistId' has a wrong offset!");
static_assert(offsetof(AFortGameStateAthena, WinningPlayerName) == 0x0013C8, "Member 'AFortGameStateAthena::WinningPlayerName' has a wrong offset!");
static_assert(offsetof(AFortGameStateAthena, WinningTeam) == 0x0013D8, "Member 'AFortGameStateAthena::WinningTeam' has a wrong offset!");
static_assert(offsetof(AFortGameStateAthena, KillFeedEntry) == 0x0013E0, "Member 'AFortGameStateAthena::KillFeedEntry' has a wrong offset!");
static_assert(offsetof(AFortGameStateAthena, KillFeedUpdated) == 0x001400, "Member 'AFortGameStateAthena::KillFeedUpdated' has a wrong offset!");
static_assert(offsetof(AFortGameStateAthena, SafeZoneIndicator) == 0x001410, "Member 'AFortGameStateAthena::SafeZoneIndicator' has a wrong offset!");
static_assert(offsetof(AFortGameStateAthena, MinimapBackgroundBrush) == 0x001418, "Member 'AFortGameStateAthena::MinimapBackgroundBrush' has a wrong offset!");
static_assert(offsetof(AFortGameStateAthena, MinimapBackgroundImage) == 0x0014A8, "Member 'AFortGameStateAthena::MinimapBackgroundImage' has a wrong offset!");
static_assert(offsetof(AFortGameStateAthena, MinimapBackgroundMID) == 0x0014B0, "Member 'AFortGameStateAthena::MinimapBackgroundMID' has a wrong offset!");
static_assert(offsetof(AFortGameStateAthena, MiniMapBackgroundDrawingMaterial) == 0x0014B8, "Member 'AFortGameStateAthena::MiniMapBackgroundDrawingMaterial' has a wrong offset!");
static_assert(offsetof(AFortGameStateAthena, MapInfo) == 0x0014C0, "Member 'AFortGameStateAthena::MapInfo' has a wrong offset!");
static_assert(offsetof(AFortGameStateAthena, GamePhase) == 0x0014C8, "Member 'AFortGameStateAthena::GamePhase' has a wrong offset!");
static_assert(offsetof(AFortGameStateAthena, SafeZonePhase) == 0x0014C9, "Member 'AFortGameStateAthena::SafeZonePhase' has a wrong offset!");
static_assert(offsetof(AFortGameStateAthena, GamePhaseStep) == 0x0014CA, "Member 'AFortGameStateAthena::GamePhaseStep' has a wrong offset!");
static_assert(offsetof(AFortGameStateAthena, GamePhaseStepTimeRemaining) == 0x0014CC, "Member 'AFortGameStateAthena::GamePhaseStepTimeRemaining' has a wrong offset!");
static_assert(offsetof(AFortGameStateAthena, Aircraft) == 0x0014D0, "Member 'AFortGameStateAthena::Aircraft' has a wrong offset!");

// Class FortniteGame.FortCameraBase
// 0x0040 (0x08C0 - 0x0880)
class AFortCameraBase : public ACameraActor
{
public:
	float                                         MinDistanceToDrag;                                 // 0x0880(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultFieldOfView;                                // 0x0884(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               DefaultRotation;                                   // 0x0888(0x000C)(Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                DefaultLocation;                                   // 0x0894(0x000C)(Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortExhibitActor*                      ExhibitActor;                                      // 0x08A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bExhibitActorChanged;                              // 0x08A8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          CheckForDragBegin;                                 // 0x08A9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8AA[0x2];                                      // 0x08AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              DownDelta;                                         // 0x08AC(0x0008)(Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8B4[0xC];                                      // 0x08B4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Exhibit(class AFortExhibitActor* TargetActor);
	void OnActivated();
	void OnDeactivated();
	void OnDragBegin();
	void OnDragEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCameraBase">();
	}
	static class AFortCameraBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortCameraBase>();
	}
};
static_assert(alignof(AFortCameraBase) == 0x000010, "Wrong alignment on AFortCameraBase");
static_assert(sizeof(AFortCameraBase) == 0x0008C0, "Wrong size on AFortCameraBase");
static_assert(offsetof(AFortCameraBase, MinDistanceToDrag) == 0x000880, "Member 'AFortCameraBase::MinDistanceToDrag' has a wrong offset!");
static_assert(offsetof(AFortCameraBase, DefaultFieldOfView) == 0x000884, "Member 'AFortCameraBase::DefaultFieldOfView' has a wrong offset!");
static_assert(offsetof(AFortCameraBase, DefaultRotation) == 0x000888, "Member 'AFortCameraBase::DefaultRotation' has a wrong offset!");
static_assert(offsetof(AFortCameraBase, DefaultLocation) == 0x000894, "Member 'AFortCameraBase::DefaultLocation' has a wrong offset!");
static_assert(offsetof(AFortCameraBase, ExhibitActor) == 0x0008A0, "Member 'AFortCameraBase::ExhibitActor' has a wrong offset!");
static_assert(offsetof(AFortCameraBase, bExhibitActorChanged) == 0x0008A8, "Member 'AFortCameraBase::bExhibitActorChanged' has a wrong offset!");
static_assert(offsetof(AFortCameraBase, CheckForDragBegin) == 0x0008A9, "Member 'AFortCameraBase::CheckForDragBegin' has a wrong offset!");
static_assert(offsetof(AFortCameraBase, DownDelta) == 0x0008AC, "Member 'AFortCameraBase::DownDelta' has a wrong offset!");

// Class FortniteGame.FortTheaterCamera
// 0x0000 (0x08C0 - 0x08C0)
class AFortTheaterCamera : public AFortCameraBase
{
public:
	void SetTileFocus(class AFortTheaterMapTile* TargetTile);

	struct FVector LimitToTheater(const struct FVector& DesiredPosition) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTheaterCamera">();
	}
	static class AFortTheaterCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortTheaterCamera>();
	}
};
static_assert(alignof(AFortTheaterCamera) == 0x000010, "Wrong alignment on AFortTheaterCamera");
static_assert(sizeof(AFortTheaterCamera) == 0x0008C0, "Wrong size on AFortTheaterCamera");

// Class FortniteGame.HomeBaseContext
// 0x00B8 (0x00E0 - 0x0028)
class UHomeBaseContext final : public UBlueprintContextBase
{
public:
	UMulticastDelegateProperty_                   OnWorkerPreviewStateChanged;                       // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnHomebaseInventoryUpdated;                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMaximumItemLevelChanged;                         // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnItemUpgradePointsChanged;                        // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   SquadSlotMarkedAsSeen;                             // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x28];                                      // 0x0078(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnPlayerInfoChangedDelegate;                       // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnItemSlottingPreviewInfoChangedEvent;             // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_D0[0x10];                                      // 0x00D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void GetStaticSetBonusData(const struct FGameplayTag& InSetBonusTag, struct FWorkerSetBonusData* OutSetBonusData, struct FFortMultiSizeBrush* OutBrush);

	void BroadcastSquadSlotMarkedAsSeen();
	void ClearFrontEndOnlyExpeditionSquad(const class FName SquadId);
	void GetAllResourceCollectorRewardEstimates(TArray<struct FFortItemQuantityPair>* OutEstimates);
	int32 GetNumAccountLimitedItems();
	void GetResourceCollectorRateInfo(class UFortCollectedResourceItem* CollectorType, float* RatePerSecond, int32* MaxCapacity);
	void GetResourceCollectorRewardsEstimate(class UFortCollectedResourceItem* CollectorType, struct FFortItemQuantityPair* OutEstimate);
	void GetResourceCollectorRewardsEstimates(const TArray<class UFortCollectedResourceItem*>& CollectorTypes, TArray<struct FFortItemQuantityPair>* OutEstimates);

	class FName GetActiveCombatSquadId() const;
	class FName GetActiveDefenderSquadId() const;
	TArray<class UFortItem*> GetItemsInSquad(const class FName SquadId, bool UsePreviewState, bool bRemoveEmptySquadSlots, TSubclassOf<class UFortItem> OfClassType) const;
	bool GetLocalPlayerHomebaseRating(int32* Rating, float* ProgressFraction) const;
	bool GetLocalTeamHomebaseRating(int32* Rating, float* ProgressFraction) const;
	class FName GetNodePageIdForHomebaseNode(const class FName NodeID) const;
	void GetSquadSlotOfItem(const class UFortItem* Item, class FName* OutSquadId, int32* OutSquadSlotIndex) const;
	bool GetTeamHomebaseRating(const struct FUniqueNetIdRepl& PlayerID, int32* Rating, float* ProgressFraction) const;
	bool GetTotalHomebaseRating(const struct FUniqueNetIdRepl& UniqueId, int32* Rating, float* ProgressFraction) const;
	int32 GetTotalSkillPointsEarned() const;
	class FName GetUnlockingHomebaseNodeIdForSquadSlot(const class FName SquadId, const int32 SquadSlotIndex) const;
	void GetWorkerPreviewStatus(bool* OutIsPreviewing, class UFortWorker** OutWorker, bool* OutMatchesPersonality, bool* OutMatchesSquadType, struct FWorkerSetBonusState* OutSetBonusState) const;
	bool IsPreviewingWorkerSlotting() const;
	bool TryGetHomebaseNodeData(const class FName NodeID, struct FHomebaseNode* OutHomebaseNode) const;
	bool TryGetHomebaseNodePageData(const class FName NodePageId, struct FHomebaseNodePage* OutHomebaseNodePage) const;
	bool TryGetHomebaseSquadData(const class FName SquadId, struct FHomebaseSquad* OutHomebaseSquad) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HomeBaseContext">();
	}
	static class UHomeBaseContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHomeBaseContext>();
	}
};
static_assert(alignof(UHomeBaseContext) == 0x000008, "Wrong alignment on UHomeBaseContext");
static_assert(sizeof(UHomeBaseContext) == 0x0000E0, "Wrong size on UHomeBaseContext");
static_assert(offsetof(UHomeBaseContext, OnWorkerPreviewStateChanged) == 0x000028, "Member 'UHomeBaseContext::OnWorkerPreviewStateChanged' has a wrong offset!");
static_assert(offsetof(UHomeBaseContext, OnHomebaseInventoryUpdated) == 0x000038, "Member 'UHomeBaseContext::OnHomebaseInventoryUpdated' has a wrong offset!");
static_assert(offsetof(UHomeBaseContext, OnMaximumItemLevelChanged) == 0x000048, "Member 'UHomeBaseContext::OnMaximumItemLevelChanged' has a wrong offset!");
static_assert(offsetof(UHomeBaseContext, OnItemUpgradePointsChanged) == 0x000058, "Member 'UHomeBaseContext::OnItemUpgradePointsChanged' has a wrong offset!");
static_assert(offsetof(UHomeBaseContext, SquadSlotMarkedAsSeen) == 0x000068, "Member 'UHomeBaseContext::SquadSlotMarkedAsSeen' has a wrong offset!");
static_assert(offsetof(UHomeBaseContext, OnPlayerInfoChangedDelegate) == 0x0000A0, "Member 'UHomeBaseContext::OnPlayerInfoChangedDelegate' has a wrong offset!");
static_assert(offsetof(UHomeBaseContext, OnItemSlottingPreviewInfoChangedEvent) == 0x0000C0, "Member 'UHomeBaseContext::OnItemSlottingPreviewInfoChangedEvent' has a wrong offset!");

// Class FortniteGame.FortClientAnnouncement_Basic
// 0x00F0 (0x04E8 - 0x03F8)
class AFortClientAnnouncement_Basic : public AFortClientAnnouncement
{
public:
	struct FFortClientAnnouncementData_Basic      BasicData;                                         // 0x03F8(0x00F0)(Edit, BlueprintVisible, Net, RepNotify, ExposeOnSpawn, NativeAccessSpecifierPublic)

public:
	void OnRep_BasicData(const struct FFortClientAnnouncementData_Basic& PreviousBasicData);
	void SetDetailText(const class FText& DetailText);
	void SetDisplayTime(float DisplayTime);
	void SetIcon(struct FSlateBrush* Icon);
	void SetTitleText(const class FText& TitleText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortClientAnnouncement_Basic">();
	}
	static class AFortClientAnnouncement_Basic* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortClientAnnouncement_Basic>();
	}
};
static_assert(alignof(AFortClientAnnouncement_Basic) == 0x000008, "Wrong alignment on AFortClientAnnouncement_Basic");
static_assert(sizeof(AFortClientAnnouncement_Basic) == 0x0004E8, "Wrong size on AFortClientAnnouncement_Basic");
static_assert(offsetof(AFortClientAnnouncement_Basic, BasicData) == 0x0003F8, "Member 'AFortClientAnnouncement_Basic::BasicData' has a wrong offset!");

// Class FortniteGame.FortDeathCameraMode
// 0x0020 (0x0070 - 0x0050)
class UFortDeathCameraMode final : public UFortCameraMode
{
public:
	float                                         FOV;                                               // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeToTrackTarget;                                 // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TrackToTargetSpeed;                                // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C[0x14];                                      // 0x005C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDeathCameraMode">();
	}
	static class UFortDeathCameraMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDeathCameraMode>();
	}
};
static_assert(alignof(UFortDeathCameraMode) == 0x000008, "Wrong alignment on UFortDeathCameraMode");
static_assert(sizeof(UFortDeathCameraMode) == 0x000070, "Wrong size on UFortDeathCameraMode");
static_assert(offsetof(UFortDeathCameraMode, FOV) == 0x000050, "Member 'UFortDeathCameraMode::FOV' has a wrong offset!");
static_assert(offsetof(UFortDeathCameraMode, TimeToTrackTarget) == 0x000054, "Member 'UFortDeathCameraMode::TimeToTrackTarget' has a wrong offset!");
static_assert(offsetof(UFortDeathCameraMode, TrackToTargetSpeed) == 0x000058, "Member 'UFortDeathCameraMode::TrackToTargetSpeed' has a wrong offset!");

// Class FortniteGame.FortCollectionBookData
// 0x0040 (0x0068 - 0x0028)
class UFortCollectionBookData final : public UDataAsset
{
public:
	class UDataTable*                             PageCategoryData;                                  // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             PageData;                                          // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             SectionData;                                       // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             SlotData;                                          // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             SlotSourceData;                                    // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             XPWeightData;                                      // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            SlotRarityFactorData;                              // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             BookXPData;                                        // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void GetPageIdsFromCategoryId(class FName CategoryId, TArray<class FName>* PageIds) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCollectionBookData">();
	}
	static class UFortCollectionBookData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCollectionBookData>();
	}
};
static_assert(alignof(UFortCollectionBookData) == 0x000008, "Wrong alignment on UFortCollectionBookData");
static_assert(sizeof(UFortCollectionBookData) == 0x000068, "Wrong size on UFortCollectionBookData");
static_assert(offsetof(UFortCollectionBookData, PageCategoryData) == 0x000028, "Member 'UFortCollectionBookData::PageCategoryData' has a wrong offset!");
static_assert(offsetof(UFortCollectionBookData, PageData) == 0x000030, "Member 'UFortCollectionBookData::PageData' has a wrong offset!");
static_assert(offsetof(UFortCollectionBookData, SectionData) == 0x000038, "Member 'UFortCollectionBookData::SectionData' has a wrong offset!");
static_assert(offsetof(UFortCollectionBookData, SlotData) == 0x000040, "Member 'UFortCollectionBookData::SlotData' has a wrong offset!");
static_assert(offsetof(UFortCollectionBookData, SlotSourceData) == 0x000048, "Member 'UFortCollectionBookData::SlotSourceData' has a wrong offset!");
static_assert(offsetof(UFortCollectionBookData, XPWeightData) == 0x000050, "Member 'UFortCollectionBookData::XPWeightData' has a wrong offset!");
static_assert(offsetof(UFortCollectionBookData, SlotRarityFactorData) == 0x000058, "Member 'UFortCollectionBookData::SlotRarityFactorData' has a wrong offset!");
static_assert(offsetof(UFortCollectionBookData, BookXPData) == 0x000060, "Member 'UFortCollectionBookData::BookXPData' has a wrong offset!");

// Class FortniteGame.FortClientOnlyActor
// 0x0008 (0x0390 - 0x0388)
class AFortClientOnlyActor : public AActor
{
public:
	uint8                                         Pad_388[0x8];                                      // 0x0388(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortClientOnlyActor">();
	}
	static class AFortClientOnlyActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortClientOnlyActor>();
	}
};
static_assert(alignof(AFortClientOnlyActor) == 0x000008, "Wrong alignment on AFortClientOnlyActor");
static_assert(sizeof(AFortClientOnlyActor) == 0x000390, "Wrong size on AFortClientOnlyActor");

// Class FortniteGame.FortFXManager
// 0x00F8 (0x0488 - 0x0390)
class AFortFXManager final : public AFortClientOnlyActor
{
public:
	TArray<struct FFortSplineMeshAnimSet>         SplineAnimSets;                                    // 0x0390(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FFortMIDAnimSet>                MIDAnimSets;                                       // 0x03A0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FFortParticleAnimSet>           ParticleAnimSets;                                  // 0x03B0(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FFortLightAnimSet>              LightAnimSets;                                     // 0x03C0(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class AFortWeaponRanged*>              PendingWeaponFX;                                   // 0x03D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E0[0xA8];                                     // 0x03E0(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void AddLightAnimationIntensity(class UObject* WorldContextObject, class ULightComponent* LightComp, float StartValue, float EndValue, class UCurveFloat* LerpCurve, bool bOneMinusLerpValue, float Duration, bool bPlayReverse);
	static void AddMIDAnimationColor(class UObject* WorldContextObject, class UMaterialInstanceDynamic* Mid, class FName ParamName, const struct FLinearColor& StartValue, const struct FLinearColor& EndValue, class UCurveFloat* LerpCurve, bool bOneMinusLerpValue, float Duration, bool bPlayReverse);
	static void AddMIDAnimationColorCurve(class UObject* WorldContextObject, class UMaterialInstanceDynamic* Mid, class FName ParamName, class UCurveLinearColor* ColorCurve, float Duration, bool bPlayReverse);
	static void AddMIDAnimationFloat(class UObject* WorldContextObject, class UMaterialInstanceDynamic* Mid, class FName ParamName, float StartValue, float EndValue, class UCurveFloat* LerpCurve, bool bOneMinusLerpValue, float Duration, bool bPlayReverse);
	static void AddParticleAnimationFloat(class UObject* WorldContextObject, class UParticleSystemComponent* ParticleSystemComp, class FName ParamName, float StartValue, float EndValue, class UCurveFloat* LerpCurve, bool bOneMinusLerpValue, float Duration, bool bPlayReverse);
	static void AddSplineMeshScaleAnimation(class UObject* WorldContextObject, class USplineMeshComponent* SplineMesh, float StartScaleStart, float StartScaleEnd, float EndScaleStart, float EndScaleEnd, class UCurveFloat* LerpCurve, bool bOneMinusLerpValue, float Duration, bool bPlayReverse);
	static void AddSplineMeshSnapAnimation(class UObject* WorldContextObject, const TArray<class USplineMeshComponent*>& SplineMeshes, class USplineComponent* TargetSpline, class UCurveFloat* GrowthCurve, float Duration, bool bPlayGrowthReverse);
	static void RemoveLightAnimations(class UObject* WorldContextObject, class ULightComponent* LightComp);
	static void RemoveMIDAnimations(class UObject* WorldContextObject, class UMaterialInstanceDynamic* Mid);
	static void RemoveParticleAnimations(class UObject* WorldContextObject, class UParticleSystemComponent* ParticleSystemComp);
	static void RemoveSplineMeshAnimations(class UObject* WorldContextObject, class USplineMeshComponent* SplineMesh);
	static void ReturnFXActorToPool(class UObject* WorldContextObject, class AActor* FXActor);
	static class AActor* SpawnPooledFXActor(class UObject* WorldContextObject, TSubclassOf<class AActor> FXActorClass, const struct FTransform& SpawnTransform);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortFXManager">();
	}
	static class AFortFXManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortFXManager>();
	}
};
static_assert(alignof(AFortFXManager) == 0x000008, "Wrong alignment on AFortFXManager");
static_assert(sizeof(AFortFXManager) == 0x000488, "Wrong size on AFortFXManager");
static_assert(offsetof(AFortFXManager, SplineAnimSets) == 0x000390, "Member 'AFortFXManager::SplineAnimSets' has a wrong offset!");
static_assert(offsetof(AFortFXManager, MIDAnimSets) == 0x0003A0, "Member 'AFortFXManager::MIDAnimSets' has a wrong offset!");
static_assert(offsetof(AFortFXManager, ParticleAnimSets) == 0x0003B0, "Member 'AFortFXManager::ParticleAnimSets' has a wrong offset!");
static_assert(offsetof(AFortFXManager, LightAnimSets) == 0x0003C0, "Member 'AFortFXManager::LightAnimSets' has a wrong offset!");
static_assert(offsetof(AFortFXManager, PendingWeaponFX) == 0x0003D0, "Member 'AFortFXManager::PendingWeaponFX' has a wrong offset!");

// Class FortniteGame.Stat
// 0x0098 (0x00C0 - 0x0028)
class UStat final : public UObject
{
public:
	class FName                                   StatName;                                          // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStatRecordingPeriod                          HighestPeriodToTrack;                              // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 StatDataByPeriod;                                  // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         AbsoluteMaxValue;                                  // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x74];                                      // 0x004C(0x0074)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Stat">();
	}
	static class UStat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStat>();
	}
};
static_assert(alignof(UStat) == 0x000008, "Wrong alignment on UStat");
static_assert(sizeof(UStat) == 0x0000C0, "Wrong size on UStat");
static_assert(offsetof(UStat, StatName) == 0x000028, "Member 'UStat::StatName' has a wrong offset!");
static_assert(offsetof(UStat, HighestPeriodToTrack) == 0x000030, "Member 'UStat::HighestPeriodToTrack' has a wrong offset!");
static_assert(offsetof(UStat, StatDataByPeriod) == 0x000038, "Member 'UStat::StatDataByPeriod' has a wrong offset!");
static_assert(offsetof(UStat, AbsoluteMaxValue) == 0x000048, "Member 'UStat::AbsoluteMaxValue' has a wrong offset!");

// Class FortniteGame.FortCarriedObject
// 0x0170 (0x04F8 - 0x0388)
class AFortCarriedObject : public AActor
{
public:
	uint8                                         Pad_388[0x18];                                     // 0x0388(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UProjectileMovementComponent*           ProjectileComp;                                    // 0x03A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCarriedObjectAttachmentInfo           HolderInfo;                                        // 0x03B0(0x0028)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D8[0x28];                                     // 0x03D8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                IndicatorRelativeOffset;                           // 0x0400(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40C[0x4];                                      // 0x040C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            Indicator;                                         // 0x0410(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSlateColor                            DefaultIndicatorColor;                             // 0x04A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FVector                                RelativeTranslation;                               // 0x04C8(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               RelativeRotation;                                  // 0x04D4(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bPickupOnTouch;                                    // 0x04E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortTeam                                     Team;                                              // 0x04E1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4E2[0x6];                                      // 0x04E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class ABuildingFlagSpawn*                     SpawnPointActor;                                   // 0x04E8(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4F0[0x8];                                      // 0x04F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_HolderInfo(struct FCarriedObjectAttachmentInfo* PreviousInfo);
	void ReturnToSpawnPoint();

	class AActor* GetHoldingActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCarriedObject">();
	}
	static class AFortCarriedObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortCarriedObject>();
	}
};
static_assert(alignof(AFortCarriedObject) == 0x000008, "Wrong alignment on AFortCarriedObject");
static_assert(sizeof(AFortCarriedObject) == 0x0004F8, "Wrong size on AFortCarriedObject");
static_assert(offsetof(AFortCarriedObject, ProjectileComp) == 0x0003A0, "Member 'AFortCarriedObject::ProjectileComp' has a wrong offset!");
static_assert(offsetof(AFortCarriedObject, HolderInfo) == 0x0003B0, "Member 'AFortCarriedObject::HolderInfo' has a wrong offset!");
static_assert(offsetof(AFortCarriedObject, IndicatorRelativeOffset) == 0x000400, "Member 'AFortCarriedObject::IndicatorRelativeOffset' has a wrong offset!");
static_assert(offsetof(AFortCarriedObject, Indicator) == 0x000410, "Member 'AFortCarriedObject::Indicator' has a wrong offset!");
static_assert(offsetof(AFortCarriedObject, DefaultIndicatorColor) == 0x0004A0, "Member 'AFortCarriedObject::DefaultIndicatorColor' has a wrong offset!");
static_assert(offsetof(AFortCarriedObject, RelativeTranslation) == 0x0004C8, "Member 'AFortCarriedObject::RelativeTranslation' has a wrong offset!");
static_assert(offsetof(AFortCarriedObject, RelativeRotation) == 0x0004D4, "Member 'AFortCarriedObject::RelativeRotation' has a wrong offset!");
static_assert(offsetof(AFortCarriedObject, bPickupOnTouch) == 0x0004E0, "Member 'AFortCarriedObject::bPickupOnTouch' has a wrong offset!");
static_assert(offsetof(AFortCarriedObject, Team) == 0x0004E1, "Member 'AFortCarriedObject::Team' has a wrong offset!");
static_assert(offsetof(AFortCarriedObject, SpawnPointActor) == 0x0004E8, "Member 'AFortCarriedObject::SpawnPointActor' has a wrong offset!");

// Class FortniteGame.FortWeatherAugment
// 0x0020 (0x0518 - 0x04F8)
class AFortWeatherAugment final : public AFortCarriedObject
{
public:
	struct FGameplayTagContainer                  WeatherTags;                                       // 0x04F8(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)

public:
	const struct FGameplayTagContainer GetWeatherTags() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortWeatherAugment">();
	}
	static class AFortWeatherAugment* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortWeatherAugment>();
	}
};
static_assert(alignof(AFortWeatherAugment) == 0x000008, "Wrong alignment on AFortWeatherAugment");
static_assert(sizeof(AFortWeatherAugment) == 0x000518, "Wrong size on AFortWeatherAugment");
static_assert(offsetof(AFortWeatherAugment, WeatherTags) == 0x0004F8, "Member 'AFortWeatherAugment::WeatherTags' has a wrong offset!");

// Class FortniteGame.FortTokenType
// 0x0050 (0x02C0 - 0x0270)
class UFortTokenType : public UFortAccountItemDefinition
{
public:
	TSoftClassPtr<class UClass>                   ScriptedAction;                                    // 0x0270(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateColor                            NodeTintColour;                                    // 0x0290(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTokenType">();
	}
	static class UFortTokenType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortTokenType>();
	}
};
static_assert(alignof(UFortTokenType) == 0x000010, "Wrong alignment on UFortTokenType");
static_assert(sizeof(UFortTokenType) == 0x0002C0, "Wrong size on UFortTokenType");
static_assert(offsetof(UFortTokenType, ScriptedAction) == 0x000270, "Member 'UFortTokenType::ScriptedAction' has a wrong offset!");
static_assert(offsetof(UFortTokenType, NodeTintColour) == 0x000290, "Member 'UFortTokenType::NodeTintColour' has a wrong offset!");

// Class FortniteGame.FortDailyRewardScheduleTokenDefinition
// 0x0000 (0x02C0 - 0x02C0)
class UFortDailyRewardScheduleTokenDefinition final : public UFortTokenType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDailyRewardScheduleTokenDefinition">();
	}
	static class UFortDailyRewardScheduleTokenDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDailyRewardScheduleTokenDefinition>();
	}
};
static_assert(alignof(UFortDailyRewardScheduleTokenDefinition) == 0x000010, "Wrong alignment on UFortDailyRewardScheduleTokenDefinition");
static_assert(sizeof(UFortDailyRewardScheduleTokenDefinition) == 0x0002C0, "Wrong size on UFortDailyRewardScheduleTokenDefinition");

// Class FortniteGame.FortQueryData_CurvesAroundLine
// 0x0060 (0x0088 - 0x0028)
class UFortQueryData_CurvesAroundLine final : public UDataAsset
{
public:
	struct FFortPointsOnCurve                     PointsOnSideA;                                     // 0x0028(0x0030)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FFortPointsOnCurve                     PointsOnSideB;                                     // 0x0058(0x0030)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryData_CurvesAroundLine">();
	}
	static class UFortQueryData_CurvesAroundLine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryData_CurvesAroundLine>();
	}
};
static_assert(alignof(UFortQueryData_CurvesAroundLine) == 0x000008, "Wrong alignment on UFortQueryData_CurvesAroundLine");
static_assert(sizeof(UFortQueryData_CurvesAroundLine) == 0x000088, "Wrong size on UFortQueryData_CurvesAroundLine");
static_assert(offsetof(UFortQueryData_CurvesAroundLine, PointsOnSideA) == 0x000028, "Member 'UFortQueryData_CurvesAroundLine::PointsOnSideA' has a wrong offset!");
static_assert(offsetof(UFortQueryData_CurvesAroundLine, PointsOnSideB) == 0x000058, "Member 'UFortQueryData_CurvesAroundLine::PointsOnSideB' has a wrong offset!");

// Class FortniteGame.FortDailyRewardScheduleDefinitions
// 0x0010 (0x0038 - 0x0028)
class UFortDailyRewardScheduleDefinitions final : public UDataAsset
{
public:
	TArray<struct FFortDailyRewardScheduleDefinition> Schedules;                                         // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDailyRewardScheduleDefinitions">();
	}
	static class UFortDailyRewardScheduleDefinitions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDailyRewardScheduleDefinitions>();
	}
};
static_assert(alignof(UFortDailyRewardScheduleDefinitions) == 0x000008, "Wrong alignment on UFortDailyRewardScheduleDefinitions");
static_assert(sizeof(UFortDailyRewardScheduleDefinitions) == 0x000038, "Wrong size on UFortDailyRewardScheduleDefinitions");
static_assert(offsetof(UFortDailyRewardScheduleDefinitions, Schedules) == 0x000028, "Member 'UFortDailyRewardScheduleDefinitions::Schedules' has a wrong offset!");

// Class FortniteGame.FortOutpostItemDefinition
// 0x0020 (0x0250 - 0x0230)
class UFortOutpostItemDefinition final : public UFortCloudSaveItemDefinition
{
public:
	TArray<TSubclassOf<class UGameplayEffect>>    StaticGameplayEffectsByLevel;                      // 0x0228(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class FText                                   LongDescription;                                   // 0x0238(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	class FText GetLongDescription() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortOutpostItemDefinition">();
	}
	static class UFortOutpostItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortOutpostItemDefinition>();
	}
};
static_assert(alignof(UFortOutpostItemDefinition) == 0x000010, "Wrong alignment on UFortOutpostItemDefinition");
static_assert(sizeof(UFortOutpostItemDefinition) == 0x000250, "Wrong size on UFortOutpostItemDefinition");
static_assert(offsetof(UFortOutpostItemDefinition, StaticGameplayEffectsByLevel) == 0x000228, "Member 'UFortOutpostItemDefinition::StaticGameplayEffectsByLevel' has a wrong offset!");
static_assert(offsetof(UFortOutpostItemDefinition, LongDescription) == 0x000238, "Member 'UFortOutpostItemDefinition::LongDescription' has a wrong offset!");

// Class FortniteGame.FortBTTask_BotMissionBuild
// 0x0000 (0x0098 - 0x0098)
class UFortBTTask_BotMissionBuild final : public UBTTask_BlackboardBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTTask_BotMissionBuild">();
	}
	static class UFortBTTask_BotMissionBuild* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTTask_BotMissionBuild>();
	}
};
static_assert(alignof(UFortBTTask_BotMissionBuild) == 0x000008, "Wrong alignment on UFortBTTask_BotMissionBuild");
static_assert(sizeof(UFortBTTask_BotMissionBuild) == 0x000098, "Wrong size on UFortBTTask_BotMissionBuild");

// Class FortniteGame.FortOutpostData
// 0x0198 (0x01C0 - 0x0028)
class UFortOutpostData final : public UDataAsset
{
public:
	int32                                         StructureLimitNotificationThreshold;               // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOutpostBuildingData                   StormShieldData;                                   // 0x0030(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FCraftingTableBuildingData             CraftingTableData;                                 // 0x0050(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FFabricatorBuildingData                FabricatorData;                                    // 0x0080(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FHarvestingOptimizerBuildingData       HarvestingOptimizerData;                           // 0x00E8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FStorageVaultBuildingData              StorageVaultData;                                  // 0x0108(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FOutpostUpgradeAndPrestigeBuildingData OutpostUpgradeAndPrestigeData;                     // 0x0138(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortOutpostData">();
	}
	static class UFortOutpostData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortOutpostData>();
	}
};
static_assert(alignof(UFortOutpostData) == 0x000008, "Wrong alignment on UFortOutpostData");
static_assert(sizeof(UFortOutpostData) == 0x0001C0, "Wrong size on UFortOutpostData");
static_assert(offsetof(UFortOutpostData, StructureLimitNotificationThreshold) == 0x000028, "Member 'UFortOutpostData::StructureLimitNotificationThreshold' has a wrong offset!");
static_assert(offsetof(UFortOutpostData, StormShieldData) == 0x000030, "Member 'UFortOutpostData::StormShieldData' has a wrong offset!");
static_assert(offsetof(UFortOutpostData, CraftingTableData) == 0x000050, "Member 'UFortOutpostData::CraftingTableData' has a wrong offset!");
static_assert(offsetof(UFortOutpostData, FabricatorData) == 0x000080, "Member 'UFortOutpostData::FabricatorData' has a wrong offset!");
static_assert(offsetof(UFortOutpostData, HarvestingOptimizerData) == 0x0000E8, "Member 'UFortOutpostData::HarvestingOptimizerData' has a wrong offset!");
static_assert(offsetof(UFortOutpostData, StorageVaultData) == 0x000108, "Member 'UFortOutpostData::StorageVaultData' has a wrong offset!");
static_assert(offsetof(UFortOutpostData, OutpostUpgradeAndPrestigeData) == 0x000138, "Member 'UFortOutpostData::OutpostUpgradeAndPrestigeData' has a wrong offset!");

// Class FortniteGame.FortAttributeCategory
// 0x0010 (0x0038 - 0x0028)
class UFortAttributeCategory final : public UDataAsset
{
public:
	TArray<struct FMyFortCategoryData>            Categories;                                        // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAttributeCategory">();
	}
	static class UFortAttributeCategory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAttributeCategory>();
	}
};
static_assert(alignof(UFortAttributeCategory) == 0x000008, "Wrong alignment on UFortAttributeCategory");
static_assert(sizeof(UFortAttributeCategory) == 0x000038, "Wrong size on UFortAttributeCategory");
static_assert(offsetof(UFortAttributeCategory, Categories) == 0x000028, "Member 'UFortAttributeCategory::Categories' has a wrong offset!");

// Class FortniteGame.FortQueryContext_TwoPointSolverPointA
// 0x0000 (0x0028 - 0x0028)
class UFortQueryContext_TwoPointSolverPointA final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_TwoPointSolverPointA">();
	}
	static class UFortQueryContext_TwoPointSolverPointA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_TwoPointSolverPointA>();
	}
};
static_assert(alignof(UFortQueryContext_TwoPointSolverPointA) == 0x000008, "Wrong alignment on UFortQueryContext_TwoPointSolverPointA");
static_assert(sizeof(UFortQueryContext_TwoPointSolverPointA) == 0x000028, "Wrong size on UFortQueryContext_TwoPointSolverPointA");

// Class FortniteGame.FortEditToolItemDefinition
// 0x0000 (0x0630 - 0x0630)
class UFortEditToolItemDefinition final : public UFortWeaponItemDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortEditToolItemDefinition">();
	}
	static class UFortEditToolItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortEditToolItemDefinition>();
	}
};
static_assert(alignof(UFortEditToolItemDefinition) == 0x000010, "Wrong alignment on UFortEditToolItemDefinition");
static_assert(sizeof(UFortEditToolItemDefinition) == 0x000630, "Wrong size on UFortEditToolItemDefinition");

// Class FortniteGame.FortZoneTheme
// 0x0248 (0x0270 - 0x0028)
class UFortZoneTheme : public UPrimaryDataAsset
{
public:
	TSoftClassPtr<class UClass>                   TheaterMapTileClass;                               // 0x0028(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  ZoneToUse;                                         // 0x0048(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   ZoneName;                                          // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   ZoneDescription;                                   // 0x0080(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   AbundantResources;                                 // 0x0098(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EFortZoneType                                 ZoneType;                                          // 0x00B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   ZoneGameMode;                                      // 0x00B8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ZoneTags;                                          // 0x00D8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   LobbyBeaconHostClass;                              // 0x00F8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFortCloudSaveItemDefinition> CloudSaveItemDefinition;                           // 0x0118(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ZoneIndex;                                         // 0x0138(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlaylistId;                                        // 0x013C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamSize;                                          // 0x0140(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamCount;                                         // 0x0144(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPartySize;                                      // 0x0148(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPlayers;                                        // 0x014C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CriticalMissionEligibilityLength;                  // 0x0150(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CriticalMissionEligibilityGracePeriodLength;       // 0x0154(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDeployableBaseSupportSettings         DeployableBaseSettings;                            // 0x0158(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         IgnoreGeneratedRewards : 1;                        // 0x01D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D9[0x7];                                      // 0x01D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   PlayerSpawnPadClass;                               // 0x01E0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  InitialPlayerSpawnTags;                            // 0x0200(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  BackupPlayerSpawnTags;                             // 0x0220(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bOverrideConningText;                              // 0x0240(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_241[0x7];                                      // 0x0241(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ConningOverrideText;                               // 0x0248(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FZoneThemeDifficultyProperties> DifficultyProperties;                              // 0x0260(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortZoneTheme">();
	}
	static class UFortZoneTheme* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortZoneTheme>();
	}
};
static_assert(alignof(UFortZoneTheme) == 0x000008, "Wrong alignment on UFortZoneTheme");
static_assert(sizeof(UFortZoneTheme) == 0x000270, "Wrong size on UFortZoneTheme");
static_assert(offsetof(UFortZoneTheme, TheaterMapTileClass) == 0x000028, "Member 'UFortZoneTheme::TheaterMapTileClass' has a wrong offset!");
static_assert(offsetof(UFortZoneTheme, ZoneToUse) == 0x000048, "Member 'UFortZoneTheme::ZoneToUse' has a wrong offset!");
static_assert(offsetof(UFortZoneTheme, ZoneName) == 0x000068, "Member 'UFortZoneTheme::ZoneName' has a wrong offset!");
static_assert(offsetof(UFortZoneTheme, ZoneDescription) == 0x000080, "Member 'UFortZoneTheme::ZoneDescription' has a wrong offset!");
static_assert(offsetof(UFortZoneTheme, AbundantResources) == 0x000098, "Member 'UFortZoneTheme::AbundantResources' has a wrong offset!");
static_assert(offsetof(UFortZoneTheme, ZoneType) == 0x0000B0, "Member 'UFortZoneTheme::ZoneType' has a wrong offset!");
static_assert(offsetof(UFortZoneTheme, ZoneGameMode) == 0x0000B8, "Member 'UFortZoneTheme::ZoneGameMode' has a wrong offset!");
static_assert(offsetof(UFortZoneTheme, ZoneTags) == 0x0000D8, "Member 'UFortZoneTheme::ZoneTags' has a wrong offset!");
static_assert(offsetof(UFortZoneTheme, LobbyBeaconHostClass) == 0x0000F8, "Member 'UFortZoneTheme::LobbyBeaconHostClass' has a wrong offset!");
static_assert(offsetof(UFortZoneTheme, CloudSaveItemDefinition) == 0x000118, "Member 'UFortZoneTheme::CloudSaveItemDefinition' has a wrong offset!");
static_assert(offsetof(UFortZoneTheme, ZoneIndex) == 0x000138, "Member 'UFortZoneTheme::ZoneIndex' has a wrong offset!");
static_assert(offsetof(UFortZoneTheme, PlaylistId) == 0x00013C, "Member 'UFortZoneTheme::PlaylistId' has a wrong offset!");
static_assert(offsetof(UFortZoneTheme, TeamSize) == 0x000140, "Member 'UFortZoneTheme::TeamSize' has a wrong offset!");
static_assert(offsetof(UFortZoneTheme, TeamCount) == 0x000144, "Member 'UFortZoneTheme::TeamCount' has a wrong offset!");
static_assert(offsetof(UFortZoneTheme, MaxPartySize) == 0x000148, "Member 'UFortZoneTheme::MaxPartySize' has a wrong offset!");
static_assert(offsetof(UFortZoneTheme, MaxPlayers) == 0x00014C, "Member 'UFortZoneTheme::MaxPlayers' has a wrong offset!");
static_assert(offsetof(UFortZoneTheme, CriticalMissionEligibilityLength) == 0x000150, "Member 'UFortZoneTheme::CriticalMissionEligibilityLength' has a wrong offset!");
static_assert(offsetof(UFortZoneTheme, CriticalMissionEligibilityGracePeriodLength) == 0x000154, "Member 'UFortZoneTheme::CriticalMissionEligibilityGracePeriodLength' has a wrong offset!");
static_assert(offsetof(UFortZoneTheme, DeployableBaseSettings) == 0x000158, "Member 'UFortZoneTheme::DeployableBaseSettings' has a wrong offset!");
static_assert(offsetof(UFortZoneTheme, PlayerSpawnPadClass) == 0x0001E0, "Member 'UFortZoneTheme::PlayerSpawnPadClass' has a wrong offset!");
static_assert(offsetof(UFortZoneTheme, InitialPlayerSpawnTags) == 0x000200, "Member 'UFortZoneTheme::InitialPlayerSpawnTags' has a wrong offset!");
static_assert(offsetof(UFortZoneTheme, BackupPlayerSpawnTags) == 0x000220, "Member 'UFortZoneTheme::BackupPlayerSpawnTags' has a wrong offset!");
static_assert(offsetof(UFortZoneTheme, bOverrideConningText) == 0x000240, "Member 'UFortZoneTheme::bOverrideConningText' has a wrong offset!");
static_assert(offsetof(UFortZoneTheme, ConningOverrideText) == 0x000248, "Member 'UFortZoneTheme::ConningOverrideText' has a wrong offset!");
static_assert(offsetof(UFortZoneTheme, DifficultyProperties) == 0x000260, "Member 'UFortZoneTheme::DifficultyProperties' has a wrong offset!");

// Class FortniteGame.FortTagUIDataLookupTable
// 0x0060 (0x0088 - 0x0028)
class UFortTagUIDataLookupTable final : public UDataAsset
{
public:
	TArray<struct FFortTagUIData>                 TagUIDataList;                                     // 0x0028(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTagUIDataLookupTable">();
	}
	static class UFortTagUIDataLookupTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortTagUIDataLookupTable>();
	}
};
static_assert(alignof(UFortTagUIDataLookupTable) == 0x000008, "Wrong alignment on UFortTagUIDataLookupTable");
static_assert(sizeof(UFortTagUIDataLookupTable) == 0x000088, "Wrong size on UFortTagUIDataLookupTable");
static_assert(offsetof(UFortTagUIDataLookupTable, TagUIDataList) == 0x000028, "Member 'UFortTagUIDataLookupTable::TagUIDataList' has a wrong offset!");

// Class FortniteGame.FortRegisteredPlayerInfo
// 0x0158 (0x0180 - 0x0028)
class UFortRegisteredPlayerInfo final : public UObject
{
public:
	UMulticastDelegateProperty_                   OnAbilitySystemActorChangedChangedDelegate;        // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FUniqueNetIdRepl                       PlayerID;                                          // 0x0038(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 PlayerName;                                        // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FUniqueNetIdRepl                       PartyLeaderId;                                     // 0x0060(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EFortTeam                                     TeamAssignment;                                    // 0x0078(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlayerIndex;                                       // 0x007C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsInitialPlayer;                                  // 0x0080(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShouldLockProfile;                                // 0x0081(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bFailedToLockProfile;                              // 0x0082(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_83[0x1];                                       // 0x0083(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  UnregistrationSaveGUID;                            // 0x0084(0x0010)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERegisteredPlayerUnregistrationStatus         UnregistrationStatus;                              // 0x0094(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           UnregisterFailsafeTimerHandle;                     // 0x0098(0x0008)(NoDestructor, NativeAccessSpecifierPrivate)
	class UFortMcpProfileAccount*                 AccountProfile;                                    // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortMcpProfileWorld*                   WorldProfile;                                      // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortMcpProfileWorld*                   OutpostProfile;                                    // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortMcpProfileMetadata*                MetadataProfile;                                   // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortQuestManager*                      QuestManager;                                      // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortCollectionBookManager*             CollectionBookManager;                             // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortExpeditionManager*                 ExpeditionManager;                                 // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortLinkedAccountManager*              LinkedAccountManager;                              // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x98];                                      // 0x00E0(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortHero*                              AthenaMenuHeroDef;                                 // 0x0178(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UAbilitySystemComponent* GetAbilitySystemComponent() const;
	class FString GetPlayerName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortRegisteredPlayerInfo">();
	}
	static class UFortRegisteredPlayerInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortRegisteredPlayerInfo>();
	}
};
static_assert(alignof(UFortRegisteredPlayerInfo) == 0x000008, "Wrong alignment on UFortRegisteredPlayerInfo");
static_assert(sizeof(UFortRegisteredPlayerInfo) == 0x000180, "Wrong size on UFortRegisteredPlayerInfo");
static_assert(offsetof(UFortRegisteredPlayerInfo, OnAbilitySystemActorChangedChangedDelegate) == 0x000028, "Member 'UFortRegisteredPlayerInfo::OnAbilitySystemActorChangedChangedDelegate' has a wrong offset!");
static_assert(offsetof(UFortRegisteredPlayerInfo, PlayerID) == 0x000038, "Member 'UFortRegisteredPlayerInfo::PlayerID' has a wrong offset!");
static_assert(offsetof(UFortRegisteredPlayerInfo, PlayerName) == 0x000050, "Member 'UFortRegisteredPlayerInfo::PlayerName' has a wrong offset!");
static_assert(offsetof(UFortRegisteredPlayerInfo, PartyLeaderId) == 0x000060, "Member 'UFortRegisteredPlayerInfo::PartyLeaderId' has a wrong offset!");
static_assert(offsetof(UFortRegisteredPlayerInfo, TeamAssignment) == 0x000078, "Member 'UFortRegisteredPlayerInfo::TeamAssignment' has a wrong offset!");
static_assert(offsetof(UFortRegisteredPlayerInfo, PlayerIndex) == 0x00007C, "Member 'UFortRegisteredPlayerInfo::PlayerIndex' has a wrong offset!");
static_assert(offsetof(UFortRegisteredPlayerInfo, bIsInitialPlayer) == 0x000080, "Member 'UFortRegisteredPlayerInfo::bIsInitialPlayer' has a wrong offset!");
static_assert(offsetof(UFortRegisteredPlayerInfo, bShouldLockProfile) == 0x000081, "Member 'UFortRegisteredPlayerInfo::bShouldLockProfile' has a wrong offset!");
static_assert(offsetof(UFortRegisteredPlayerInfo, bFailedToLockProfile) == 0x000082, "Member 'UFortRegisteredPlayerInfo::bFailedToLockProfile' has a wrong offset!");
static_assert(offsetof(UFortRegisteredPlayerInfo, UnregistrationSaveGUID) == 0x000084, "Member 'UFortRegisteredPlayerInfo::UnregistrationSaveGUID' has a wrong offset!");
static_assert(offsetof(UFortRegisteredPlayerInfo, UnregistrationStatus) == 0x000094, "Member 'UFortRegisteredPlayerInfo::UnregistrationStatus' has a wrong offset!");
static_assert(offsetof(UFortRegisteredPlayerInfo, UnregisterFailsafeTimerHandle) == 0x000098, "Member 'UFortRegisteredPlayerInfo::UnregisterFailsafeTimerHandle' has a wrong offset!");
static_assert(offsetof(UFortRegisteredPlayerInfo, AccountProfile) == 0x0000A0, "Member 'UFortRegisteredPlayerInfo::AccountProfile' has a wrong offset!");
static_assert(offsetof(UFortRegisteredPlayerInfo, WorldProfile) == 0x0000A8, "Member 'UFortRegisteredPlayerInfo::WorldProfile' has a wrong offset!");
static_assert(offsetof(UFortRegisteredPlayerInfo, OutpostProfile) == 0x0000B0, "Member 'UFortRegisteredPlayerInfo::OutpostProfile' has a wrong offset!");
static_assert(offsetof(UFortRegisteredPlayerInfo, MetadataProfile) == 0x0000B8, "Member 'UFortRegisteredPlayerInfo::MetadataProfile' has a wrong offset!");
static_assert(offsetof(UFortRegisteredPlayerInfo, QuestManager) == 0x0000C0, "Member 'UFortRegisteredPlayerInfo::QuestManager' has a wrong offset!");
static_assert(offsetof(UFortRegisteredPlayerInfo, CollectionBookManager) == 0x0000C8, "Member 'UFortRegisteredPlayerInfo::CollectionBookManager' has a wrong offset!");
static_assert(offsetof(UFortRegisteredPlayerInfo, ExpeditionManager) == 0x0000D0, "Member 'UFortRegisteredPlayerInfo::ExpeditionManager' has a wrong offset!");
static_assert(offsetof(UFortRegisteredPlayerInfo, LinkedAccountManager) == 0x0000D8, "Member 'UFortRegisteredPlayerInfo::LinkedAccountManager' has a wrong offset!");
static_assert(offsetof(UFortRegisteredPlayerInfo, AthenaMenuHeroDef) == 0x000178, "Member 'UFortRegisteredPlayerInfo::AthenaMenuHeroDef' has a wrong offset!");

// Class FortniteGame.FortMissionGenerationData
// 0x00D8 (0x0100 - 0x0028)
class UFortMissionGenerationData final : public UDataAsset
{
public:
	TArray<class UFortMissionGenerator*>          PrimaryMissionGenerators;                          // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         PrimaryMissionMinPowerPointsUsagePercentage;       // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCurveTableRowHandle                   SecondaryMissionPowerPointsBudgetMultiplier;       // 0x0040(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCurveTableRowHandle                   MinSecondaryMissionPowerPointsMultiplier;          // 0x0050(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCurveTableRowHandle                   MaxSecondaryMissionPowerPointsMultiplier;          // 0x0060(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCurveTableRowHandle                   MinSecondaryMissions;                              // 0x0070(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCurveTableRowHandle                   MaxSecondaryMissions;                              // 0x0080(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCurveTableRowHandle                   TertiaryMissionPowerPointsBudgetMultiplier;        // 0x0090(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCurveTableRowHandle                   MinTertiaryMissionPowerPointsMultiplier;           // 0x00A0(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCurveTableRowHandle                   MaxTertiaryMissionPowerPointsMultiplier;           // 0x00B0(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCurveTableRowHandle                   PowerPointsCurve;                                  // 0x00C0(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FFortDifficultyOptionBudget>    EncounterDifficultyOptionBudgets;                  // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         EncounterMinDifficultyOptionPointsUsagePercentage; // 0x00E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFortDifficultyOptionBudget>    MissionDifficultyOptionBudgets;                    // 0x00E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         MissionMinDifficultyOptionPointsUsagePercentage;   // 0x00F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMissionGenerationData">();
	}
	static class UFortMissionGenerationData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMissionGenerationData>();
	}
};
static_assert(alignof(UFortMissionGenerationData) == 0x000008, "Wrong alignment on UFortMissionGenerationData");
static_assert(sizeof(UFortMissionGenerationData) == 0x000100, "Wrong size on UFortMissionGenerationData");
static_assert(offsetof(UFortMissionGenerationData, PrimaryMissionGenerators) == 0x000028, "Member 'UFortMissionGenerationData::PrimaryMissionGenerators' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerationData, PrimaryMissionMinPowerPointsUsagePercentage) == 0x000038, "Member 'UFortMissionGenerationData::PrimaryMissionMinPowerPointsUsagePercentage' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerationData, SecondaryMissionPowerPointsBudgetMultiplier) == 0x000040, "Member 'UFortMissionGenerationData::SecondaryMissionPowerPointsBudgetMultiplier' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerationData, MinSecondaryMissionPowerPointsMultiplier) == 0x000050, "Member 'UFortMissionGenerationData::MinSecondaryMissionPowerPointsMultiplier' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerationData, MaxSecondaryMissionPowerPointsMultiplier) == 0x000060, "Member 'UFortMissionGenerationData::MaxSecondaryMissionPowerPointsMultiplier' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerationData, MinSecondaryMissions) == 0x000070, "Member 'UFortMissionGenerationData::MinSecondaryMissions' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerationData, MaxSecondaryMissions) == 0x000080, "Member 'UFortMissionGenerationData::MaxSecondaryMissions' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerationData, TertiaryMissionPowerPointsBudgetMultiplier) == 0x000090, "Member 'UFortMissionGenerationData::TertiaryMissionPowerPointsBudgetMultiplier' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerationData, MinTertiaryMissionPowerPointsMultiplier) == 0x0000A0, "Member 'UFortMissionGenerationData::MinTertiaryMissionPowerPointsMultiplier' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerationData, MaxTertiaryMissionPowerPointsMultiplier) == 0x0000B0, "Member 'UFortMissionGenerationData::MaxTertiaryMissionPowerPointsMultiplier' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerationData, PowerPointsCurve) == 0x0000C0, "Member 'UFortMissionGenerationData::PowerPointsCurve' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerationData, EncounterDifficultyOptionBudgets) == 0x0000D0, "Member 'UFortMissionGenerationData::EncounterDifficultyOptionBudgets' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerationData, EncounterMinDifficultyOptionPointsUsagePercentage) == 0x0000E0, "Member 'UFortMissionGenerationData::EncounterMinDifficultyOptionPointsUsagePercentage' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerationData, MissionDifficultyOptionBudgets) == 0x0000E8, "Member 'UFortMissionGenerationData::MissionDifficultyOptionBudgets' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerationData, MissionMinDifficultyOptionPointsUsagePercentage) == 0x0000F8, "Member 'UFortMissionGenerationData::MissionMinDifficultyOptionPointsUsagePercentage' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionEncounter_SpawnPointsMultiplier
// 0x0008 (0x0050 - 0x0048)
class UFortDifficultyOptionEncounter_SpawnPointsMultiplier final : public UFortDifficultyOptionEncounter
{
public:
	struct FFloatInterval                         MultiplierRange;                                   // 0x0048(0x0008)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionEncounter_SpawnPointsMultiplier">();
	}
	static class UFortDifficultyOptionEncounter_SpawnPointsMultiplier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionEncounter_SpawnPointsMultiplier>();
	}
};
static_assert(alignof(UFortDifficultyOptionEncounter_SpawnPointsMultiplier) == 0x000008, "Wrong alignment on UFortDifficultyOptionEncounter_SpawnPointsMultiplier");
static_assert(sizeof(UFortDifficultyOptionEncounter_SpawnPointsMultiplier) == 0x000050, "Wrong size on UFortDifficultyOptionEncounter_SpawnPointsMultiplier");
static_assert(offsetof(UFortDifficultyOptionEncounter_SpawnPointsMultiplier, MultiplierRange) == 0x000048, "Member 'UFortDifficultyOptionEncounter_SpawnPointsMultiplier::MultiplierRange' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionEncounter_Breathers
// 0x0038 (0x0080 - 0x0048)
class UFortDifficultyOptionEncounter_Breathers final : public UFortDifficultyOptionEncounter
{
public:
	bool                                          bUseBreathers;                                     // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCurveTableRowHandle                   LowPlayerPerformanceBreatherTimeSecondsCurve;      // 0x0050(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   NormalPlayerPerformanceBreatherTimeSecondsCurve;   // 0x0060(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   HighPlayerPerformanceBreatherTimeSecondsCurve;     // 0x0070(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionEncounter_Breathers">();
	}
	static class UFortDifficultyOptionEncounter_Breathers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionEncounter_Breathers>();
	}
};
static_assert(alignof(UFortDifficultyOptionEncounter_Breathers) == 0x000008, "Wrong alignment on UFortDifficultyOptionEncounter_Breathers");
static_assert(sizeof(UFortDifficultyOptionEncounter_Breathers) == 0x000080, "Wrong size on UFortDifficultyOptionEncounter_Breathers");
static_assert(offsetof(UFortDifficultyOptionEncounter_Breathers, bUseBreathers) == 0x000048, "Member 'UFortDifficultyOptionEncounter_Breathers::bUseBreathers' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionEncounter_Breathers, LowPlayerPerformanceBreatherTimeSecondsCurve) == 0x000050, "Member 'UFortDifficultyOptionEncounter_Breathers::LowPlayerPerformanceBreatherTimeSecondsCurve' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionEncounter_Breathers, NormalPlayerPerformanceBreatherTimeSecondsCurve) == 0x000060, "Member 'UFortDifficultyOptionEncounter_Breathers::NormalPlayerPerformanceBreatherTimeSecondsCurve' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionEncounter_Breathers, HighPlayerPerformanceBreatherTimeSecondsCurve) == 0x000070, "Member 'UFortDifficultyOptionEncounter_Breathers::HighPlayerPerformanceBreatherTimeSecondsCurve' has a wrong offset!");

// Class FortniteGame.FortBTTask_SetFrustrationDiscouragement
// 0x0008 (0x0078 - 0x0070)
class UFortBTTask_SetFrustrationDiscouragement final : public UBTTaskNode
{
public:
	float                                         DiscouragementDuration;                            // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTTask_SetFrustrationDiscouragement">();
	}
	static class UFortBTTask_SetFrustrationDiscouragement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTTask_SetFrustrationDiscouragement>();
	}
};
static_assert(alignof(UFortBTTask_SetFrustrationDiscouragement) == 0x000008, "Wrong alignment on UFortBTTask_SetFrustrationDiscouragement");
static_assert(sizeof(UFortBTTask_SetFrustrationDiscouragement) == 0x000078, "Wrong size on UFortBTTask_SetFrustrationDiscouragement");
static_assert(offsetof(UFortBTTask_SetFrustrationDiscouragement, DiscouragementDuration) == 0x000070, "Member 'UFortBTTask_SetFrustrationDiscouragement::DiscouragementDuration' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionEncounter_UtilitiesLocked
// 0x0010 (0x0058 - 0x0048)
class UFortDifficultyOptionEncounter_UtilitiesLocked final : public UFortDifficultyOptionEncounter
{
public:
	TArray<struct FFortEncounterLockedUtility>    LockedUtilities;                                   // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionEncounter_UtilitiesLocked">();
	}
	static class UFortDifficultyOptionEncounter_UtilitiesLocked* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionEncounter_UtilitiesLocked>();
	}
};
static_assert(alignof(UFortDifficultyOptionEncounter_UtilitiesLocked) == 0x000008, "Wrong alignment on UFortDifficultyOptionEncounter_UtilitiesLocked");
static_assert(sizeof(UFortDifficultyOptionEncounter_UtilitiesLocked) == 0x000058, "Wrong size on UFortDifficultyOptionEncounter_UtilitiesLocked");
static_assert(offsetof(UFortDifficultyOptionEncounter_UtilitiesLocked, LockedUtilities) == 0x000048, "Member 'UFortDifficultyOptionEncounter_UtilitiesLocked::LockedUtilities' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionEncounter_Distance
// 0x0008 (0x0050 - 0x0048)
class UFortDifficultyOptionEncounter_Distance final : public UFortDifficultyOptionEncounter
{
public:
	float                                         MinSpawnDistance;                                  // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxSpawnDistance;                                  // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionEncounter_Distance">();
	}
	static class UFortDifficultyOptionEncounter_Distance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionEncounter_Distance>();
	}
};
static_assert(alignof(UFortDifficultyOptionEncounter_Distance) == 0x000008, "Wrong alignment on UFortDifficultyOptionEncounter_Distance");
static_assert(sizeof(UFortDifficultyOptionEncounter_Distance) == 0x000050, "Wrong size on UFortDifficultyOptionEncounter_Distance");
static_assert(offsetof(UFortDifficultyOptionEncounter_Distance, MinSpawnDistance) == 0x000048, "Member 'UFortDifficultyOptionEncounter_Distance::MinSpawnDistance' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionEncounter_Distance, MaxSpawnDistance) == 0x00004C, "Member 'UFortDifficultyOptionEncounter_Distance::MaxSpawnDistance' has a wrong offset!");

// Class FortniteGame.FortQuestObjectiveInfo
// 0x0080 (0x00A8 - 0x0028)
class UFortQuestObjectiveInfo final : public UObject
{
public:
	class FName                                   BackendName;                                       // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortQuestObjectiveStatEvent                  StatEvent;                                         // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortQuestObjectiveItemEvent                  ItemEvent;                                         // 0x0031(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UFortItemDefinition>     ItemReference;                                     // 0x0038(0x0020)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0058(0x0018)(NativeAccessSpecifierPublic)
	class FText                                   HudShortDescription;                               // 0x0070(0x0018)(NativeAccessSpecifierPublic)
	class UTexture2D*                             HudIcon;                                           // 0x0088(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AchievedCount;                                     // 0x0090(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredCount;                                     // 0x0094(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastNotifiedCount;                                 // 0x0098(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVisible;                                          // 0x009C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bActive;                                           // 0x009D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9E[0xA];                                       // 0x009E(0x000A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisplayDynamicQuestUpdate();

	class UFortQuestItem* GetOwningQuest() const;
	bool HasCompleted() const;
	bool IsActive() const;
	bool IsInProgress() const;
	bool IsVisibleToUser() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQuestObjectiveInfo">();
	}
	static class UFortQuestObjectiveInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQuestObjectiveInfo>();
	}
};
static_assert(alignof(UFortQuestObjectiveInfo) == 0x000008, "Wrong alignment on UFortQuestObjectiveInfo");
static_assert(sizeof(UFortQuestObjectiveInfo) == 0x0000A8, "Wrong size on UFortQuestObjectiveInfo");
static_assert(offsetof(UFortQuestObjectiveInfo, BackendName) == 0x000028, "Member 'UFortQuestObjectiveInfo::BackendName' has a wrong offset!");
static_assert(offsetof(UFortQuestObjectiveInfo, StatEvent) == 0x000030, "Member 'UFortQuestObjectiveInfo::StatEvent' has a wrong offset!");
static_assert(offsetof(UFortQuestObjectiveInfo, ItemEvent) == 0x000031, "Member 'UFortQuestObjectiveInfo::ItemEvent' has a wrong offset!");
static_assert(offsetof(UFortQuestObjectiveInfo, ItemReference) == 0x000038, "Member 'UFortQuestObjectiveInfo::ItemReference' has a wrong offset!");
static_assert(offsetof(UFortQuestObjectiveInfo, Description) == 0x000058, "Member 'UFortQuestObjectiveInfo::Description' has a wrong offset!");
static_assert(offsetof(UFortQuestObjectiveInfo, HudShortDescription) == 0x000070, "Member 'UFortQuestObjectiveInfo::HudShortDescription' has a wrong offset!");
static_assert(offsetof(UFortQuestObjectiveInfo, HudIcon) == 0x000088, "Member 'UFortQuestObjectiveInfo::HudIcon' has a wrong offset!");
static_assert(offsetof(UFortQuestObjectiveInfo, AchievedCount) == 0x000090, "Member 'UFortQuestObjectiveInfo::AchievedCount' has a wrong offset!");
static_assert(offsetof(UFortQuestObjectiveInfo, RequiredCount) == 0x000094, "Member 'UFortQuestObjectiveInfo::RequiredCount' has a wrong offset!");
static_assert(offsetof(UFortQuestObjectiveInfo, LastNotifiedCount) == 0x000098, "Member 'UFortQuestObjectiveInfo::LastNotifiedCount' has a wrong offset!");
static_assert(offsetof(UFortQuestObjectiveInfo, bVisible) == 0x00009C, "Member 'UFortQuestObjectiveInfo::bVisible' has a wrong offset!");
static_assert(offsetof(UFortQuestObjectiveInfo, bActive) == 0x00009D, "Member 'UFortQuestObjectiveInfo::bActive' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionEncounter_DirectionNumber
// 0x0008 (0x0050 - 0x0048)
class UFortDifficultyOptionEncounter_DirectionNumber final : public UFortDifficultyOptionEncounter
{
public:
	int32                                         NumberOfDirections;                                // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionEncounter_DirectionNumber">();
	}
	static class UFortDifficultyOptionEncounter_DirectionNumber* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionEncounter_DirectionNumber>();
	}
};
static_assert(alignof(UFortDifficultyOptionEncounter_DirectionNumber) == 0x000008, "Wrong alignment on UFortDifficultyOptionEncounter_DirectionNumber");
static_assert(sizeof(UFortDifficultyOptionEncounter_DirectionNumber) == 0x000050, "Wrong size on UFortDifficultyOptionEncounter_DirectionNumber");
static_assert(offsetof(UFortDifficultyOptionEncounter_DirectionNumber, NumberOfDirections) == 0x000048, "Member 'UFortDifficultyOptionEncounter_DirectionNumber::NumberOfDirections' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionEncounter_SpawnLimitPawns
// 0x0008 (0x0050 - 0x0048)
class UFortDifficultyOptionEncounter_SpawnLimitPawns final : public UFortDifficultyOptionEncounter
{
public:
	int32                                         PawnNumberLimit;                                   // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionEncounter_SpawnLimitPawns">();
	}
	static class UFortDifficultyOptionEncounter_SpawnLimitPawns* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionEncounter_SpawnLimitPawns>();
	}
};
static_assert(alignof(UFortDifficultyOptionEncounter_SpawnLimitPawns) == 0x000008, "Wrong alignment on UFortDifficultyOptionEncounter_SpawnLimitPawns");
static_assert(sizeof(UFortDifficultyOptionEncounter_SpawnLimitPawns) == 0x000050, "Wrong size on UFortDifficultyOptionEncounter_SpawnLimitPawns");
static_assert(offsetof(UFortDifficultyOptionEncounter_SpawnLimitPawns, PawnNumberLimit) == 0x000048, "Member 'UFortDifficultyOptionEncounter_SpawnLimitPawns::PawnNumberLimit' has a wrong offset!");

// Class FortniteGame.MyTownData
// 0x0060 (0x0088 - 0x0028)
class UMyTownData final : public UDataAsset
{
public:
	TArray<struct FMyTownWorkerPersonalityData>   WorkerPersonalities;                               // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FMyTownWorkerSetBonusData>      WorkerSetBonuses;                                  // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UFortPersistentResourceItemDefinition*  PersonnelXpItemDefinition;                         // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortPersistentResourceItemDefinition*  HeroXpItemDefinition;                              // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortPersistentResourceItemDefinition*  VoucherItemDefinition;                             // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortPersistentResourceItemDefinition*  SchematicXpItemDefinition;                         // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortCurrencyItemDefinition*            CurrencyItemDefinition;                            // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortTokenType*                         SkillPointItemDefinition;                          // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortTokenType*                         ResearchPointItemDefinition;                       // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            TotalRatingGameplayEffect;                         // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MyTownData">();
	}
	static class UMyTownData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMyTownData>();
	}
};
static_assert(alignof(UMyTownData) == 0x000008, "Wrong alignment on UMyTownData");
static_assert(sizeof(UMyTownData) == 0x000088, "Wrong size on UMyTownData");
static_assert(offsetof(UMyTownData, WorkerPersonalities) == 0x000028, "Member 'UMyTownData::WorkerPersonalities' has a wrong offset!");
static_assert(offsetof(UMyTownData, WorkerSetBonuses) == 0x000038, "Member 'UMyTownData::WorkerSetBonuses' has a wrong offset!");
static_assert(offsetof(UMyTownData, PersonnelXpItemDefinition) == 0x000048, "Member 'UMyTownData::PersonnelXpItemDefinition' has a wrong offset!");
static_assert(offsetof(UMyTownData, HeroXpItemDefinition) == 0x000050, "Member 'UMyTownData::HeroXpItemDefinition' has a wrong offset!");
static_assert(offsetof(UMyTownData, VoucherItemDefinition) == 0x000058, "Member 'UMyTownData::VoucherItemDefinition' has a wrong offset!");
static_assert(offsetof(UMyTownData, SchematicXpItemDefinition) == 0x000060, "Member 'UMyTownData::SchematicXpItemDefinition' has a wrong offset!");
static_assert(offsetof(UMyTownData, CurrencyItemDefinition) == 0x000068, "Member 'UMyTownData::CurrencyItemDefinition' has a wrong offset!");
static_assert(offsetof(UMyTownData, SkillPointItemDefinition) == 0x000070, "Member 'UMyTownData::SkillPointItemDefinition' has a wrong offset!");
static_assert(offsetof(UMyTownData, ResearchPointItemDefinition) == 0x000078, "Member 'UMyTownData::ResearchPointItemDefinition' has a wrong offset!");
static_assert(offsetof(UMyTownData, TotalRatingGameplayEffect) == 0x000080, "Member 'UMyTownData::TotalRatingGameplayEffect' has a wrong offset!");

// Class FortniteGame.FortSurvivorData
// 0x0068 (0x0090 - 0x0028)
class UFortSurvivorData final : public UDataAsset
{
public:
	class UDataTable*                             SurvivorFemaleFirstNameData;                       // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             SurvivorMaleFirstNameData;                         // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             SurvivorFemaleLastNameData;                        // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             SurvivorMaleLastNameData;                          // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x48];                                      // 0x0048(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortSurvivorData">();
	}
	static class UFortSurvivorData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortSurvivorData>();
	}
};
static_assert(alignof(UFortSurvivorData) == 0x000008, "Wrong alignment on UFortSurvivorData");
static_assert(sizeof(UFortSurvivorData) == 0x000090, "Wrong size on UFortSurvivorData");
static_assert(offsetof(UFortSurvivorData, SurvivorFemaleFirstNameData) == 0x000028, "Member 'UFortSurvivorData::SurvivorFemaleFirstNameData' has a wrong offset!");
static_assert(offsetof(UFortSurvivorData, SurvivorMaleFirstNameData) == 0x000030, "Member 'UFortSurvivorData::SurvivorMaleFirstNameData' has a wrong offset!");
static_assert(offsetof(UFortSurvivorData, SurvivorFemaleLastNameData) == 0x000038, "Member 'UFortSurvivorData::SurvivorFemaleLastNameData' has a wrong offset!");
static_assert(offsetof(UFortSurvivorData, SurvivorMaleLastNameData) == 0x000040, "Member 'UFortSurvivorData::SurvivorMaleLastNameData' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionEncounter_SpawnTiming
// 0x0008 (0x0050 - 0x0048)
class UFortDifficultyOptionEncounter_SpawnTiming final : public UFortDifficultyOptionEncounter
{
public:
	float                                         SpawnIntervalSeconds;                              // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionEncounter_SpawnTiming">();
	}
	static class UFortDifficultyOptionEncounter_SpawnTiming* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionEncounter_SpawnTiming>();
	}
};
static_assert(alignof(UFortDifficultyOptionEncounter_SpawnTiming) == 0x000008, "Wrong alignment on UFortDifficultyOptionEncounter_SpawnTiming");
static_assert(sizeof(UFortDifficultyOptionEncounter_SpawnTiming) == 0x000050, "Wrong size on UFortDifficultyOptionEncounter_SpawnTiming");
static_assert(offsetof(UFortDifficultyOptionEncounter_SpawnTiming, SpawnIntervalSeconds) == 0x000048, "Member 'UFortDifficultyOptionEncounter_SpawnTiming::SpawnIntervalSeconds' has a wrong offset!");

// Class FortniteGame.Fort3PCameraMode
// 0x00D8 (0x0128 - 0x0050)
class UFort3PCameraMode : public UFortCameraMode
{
public:
	struct FViewOffsetData                        ViewOffsets;                                       // 0x0050(0x0024)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         FOV;                                               // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                SafeLocationOffset;                                // 0x0078(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bValidateSafeLoc : 1;                              // 0x0084(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDoPredictiveAvoidance : 1;                        // 0x0084(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bPreventPenetration : 1;                           // 0x0084(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPenetrationAvoidanceFeeler>    PenetrationAvoidanceFeelers;                       // 0x0088(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         PenetrationBlendInTime;                            // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PenetrationBlendOutTime;                           // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                PivotLocInterpSpeed;                               // 0x00A0(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PivotRotInterpSpeed;                               // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FOVInterpSpeed;                                    // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ViewOffsetInterpSpeed;                             // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SafeLocationInterpSpeed;                           // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LastActualViewOffset;                              // 0x00BC(0x000C)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                LastIdealViewOffset;                               // 0x00C8(0x000C)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LastFOV;                                           // 0x00D4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                LastSafeLocationLocal;                             // 0x00D8(0x000C)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                LastSafeLocation;                                  // 0x00E4(0x000C)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LastSafeLocBlockedPct;                             // 0x00F0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LastPenetrationBlockedPct;                         // 0x00F4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                LastActualPivotLoc;                                // 0x00F8(0x000C)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               LastActualPivotRot;                                // 0x0104(0x000C)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector                                LastIdealPivotLoc;                                 // 0x0110(0x000C)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               LastIdealPivotRot;                                 // 0x011C(0x000C)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Fort3PCameraMode">();
	}
	static class UFort3PCameraMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFort3PCameraMode>();
	}
};
static_assert(alignof(UFort3PCameraMode) == 0x000008, "Wrong alignment on UFort3PCameraMode");
static_assert(sizeof(UFort3PCameraMode) == 0x000128, "Wrong size on UFort3PCameraMode");
static_assert(offsetof(UFort3PCameraMode, ViewOffsets) == 0x000050, "Member 'UFort3PCameraMode::ViewOffsets' has a wrong offset!");
static_assert(offsetof(UFort3PCameraMode, FOV) == 0x000074, "Member 'UFort3PCameraMode::FOV' has a wrong offset!");
static_assert(offsetof(UFort3PCameraMode, SafeLocationOffset) == 0x000078, "Member 'UFort3PCameraMode::SafeLocationOffset' has a wrong offset!");
static_assert(offsetof(UFort3PCameraMode, PenetrationAvoidanceFeelers) == 0x000088, "Member 'UFort3PCameraMode::PenetrationAvoidanceFeelers' has a wrong offset!");
static_assert(offsetof(UFort3PCameraMode, PenetrationBlendInTime) == 0x000098, "Member 'UFort3PCameraMode::PenetrationBlendInTime' has a wrong offset!");
static_assert(offsetof(UFort3PCameraMode, PenetrationBlendOutTime) == 0x00009C, "Member 'UFort3PCameraMode::PenetrationBlendOutTime' has a wrong offset!");
static_assert(offsetof(UFort3PCameraMode, PivotLocInterpSpeed) == 0x0000A0, "Member 'UFort3PCameraMode::PivotLocInterpSpeed' has a wrong offset!");
static_assert(offsetof(UFort3PCameraMode, PivotRotInterpSpeed) == 0x0000AC, "Member 'UFort3PCameraMode::PivotRotInterpSpeed' has a wrong offset!");
static_assert(offsetof(UFort3PCameraMode, FOVInterpSpeed) == 0x0000B0, "Member 'UFort3PCameraMode::FOVInterpSpeed' has a wrong offset!");
static_assert(offsetof(UFort3PCameraMode, ViewOffsetInterpSpeed) == 0x0000B4, "Member 'UFort3PCameraMode::ViewOffsetInterpSpeed' has a wrong offset!");
static_assert(offsetof(UFort3PCameraMode, SafeLocationInterpSpeed) == 0x0000B8, "Member 'UFort3PCameraMode::SafeLocationInterpSpeed' has a wrong offset!");
static_assert(offsetof(UFort3PCameraMode, LastActualViewOffset) == 0x0000BC, "Member 'UFort3PCameraMode::LastActualViewOffset' has a wrong offset!");
static_assert(offsetof(UFort3PCameraMode, LastIdealViewOffset) == 0x0000C8, "Member 'UFort3PCameraMode::LastIdealViewOffset' has a wrong offset!");
static_assert(offsetof(UFort3PCameraMode, LastFOV) == 0x0000D4, "Member 'UFort3PCameraMode::LastFOV' has a wrong offset!");
static_assert(offsetof(UFort3PCameraMode, LastSafeLocationLocal) == 0x0000D8, "Member 'UFort3PCameraMode::LastSafeLocationLocal' has a wrong offset!");
static_assert(offsetof(UFort3PCameraMode, LastSafeLocation) == 0x0000E4, "Member 'UFort3PCameraMode::LastSafeLocation' has a wrong offset!");
static_assert(offsetof(UFort3PCameraMode, LastSafeLocBlockedPct) == 0x0000F0, "Member 'UFort3PCameraMode::LastSafeLocBlockedPct' has a wrong offset!");
static_assert(offsetof(UFort3PCameraMode, LastPenetrationBlockedPct) == 0x0000F4, "Member 'UFort3PCameraMode::LastPenetrationBlockedPct' has a wrong offset!");
static_assert(offsetof(UFort3PCameraMode, LastActualPivotLoc) == 0x0000F8, "Member 'UFort3PCameraMode::LastActualPivotLoc' has a wrong offset!");
static_assert(offsetof(UFort3PCameraMode, LastActualPivotRot) == 0x000104, "Member 'UFort3PCameraMode::LastActualPivotRot' has a wrong offset!");
static_assert(offsetof(UFort3PCameraMode, LastIdealPivotLoc) == 0x000110, "Member 'UFort3PCameraMode::LastIdealPivotLoc' has a wrong offset!");
static_assert(offsetof(UFort3PCameraMode, LastIdealPivotRot) == 0x00011C, "Member 'UFort3PCameraMode::LastIdealPivotRot' has a wrong offset!");

// Class FortniteGame.Fort3PCam_Targeting
// 0x0000 (0x0128 - 0x0128)
class UFort3PCam_Targeting : public UFort3PCameraMode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Fort3PCam_Targeting">();
	}
	static class UFort3PCam_Targeting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFort3PCam_Targeting>();
	}
};
static_assert(alignof(UFort3PCam_Targeting) == 0x000008, "Wrong alignment on UFort3PCam_Targeting");
static_assert(sizeof(UFort3PCam_Targeting) == 0x000128, "Wrong size on UFort3PCam_Targeting");

// Class FortniteGame.FortAsyncAction_MCPContextUpgradeItem
// 0x0020 (0x0048 - 0x0028)
class UFortAsyncAction_MCPContextUpgradeItem final : public UBlueprintAsyncActionBase
{
public:
	UMulticastDelegateProperty_                   OnMCPRequestComplete;                              // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UFortMcpContext>         MCPContext;                                        // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UFortItem>               ItemToUpgrade;                                     // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UFortAsyncAction_MCPContextUpgradeItem* UpgradeItem(const class UFortMcpContext* MCPContext_0, const class UFortItem* ItemToUpgrade_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAsyncAction_MCPContextUpgradeItem">();
	}
	static class UFortAsyncAction_MCPContextUpgradeItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAsyncAction_MCPContextUpgradeItem>();
	}
};
static_assert(alignof(UFortAsyncAction_MCPContextUpgradeItem) == 0x000008, "Wrong alignment on UFortAsyncAction_MCPContextUpgradeItem");
static_assert(sizeof(UFortAsyncAction_MCPContextUpgradeItem) == 0x000048, "Wrong size on UFortAsyncAction_MCPContextUpgradeItem");
static_assert(offsetof(UFortAsyncAction_MCPContextUpgradeItem, OnMCPRequestComplete) == 0x000028, "Member 'UFortAsyncAction_MCPContextUpgradeItem::OnMCPRequestComplete' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_MCPContextUpgradeItem, MCPContext) == 0x000038, "Member 'UFortAsyncAction_MCPContextUpgradeItem::MCPContext' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_MCPContextUpgradeItem, ItemToUpgrade) == 0x000040, "Member 'UFortAsyncAction_MCPContextUpgradeItem::ItemToUpgrade' has a wrong offset!");

// Class FortniteGame.FortAsyncAction_MCPContextConsumeItem
// 0x0038 (0x0060 - 0x0028)
class UFortAsyncAction_MCPContextConsumeItem final : public UBlueprintAsyncActionBase
{
public:
	UMulticastDelegateProperty_                   OnMCPRequestComplete;                              // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UFortMcpContext>         MCPContext;                                        // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UFortItem>               ItemToConsume;                                     // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FUniqueNetIdRepl                       TargetAccountId;                                   // 0x0048(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UFortAsyncAction_MCPContextConsumeItem* ConsumeItem(const class UFortMcpContext* MCPContext_0, const class UFortItem* ItemToConsume_0, const struct FUniqueNetIdRepl& TargetAccountId_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAsyncAction_MCPContextConsumeItem">();
	}
	static class UFortAsyncAction_MCPContextConsumeItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAsyncAction_MCPContextConsumeItem>();
	}
};
static_assert(alignof(UFortAsyncAction_MCPContextConsumeItem) == 0x000008, "Wrong alignment on UFortAsyncAction_MCPContextConsumeItem");
static_assert(sizeof(UFortAsyncAction_MCPContextConsumeItem) == 0x000060, "Wrong size on UFortAsyncAction_MCPContextConsumeItem");
static_assert(offsetof(UFortAsyncAction_MCPContextConsumeItem, OnMCPRequestComplete) == 0x000028, "Member 'UFortAsyncAction_MCPContextConsumeItem::OnMCPRequestComplete' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_MCPContextConsumeItem, MCPContext) == 0x000038, "Member 'UFortAsyncAction_MCPContextConsumeItem::MCPContext' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_MCPContextConsumeItem, ItemToConsume) == 0x000040, "Member 'UFortAsyncAction_MCPContextConsumeItem::ItemToConsume' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_MCPContextConsumeItem, TargetAccountId) == 0x000048, "Member 'UFortAsyncAction_MCPContextConsumeItem::TargetAccountId' has a wrong offset!");

// Class FortniteGame.FortMcpContext
// 0x03F8 (0x0420 - 0x0028)
class UFortMcpContext final : public UBlueprintContextBase
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnHeroesChanged;                                   // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnXpBoostChanged;                                  // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFounderGranted;                                  // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnDailyRewardTokenGranted;                         // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnLocalAccountInfoChanged;                         // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnCurrentlyViewedAccountInfoChanged;               // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMissionRewardsOpened;                            // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMissionRewardsOpenFailed;                        // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMissionAlertRewardsOpened;                       // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnResourceCollectorClaimed;                        // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnConversionComplete;                              // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnTransmogComplete;                                // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnTransmogFailed;                                  // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnLiveStreamingQuestWindowStarts;                  // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnLiveStreamingQuestWindowEnds;                    // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnLiveStreamingQuestWindowSelectedViewers;         // 0x0120(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnRealMoneyPurchaseComplete;                       // 0x0130(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_140[0x1C0];                                    // 0x0140(0x01C0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFriendCode>                    CachedFriendCodes;                                 // 0x0300(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	class FText                                   FriendCodeMessageTitle;                            // 0x0310(0x0018)(Edit, Config, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFriendCodeLocString>           FriendCodeMessageTitleLocTexts;                    // 0x0328(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	class FText                                   FriendCodeMessageBody;                             // 0x0338(0x0018)(Edit, Config, Protected, NativeAccessSpecifierProtected)
	class FText                                   FriendCodeMessageDetails;                          // 0x0350(0x0018)(Edit, Config, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFriendCodeLocString>           FriendCodeMessageDetailsLocTexts;                  // 0x0368(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_378[0x80];                                     // 0x0378(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(class UWidget* WebWidget, const class FString& OfferId)> DisplayPurchaseWidget;                             // 0x03F8(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPrivate)
	TDelegate<void()>                             DismissPurchaseWidget;                             // 0x0408(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_418[0x8];                                      // 0x0418(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AbandonExpedition(const class UFortExpeditionItem* Expedition);
	void ApplyAlteration(class UFortAlterableItem* Item, class UFortAlterationItem* AlterationToApply);
	bool AreMissionRewardsAvailable();
	void CancelEpicPurchasingDisplay();
	void ClaimAllResourceCollectors();
	void ClaimResourceCollectors(const TArray<class UFortCollectedResourceItem*>& CollectorTypes);
	void CollectExpedition(const class UFortExpeditionItem* Expedition);
	void ConvertItem(const class UFortItem* ItemToConvert, int32 RecipeIndex);
	void GetAllResourceCollectors(TArray<class UFortCollectedResourceItem*>* ResourceCollectorsOwned);
	class FText GetEULAText();
	class FText GetFriendCodeDescription(const struct FFriendCode& FriendCode);
	class FText GetFriendCodeDisplayName(const struct FFriendCode& FriendCode);
	void GrantPendingMissionAlertRewards();
	bool IsAllowedConversionIndex(const class UFortItem* ItemToConvert, int32 RecipeIndex);
	void IssueFriendCode(const TDelegate<void(bool bSuccess, struct FFriendCode& FriendCode)>& OnCompleteDelegate);
	void ListMtxPackages(const TDelegate<void(TArray<struct FMtxPackage>& Offers)>& Callback, bool bIncludeCurrency);
	void MarkItemSeen(class UFortAccountItem* ItemToMarkSeen);
	void OpenMissionRewards();
	void PurchaseRealMoneyCatalogEntry(const class FString& OfferId, const TDelegate<void(bool bSuccess)>& Callback);
	void QueryUnredeemedFriendCodes(const TDelegate<void(bool bSuccess, TArray<struct FFriendCode>& FriendCodes)>& OnCompleteDelegate);
	void RecycleItem(const class UFortItem* ItemToRecycle);
	void RecycleItemBatch(const TArray<class UFortItem*>& ItemsToRecycle);
	void RegisterForEpicPurchasingDisplay(const TDelegate<void(class UWidget* WebWidget, const class FString& OfferId)>& DisplayCallback, const TDelegate<void()>& DismissCallback);
	void SendFriendCodePlatformMessage(const struct FFriendCode& FriendCode, const TDelegate<void(bool bMessageSent)>& OnCompleteDelegate);
	void SetItemFavoriteStatus(class UFortAccountItem* Item, bool bFavorite);
	bool StartExpedition(const class UFortExpeditionItem* Expedition, const float SuccessChance, const class FName& SquadId, const float SquadRating, const TArray<class UFortItem*>& SlottedSquadItems, const TArray<int32>& SlotIndices, const TArray<float>& ItemRatingMods, float GlobalMod);
	void TransmogItem(const class UFortConversionControlItemDefinition* ControlKeyItem, const TArray<class UFortItem*>& ItemsToSacrifice);

	void DisplayEmptyStoreDialog() const;
	class UFortAccountItem* GetAccountItemWithDefinition(const class UFortAccountItemDefinition* AccountItemDefinition) const;
	void GetAllAlterations(TArray<class UFortAlterationItem*>* OutAlterations, EFortAlteration InAlterationType) const;
	void GetAllHeroes(TArray<class UFortHero*>* Result) const;
	void GetCurrentlyViewedAccountInfo(struct FFortPublicAccountInfo* Result) const;
	class UFortHero* GetDefaultHero() const;
	int32 GetGroupXpBonusPercent() const;
	int32 GetHeroXpBalance() const;
	void GetHomeBaseInfo(struct FFortHomeBaseInfo* Result) const;
	void GetHomeBaseInfoForPlayer(struct FFortHomeBaseInfo* Result, const struct FUniqueNetIdRepl& MemberUniqueId) const;
	void GetLocalAccountInfo(struct FFortPrivateAccountInfo* Result) const;
	class FText GetLoginStatusText() const;
	class UFortMcpProfileAccount* GetMcpProfile() const;
	int32 GetNumFriendCodesToIssue() const;
	int32 GetPersonalXpBonusPercent() const;
	int32 GetPersonnelXpBalance() const;
	int32 GetPlayersXPPercentContributionToLocalPlayer(const struct FUniqueNetIdRepl& PlayerID) const;
	int32 GetRestXpBalance() const;
	int32 GetRestXpBonusPercent() const;
	int32 GetSchematicXpBalance() const;
	int32 GetUpgradeXPBalance(const EFortItemType ItemTypeToBeUpgraded) const;
	int32 GetXpBoostBalance() const;
	bool HasPendingMissionAlertRewards() const;
	bool IsDailyRewardAvailable(int32* OutMinutesUntilNextReward) const;
	bool IsLocalPlayersUniqueID(const struct FUniqueNetIdRepl& PlayerID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMcpContext">();
	}
	static class UFortMcpContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMcpContext>();
	}
};
static_assert(alignof(UFortMcpContext) == 0x000008, "Wrong alignment on UFortMcpContext");
static_assert(sizeof(UFortMcpContext) == 0x000420, "Wrong size on UFortMcpContext");
static_assert(offsetof(UFortMcpContext, OnHeroesChanged) == 0x000030, "Member 'UFortMcpContext::OnHeroesChanged' has a wrong offset!");
static_assert(offsetof(UFortMcpContext, OnXpBoostChanged) == 0x000040, "Member 'UFortMcpContext::OnXpBoostChanged' has a wrong offset!");
static_assert(offsetof(UFortMcpContext, OnFounderGranted) == 0x000050, "Member 'UFortMcpContext::OnFounderGranted' has a wrong offset!");
static_assert(offsetof(UFortMcpContext, OnDailyRewardTokenGranted) == 0x000060, "Member 'UFortMcpContext::OnDailyRewardTokenGranted' has a wrong offset!");
static_assert(offsetof(UFortMcpContext, OnLocalAccountInfoChanged) == 0x000070, "Member 'UFortMcpContext::OnLocalAccountInfoChanged' has a wrong offset!");
static_assert(offsetof(UFortMcpContext, OnCurrentlyViewedAccountInfoChanged) == 0x000080, "Member 'UFortMcpContext::OnCurrentlyViewedAccountInfoChanged' has a wrong offset!");
static_assert(offsetof(UFortMcpContext, OnMissionRewardsOpened) == 0x000090, "Member 'UFortMcpContext::OnMissionRewardsOpened' has a wrong offset!");
static_assert(offsetof(UFortMcpContext, OnMissionRewardsOpenFailed) == 0x0000A0, "Member 'UFortMcpContext::OnMissionRewardsOpenFailed' has a wrong offset!");
static_assert(offsetof(UFortMcpContext, OnMissionAlertRewardsOpened) == 0x0000B0, "Member 'UFortMcpContext::OnMissionAlertRewardsOpened' has a wrong offset!");
static_assert(offsetof(UFortMcpContext, OnResourceCollectorClaimed) == 0x0000C0, "Member 'UFortMcpContext::OnResourceCollectorClaimed' has a wrong offset!");
static_assert(offsetof(UFortMcpContext, OnConversionComplete) == 0x0000D0, "Member 'UFortMcpContext::OnConversionComplete' has a wrong offset!");
static_assert(offsetof(UFortMcpContext, OnTransmogComplete) == 0x0000E0, "Member 'UFortMcpContext::OnTransmogComplete' has a wrong offset!");
static_assert(offsetof(UFortMcpContext, OnTransmogFailed) == 0x0000F0, "Member 'UFortMcpContext::OnTransmogFailed' has a wrong offset!");
static_assert(offsetof(UFortMcpContext, OnLiveStreamingQuestWindowStarts) == 0x000100, "Member 'UFortMcpContext::OnLiveStreamingQuestWindowStarts' has a wrong offset!");
static_assert(offsetof(UFortMcpContext, OnLiveStreamingQuestWindowEnds) == 0x000110, "Member 'UFortMcpContext::OnLiveStreamingQuestWindowEnds' has a wrong offset!");
static_assert(offsetof(UFortMcpContext, OnLiveStreamingQuestWindowSelectedViewers) == 0x000120, "Member 'UFortMcpContext::OnLiveStreamingQuestWindowSelectedViewers' has a wrong offset!");
static_assert(offsetof(UFortMcpContext, OnRealMoneyPurchaseComplete) == 0x000130, "Member 'UFortMcpContext::OnRealMoneyPurchaseComplete' has a wrong offset!");
static_assert(offsetof(UFortMcpContext, CachedFriendCodes) == 0x000300, "Member 'UFortMcpContext::CachedFriendCodes' has a wrong offset!");
static_assert(offsetof(UFortMcpContext, FriendCodeMessageTitle) == 0x000310, "Member 'UFortMcpContext::FriendCodeMessageTitle' has a wrong offset!");
static_assert(offsetof(UFortMcpContext, FriendCodeMessageTitleLocTexts) == 0x000328, "Member 'UFortMcpContext::FriendCodeMessageTitleLocTexts' has a wrong offset!");
static_assert(offsetof(UFortMcpContext, FriendCodeMessageBody) == 0x000338, "Member 'UFortMcpContext::FriendCodeMessageBody' has a wrong offset!");
static_assert(offsetof(UFortMcpContext, FriendCodeMessageDetails) == 0x000350, "Member 'UFortMcpContext::FriendCodeMessageDetails' has a wrong offset!");
static_assert(offsetof(UFortMcpContext, FriendCodeMessageDetailsLocTexts) == 0x000368, "Member 'UFortMcpContext::FriendCodeMessageDetailsLocTexts' has a wrong offset!");
static_assert(offsetof(UFortMcpContext, DisplayPurchaseWidget) == 0x0003F8, "Member 'UFortMcpContext::DisplayPurchaseWidget' has a wrong offset!");
static_assert(offsetof(UFortMcpContext, DismissPurchaseWidget) == 0x000408, "Member 'UFortMcpContext::DismissPurchaseWidget' has a wrong offset!");

// Class FortniteGame.FortGameplayModMagnitudeCalculation
// 0x0000 (0x0040 - 0x0040)
class UFortGameplayModMagnitudeCalculation : public UGameplayModMagnitudeCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameplayModMagnitudeCalculation">();
	}
	static class UFortGameplayModMagnitudeCalculation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGameplayModMagnitudeCalculation>();
	}
};
static_assert(alignof(UFortGameplayModMagnitudeCalculation) == 0x000008, "Wrong alignment on UFortGameplayModMagnitudeCalculation");
static_assert(sizeof(UFortGameplayModMagnitudeCalculation) == 0x000040, "Wrong size on UFortGameplayModMagnitudeCalculation");

// Class FortniteGame.FromOffenseModMagnitudeCalculation
// 0x0070 (0x00B0 - 0x0040)
class UFromOffenseModMagnitudeCalculation final : public UFortGameplayModMagnitudeCalculation
{
public:
	uint8                                         Pad_40[0x70];                                      // 0x0040(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FromOffenseModMagnitudeCalculation">();
	}
	static class UFromOffenseModMagnitudeCalculation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFromOffenseModMagnitudeCalculation>();
	}
};
static_assert(alignof(UFromOffenseModMagnitudeCalculation) == 0x000008, "Wrong alignment on UFromOffenseModMagnitudeCalculation");
static_assert(sizeof(UFromOffenseModMagnitudeCalculation) == 0x0000B0, "Wrong size on UFromOffenseModMagnitudeCalculation");

// Class FortniteGame.FortClientAnnouncement_Conversation
// 0x0050 (0x0448 - 0x03F8)
class AFortClientAnnouncement_Conversation : public AFortClientAnnouncement
{
public:
	uint8                                         Pad_3F8[0x10];                                     // 0x03F8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortClientAnnouncementData_Conversation ConversationData;                                  // 0x0408(0x0010)(Edit, BlueprintVisible, Net, NoDestructor, ExposeOnSpawn, NativeAccessSpecifierPublic)
	class UAudioComponent*                        SpeechComponent;                                   // 0x0418(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutoPlayConversation;                             // 0x0420(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCurrentlyPlaying;                                 // 0x0421(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_422[0x2];                                      // 0x0422(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentSentenceIndex;                              // 0x0424(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_428[0x20];                                     // 0x0428(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CurrentSentenceAudioFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortClientAnnouncement_Conversation">();
	}
	static class AFortClientAnnouncement_Conversation* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortClientAnnouncement_Conversation>();
	}
};
static_assert(alignof(AFortClientAnnouncement_Conversation) == 0x000008, "Wrong alignment on AFortClientAnnouncement_Conversation");
static_assert(sizeof(AFortClientAnnouncement_Conversation) == 0x000448, "Wrong size on AFortClientAnnouncement_Conversation");
static_assert(offsetof(AFortClientAnnouncement_Conversation, ConversationData) == 0x000408, "Member 'AFortClientAnnouncement_Conversation::ConversationData' has a wrong offset!");
static_assert(offsetof(AFortClientAnnouncement_Conversation, SpeechComponent) == 0x000418, "Member 'AFortClientAnnouncement_Conversation::SpeechComponent' has a wrong offset!");
static_assert(offsetof(AFortClientAnnouncement_Conversation, bAutoPlayConversation) == 0x000420, "Member 'AFortClientAnnouncement_Conversation::bAutoPlayConversation' has a wrong offset!");
static_assert(offsetof(AFortClientAnnouncement_Conversation, bCurrentlyPlaying) == 0x000421, "Member 'AFortClientAnnouncement_Conversation::bCurrentlyPlaying' has a wrong offset!");
static_assert(offsetof(AFortClientAnnouncement_Conversation, CurrentSentenceIndex) == 0x000424, "Member 'AFortClientAnnouncement_Conversation::CurrentSentenceIndex' has a wrong offset!");

// Class FortniteGame.FortClientAnnouncement_TutorialConversation
// 0x0168 (0x05B0 - 0x0448)
class AFortClientAnnouncement_TutorialConversation : public AFortClientAnnouncement_Conversation
{
public:
	uint8                                         Pad_448[0x8];                                      // 0x0448(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortClientAnnouncementData_Tutorial   TutorialData;                                      // 0x0450(0x0140)(Edit, BlueprintVisible, Net, ExposeOnSpawn, NativeAccessSpecifierPublic)
	float                                         AutoContinueDelay;                                 // 0x0590(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_594[0x1C];                                     // 0x0594(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_TutorialData(const struct FFortClientAnnouncementData_Tutorial& PreviousTutorialData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortClientAnnouncement_TutorialConversation">();
	}
	static class AFortClientAnnouncement_TutorialConversation* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortClientAnnouncement_TutorialConversation>();
	}
};
static_assert(alignof(AFortClientAnnouncement_TutorialConversation) == 0x000008, "Wrong alignment on AFortClientAnnouncement_TutorialConversation");
static_assert(sizeof(AFortClientAnnouncement_TutorialConversation) == 0x0005B0, "Wrong size on AFortClientAnnouncement_TutorialConversation");
static_assert(offsetof(AFortClientAnnouncement_TutorialConversation, TutorialData) == 0x000450, "Member 'AFortClientAnnouncement_TutorialConversation::TutorialData' has a wrong offset!");
static_assert(offsetof(AFortClientAnnouncement_TutorialConversation, AutoContinueDelay) == 0x000590, "Member 'AFortClientAnnouncement_TutorialConversation::AutoContinueDelay' has a wrong offset!");

// Class FortniteGame.FortUITeamInfo
// 0x01E8 (0x0210 - 0x0028)
class UFortUITeamInfo final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnTeamMemberFinishedSynchronizing;                 // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnTeamMemberAdded;                                 // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnTeamMemberRemoved;                               // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnTeamMemberStateChanged;                          // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnTeamMemberPromoted;                              // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnTeamHitPointFractionsChanged;                    // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0xA0];                                      // 0x0090(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortPartyContext*                      TeamContext;                                       // 0x0130(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EFortTeam                                     TeamAssignment;                                    // 0x0138(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_139[0x7];                                      // 0x0139(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UEnum*                                  FortTeamUEnum;                                     // 0x0140(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         TotalFilledSlots;                                  // 0x0148(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         PreviousFilledSlots;                               // 0x014C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_150[0xC0];                                     // 0x0150(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetTeamHitPointFractions(TArray<float>* HealthFractions, TArray<float>* ShieldFractions);
	void GetTeamMemberIDs(TArray<struct FUniqueNetIdRepl>* TeamMemberIDs);
	void GetTeamMembers(TArray<struct FFortTeamMemberInfo>* TeamMembers);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortUITeamInfo">();
	}
	static class UFortUITeamInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortUITeamInfo>();
	}
};
static_assert(alignof(UFortUITeamInfo) == 0x000008, "Wrong alignment on UFortUITeamInfo");
static_assert(sizeof(UFortUITeamInfo) == 0x000210, "Wrong size on UFortUITeamInfo");
static_assert(offsetof(UFortUITeamInfo, OnTeamMemberFinishedSynchronizing) == 0x000030, "Member 'UFortUITeamInfo::OnTeamMemberFinishedSynchronizing' has a wrong offset!");
static_assert(offsetof(UFortUITeamInfo, OnTeamMemberAdded) == 0x000040, "Member 'UFortUITeamInfo::OnTeamMemberAdded' has a wrong offset!");
static_assert(offsetof(UFortUITeamInfo, OnTeamMemberRemoved) == 0x000050, "Member 'UFortUITeamInfo::OnTeamMemberRemoved' has a wrong offset!");
static_assert(offsetof(UFortUITeamInfo, OnTeamMemberStateChanged) == 0x000060, "Member 'UFortUITeamInfo::OnTeamMemberStateChanged' has a wrong offset!");
static_assert(offsetof(UFortUITeamInfo, OnTeamMemberPromoted) == 0x000070, "Member 'UFortUITeamInfo::OnTeamMemberPromoted' has a wrong offset!");
static_assert(offsetof(UFortUITeamInfo, OnTeamHitPointFractionsChanged) == 0x000080, "Member 'UFortUITeamInfo::OnTeamHitPointFractionsChanged' has a wrong offset!");
static_assert(offsetof(UFortUITeamInfo, TeamContext) == 0x000130, "Member 'UFortUITeamInfo::TeamContext' has a wrong offset!");
static_assert(offsetof(UFortUITeamInfo, TeamAssignment) == 0x000138, "Member 'UFortUITeamInfo::TeamAssignment' has a wrong offset!");
static_assert(offsetof(UFortUITeamInfo, FortTeamUEnum) == 0x000140, "Member 'UFortUITeamInfo::FortTeamUEnum' has a wrong offset!");
static_assert(offsetof(UFortUITeamInfo, TotalFilledSlots) == 0x000148, "Member 'UFortUITeamInfo::TotalFilledSlots' has a wrong offset!");
static_assert(offsetof(UFortUITeamInfo, PreviousFilledSlots) == 0x00014C, "Member 'UFortUITeamInfo::PreviousFilledSlots' has a wrong offset!");

// Class FortniteGame.FortSocialItem
// 0x0050 (0x0078 - 0x0028)
class UFortSocialItem final : public UObject
{
public:
	EFortSocialItemType                           SocialItemType;                                    // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortSocialItemHeaderType                     HeaderType;                                        // 0x0029(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   HeaderName;                                        // 0x0030(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPresenceUpdated;                                 // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnInviteJoinUpdated;                               // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x10];                                      // 0x0068(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FFortSocialItemBasicData GetBasicInfo() const;
	class FText GetDisplayName() const;
	class FText GetLocation() const;
	EFortSocialItemPresenceStatus GetPresenceStatus() const;
	struct FUniqueNetIdRepl GetUniquePlayerId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortSocialItem">();
	}
	static class UFortSocialItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortSocialItem>();
	}
};
static_assert(alignof(UFortSocialItem) == 0x000008, "Wrong alignment on UFortSocialItem");
static_assert(sizeof(UFortSocialItem) == 0x000078, "Wrong size on UFortSocialItem");
static_assert(offsetof(UFortSocialItem, SocialItemType) == 0x000028, "Member 'UFortSocialItem::SocialItemType' has a wrong offset!");
static_assert(offsetof(UFortSocialItem, HeaderType) == 0x000029, "Member 'UFortSocialItem::HeaderType' has a wrong offset!");
static_assert(offsetof(UFortSocialItem, HeaderName) == 0x000030, "Member 'UFortSocialItem::HeaderName' has a wrong offset!");
static_assert(offsetof(UFortSocialItem, OnPresenceUpdated) == 0x000048, "Member 'UFortSocialItem::OnPresenceUpdated' has a wrong offset!");
static_assert(offsetof(UFortSocialItem, OnInviteJoinUpdated) == 0x000058, "Member 'UFortSocialItem::OnInviteJoinUpdated' has a wrong offset!");

// Class FortniteGame.FortRegionInfo
// 0x00D8 (0x0100 - 0x0028)
class UFortRegionInfo final : public UDataAsset
{
public:
	class FText                                   RegionName;                                        // 0x0028(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  RegionTags;                                        // 0x0040(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FFortRequirementsInfo                  Requirements;                                      // 0x0060(0x0040)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FFortMissionAlertRequirementsInfo> MissionAlertRequirements;                          // 0x00A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FFortTheaterMapMissionData             MissionData;                                       // 0x00B0(0x0030)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USlateBrushAsset>        RegionThemeIcon;                                   // 0x00E0(0x0020)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortRegionInfo">();
	}
	static class UFortRegionInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortRegionInfo>();
	}
};
static_assert(alignof(UFortRegionInfo) == 0x000008, "Wrong alignment on UFortRegionInfo");
static_assert(sizeof(UFortRegionInfo) == 0x000100, "Wrong size on UFortRegionInfo");
static_assert(offsetof(UFortRegionInfo, RegionName) == 0x000028, "Member 'UFortRegionInfo::RegionName' has a wrong offset!");
static_assert(offsetof(UFortRegionInfo, RegionTags) == 0x000040, "Member 'UFortRegionInfo::RegionTags' has a wrong offset!");
static_assert(offsetof(UFortRegionInfo, Requirements) == 0x000060, "Member 'UFortRegionInfo::Requirements' has a wrong offset!");
static_assert(offsetof(UFortRegionInfo, MissionAlertRequirements) == 0x0000A0, "Member 'UFortRegionInfo::MissionAlertRequirements' has a wrong offset!");
static_assert(offsetof(UFortRegionInfo, MissionData) == 0x0000B0, "Member 'UFortRegionInfo::MissionData' has a wrong offset!");
static_assert(offsetof(UFortRegionInfo, RegionThemeIcon) == 0x0000E0, "Member 'UFortRegionInfo::RegionThemeIcon' has a wrong offset!");

// Class FortniteGame.WorldMapPin
// 0x0018 (0x03A0 - 0x0388)
class AWorldMapPin : public AActor
{
public:
	class USceneComponent*                        SceneComponent;                                    // 0x0388(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TheaterId;                                         // 0x0390(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnTheaterIdSet();
	void SetTheaterId(const class FString& NewId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldMapPin">();
	}
	static class AWorldMapPin* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWorldMapPin>();
	}
};
static_assert(alignof(AWorldMapPin) == 0x000008, "Wrong alignment on AWorldMapPin");
static_assert(sizeof(AWorldMapPin) == 0x0003A0, "Wrong size on AWorldMapPin");
static_assert(offsetof(AWorldMapPin, SceneComponent) == 0x000388, "Member 'AWorldMapPin::SceneComponent' has a wrong offset!");
static_assert(offsetof(AWorldMapPin, TheaterId) == 0x000390, "Member 'AWorldMapPin::TheaterId' has a wrong offset!");

// Class FortniteGame.FromTeamResistanceModMagnitudeCalculation
// 0x0070 (0x00B0 - 0x0040)
class UFromTeamResistanceModMagnitudeCalculation final : public UFortGameplayModMagnitudeCalculation
{
public:
	uint8                                         Pad_40[0x70];                                      // 0x0040(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FromTeamResistanceModMagnitudeCalculation">();
	}
	static class UFromTeamResistanceModMagnitudeCalculation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFromTeamResistanceModMagnitudeCalculation>();
	}
};
static_assert(alignof(UFromTeamResistanceModMagnitudeCalculation) == 0x000008, "Wrong alignment on UFromTeamResistanceModMagnitudeCalculation");
static_assert(sizeof(UFromTeamResistanceModMagnitudeCalculation) == 0x0000B0, "Wrong size on UFromTeamResistanceModMagnitudeCalculation");

// Class FortniteGame.WorldTileGroup
// 0x00D8 (0x0100 - 0x0028)
class UWorldTileGroup final : public UDataAsset
{
public:
	class FString                                 TileID;                                            // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOnlyPlaceDiagonalWithAdjacent : 1;                // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTileGroupMapInfo>              FlatMapInfos;                                      // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTileGroupMapInfo>              InnerMapInfos;                                     // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTileGroupMapInfo>              OuterMapInfos;                                     // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTileGroupMapInfo>              StraightMapInfos;                                  // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  Sim_FlatWorld;                                     // 0x0080(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UWorld>                  Sim_InnerWorld;                                    // 0x00A0(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UWorld>                  Sim_OuterWorld;                                    // 0x00C0(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UWorld>                  Sim_StraightWorld;                                 // 0x00E0(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldTileGroup">();
	}
	static class UWorldTileGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldTileGroup>();
	}
};
static_assert(alignof(UWorldTileGroup) == 0x000008, "Wrong alignment on UWorldTileGroup");
static_assert(sizeof(UWorldTileGroup) == 0x000100, "Wrong size on UWorldTileGroup");
static_assert(offsetof(UWorldTileGroup, TileID) == 0x000028, "Member 'UWorldTileGroup::TileID' has a wrong offset!");
static_assert(offsetof(UWorldTileGroup, FlatMapInfos) == 0x000040, "Member 'UWorldTileGroup::FlatMapInfos' has a wrong offset!");
static_assert(offsetof(UWorldTileGroup, InnerMapInfos) == 0x000050, "Member 'UWorldTileGroup::InnerMapInfos' has a wrong offset!");
static_assert(offsetof(UWorldTileGroup, OuterMapInfos) == 0x000060, "Member 'UWorldTileGroup::OuterMapInfos' has a wrong offset!");
static_assert(offsetof(UWorldTileGroup, StraightMapInfos) == 0x000070, "Member 'UWorldTileGroup::StraightMapInfos' has a wrong offset!");
static_assert(offsetof(UWorldTileGroup, Sim_FlatWorld) == 0x000080, "Member 'UWorldTileGroup::Sim_FlatWorld' has a wrong offset!");
static_assert(offsetof(UWorldTileGroup, Sim_InnerWorld) == 0x0000A0, "Member 'UWorldTileGroup::Sim_InnerWorld' has a wrong offset!");
static_assert(offsetof(UWorldTileGroup, Sim_OuterWorld) == 0x0000C0, "Member 'UWorldTileGroup::Sim_OuterWorld' has a wrong offset!");
static_assert(offsetof(UWorldTileGroup, Sim_StraightWorld) == 0x0000E0, "Member 'UWorldTileGroup::Sim_StraightWorld' has a wrong offset!");

// Class FortniteGame.FortTheaterInfo
// 0x0688 (0x06B0 - 0x0028)
class UFortTheaterInfo final : public UDataAsset
{
public:
	class FString                                 UniqueId;                                          // 0x0028(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SaveVersion;                                       // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortTheaterMapData                    TheaterData;                                       // 0x0040(0x0540)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FFortTheaterMapMissionData             Missions;                                          // 0x0580(0x0030)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FFortTheaterMapMissionAlertData        MissionAlerts;                                     // 0x05B0(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bForceIncludeInCookIfReferenced;                   // 0x05D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D1[0x7];                                      // 0x05D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UFortZoneTheme>             SelectedZoneTheme;                                 // 0x05D8(0x0008)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortRegionInfo*                        SelectedZoneRegion;                                // 0x05E0(0x0008)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortTheaterMapTileType                       SelectedTileType;                                  // 0x05E8(0x0001)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E9[0x7];                                      // 0x05E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  SelectedTileTags;                                  // 0x05F0(0x0020)(Edit, Transient, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FFortRequirementsInfo                  SelectedTileRequirements;                          // 0x0610(0x0040)(Edit, Transient, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortLinkedQuest>               SelectedLinkedQuests;                              // 0x0650(0x0010)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortTheaterMissionWeight>      SelectedMissionWeightOverrides;                    // 0x0660(0x0010)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortTheaterDifficultyWeight>   SelectedDifficultyWeightOverrides;                 // 0x0670(0x0010)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bCanSelectedTileHaveMissionAlert;                  // 0x0680(0x0001)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_681[0x7];                                      // 0x0681(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFortEditorTheaterMapRegionColor> RegionColors;                                      // 0x0688(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortTheaterTileEditorData>     EditorTiles;                                       // 0x0698(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         TheaterWidth;                                      // 0x06A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TheaterHeight;                                     // 0x06AC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTheaterInfo">();
	}
	static class UFortTheaterInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortTheaterInfo>();
	}
};
static_assert(alignof(UFortTheaterInfo) == 0x000008, "Wrong alignment on UFortTheaterInfo");
static_assert(sizeof(UFortTheaterInfo) == 0x0006B0, "Wrong size on UFortTheaterInfo");
static_assert(offsetof(UFortTheaterInfo, UniqueId) == 0x000028, "Member 'UFortTheaterInfo::UniqueId' has a wrong offset!");
static_assert(offsetof(UFortTheaterInfo, SaveVersion) == 0x000038, "Member 'UFortTheaterInfo::SaveVersion' has a wrong offset!");
static_assert(offsetof(UFortTheaterInfo, TheaterData) == 0x000040, "Member 'UFortTheaterInfo::TheaterData' has a wrong offset!");
static_assert(offsetof(UFortTheaterInfo, Missions) == 0x000580, "Member 'UFortTheaterInfo::Missions' has a wrong offset!");
static_assert(offsetof(UFortTheaterInfo, MissionAlerts) == 0x0005B0, "Member 'UFortTheaterInfo::MissionAlerts' has a wrong offset!");
static_assert(offsetof(UFortTheaterInfo, bForceIncludeInCookIfReferenced) == 0x0005D0, "Member 'UFortTheaterInfo::bForceIncludeInCookIfReferenced' has a wrong offset!");
static_assert(offsetof(UFortTheaterInfo, SelectedZoneTheme) == 0x0005D8, "Member 'UFortTheaterInfo::SelectedZoneTheme' has a wrong offset!");
static_assert(offsetof(UFortTheaterInfo, SelectedZoneRegion) == 0x0005E0, "Member 'UFortTheaterInfo::SelectedZoneRegion' has a wrong offset!");
static_assert(offsetof(UFortTheaterInfo, SelectedTileType) == 0x0005E8, "Member 'UFortTheaterInfo::SelectedTileType' has a wrong offset!");
static_assert(offsetof(UFortTheaterInfo, SelectedTileTags) == 0x0005F0, "Member 'UFortTheaterInfo::SelectedTileTags' has a wrong offset!");
static_assert(offsetof(UFortTheaterInfo, SelectedTileRequirements) == 0x000610, "Member 'UFortTheaterInfo::SelectedTileRequirements' has a wrong offset!");
static_assert(offsetof(UFortTheaterInfo, SelectedLinkedQuests) == 0x000650, "Member 'UFortTheaterInfo::SelectedLinkedQuests' has a wrong offset!");
static_assert(offsetof(UFortTheaterInfo, SelectedMissionWeightOverrides) == 0x000660, "Member 'UFortTheaterInfo::SelectedMissionWeightOverrides' has a wrong offset!");
static_assert(offsetof(UFortTheaterInfo, SelectedDifficultyWeightOverrides) == 0x000670, "Member 'UFortTheaterInfo::SelectedDifficultyWeightOverrides' has a wrong offset!");
static_assert(offsetof(UFortTheaterInfo, bCanSelectedTileHaveMissionAlert) == 0x000680, "Member 'UFortTheaterInfo::bCanSelectedTileHaveMissionAlert' has a wrong offset!");
static_assert(offsetof(UFortTheaterInfo, RegionColors) == 0x000688, "Member 'UFortTheaterInfo::RegionColors' has a wrong offset!");
static_assert(offsetof(UFortTheaterInfo, EditorTiles) == 0x000698, "Member 'UFortTheaterInfo::EditorTiles' has a wrong offset!");
static_assert(offsetof(UFortTheaterInfo, TheaterWidth) == 0x0006A8, "Member 'UFortTheaterInfo::TheaterWidth' has a wrong offset!");
static_assert(offsetof(UFortTheaterInfo, TheaterHeight) == 0x0006AC, "Member 'UFortTheaterInfo::TheaterHeight' has a wrong offset!");

// Class FortniteGame.FortTimeOfDayCollection
// 0x0010 (0x0038 - 0x0028)
class UFortTimeOfDayCollection final : public UDataAsset
{
public:
	TArray<TSoftClassPtr<class UClass>>           TimeOfDayManagers;                                 // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTimeOfDayCollection">();
	}
	static class UFortTimeOfDayCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortTimeOfDayCollection>();
	}
};
static_assert(alignof(UFortTimeOfDayCollection) == 0x000008, "Wrong alignment on UFortTimeOfDayCollection");
static_assert(sizeof(UFortTimeOfDayCollection) == 0x000038, "Wrong size on UFortTimeOfDayCollection");
static_assert(offsetof(UFortTimeOfDayCollection, TimeOfDayManagers) == 0x000028, "Member 'UFortTimeOfDayCollection::TimeOfDayManagers' has a wrong offset!");

// Class FortniteGame.FortWindManager
// 0x0250 (0x05D8 - 0x0388)
class AFortWindManager : public AActor
{
public:
	uint8                                         Pad_388[0x8];                                      // 0x0388(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DistanceBetweenPixels;                             // 0x0390(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SectionWidth;                                      // 0x0394(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinimumSectionBlendTime;                           // 0x0398(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39C[0x4];                                      // 0x039C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UMaterialInterface>      MaterialDefiningParametersToInterpolate;           // 0x03A0(0x0020)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   WindVectorParameterName;                           // 0x03C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           WindOffsetMaterialParameterNames;                  // 0x03C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<class FName>                           WindSpeedMaterialParameterNames;                   // 0x03D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<class FName>                           WindMaterialScalarParameterNamesToInterpolate;     // 0x03E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<class FName>                           WindMaterialVectorParameterNamesToInterpolate;     // 0x03F8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<struct FFortWindImpulseRadius>         WindImpulses;                                      // 0x0408(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FFortWindImpulseCylinderDelta>  WindImpulseCylinderDeltas;                         // 0x0418(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FFortWindImpulseCylinder>       WindImpulseCylinders;                              // 0x0428(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FFortWindResponder>             WindResponders;                                    // 0x0438(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<int32>                                 NearbyCacheIndices;                                // 0x0448(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_458[0x10];                                     // 0x0458(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortWindResponder                     ActiveAudioWindResponder;                          // 0x0468(0x0098)(Transient, NativeAccessSpecifierPrivate)
	TMap<class ABuildingSMActor*, class UAudioComponent*> WindActorToWindResponderAudioMap;                  // 0x0500(0x0050)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class FName                                   AudioWindSpeedParameterName;                       // 0x0550(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AudioWindInterpSpeed;                              // 0x0558(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AudioWindMaxResponderDistance;                     // 0x055C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UAudioComponent*>                WindAudioComponentPool;                            // 0x0560(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_570[0x68];                                     // 0x0570(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void BreakWindImpulseCylinder(const struct FFortWindImpulseCylinder& InWindImpulseCylinder, struct FVector* ImpulseLocation, float* ImpulseInnerRadius, float* ImpulseOuterRadius, float* ImpulseMagnitude, struct FVector* ImpulseDirection);
	static void BreakWindImpulseCylinderAdvanced(const struct FFortWindImpulseCylinder& WindImpulseCylinder, struct FVector* WindLocation, float* WindInnerRadius, float* WindOuterRadius, struct FVector* WindWorldDirection, float* WindMagnitude, struct FBox* WindWorldBounds, bool* bIsWindChanging, bool* bIsWindChangePending);
	static void BreakWindImpulseCylinderDelta(const struct FFortWindImpulseCylinderDelta& WindImpulseCylinderDelta, struct FVector* WindDeltaCenter, bool* bWindImpulseInitialized, bool* bWindRipplesOutward, float* WindDeltaSectionWidth, float* WindDeltaInnerSectionRadius, float* WindDeltaOuterSectionRadius, float* WindDeltaMaximumRadius, float* WindDeltaDesiredOverallBlendTime, float* WindDeltaSectionBlendTime, float* WindDeltaSectionCurrentBlendTime, float* WindDeltaPreviousMagnitude, float* WindDeltaSectionCurrentMagnitude, float* WindDeltaDesiredMagnitude, struct FBox* WindDeltaOuterWorldBounds, struct FBox* WindDeltaInnerWorldBounds, struct FBox* WindImpulseBounds, struct FFortWindImpulseHandle* WindImpulseHandleToModify);
	static void BreakWindImpulseRadius(const struct FFortWindImpulseRadius& InWindImpulseRadius, struct FVector* ImpulseLocation, float* ImpulseRadius, float* ImpulseMagnitude, float* ImpulseBlendTime);
	static class AFortWindManager* GetWindManager(const class UObject* WorldContextObject);
	static struct FFortWindImpulseCylinder MakeWindImpulseCylinder(const struct FVector& ImpulseLocation, float ImpulseInnerRadius, float ImpulseOuterRadius, float ImpulseMagnitude, const struct FVector& ImpulseDirection);
	static struct FFortWindImpulseRadius MakeWindImpulseRadius(const struct FVector& ImpulseLocation, float ImpulseRadius, float ImpulseMagnitude, float ImpulseBlendTime);

	struct FFortWindImpulseHandle AddWindImpulse(const struct FFortWindImpulseRadius& WindImpulse);
	struct FFortWindImpulseHandle AddWindImpulseCylinder(const struct FFortWindImpulseCylinder& WindImpulseCylinder, float BlendTime);
	void AddWindParticleSystemComponent(class UParticleSystemComponent* ParticleSystemComponent);
	void OnWindAudioBecameActive(class UAudioComponent* WindAudioComp);
	void OnWindAudioBecameInactive(class UAudioComponent* WindAudioComp);
	void OnWindImpulseCylinderCreation(const struct FFortWindImpulseCylinder& WindImpulseCylinder, const struct FFortWindImpulseCylinderDelta& WindImpulseCylinderDelta);
	void OnWindImpulseCylinderDeath(const struct FFortWindImpulseCylinder& WindImpulseCylinder);
	void OnWindImpulseCylinderDeltaComplete(const struct FFortWindImpulseCylinder& WindImpulseCylinder);
	void OnWorldReady();
	void RemoveWindImpulse(const struct FFortWindImpulseHandle& ImpulseHandle, float BlendTime);
	void RemoveWindParticleSystemComponent(class UParticleSystemComponent* ParticleSystemComponent);
	bool SetWindImpulse(const struct FFortWindImpulseHandle& ImpulseHandle, const struct FFortWindImpulseRadius& WindImpulse);
	bool SetWindImpulseCylinderMagnitude(const struct FFortWindImpulseHandle& ImpulseHandle, float NewMagnitude, float BlendTime);

	bool GetCurrentWindImpulseCylinderDelta(struct FFortWindImpulseCylinder* WindImpulseCylinder, struct FFortWindImpulseCylinderDelta* WindImpulseCylinderDelta) const;
	void GetGlobalWindIntensityAndDirection(float* WindIntensity, struct FVector* WindDirection) const;
	bool GetWindLocationFromWorldLocation(const struct FVector& WorldLocation, struct FVector* WindWorldLocation) const;
	bool HasWindImpulse(const struct FFortWindImpulseHandle& WindImpulseHandle) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortWindManager">();
	}
	static class AFortWindManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortWindManager>();
	}
};
static_assert(alignof(AFortWindManager) == 0x000008, "Wrong alignment on AFortWindManager");
static_assert(sizeof(AFortWindManager) == 0x0005D8, "Wrong size on AFortWindManager");
static_assert(offsetof(AFortWindManager, DistanceBetweenPixels) == 0x000390, "Member 'AFortWindManager::DistanceBetweenPixels' has a wrong offset!");
static_assert(offsetof(AFortWindManager, SectionWidth) == 0x000394, "Member 'AFortWindManager::SectionWidth' has a wrong offset!");
static_assert(offsetof(AFortWindManager, MinimumSectionBlendTime) == 0x000398, "Member 'AFortWindManager::MinimumSectionBlendTime' has a wrong offset!");
static_assert(offsetof(AFortWindManager, MaterialDefiningParametersToInterpolate) == 0x0003A0, "Member 'AFortWindManager::MaterialDefiningParametersToInterpolate' has a wrong offset!");
static_assert(offsetof(AFortWindManager, WindVectorParameterName) == 0x0003C0, "Member 'AFortWindManager::WindVectorParameterName' has a wrong offset!");
static_assert(offsetof(AFortWindManager, WindOffsetMaterialParameterNames) == 0x0003C8, "Member 'AFortWindManager::WindOffsetMaterialParameterNames' has a wrong offset!");
static_assert(offsetof(AFortWindManager, WindSpeedMaterialParameterNames) == 0x0003D8, "Member 'AFortWindManager::WindSpeedMaterialParameterNames' has a wrong offset!");
static_assert(offsetof(AFortWindManager, WindMaterialScalarParameterNamesToInterpolate) == 0x0003E8, "Member 'AFortWindManager::WindMaterialScalarParameterNamesToInterpolate' has a wrong offset!");
static_assert(offsetof(AFortWindManager, WindMaterialVectorParameterNamesToInterpolate) == 0x0003F8, "Member 'AFortWindManager::WindMaterialVectorParameterNamesToInterpolate' has a wrong offset!");
static_assert(offsetof(AFortWindManager, WindImpulses) == 0x000408, "Member 'AFortWindManager::WindImpulses' has a wrong offset!");
static_assert(offsetof(AFortWindManager, WindImpulseCylinderDeltas) == 0x000418, "Member 'AFortWindManager::WindImpulseCylinderDeltas' has a wrong offset!");
static_assert(offsetof(AFortWindManager, WindImpulseCylinders) == 0x000428, "Member 'AFortWindManager::WindImpulseCylinders' has a wrong offset!");
static_assert(offsetof(AFortWindManager, WindResponders) == 0x000438, "Member 'AFortWindManager::WindResponders' has a wrong offset!");
static_assert(offsetof(AFortWindManager, NearbyCacheIndices) == 0x000448, "Member 'AFortWindManager::NearbyCacheIndices' has a wrong offset!");
static_assert(offsetof(AFortWindManager, ActiveAudioWindResponder) == 0x000468, "Member 'AFortWindManager::ActiveAudioWindResponder' has a wrong offset!");
static_assert(offsetof(AFortWindManager, WindActorToWindResponderAudioMap) == 0x000500, "Member 'AFortWindManager::WindActorToWindResponderAudioMap' has a wrong offset!");
static_assert(offsetof(AFortWindManager, AudioWindSpeedParameterName) == 0x000550, "Member 'AFortWindManager::AudioWindSpeedParameterName' has a wrong offset!");
static_assert(offsetof(AFortWindManager, AudioWindInterpSpeed) == 0x000558, "Member 'AFortWindManager::AudioWindInterpSpeed' has a wrong offset!");
static_assert(offsetof(AFortWindManager, AudioWindMaxResponderDistance) == 0x00055C, "Member 'AFortWindManager::AudioWindMaxResponderDistance' has a wrong offset!");
static_assert(offsetof(AFortWindManager, WindAudioComponentPool) == 0x000560, "Member 'AFortWindManager::WindAudioComponentPool' has a wrong offset!");

// Class FortniteGame.FortRejoinCheck
// 0x00D0 (0x0280 - 0x01B0)
class UFortRejoinCheck final : public URejoinCheck
{
public:
	bool                                          bAbandonAfterCheck;                                // 0x01B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAttemptingAbandon;                                // 0x01B1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B2[0xCE];                                     // 0x01B2(0x00CE)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortRejoinCheck">();
	}
	static class UFortRejoinCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortRejoinCheck>();
	}
};
static_assert(alignof(UFortRejoinCheck) == 0x000008, "Wrong alignment on UFortRejoinCheck");
static_assert(sizeof(UFortRejoinCheck) == 0x000280, "Wrong size on UFortRejoinCheck");
static_assert(offsetof(UFortRejoinCheck, bAbandonAfterCheck) == 0x0001B0, "Member 'UFortRejoinCheck::bAbandonAfterCheck' has a wrong offset!");
static_assert(offsetof(UFortRejoinCheck, bAttemptingAbandon) == 0x0001B1, "Member 'UFortRejoinCheck::bAttemptingAbandon' has a wrong offset!");

// Class FortniteGame.FortMissionInfo
// 0x0770 (0x0798 - 0x0028)
class UFortMissionInfo final : public UPrimaryDataAsset
{
public:
	TSoftClassPtr<class UClass>                   MissionRef;                                        // 0x0028(0x0020)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EFortMissionType                              MissionType;                                       // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  MissionTags;                                       // 0x0050(0x0020)(Edit, DisableEditOnInstance, AssetRegistrySearchable, NativeAccessSpecifierPublic)
	float                                         TimeOfDaySpeed;                                    // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoneEndDelay;                                      // 0x0074(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortBadgeItemDefinition*               MissionRewardBadge;                                // 0x0078(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MissionRewardItemsLootTierGroup;                   // 0x0080(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxRewardLootTierPoints;                           // 0x0088(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ParTime;                                           // 0x008C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortBadgeItemDefinition*               UnderParBadge;                                     // 0x0090(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxMissionPoints;                                  // 0x0098(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVictoryTileRequired;                              // 0x009C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   MissionDescription;                                // 0x00A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FFortMultiSizeBrush                    MissionIcons;                                      // 0x00B8(0x0360)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UMediaSource*                           EndOfMissionMediaSource;                           // 0x0418(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipEndOfMissionVideo;                            // 0x0420(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_421[0x3];                                      // 0x0421(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DaysToLive;                                        // 0x0424(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFortObjectiveBlock>            ObjectiveBlocks;                                   // 0x0428(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bShowMinimapIconsOnlyIfFocused;                    // 0x0438(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_439[0x3];                                      // 0x0439(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExpectedCompletionTime;                            // 0x043C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MissionEncounterTime;                              // 0x0440(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_444[0x4];                                      // 0x0444(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortMissionPlacementItems             MissionPlacementInfo;                              // 0x0448(0x0040)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         MinDistanceToOtherMissions;                        // 0x0488(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDistanceToAllowSpawnPad;                        // 0x048C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFortPlacementActorFinderInfo          PlacementActorInfo;                                // 0x0490(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bStartPlayingOnLoad;                               // 0x04A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A9[0x7];                                      // 0x04A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   RewardsTitleText;                                  // 0x04B0(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   RewardsDescriptionText;                            // 0x04C8(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   NonParticipationRewardsDescriptionText;            // 0x04E0(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FFortMissionPopupWidgetData            PopupWidgetData;                                   // 0x04F8(0x01E8)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UFortMissionWeightedRewards*            WeightedRewards;                                   // 0x06E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsGroupContent;                                   // 0x06E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6E9[0x7];                                      // 0x06E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   MissionName;                                       // 0x06F0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortEncounterProfile>          EncounterProfiles;                                 // 0x0708(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortEncounterSequenceSettings> EncounterSequences;                                // 0x0718(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFortDifficultyOptionSetMission> MissionOptions;                                    // 0x0728(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  MissionDifficultyOptionTags;                       // 0x0748(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortMissionTaggedRewards>      TaggedRewards;                                     // 0x0768(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FMissionPerDifficultyProperties> PerDifficultyProperties;                           // 0x0778(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FFortMissionConfigDataParams           ConfigParams;                                      // 0x0788(0x0010)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMissionInfo">();
	}
	static class UFortMissionInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMissionInfo>();
	}
};
static_assert(alignof(UFortMissionInfo) == 0x000008, "Wrong alignment on UFortMissionInfo");
static_assert(sizeof(UFortMissionInfo) == 0x000798, "Wrong size on UFortMissionInfo");
static_assert(offsetof(UFortMissionInfo, MissionRef) == 0x000028, "Member 'UFortMissionInfo::MissionRef' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, MissionType) == 0x000048, "Member 'UFortMissionInfo::MissionType' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, MissionTags) == 0x000050, "Member 'UFortMissionInfo::MissionTags' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, TimeOfDaySpeed) == 0x000070, "Member 'UFortMissionInfo::TimeOfDaySpeed' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, ZoneEndDelay) == 0x000074, "Member 'UFortMissionInfo::ZoneEndDelay' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, MissionRewardBadge) == 0x000078, "Member 'UFortMissionInfo::MissionRewardBadge' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, MissionRewardItemsLootTierGroup) == 0x000080, "Member 'UFortMissionInfo::MissionRewardItemsLootTierGroup' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, MaxRewardLootTierPoints) == 0x000088, "Member 'UFortMissionInfo::MaxRewardLootTierPoints' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, ParTime) == 0x00008C, "Member 'UFortMissionInfo::ParTime' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, UnderParBadge) == 0x000090, "Member 'UFortMissionInfo::UnderParBadge' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, MaxMissionPoints) == 0x000098, "Member 'UFortMissionInfo::MaxMissionPoints' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, bVictoryTileRequired) == 0x00009C, "Member 'UFortMissionInfo::bVictoryTileRequired' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, MissionDescription) == 0x0000A0, "Member 'UFortMissionInfo::MissionDescription' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, MissionIcons) == 0x0000B8, "Member 'UFortMissionInfo::MissionIcons' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, EndOfMissionMediaSource) == 0x000418, "Member 'UFortMissionInfo::EndOfMissionMediaSource' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, bSkipEndOfMissionVideo) == 0x000420, "Member 'UFortMissionInfo::bSkipEndOfMissionVideo' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, DaysToLive) == 0x000424, "Member 'UFortMissionInfo::DaysToLive' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, ObjectiveBlocks) == 0x000428, "Member 'UFortMissionInfo::ObjectiveBlocks' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, bShowMinimapIconsOnlyIfFocused) == 0x000438, "Member 'UFortMissionInfo::bShowMinimapIconsOnlyIfFocused' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, ExpectedCompletionTime) == 0x00043C, "Member 'UFortMissionInfo::ExpectedCompletionTime' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, MissionEncounterTime) == 0x000440, "Member 'UFortMissionInfo::MissionEncounterTime' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, MissionPlacementInfo) == 0x000448, "Member 'UFortMissionInfo::MissionPlacementInfo' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, MinDistanceToOtherMissions) == 0x000488, "Member 'UFortMissionInfo::MinDistanceToOtherMissions' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, MinDistanceToAllowSpawnPad) == 0x00048C, "Member 'UFortMissionInfo::MinDistanceToAllowSpawnPad' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, PlacementActorInfo) == 0x000490, "Member 'UFortMissionInfo::PlacementActorInfo' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, bStartPlayingOnLoad) == 0x0004A8, "Member 'UFortMissionInfo::bStartPlayingOnLoad' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, RewardsTitleText) == 0x0004B0, "Member 'UFortMissionInfo::RewardsTitleText' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, RewardsDescriptionText) == 0x0004C8, "Member 'UFortMissionInfo::RewardsDescriptionText' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, NonParticipationRewardsDescriptionText) == 0x0004E0, "Member 'UFortMissionInfo::NonParticipationRewardsDescriptionText' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, PopupWidgetData) == 0x0004F8, "Member 'UFortMissionInfo::PopupWidgetData' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, WeightedRewards) == 0x0006E0, "Member 'UFortMissionInfo::WeightedRewards' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, bIsGroupContent) == 0x0006E8, "Member 'UFortMissionInfo::bIsGroupContent' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, MissionName) == 0x0006F0, "Member 'UFortMissionInfo::MissionName' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, EncounterProfiles) == 0x000708, "Member 'UFortMissionInfo::EncounterProfiles' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, EncounterSequences) == 0x000718, "Member 'UFortMissionInfo::EncounterSequences' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, MissionOptions) == 0x000728, "Member 'UFortMissionInfo::MissionOptions' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, MissionDifficultyOptionTags) == 0x000748, "Member 'UFortMissionInfo::MissionDifficultyOptionTags' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, TaggedRewards) == 0x000768, "Member 'UFortMissionInfo::TaggedRewards' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, PerDifficultyProperties) == 0x000778, "Member 'UFortMissionInfo::PerDifficultyProperties' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, ConfigParams) == 0x000788, "Member 'UFortMissionInfo::ConfigParams' has a wrong offset!");

// Class FortniteGame.FortTheaterMapTile
// 0x0270 (0x0600 - 0x0390)
class AFortTheaterMapTile : public AFortClientOnlyActor
{
public:
	bool                                          bFocused;                                          // 0x0390(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHostSelected;                                     // 0x0391(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGoToPromptEnabled;                                // 0x0392(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_393[0x1];                                      // 0x0393(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortHexMapCoord                       MapCoord;                                          // 0x0394(0x000C)(NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bHasFinishedLoading;                               // 0x03A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortTheaterMapTileType                       TileType;                                          // 0x03A1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A2[0x6];                                      // 0x03A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UFortZoneTheme>             ZoneThemeClass;                                    // 0x03A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TileIndex;                                         // 0x03B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RegionIndex;                                       // 0x03B4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                SelectionOffset;                                   // 0x03B8(0x000C)(Edit, BlueprintVisible, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                FocusOffset;                                       // 0x03C4(0x000C)(Edit, BlueprintVisible, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SelectionInterpSpeed;                              // 0x03D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NormalBrightness;                                  // 0x03D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LockedBrightness;                                  // 0x03D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FocusedBrightness;                                 // 0x03DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SelectedBrightnessRange;                           // 0x03E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SelectedPulseSpeed;                                // 0x03E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableBrightnessCode;                             // 0x03E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E9[0x3];                                      // 0x03E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StaticMeshMaterialID;                              // 0x03EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                InitialLocation;                                   // 0x03F0(0x000C)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3FC[0x4];                                      // 0x03FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortAvailableMissionData              MissionData;                                       // 0x0400(0x00A0)(Protected, NativeAccessSpecifierProtected)
	struct FFortAvailableMissionData              LastValidMissionData;                              // 0x04A0(0x00A0)(Protected, NativeAccessSpecifierProtected)
	struct FDataTableRowHandle                    ZoneDifficultyInfo;                                // 0x0540(0x0010)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FFortAvailableMissionAlertData         MissionAlertData;                                  // 0x0550(0x0098)(Protected, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x05E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UMaterialInstanceDynamic*>       AdjacencyMIDs;                                     // 0x05F0(0x0010)(BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void OnClientDeselect();
	void OnClientSelect();
	void OnDefocus();
	void OnDeselectWrapper(bool bIsGameSessionOwner);
	void OnDisableGoToPrompt();
	void OnEnableGoToPrompt();
	void OnFocus();
	void OnHostDeselect();
	void OnHostSelect();
	void OnInitializeTile();
	void OnMarkedQuestChanged();
	void OnMissionDataUpdated();
	void OnMouseOverBegin(class AActor* MousedOverActor);
	void OnMouseOverEnd(class AActor* MousedOverActor);
	void OnSelectWrapper(bool bIsGameSessionOwner);
	void OnTileClicked(class AActor* ClickedActor, const struct FKey& ButtonReleased);

	bool DoesTileAllowQuickplay() const;
	EFortMissionAlertCategory GetMissionAlertCategory() const;
	struct FGameDifficultyInfo GetZoneDifficulty() const;
	bool HasValidMissionData() const;
	bool IsMissionAlertTile() const;
	bool IsTileHidden() const;
	bool IsTileLocked() const;
	bool IsTilePlayable() const;
	bool IsTileQuestRecommended() const;
	bool IsTileSelectable() const;
	bool IsTileValidForMarkedQuest(class UFortQuestItem** OutMarkedQuest) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTheaterMapTile">();
	}
	static class AFortTheaterMapTile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortTheaterMapTile>();
	}
};
static_assert(alignof(AFortTheaterMapTile) == 0x000008, "Wrong alignment on AFortTheaterMapTile");
static_assert(sizeof(AFortTheaterMapTile) == 0x000600, "Wrong size on AFortTheaterMapTile");
static_assert(offsetof(AFortTheaterMapTile, bFocused) == 0x000390, "Member 'AFortTheaterMapTile::bFocused' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, bHostSelected) == 0x000391, "Member 'AFortTheaterMapTile::bHostSelected' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, bGoToPromptEnabled) == 0x000392, "Member 'AFortTheaterMapTile::bGoToPromptEnabled' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, MapCoord) == 0x000394, "Member 'AFortTheaterMapTile::MapCoord' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, bHasFinishedLoading) == 0x0003A0, "Member 'AFortTheaterMapTile::bHasFinishedLoading' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, TileType) == 0x0003A1, "Member 'AFortTheaterMapTile::TileType' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, ZoneThemeClass) == 0x0003A8, "Member 'AFortTheaterMapTile::ZoneThemeClass' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, TileIndex) == 0x0003B0, "Member 'AFortTheaterMapTile::TileIndex' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, RegionIndex) == 0x0003B4, "Member 'AFortTheaterMapTile::RegionIndex' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, SelectionOffset) == 0x0003B8, "Member 'AFortTheaterMapTile::SelectionOffset' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, FocusOffset) == 0x0003C4, "Member 'AFortTheaterMapTile::FocusOffset' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, SelectionInterpSpeed) == 0x0003D0, "Member 'AFortTheaterMapTile::SelectionInterpSpeed' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, NormalBrightness) == 0x0003D4, "Member 'AFortTheaterMapTile::NormalBrightness' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, LockedBrightness) == 0x0003D8, "Member 'AFortTheaterMapTile::LockedBrightness' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, FocusedBrightness) == 0x0003DC, "Member 'AFortTheaterMapTile::FocusedBrightness' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, SelectedBrightnessRange) == 0x0003E0, "Member 'AFortTheaterMapTile::SelectedBrightnessRange' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, SelectedPulseSpeed) == 0x0003E4, "Member 'AFortTheaterMapTile::SelectedPulseSpeed' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, bEnableBrightnessCode) == 0x0003E8, "Member 'AFortTheaterMapTile::bEnableBrightnessCode' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, StaticMeshMaterialID) == 0x0003EC, "Member 'AFortTheaterMapTile::StaticMeshMaterialID' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, InitialLocation) == 0x0003F0, "Member 'AFortTheaterMapTile::InitialLocation' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, MissionData) == 0x000400, "Member 'AFortTheaterMapTile::MissionData' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, LastValidMissionData) == 0x0004A0, "Member 'AFortTheaterMapTile::LastValidMissionData' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, ZoneDifficultyInfo) == 0x000540, "Member 'AFortTheaterMapTile::ZoneDifficultyInfo' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, MissionAlertData) == 0x000550, "Member 'AFortTheaterMapTile::MissionAlertData' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, StaticMeshComponent) == 0x0005E8, "Member 'AFortTheaterMapTile::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, AdjacencyMIDs) == 0x0005F0, "Member 'AFortTheaterMapTile::AdjacencyMIDs' has a wrong offset!");

// Class FortniteGame.FortTheaterMapViewer
// 0x0288 (0x0610 - 0x0388)
class AFortTheaterMapViewer : public AActor
{
public:
	uint8                                         Pad_388[0x8];                                      // 0x0388(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFortAvailableTheaterMissions>  MissionAvailabilityList;                           // 0x0390(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FFortAvailableMissionAlerts>    MissionAlertAvailabilityList;                      // 0x03A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FBox                                   HexMapSize;                                        // 0x03B0(0x001C)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         HexTileWidth;                                      // 0x03CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HexTileHeight;                                     // 0x03D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D4[0x4];                                      // 0x03D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              LastTheaterRefresh;                                // 0x03D8(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AFortTheaterMapTile*>            HexMap;                                            // 0x03E0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FString                                 CurrentTheaterId;                                  // 0x03F0(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<bool>                                  LeaderTileAccessStates;                            // 0x0400(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class AFortTheaterMapTile*                    CurrentSelectedTile;                               // 0x0410(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FFortTheaterMapData>            TheaterList;                                       // 0x0418(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         NumValidHexMapTiles;                               // 0x0428(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_42C[0x1E4];                                    // 0x042C(0x01E4)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleMarkedQuestsChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTheaterMapViewer">();
	}
	static class AFortTheaterMapViewer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortTheaterMapViewer>();
	}
};
static_assert(alignof(AFortTheaterMapViewer) == 0x000008, "Wrong alignment on AFortTheaterMapViewer");
static_assert(sizeof(AFortTheaterMapViewer) == 0x000610, "Wrong size on AFortTheaterMapViewer");
static_assert(offsetof(AFortTheaterMapViewer, MissionAvailabilityList) == 0x000390, "Member 'AFortTheaterMapViewer::MissionAvailabilityList' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapViewer, MissionAlertAvailabilityList) == 0x0003A0, "Member 'AFortTheaterMapViewer::MissionAlertAvailabilityList' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapViewer, HexMapSize) == 0x0003B0, "Member 'AFortTheaterMapViewer::HexMapSize' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapViewer, HexTileWidth) == 0x0003CC, "Member 'AFortTheaterMapViewer::HexTileWidth' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapViewer, HexTileHeight) == 0x0003D0, "Member 'AFortTheaterMapViewer::HexTileHeight' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapViewer, LastTheaterRefresh) == 0x0003D8, "Member 'AFortTheaterMapViewer::LastTheaterRefresh' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapViewer, HexMap) == 0x0003E0, "Member 'AFortTheaterMapViewer::HexMap' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapViewer, CurrentTheaterId) == 0x0003F0, "Member 'AFortTheaterMapViewer::CurrentTheaterId' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapViewer, LeaderTileAccessStates) == 0x000400, "Member 'AFortTheaterMapViewer::LeaderTileAccessStates' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapViewer, CurrentSelectedTile) == 0x000410, "Member 'AFortTheaterMapViewer::CurrentSelectedTile' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapViewer, TheaterList) == 0x000418, "Member 'AFortTheaterMapViewer::TheaterList' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapViewer, NumValidHexMapTiles) == 0x000428, "Member 'AFortTheaterMapViewer::NumValidHexMapTiles' has a wrong offset!");

// Class FortniteGame.FortClientAnnouncement_ConversationCodeInterface
// 0x0000 (0x0028 - 0x0028)
class IFortClientAnnouncement_ConversationCodeInterface final : public IInterface
{
public:
	bool PlayConversation();
	bool PlayConversationFromSentence(const struct FFortConversationSentence& StartingSentence);
	bool PlayConversationFromSentenceIndex(int32 StartingSentenceIndex);
	void StopConversation();

	bool IsPlayingConversation(bool bCheckAudioComponent) const;
	bool IsPlayingSentence(const struct FFortConversationSentence& Sentence) const;
	bool IsPlayingSentenceIndex(int32 SentenceIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortClientAnnouncement_ConversationCodeInterface">();
	}
	static class IFortClientAnnouncement_ConversationCodeInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortClientAnnouncement_ConversationCodeInterface>();
	}
};
static_assert(alignof(IFortClientAnnouncement_ConversationCodeInterface) == 0x000008, "Wrong alignment on IFortClientAnnouncement_ConversationCodeInterface");
static_assert(sizeof(IFortClientAnnouncement_ConversationCodeInterface) == 0x000028, "Wrong size on IFortClientAnnouncement_ConversationCodeInterface");

// Class FortniteGame.FortPlacementActorTagTest
// 0x0040 (0x0068 - 0x0028)
class UFortPlacementActorTagTest final : public UObject
{
public:
	struct FGameplayTagContainer                  TagsToApplyOnSuccess;                              // 0x0028(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TagsToApplyOnFailure;                              // 0x0048(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	bool LineTraceByChannel(class AFortPlacementActor* PlacementActor, const struct FVector& Start, const struct FVector& End, ETraceTypeQuery TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, struct FHitResult* OutHit, bool bIgnoreSelf) const;
	bool ShouldApplyTagsToPlacementActor(class AFortPlacementActor* FocusPlacementActor, const struct FVector& AveragePlacementActorLocation) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlacementActorTagTest">();
	}
	static class UFortPlacementActorTagTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPlacementActorTagTest>();
	}
};
static_assert(alignof(UFortPlacementActorTagTest) == 0x000008, "Wrong alignment on UFortPlacementActorTagTest");
static_assert(sizeof(UFortPlacementActorTagTest) == 0x000068, "Wrong size on UFortPlacementActorTagTest");
static_assert(offsetof(UFortPlacementActorTagTest, TagsToApplyOnSuccess) == 0x000028, "Member 'UFortPlacementActorTagTest::TagsToApplyOnSuccess' has a wrong offset!");
static_assert(offsetof(UFortPlacementActorTagTest, TagsToApplyOnFailure) == 0x000048, "Member 'UFortPlacementActorTagTest::TagsToApplyOnFailure' has a wrong offset!");

// Class FortniteGame.FortAsyncAction_MakeTieredWaveEncounterSettings
// 0x0198 (0x01C0 - 0x0028)
class UFortAsyncAction_MakeTieredWaveEncounterSettings final : public UBlueprintAsyncActionBase
{
public:
	UMulticastDelegateProperty_                   OnComplete;                                        // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FTieredWaveSetData                     WaveData;                                          // 0x0038(0x0120)(Transient, NativeAccessSpecifierPrivate)
	struct FFortEncounterSettings                 EncounterSettings;                                 // 0x0158(0x0058)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B0[0x10];                                     // 0x01B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UFortAsyncAction_MakeTieredWaveEncounterSettings* CreateAsyncAction_MakeTieredWaveEncounterSettings(const struct FTieredWaveSetData& WaveData_0, struct FFortEncounterSettings& InEncounterSettings);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAsyncAction_MakeTieredWaveEncounterSettings">();
	}
	static class UFortAsyncAction_MakeTieredWaveEncounterSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAsyncAction_MakeTieredWaveEncounterSettings>();
	}
};
static_assert(alignof(UFortAsyncAction_MakeTieredWaveEncounterSettings) == 0x000008, "Wrong alignment on UFortAsyncAction_MakeTieredWaveEncounterSettings");
static_assert(sizeof(UFortAsyncAction_MakeTieredWaveEncounterSettings) == 0x0001C0, "Wrong size on UFortAsyncAction_MakeTieredWaveEncounterSettings");
static_assert(offsetof(UFortAsyncAction_MakeTieredWaveEncounterSettings, OnComplete) == 0x000028, "Member 'UFortAsyncAction_MakeTieredWaveEncounterSettings::OnComplete' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_MakeTieredWaveEncounterSettings, WaveData) == 0x000038, "Member 'UFortAsyncAction_MakeTieredWaveEncounterSettings::WaveData' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_MakeTieredWaveEncounterSettings, EncounterSettings) == 0x000158, "Member 'UFortAsyncAction_MakeTieredWaveEncounterSettings::EncounterSettings' has a wrong offset!");

// Class FortniteGame.FortClientBotManager
// 0x0228 (0x0250 - 0x0028)
class UFortClientBotManager : public UObject
{
public:
	uint8                                         Pad_28[0x40];                                      // 0x0028(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           MissionEndTimerHandle;                             // 0x0068(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x1E];                                      // 0x0070(0x001E)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHasAttemptedAbandon;                              // 0x008E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMatchmaking;                                    // 0x008F(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldPickRandomMap;                              // 0x0090(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldRecordFPSCharts;                            // 0x0091(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFPSRecordingStarted;                              // 0x0092(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWatchingForCallStack;                             // 0x0093(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         iSelectedTheater;                                  // 0x0094(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         iSelectedTile;                                     // 0x0098(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomZoneDifficultyMinimum;                       // 0x009C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomZoneDifficultyMaximum;                       // 0x00A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumSkillPurchasesAttempted;                        // 0x00A4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSkillPurchaseAttempts;                          // 0x00A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumWorkerSlotsAttempted;                           // 0x00AC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxWorkerSlotAttempts;                             // 0x00B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LobbyActionTimer;                                  // 0x00B4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeBetweenLobbyActions;                           // 0x00B8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWaitingForSkillTreePurchase;                      // 0x00BC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWaitingForWorkerSlot;                             // 0x00BD(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BE[0x2];                                       // 0x00BE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LoopsSpentWaitingForFrontend;                      // 0x00C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeBetweenStartButtonClicks;                      // 0x00C4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x4];                                       // 0x00C8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeSinceFriendInvitesSent;                        // 0x00CC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastMatchmakeTime;                                 // 0x00D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MatchmakingStartTime;                              // 0x00D4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastChangedStateTime;                              // 0x00D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastRandomTurnTime;                                // 0x00DC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastPickLootTime;                                  // 0x00E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastPickEnemyTime;                                 // 0x00E4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastEnemyKilledTime;                               // 0x00E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastBuildingKilledTime;                            // 0x00EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastGoodInteraction;                               // 0x00F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastCheckGoodTarget;                               // 0x00F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x48];                                      // 0x00F8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortPawn*                              EnemyTarget;                                       // 0x0140(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AFortPickup*                            PickupTarget;                                      // 0x0148(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABuildingActor*                         BuildingTarget;                                    // 0x0150(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABuildingActor*                         MissionTarget;                                     // 0x0158(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABuildingActor*                         PrimaryMissionTarget;                              // 0x0160(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ABuildingActor*>                 AllMissionTargets;                                 // 0x0168(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ABuildingActor*>                 ActiveMissionTargets;                              // 0x0178(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_188[0xA0];                                     // 0x0188(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ViewLocation;                                      // 0x0228(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_234[0x4];                                      // 0x0234(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortPlayerPawn*                        MyPawn;                                            // 0x0238(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UFortWorldItem*>                 ItemsToCheckForMaxStackSize;                       // 0x0240(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortClientBotManager">();
	}
	static class UFortClientBotManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortClientBotManager>();
	}
};
static_assert(alignof(UFortClientBotManager) == 0x000008, "Wrong alignment on UFortClientBotManager");
static_assert(sizeof(UFortClientBotManager) == 0x000250, "Wrong size on UFortClientBotManager");
static_assert(offsetof(UFortClientBotManager, MissionEndTimerHandle) == 0x000068, "Member 'UFortClientBotManager::MissionEndTimerHandle' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, bHasAttemptedAbandon) == 0x00008E, "Member 'UFortClientBotManager::bHasAttemptedAbandon' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, bIsMatchmaking) == 0x00008F, "Member 'UFortClientBotManager::bIsMatchmaking' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, bShouldPickRandomMap) == 0x000090, "Member 'UFortClientBotManager::bShouldPickRandomMap' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, bShouldRecordFPSCharts) == 0x000091, "Member 'UFortClientBotManager::bShouldRecordFPSCharts' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, bFPSRecordingStarted) == 0x000092, "Member 'UFortClientBotManager::bFPSRecordingStarted' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, bWatchingForCallStack) == 0x000093, "Member 'UFortClientBotManager::bWatchingForCallStack' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, iSelectedTheater) == 0x000094, "Member 'UFortClientBotManager::iSelectedTheater' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, iSelectedTile) == 0x000098, "Member 'UFortClientBotManager::iSelectedTile' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, RandomZoneDifficultyMinimum) == 0x00009C, "Member 'UFortClientBotManager::RandomZoneDifficultyMinimum' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, RandomZoneDifficultyMaximum) == 0x0000A0, "Member 'UFortClientBotManager::RandomZoneDifficultyMaximum' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, NumSkillPurchasesAttempted) == 0x0000A4, "Member 'UFortClientBotManager::NumSkillPurchasesAttempted' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, MaxSkillPurchaseAttempts) == 0x0000A8, "Member 'UFortClientBotManager::MaxSkillPurchaseAttempts' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, NumWorkerSlotsAttempted) == 0x0000AC, "Member 'UFortClientBotManager::NumWorkerSlotsAttempted' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, MaxWorkerSlotAttempts) == 0x0000B0, "Member 'UFortClientBotManager::MaxWorkerSlotAttempts' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, LobbyActionTimer) == 0x0000B4, "Member 'UFortClientBotManager::LobbyActionTimer' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, TimeBetweenLobbyActions) == 0x0000B8, "Member 'UFortClientBotManager::TimeBetweenLobbyActions' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, bWaitingForSkillTreePurchase) == 0x0000BC, "Member 'UFortClientBotManager::bWaitingForSkillTreePurchase' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, bWaitingForWorkerSlot) == 0x0000BD, "Member 'UFortClientBotManager::bWaitingForWorkerSlot' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, LoopsSpentWaitingForFrontend) == 0x0000C0, "Member 'UFortClientBotManager::LoopsSpentWaitingForFrontend' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, TimeBetweenStartButtonClicks) == 0x0000C4, "Member 'UFortClientBotManager::TimeBetweenStartButtonClicks' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, TimeSinceFriendInvitesSent) == 0x0000CC, "Member 'UFortClientBotManager::TimeSinceFriendInvitesSent' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, LastMatchmakeTime) == 0x0000D0, "Member 'UFortClientBotManager::LastMatchmakeTime' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, MatchmakingStartTime) == 0x0000D4, "Member 'UFortClientBotManager::MatchmakingStartTime' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, LastChangedStateTime) == 0x0000D8, "Member 'UFortClientBotManager::LastChangedStateTime' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, LastRandomTurnTime) == 0x0000DC, "Member 'UFortClientBotManager::LastRandomTurnTime' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, LastPickLootTime) == 0x0000E0, "Member 'UFortClientBotManager::LastPickLootTime' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, LastPickEnemyTime) == 0x0000E4, "Member 'UFortClientBotManager::LastPickEnemyTime' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, LastEnemyKilledTime) == 0x0000E8, "Member 'UFortClientBotManager::LastEnemyKilledTime' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, LastBuildingKilledTime) == 0x0000EC, "Member 'UFortClientBotManager::LastBuildingKilledTime' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, LastGoodInteraction) == 0x0000F0, "Member 'UFortClientBotManager::LastGoodInteraction' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, LastCheckGoodTarget) == 0x0000F4, "Member 'UFortClientBotManager::LastCheckGoodTarget' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, EnemyTarget) == 0x000140, "Member 'UFortClientBotManager::EnemyTarget' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, PickupTarget) == 0x000148, "Member 'UFortClientBotManager::PickupTarget' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, BuildingTarget) == 0x000150, "Member 'UFortClientBotManager::BuildingTarget' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, MissionTarget) == 0x000158, "Member 'UFortClientBotManager::MissionTarget' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, PrimaryMissionTarget) == 0x000160, "Member 'UFortClientBotManager::PrimaryMissionTarget' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, AllMissionTargets) == 0x000168, "Member 'UFortClientBotManager::AllMissionTargets' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, ActiveMissionTargets) == 0x000178, "Member 'UFortClientBotManager::ActiveMissionTargets' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, ViewLocation) == 0x000228, "Member 'UFortClientBotManager::ViewLocation' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, MyPawn) == 0x000238, "Member 'UFortClientBotManager::MyPawn' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, ItemsToCheckForMaxStackSize) == 0x000240, "Member 'UFortClientBotManager::ItemsToCheckForMaxStackSize' has a wrong offset!");

// Class FortniteGame.FortClientBotManagerAthena
// 0x0078 (0x02C8 - 0x0250)
class UFortClientBotManagerAthena final : public UFortClientBotManager
{
public:
	uint8                                         Pad_250[0x78];                                     // 0x0250(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortClientBotManagerAthena">();
	}
	static class UFortClientBotManagerAthena* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortClientBotManagerAthena>();
	}
};
static_assert(alignof(UFortClientBotManagerAthena) == 0x000008, "Wrong alignment on UFortClientBotManagerAthena");
static_assert(sizeof(UFortClientBotManagerAthena) == 0x0002C8, "Wrong size on UFortClientBotManagerAthena");

// Class FortniteGame.FortAsyncAction_PlayConversation
// 0x0058 (0x0080 - 0x0028)
class UFortAsyncAction_PlayConversation final : public UBlueprintAsyncActionBase
{
public:
	UMulticastDelegateProperty_                   OnSuccess;                                         // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnCanceled;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFailure;                                         // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AFortPawn*                              Pawn;                                              // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortConversation*                      ConversationToPlay;                                // 0x0060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x18];                                      // 0x0068(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UFortAsyncAction_PlayConversation* PlayConversation(class AFortPawn* Pawn_0, class UFortConversation* ConversationToPlay_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAsyncAction_PlayConversation">();
	}
	static class UFortAsyncAction_PlayConversation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAsyncAction_PlayConversation>();
	}
};
static_assert(alignof(UFortAsyncAction_PlayConversation) == 0x000008, "Wrong alignment on UFortAsyncAction_PlayConversation");
static_assert(sizeof(UFortAsyncAction_PlayConversation) == 0x000080, "Wrong size on UFortAsyncAction_PlayConversation");
static_assert(offsetof(UFortAsyncAction_PlayConversation, OnSuccess) == 0x000028, "Member 'UFortAsyncAction_PlayConversation::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_PlayConversation, OnCanceled) == 0x000038, "Member 'UFortAsyncAction_PlayConversation::OnCanceled' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_PlayConversation, OnFailure) == 0x000048, "Member 'UFortAsyncAction_PlayConversation::OnFailure' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_PlayConversation, Pawn) == 0x000058, "Member 'UFortAsyncAction_PlayConversation::Pawn' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_PlayConversation, ConversationToPlay) == 0x000060, "Member 'UFortAsyncAction_PlayConversation::ConversationToPlay' has a wrong offset!");

// Class FortniteGame.FortAsyncAction_SendQuestStatEvent
// 0x00B0 (0x00D8 - 0x0028)
class UFortAsyncAction_SendQuestStatEvent final : public UBlueprintAsyncActionBase
{
public:
	UMulticastDelegateProperty_                   OnSuccess;                                         // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnIgnored;                                         // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFailure;                                         // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UFortQuestManager*                      QuestManager;                                      // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDataTableRowHandle                    ObjectiveStat;                                     // 0x0060(0x0010)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  TargetTags;                                        // 0x0070(0x0020)(Transient, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  SourceTags;                                        // 0x0090(0x0020)(Transient, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  ContextTags;                                       // 0x00B0(0x0020)(Transient, NativeAccessSpecifierPrivate)
	int32                                         Count;                                             // 0x00D0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UFortAsyncAction_SendQuestStatEvent* SendClientStatEvent(class UFortQuestManager* QuestManager_0, const struct FDataTableRowHandle& ObjectiveStat_0, int32 Count_0);
	static class UFortAsyncAction_SendQuestStatEvent* SendClientStatEventWithTags(class UFortQuestManager* QuestManager_0, const struct FGameplayTagContainer& TargetTags_0, const struct FGameplayTagContainer& SourceTags_0, const struct FGameplayTagContainer& ContextTags_0, int32 Count_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAsyncAction_SendQuestStatEvent">();
	}
	static class UFortAsyncAction_SendQuestStatEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAsyncAction_SendQuestStatEvent>();
	}
};
static_assert(alignof(UFortAsyncAction_SendQuestStatEvent) == 0x000008, "Wrong alignment on UFortAsyncAction_SendQuestStatEvent");
static_assert(sizeof(UFortAsyncAction_SendQuestStatEvent) == 0x0000D8, "Wrong size on UFortAsyncAction_SendQuestStatEvent");
static_assert(offsetof(UFortAsyncAction_SendQuestStatEvent, OnSuccess) == 0x000028, "Member 'UFortAsyncAction_SendQuestStatEvent::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_SendQuestStatEvent, OnIgnored) == 0x000038, "Member 'UFortAsyncAction_SendQuestStatEvent::OnIgnored' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_SendQuestStatEvent, OnFailure) == 0x000048, "Member 'UFortAsyncAction_SendQuestStatEvent::OnFailure' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_SendQuestStatEvent, QuestManager) == 0x000058, "Member 'UFortAsyncAction_SendQuestStatEvent::QuestManager' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_SendQuestStatEvent, ObjectiveStat) == 0x000060, "Member 'UFortAsyncAction_SendQuestStatEvent::ObjectiveStat' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_SendQuestStatEvent, TargetTags) == 0x000070, "Member 'UFortAsyncAction_SendQuestStatEvent::TargetTags' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_SendQuestStatEvent, SourceTags) == 0x000090, "Member 'UFortAsyncAction_SendQuestStatEvent::SourceTags' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_SendQuestStatEvent, ContextTags) == 0x0000B0, "Member 'UFortAsyncAction_SendQuestStatEvent::ContextTags' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_SendQuestStatEvent, Count) == 0x0000D0, "Member 'UFortAsyncAction_SendQuestStatEvent::Count' has a wrong offset!");

// Class FortniteGame.FortAsyncAction_WaitForClientAnnouncement
// 0x0038 (0x0060 - 0x0028)
class UFortAsyncAction_WaitForClientAnnouncement final : public UBlueprintAsyncActionBase
{
public:
	UMulticastDelegateProperty_                   OnAllClientsReady;                                 // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnCanceled;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGuid                                  AnnouncementID;                                    // 0x0048(0x0010)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           CheckAllPlayersReadyTimerHandle;                   // 0x0058(0x0008)(NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UFortAsyncAction_WaitForClientAnnouncement* WaitForClientAnnouncement(class UObject* InWorldContextObject, class AFortClientAnnouncement* AnnouncementToWaitFor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAsyncAction_WaitForClientAnnouncement">();
	}
	static class UFortAsyncAction_WaitForClientAnnouncement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAsyncAction_WaitForClientAnnouncement>();
	}
};
static_assert(alignof(UFortAsyncAction_WaitForClientAnnouncement) == 0x000008, "Wrong alignment on UFortAsyncAction_WaitForClientAnnouncement");
static_assert(sizeof(UFortAsyncAction_WaitForClientAnnouncement) == 0x000060, "Wrong size on UFortAsyncAction_WaitForClientAnnouncement");
static_assert(offsetof(UFortAsyncAction_WaitForClientAnnouncement, OnAllClientsReady) == 0x000028, "Member 'UFortAsyncAction_WaitForClientAnnouncement::OnAllClientsReady' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_WaitForClientAnnouncement, OnCanceled) == 0x000038, "Member 'UFortAsyncAction_WaitForClientAnnouncement::OnCanceled' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_WaitForClientAnnouncement, AnnouncementID) == 0x000048, "Member 'UFortAsyncAction_WaitForClientAnnouncement::AnnouncementID' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_WaitForClientAnnouncement, CheckAllPlayersReadyTimerHandle) == 0x000058, "Member 'UFortAsyncAction_WaitForClientAnnouncement::CheckAllPlayersReadyTimerHandle' has a wrong offset!");

// Class FortniteGame.FortBTTask_GameMoveTo
// 0x0040 (0x00F0 - 0x00B0)
class UFortBTTask_GameMoveTo : public UBTTask_MoveTo
{
public:
	struct FBlackboardKeySelector                 FocalPointWhileMoving;                             // 0x00B0(0x0028)(Edit, NativeAccessSpecifierPublic)
	EPathObstacleAction                           PathObstacleAction;                                // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AFortPawn>                  PushBumpedPawnClass;                               // 0x00E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDetectUnexpectedPathBlockingObstacles : 1;        // 0x00E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableSlowdownAtGoal : 1;                         // 0x00E8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFinishMoveOnOverlap : 1;                          // 0x00E8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTTask_GameMoveTo">();
	}
	static class UFortBTTask_GameMoveTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTTask_GameMoveTo>();
	}
};
static_assert(alignof(UFortBTTask_GameMoveTo) == 0x000008, "Wrong alignment on UFortBTTask_GameMoveTo");
static_assert(sizeof(UFortBTTask_GameMoveTo) == 0x0000F0, "Wrong size on UFortBTTask_GameMoveTo");
static_assert(offsetof(UFortBTTask_GameMoveTo, FocalPointWhileMoving) == 0x0000B0, "Member 'UFortBTTask_GameMoveTo::FocalPointWhileMoving' has a wrong offset!");
static_assert(offsetof(UFortBTTask_GameMoveTo, PathObstacleAction) == 0x0000D8, "Member 'UFortBTTask_GameMoveTo::PathObstacleAction' has a wrong offset!");
static_assert(offsetof(UFortBTTask_GameMoveTo, PushBumpedPawnClass) == 0x0000E0, "Member 'UFortBTTask_GameMoveTo::PushBumpedPawnClass' has a wrong offset!");

// Class FortniteGame.FortBTTask_GameMoveDirectlyToward
// 0x0000 (0x00F0 - 0x00F0)
class UFortBTTask_GameMoveDirectlyToward final : public UFortBTTask_GameMoveTo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTTask_GameMoveDirectlyToward">();
	}
	static class UFortBTTask_GameMoveDirectlyToward* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTTask_GameMoveDirectlyToward>();
	}
};
static_assert(alignof(UFortBTTask_GameMoveDirectlyToward) == 0x000008, "Wrong alignment on UFortBTTask_GameMoveDirectlyToward");
static_assert(sizeof(UFortBTTask_GameMoveDirectlyToward) == 0x0000F0, "Wrong size on UFortBTTask_GameMoveDirectlyToward");

// Class FortniteGame.FortCollectionBookCategory
// 0x0020 (0x0048 - 0x0028)
class UFortCollectionBookCategory final : public UObject
{
public:
	class FName                                   CategoryDataRowName;                               // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SortPriority;                                      // 0x0030(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ChildrenPageIds;                                   // 0x0038(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCollectionBookCategory">();
	}
	static class UFortCollectionBookCategory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCollectionBookCategory>();
	}
};
static_assert(alignof(UFortCollectionBookCategory) == 0x000008, "Wrong alignment on UFortCollectionBookCategory");
static_assert(sizeof(UFortCollectionBookCategory) == 0x000048, "Wrong size on UFortCollectionBookCategory");
static_assert(offsetof(UFortCollectionBookCategory, CategoryDataRowName) == 0x000028, "Member 'UFortCollectionBookCategory::CategoryDataRowName' has a wrong offset!");
static_assert(offsetof(UFortCollectionBookCategory, SortPriority) == 0x000030, "Member 'UFortCollectionBookCategory::SortPriority' has a wrong offset!");
static_assert(offsetof(UFortCollectionBookCategory, ChildrenPageIds) == 0x000038, "Member 'UFortCollectionBookCategory::ChildrenPageIds' has a wrong offset!");

// Class FortniteGame.FortCameraMode_AthenaAircraft
// 0x0000 (0x0110 - 0x0110)
class UFortCameraMode_AthenaAircraft final : public UFortCameraMode_ThirdPerson
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCameraMode_AthenaAircraft">();
	}
	static class UFortCameraMode_AthenaAircraft* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCameraMode_AthenaAircraft>();
	}
};
static_assert(alignof(UFortCameraMode_AthenaAircraft) == 0x000008, "Wrong alignment on UFortCameraMode_AthenaAircraft");
static_assert(sizeof(UFortCameraMode_AthenaAircraft) == 0x000110, "Wrong size on UFortCameraMode_AthenaAircraft");

// Class FortniteGame.FortConsole
// 0x0000 (0x0130 - 0x0130)
class UFortConsole final : public UConsole
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortConsole">();
	}
	static class UFortConsole* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortConsole>();
	}
};
static_assert(alignof(UFortConsole) == 0x000008, "Wrong alignment on UFortConsole");
static_assert(sizeof(UFortConsole) == 0x000130, "Wrong size on UFortConsole");

// Class FortniteGame.FortAthenaHoverCarMovementComponent
// 0x0018 (0x02F8 - 0x02E0)
class UFortAthenaHoverCarMovementComponent final : public USimpleWheeledVehicleMovementComponent
{
public:
	uint8                                         Pad_2E0[0xC];                                      // 0x02E0(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FReplicatedAthenaVehicleState          ReplicatedAthenaState;                             // 0x02EC(0x000C)(Net, Transient, NoDestructor, NativeAccessSpecifierPrivate)

public:
	void ServerUpdateAthenaState(float InThrottleInput, float InSteeringInput, const struct FVector& InForwardVectorTarget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaHoverCarMovementComponent">();
	}
	static class UFortAthenaHoverCarMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaHoverCarMovementComponent>();
	}
};
static_assert(alignof(UFortAthenaHoverCarMovementComponent) == 0x000008, "Wrong alignment on UFortAthenaHoverCarMovementComponent");
static_assert(sizeof(UFortAthenaHoverCarMovementComponent) == 0x0002F8, "Wrong size on UFortAthenaHoverCarMovementComponent");
static_assert(offsetof(UFortAthenaHoverCarMovementComponent, ReplicatedAthenaState) == 0x0002EC, "Member 'UFortAthenaHoverCarMovementComponent::ReplicatedAthenaState' has a wrong offset!");

// Class FortniteGame.FortAthenaSimpleCarMovementComponent
// 0x0000 (0x0440 - 0x0440)
class UFortAthenaSimpleCarMovementComponent final : public UWheeledVehicleMovementComponent4W
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaSimpleCarMovementComponent">();
	}
	static class UFortAthenaSimpleCarMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAthenaSimpleCarMovementComponent>();
	}
};
static_assert(alignof(UFortAthenaSimpleCarMovementComponent) == 0x000008, "Wrong alignment on UFortAthenaSimpleCarMovementComponent");
static_assert(sizeof(UFortAthenaSimpleCarMovementComponent) == 0x000440, "Wrong size on UFortAthenaSimpleCarMovementComponent");

// Class FortniteGame.FortMiniMapComponent
// 0x00B8 (0x01C8 - 0x0110)
class UFortMiniMapComponent final : public UFortVisibilityComponent
{
public:
	struct FFortMiniMapData                       MiniMapData;                                       // 0x0110(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, Net, SaveGame, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UTexture2D*                             LocalMinimapIconOverride;                          // 0x0190(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UFortMiniMapIndicator>   MiniMapIndicator;                                  // 0x0198(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A0[0x28];                                     // 0x01A0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_MiniMapData();
	void OverrideLocalMiniMapIcon(class UTexture2D* MiniMapIcon);
	void OverrideLocalMiniMapIndicatorIsVisible(bool bVisible);
	void SetMiniMapIcon(class UTexture2D* MiniMapIcon);
	void SetMiniMapIconColor(const struct FLinearColor& InColor);
	void SetMiniMapIconColorPulsesPerSecond(float ColorPulsesPerSecond);
	void SetMiniMapIconPulseColor(const struct FLinearColor& PulseColor);
	void SetMiniMapIconScale(const struct FVector2D& IconScale);
	void SetMiniMapIconSizePulsesPerSecond(float SizePulsesPerSecond);
	void SetMiniMapIndicatorIsVisible(bool bVisible);
	void SetMiniMapIndicatorIsVisibleOnMiniMap(bool bVisibleOnMiniMap);
	void SetMiniMapLocationOffset(const struct FVector& LocationOffset);
	void SetMinimapViewableDistance(float ViewDistance);
	void SetupMiniMapComponent(class UTexture2D* MiniMapIcon, const struct FLinearColor& IconColor, const struct FLinearColor& PulseColor, float ColorPulsesPerSecond, float SizePulsesPerSecond);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMiniMapComponent">();
	}
	static class UFortMiniMapComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMiniMapComponent>();
	}
};
static_assert(alignof(UFortMiniMapComponent) == 0x000008, "Wrong alignment on UFortMiniMapComponent");
static_assert(sizeof(UFortMiniMapComponent) == 0x0001C8, "Wrong size on UFortMiniMapComponent");
static_assert(offsetof(UFortMiniMapComponent, MiniMapData) == 0x000110, "Member 'UFortMiniMapComponent::MiniMapData' has a wrong offset!");
static_assert(offsetof(UFortMiniMapComponent, LocalMinimapIconOverride) == 0x000190, "Member 'UFortMiniMapComponent::LocalMinimapIconOverride' has a wrong offset!");
static_assert(offsetof(UFortMiniMapComponent, MiniMapIndicator) == 0x000198, "Member 'UFortMiniMapComponent::MiniMapIndicator' has a wrong offset!");

// Class FortniteGame.FortPlacementActorDataProviderInterface
// 0x0000 (0x0028 - 0x0028)
class IFortPlacementActorDataProviderInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlacementActorDataProviderInterface">();
	}
	static class IFortPlacementActorDataProviderInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortPlacementActorDataProviderInterface>();
	}
};
static_assert(alignof(IFortPlacementActorDataProviderInterface) == 0x000008, "Wrong alignment on IFortPlacementActorDataProviderInterface");
static_assert(sizeof(IFortPlacementActorDataProviderInterface) == 0x000028, "Wrong size on IFortPlacementActorDataProviderInterface");

// Class FortniteGame.FortAthenaMapInfo
// 0x02C8 (0x0650 - 0x0388)
class AFortAthenaMapInfo final : public AActor
{
public:
	TSubclassOf<class ABuildingContainer>         TreasureChestClass;                                // 0x0388(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FScalableFloat                         TreasureChestMinSpawnPercent;                      // 0x0390(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FScalableFloat                         TreasureChestMaxSpawnPercent;                      // 0x03B8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSubclassOf<class ABuildingContainer>         AmmoBoxClass;                                      // 0x03E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FScalableFloat                         AmmoBoxMinSpawnPercent;                            // 0x03E8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FScalableFloat                         AmmoBoxMaxSpawnPercent;                            // 0x0410(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSubclassOf<class AFortAthenaSupplyDrop>      SupplyDropClass;                                   // 0x0438(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FScalableFloat                         SupplyDropMinPlacementHeight;                      // 0x0440(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FScalableFloat                         SupplyDropMaxPlacementHeight;                      // 0x0468(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FScalableFloat                         SupplyDropTimeInterval;                            // 0x0490(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FScalableFloat                         SupplyDropTimeDeviation;                           // 0x04B8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSubclassOf<class AFortAthenaAircraft>        AircraftClass;                                     // 0x04E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox2D                                 AircraftSpawnZone;                                 // 0x04E8(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox2D                                 AircraftDropZone;                                  // 0x04FC(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AVolume*                                AircraftDropVolume;                                // 0x0510(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FScalableFloat                         SkydivingScanForImpactWorldZ;                      // 0x0518(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FScalableFloat                         SkydivingForceDeployParachuteWorldZ;               // 0x0540(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FScalableFloat                         AircraftDeviationAngle;                            // 0x0568(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         AircraftHeight;                                    // 0x0590(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         AircraftSpeed;                                     // 0x05B8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         SafeZoneStartDelay;                                // 0x05E0(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         SafeZoneStartingRadius;                            // 0x0608(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	class AVolume*                                SafeZoneVolume;                                    // 0x0630(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FFortSafeZoneDefinition>        SafeZoneDefinitions;                               // 0x0638(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         ParachuteForceDeployWorldZ;                        // 0x0648(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_64C[0x4];                                      // 0x064C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaMapInfo">();
	}
	static class AFortAthenaMapInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAthenaMapInfo>();
	}
};
static_assert(alignof(AFortAthenaMapInfo) == 0x000008, "Wrong alignment on AFortAthenaMapInfo");
static_assert(sizeof(AFortAthenaMapInfo) == 0x000650, "Wrong size on AFortAthenaMapInfo");
static_assert(offsetof(AFortAthenaMapInfo, TreasureChestClass) == 0x000388, "Member 'AFortAthenaMapInfo::TreasureChestClass' has a wrong offset!");
static_assert(offsetof(AFortAthenaMapInfo, TreasureChestMinSpawnPercent) == 0x000390, "Member 'AFortAthenaMapInfo::TreasureChestMinSpawnPercent' has a wrong offset!");
static_assert(offsetof(AFortAthenaMapInfo, TreasureChestMaxSpawnPercent) == 0x0003B8, "Member 'AFortAthenaMapInfo::TreasureChestMaxSpawnPercent' has a wrong offset!");
static_assert(offsetof(AFortAthenaMapInfo, AmmoBoxClass) == 0x0003E0, "Member 'AFortAthenaMapInfo::AmmoBoxClass' has a wrong offset!");
static_assert(offsetof(AFortAthenaMapInfo, AmmoBoxMinSpawnPercent) == 0x0003E8, "Member 'AFortAthenaMapInfo::AmmoBoxMinSpawnPercent' has a wrong offset!");
static_assert(offsetof(AFortAthenaMapInfo, AmmoBoxMaxSpawnPercent) == 0x000410, "Member 'AFortAthenaMapInfo::AmmoBoxMaxSpawnPercent' has a wrong offset!");
static_assert(offsetof(AFortAthenaMapInfo, SupplyDropClass) == 0x000438, "Member 'AFortAthenaMapInfo::SupplyDropClass' has a wrong offset!");
static_assert(offsetof(AFortAthenaMapInfo, SupplyDropMinPlacementHeight) == 0x000440, "Member 'AFortAthenaMapInfo::SupplyDropMinPlacementHeight' has a wrong offset!");
static_assert(offsetof(AFortAthenaMapInfo, SupplyDropMaxPlacementHeight) == 0x000468, "Member 'AFortAthenaMapInfo::SupplyDropMaxPlacementHeight' has a wrong offset!");
static_assert(offsetof(AFortAthenaMapInfo, SupplyDropTimeInterval) == 0x000490, "Member 'AFortAthenaMapInfo::SupplyDropTimeInterval' has a wrong offset!");
static_assert(offsetof(AFortAthenaMapInfo, SupplyDropTimeDeviation) == 0x0004B8, "Member 'AFortAthenaMapInfo::SupplyDropTimeDeviation' has a wrong offset!");
static_assert(offsetof(AFortAthenaMapInfo, AircraftClass) == 0x0004E0, "Member 'AFortAthenaMapInfo::AircraftClass' has a wrong offset!");
static_assert(offsetof(AFortAthenaMapInfo, AircraftSpawnZone) == 0x0004E8, "Member 'AFortAthenaMapInfo::AircraftSpawnZone' has a wrong offset!");
static_assert(offsetof(AFortAthenaMapInfo, AircraftDropZone) == 0x0004FC, "Member 'AFortAthenaMapInfo::AircraftDropZone' has a wrong offset!");
static_assert(offsetof(AFortAthenaMapInfo, AircraftDropVolume) == 0x000510, "Member 'AFortAthenaMapInfo::AircraftDropVolume' has a wrong offset!");
static_assert(offsetof(AFortAthenaMapInfo, SkydivingScanForImpactWorldZ) == 0x000518, "Member 'AFortAthenaMapInfo::SkydivingScanForImpactWorldZ' has a wrong offset!");
static_assert(offsetof(AFortAthenaMapInfo, SkydivingForceDeployParachuteWorldZ) == 0x000540, "Member 'AFortAthenaMapInfo::SkydivingForceDeployParachuteWorldZ' has a wrong offset!");
static_assert(offsetof(AFortAthenaMapInfo, AircraftDeviationAngle) == 0x000568, "Member 'AFortAthenaMapInfo::AircraftDeviationAngle' has a wrong offset!");
static_assert(offsetof(AFortAthenaMapInfo, AircraftHeight) == 0x000590, "Member 'AFortAthenaMapInfo::AircraftHeight' has a wrong offset!");
static_assert(offsetof(AFortAthenaMapInfo, AircraftSpeed) == 0x0005B8, "Member 'AFortAthenaMapInfo::AircraftSpeed' has a wrong offset!");
static_assert(offsetof(AFortAthenaMapInfo, SafeZoneStartDelay) == 0x0005E0, "Member 'AFortAthenaMapInfo::SafeZoneStartDelay' has a wrong offset!");
static_assert(offsetof(AFortAthenaMapInfo, SafeZoneStartingRadius) == 0x000608, "Member 'AFortAthenaMapInfo::SafeZoneStartingRadius' has a wrong offset!");
static_assert(offsetof(AFortAthenaMapInfo, SafeZoneVolume) == 0x000630, "Member 'AFortAthenaMapInfo::SafeZoneVolume' has a wrong offset!");
static_assert(offsetof(AFortAthenaMapInfo, SafeZoneDefinitions) == 0x000638, "Member 'AFortAthenaMapInfo::SafeZoneDefinitions' has a wrong offset!");
static_assert(offsetof(AFortAthenaMapInfo, ParachuteForceDeployWorldZ) == 0x000648, "Member 'AFortAthenaMapInfo::ParachuteForceDeployWorldZ' has a wrong offset!");

// Class FortniteGame.FortAthenaSimpleCar
// 0x0038 (0x0420 - 0x03E8)
class AFortAthenaSimpleCar final : public APawn
{
public:
	class UFortAthenaSimpleCarMovementComponent*  WheeledVehicleMovementComponent;                   // 0x03E8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 MeshComponent;                                     // 0x03F0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortCameraMode_AthenaVehicle> CameraModeClass;                                   // 0x03F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FAthenaCarPlayerSlot>           PlayerSlots;                                       // 0x0400(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_410[0x10];                                     // 0x0410(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaSimpleCar">();
	}
	static class AFortAthenaSimpleCar* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAthenaSimpleCar>();
	}
};
static_assert(alignof(AFortAthenaSimpleCar) == 0x000008, "Wrong alignment on AFortAthenaSimpleCar");
static_assert(sizeof(AFortAthenaSimpleCar) == 0x000420, "Wrong size on AFortAthenaSimpleCar");
static_assert(offsetof(AFortAthenaSimpleCar, WheeledVehicleMovementComponent) == 0x0003E8, "Member 'AFortAthenaSimpleCar::WheeledVehicleMovementComponent' has a wrong offset!");
static_assert(offsetof(AFortAthenaSimpleCar, MeshComponent) == 0x0003F0, "Member 'AFortAthenaSimpleCar::MeshComponent' has a wrong offset!");
static_assert(offsetof(AFortAthenaSimpleCar, CameraModeClass) == 0x0003F8, "Member 'AFortAthenaSimpleCar::CameraModeClass' has a wrong offset!");
static_assert(offsetof(AFortAthenaSimpleCar, PlayerSlots) == 0x000400, "Member 'AFortAthenaSimpleCar::PlayerSlots' has a wrong offset!");

// Class FortniteGame.FortAIAttributesSet
// 0x0000 (0x00D0 - 0x00D0)
class UFortAIAttributesSet final : public UFortCharacterAttrSet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIAttributesSet">();
	}
	static class UFortAIAttributesSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIAttributesSet>();
	}
};
static_assert(alignof(UFortAIAttributesSet) == 0x000008, "Wrong alignment on UFortAIAttributesSet");
static_assert(sizeof(UFortAIAttributesSet) == 0x0000D0, "Wrong size on UFortAIAttributesSet");

// Class FortniteGame.FortCombatManager
// 0x0878 (0x0C00 - 0x0388)
class AFortCombatManager : public AActor
{
public:
	uint8                                         Pad_388[0x8];                                      // 0x0388(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReplicatedCombatEventHeat[0x16];                   // 0x0390(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CombatEventHeat[0x16];                             // 0x03E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CombatFactors[0xC];                                // 0x0440(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentTotalHeat;                                  // 0x0470(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaximumTotalHeat;                                  // 0x0474(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxHeatEver;                                       // 0x0478(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_47C[0x1C];                                     // 0x047C(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCombatEventData                       Events[0x16];                                      // 0x0498(0x0030)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FCombatFactorData                      Factors[0xC];                                      // 0x08B8(0x0038)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_B58[0x8];                                      // 0x0B58(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCombatThresholdData                   Thresholds[0x4];                                   // 0x0B60(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	float GetEventHeatPercent(EFortCombatEvents CombatEvent);
	float GetEventHeatPercentTotal(EFortCombatEvents CombatEvent);
	void OnRep_CombatEventHeat();
	void OnThresholdChange(EFortCombatThresholds OldThreshold, EFortCombatThresholds NewThreshold);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCombatManager">();
	}
	static class AFortCombatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortCombatManager>();
	}
};
static_assert(alignof(AFortCombatManager) == 0x000008, "Wrong alignment on AFortCombatManager");
static_assert(sizeof(AFortCombatManager) == 0x000C00, "Wrong size on AFortCombatManager");
static_assert(offsetof(AFortCombatManager, ReplicatedCombatEventHeat) == 0x000390, "Member 'AFortCombatManager::ReplicatedCombatEventHeat' has a wrong offset!");
static_assert(offsetof(AFortCombatManager, CombatEventHeat) == 0x0003E8, "Member 'AFortCombatManager::CombatEventHeat' has a wrong offset!");
static_assert(offsetof(AFortCombatManager, CombatFactors) == 0x000440, "Member 'AFortCombatManager::CombatFactors' has a wrong offset!");
static_assert(offsetof(AFortCombatManager, CurrentTotalHeat) == 0x000470, "Member 'AFortCombatManager::CurrentTotalHeat' has a wrong offset!");
static_assert(offsetof(AFortCombatManager, MaximumTotalHeat) == 0x000474, "Member 'AFortCombatManager::MaximumTotalHeat' has a wrong offset!");
static_assert(offsetof(AFortCombatManager, MaxHeatEver) == 0x000478, "Member 'AFortCombatManager::MaxHeatEver' has a wrong offset!");
static_assert(offsetof(AFortCombatManager, Events) == 0x000498, "Member 'AFortCombatManager::Events' has a wrong offset!");
static_assert(offsetof(AFortCombatManager, Factors) == 0x0008B8, "Member 'AFortCombatManager::Factors' has a wrong offset!");
static_assert(offsetof(AFortCombatManager, Thresholds) == 0x000B60, "Member 'AFortCombatManager::Thresholds' has a wrong offset!");

// Class FortniteGame.FortControlResistanceSet
// 0x0280 (0x02B0 - 0x0030)
class UFortControlResistanceSet final : public UFortAttributeSet
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortGameplayAttributeData             ControlResistance;                                 // 0x0038(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             MaxControlResistance;                              // 0x0058(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             ControlResistanceRegenRate;                        // 0x0078(0x0020)(BlueprintVisible, Net, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             ControlResistanceRegenDelay;                       // 0x0098(0x0020)(BlueprintVisible, Net, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             ControlResistanceRegenThreshold;                   // 0x00B8(0x0020)(BlueprintVisible, Net, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             KnockbackThreshold;                                // 0x00D8(0x0020)(BlueprintVisible, Net, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             KnockbackMultiplier;                               // 0x00F8(0x0020)(BlueprintVisible, Net, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             ImpactDamageResistance;                            // 0x0118(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             ImpactDamageMultiplier;                            // 0x0138(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             ImpactDamage;                                      // 0x0158(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_178[0x138];                                    // 0x0178(0x0138)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_ControlResistance();
	void OnRep_MaxControlResistance();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortControlResistanceSet">();
	}
	static class UFortControlResistanceSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortControlResistanceSet>();
	}
};
static_assert(alignof(UFortControlResistanceSet) == 0x000008, "Wrong alignment on UFortControlResistanceSet");
static_assert(sizeof(UFortControlResistanceSet) == 0x0002B0, "Wrong size on UFortControlResistanceSet");
static_assert(offsetof(UFortControlResistanceSet, ControlResistance) == 0x000038, "Member 'UFortControlResistanceSet::ControlResistance' has a wrong offset!");
static_assert(offsetof(UFortControlResistanceSet, MaxControlResistance) == 0x000058, "Member 'UFortControlResistanceSet::MaxControlResistance' has a wrong offset!");
static_assert(offsetof(UFortControlResistanceSet, ControlResistanceRegenRate) == 0x000078, "Member 'UFortControlResistanceSet::ControlResistanceRegenRate' has a wrong offset!");
static_assert(offsetof(UFortControlResistanceSet, ControlResistanceRegenDelay) == 0x000098, "Member 'UFortControlResistanceSet::ControlResistanceRegenDelay' has a wrong offset!");
static_assert(offsetof(UFortControlResistanceSet, ControlResistanceRegenThreshold) == 0x0000B8, "Member 'UFortControlResistanceSet::ControlResistanceRegenThreshold' has a wrong offset!");
static_assert(offsetof(UFortControlResistanceSet, KnockbackThreshold) == 0x0000D8, "Member 'UFortControlResistanceSet::KnockbackThreshold' has a wrong offset!");
static_assert(offsetof(UFortControlResistanceSet, KnockbackMultiplier) == 0x0000F8, "Member 'UFortControlResistanceSet::KnockbackMultiplier' has a wrong offset!");
static_assert(offsetof(UFortControlResistanceSet, ImpactDamageResistance) == 0x000118, "Member 'UFortControlResistanceSet::ImpactDamageResistance' has a wrong offset!");
static_assert(offsetof(UFortControlResistanceSet, ImpactDamageMultiplier) == 0x000138, "Member 'UFortControlResistanceSet::ImpactDamageMultiplier' has a wrong offset!");
static_assert(offsetof(UFortControlResistanceSet, ImpactDamage) == 0x000158, "Member 'UFortControlResistanceSet::ImpactDamage' has a wrong offset!");

// Class FortniteGame.FortBuildingActorSet
// 0x0040 (0x0508 - 0x04C8)
#pragma pack(push, 0x1)
class alignas(0x08) UFortBuildingActorSet : public UFortHealthSet
{
public:
	struct FFortGameplayAttributeData             BuildTime;                                         // 0x04C8(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             RepairTime;                                        // 0x04E8(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)

public:
	void OnRep_BuildTime();
	void OnRep_RepairTime();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBuildingActorSet">();
	}
	static class UFortBuildingActorSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBuildingActorSet>();
	}
};
#pragma pack(pop)
static_assert(alignof(UFortBuildingActorSet) == 0x000008, "Wrong alignment on UFortBuildingActorSet");
static_assert(sizeof(UFortBuildingActorSet) == 0x000508, "Wrong size on UFortBuildingActorSet");
static_assert(offsetof(UFortBuildingActorSet, BuildTime) == 0x0004C8, "Member 'UFortBuildingActorSet::BuildTime' has a wrong offset!");
static_assert(offsetof(UFortBuildingActorSet, RepairTime) == 0x0004E8, "Member 'UFortBuildingActorSet::RepairTime' has a wrong offset!");

// Class FortniteGame.FortGameModeOutpost
// 0x0038 (0x0860 - 0x0828)
class AFortGameModeOutpost final : public AFortGameModeZone
{
public:
	TArray<struct FFortItemEntry>                 OwnerItemRefundCache;                              // 0x0828(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FFortOutpostCoreInfo                   CurrentCoreInfo;                                   // 0x0838(0x0020)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_858[0x8];                                      // 0x0858(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameModeOutpost">();
	}
	static class AFortGameModeOutpost* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGameModeOutpost>();
	}
};
static_assert(alignof(AFortGameModeOutpost) == 0x000008, "Wrong alignment on AFortGameModeOutpost");
static_assert(sizeof(AFortGameModeOutpost) == 0x000860, "Wrong size on AFortGameModeOutpost");
static_assert(offsetof(AFortGameModeOutpost, OwnerItemRefundCache) == 0x000828, "Member 'AFortGameModeOutpost::OwnerItemRefundCache' has a wrong offset!");
static_assert(offsetof(AFortGameModeOutpost, CurrentCoreInfo) == 0x000838, "Member 'AFortGameModeOutpost::CurrentCoreInfo' has a wrong offset!");

// Class FortniteGame.FortBuildingTrapSet
// 0x0188 (0x0690 - 0x0508)
class UFortBuildingTrapSet final : public UFortBuildingActorSet
{
public:
	struct FFortGameplayAttributeData             Durability;                                        // 0x0508(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             MaxDurability;                                     // 0x0528(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             DurabilityCostPerFire;                             // 0x0548(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             ArmTime;                                           // 0x0568(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             ReloadTime;                                        // 0x0588(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A8[0xE8];                                     // 0x05A8(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Durability();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBuildingTrapSet">();
	}
	static class UFortBuildingTrapSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBuildingTrapSet>();
	}
};
static_assert(alignof(UFortBuildingTrapSet) == 0x000008, "Wrong alignment on UFortBuildingTrapSet");
static_assert(sizeof(UFortBuildingTrapSet) == 0x000690, "Wrong size on UFortBuildingTrapSet");
static_assert(offsetof(UFortBuildingTrapSet, Durability) == 0x000508, "Member 'UFortBuildingTrapSet::Durability' has a wrong offset!");
static_assert(offsetof(UFortBuildingTrapSet, MaxDurability) == 0x000528, "Member 'UFortBuildingTrapSet::MaxDurability' has a wrong offset!");
static_assert(offsetof(UFortBuildingTrapSet, DurabilityCostPerFire) == 0x000548, "Member 'UFortBuildingTrapSet::DurabilityCostPerFire' has a wrong offset!");
static_assert(offsetof(UFortBuildingTrapSet, ArmTime) == 0x000568, "Member 'UFortBuildingTrapSet::ArmTime' has a wrong offset!");
static_assert(offsetof(UFortBuildingTrapSet, ReloadTime) == 0x000588, "Member 'UFortBuildingTrapSet::ReloadTime' has a wrong offset!");

// Class FortniteGame.FortGadgetItemTooltip
// 0x0000 (0x0090 - 0x0090)
class UFortGadgetItemTooltip final : public UFortWorldItemTooltip
{
public:
	bool GetNumericValue(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, float* OutVal) const;
	bool GetTextForToken(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, class FText* OutText) const;
	bool GetTokenizedDescriptionText(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, TArray<class FText>* OutDescription) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGadgetItemTooltip">();
	}
	static class UFortGadgetItemTooltip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGadgetItemTooltip>();
	}
};
static_assert(alignof(UFortGadgetItemTooltip) == 0x000008, "Wrong alignment on UFortGadgetItemTooltip");
static_assert(sizeof(UFortGadgetItemTooltip) == 0x000090, "Wrong size on UFortGadgetItemTooltip");

// Class FortniteGame.FortHomebaseSet
// 0x0520 (0x0550 - 0x0030)
class UFortHomebaseSet final : public UFortAttributeSet
{
public:
	struct FFortGameplayAttributeData             Keep_Level;                                        // 0x0030(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             Keep_AmmoStash_Level;                              // 0x0050(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             Keep_Armory_Level;                                 // 0x0070(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             Keep_Medical_Level;                                // 0x0090(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             Keep_Storage_Level;                                // 0x00B0(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             Keep_Workshop_Level;                               // 0x00D0(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             Keep_StructureCap;                                 // 0x00F0(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             Keep_PermaniteCap;                                 // 0x0110(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             Manor_Level;                                       // 0x0130(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             Manor_StructureCap;                                // 0x0150(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             InventorySizeBonus;                                // 0x0170(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             WorldInventorySizeBonus;                           // 0x0190(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             StorageInventorySizeBonus;                         // 0x01B0(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             ResearchPointMaxBonus;                             // 0x01D0(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             MaxLevelBonus_Global;                              // 0x01F0(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             MaxLevelBonus_Schematics;                          // 0x0210(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             MaxLevelBonus_Schematics_Ranged;                   // 0x0230(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             MaxLevelBonus_Schematics_Melee;                    // 0x0250(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             MaxLevelBonus_Schematics_Traps;                    // 0x0270(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             MaxLevelBonus_Personnel;                           // 0x0290(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             MaxLevelBonus_Alterations;                         // 0x02B0(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             rate_per_second_collector_Token_collectionresource_nodegatetoken01; // 0x02D0(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             max_capacity_collector_Token_collectionresource_nodegatetoken01; // 0x02F0(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             SupplyDrop_Magnitude;                              // 0x0310(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             SupplyDrop_Level;                                  // 0x0330(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             ExpeditionSquadOne_Power;                          // 0x0350(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             ExpeditionSquadTwo_Power;                          // 0x0370(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             ExpeditionSquadThree_Power;                        // 0x0390(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             ExpeditionSquadFour_Power;                         // 0x03B0(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             ExpeditionSquadFive_Power;                         // 0x03D0(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             ExpeditionSquadSix_Power;                          // 0x03F0(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_410[0x140];                                    // 0x0410(0x0140)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_InventorySizeBonus();
	void OnRep_Keep_AmmoStash_Level();
	void OnRep_Keep_Armory_Level();
	void OnRep_Keep_Level();
	void OnRep_Keep_Medical_Level();
	void OnRep_Keep_PermaniteCap();
	void OnRep_Keep_Storage_Level();
	void OnRep_Keep_StructureCap();
	void OnRep_Keep_Workshop_Level();
	void OnRep_Manor_Level();
	void OnRep_Manor_StructureCap();
	void OnRep_max_capacity_collector_Token_collectionresource_nodegatetoken01();
	void OnRep_MaxLevelBonus_Alterations();
	void OnRep_MaxLevelBonus_Global();
	void OnRep_MaxLevelBonus_Personnel();
	void OnRep_MaxLevelBonus_Schematics();
	void OnRep_MaxLevelBonus_Schematics_Melee();
	void OnRep_MaxLevelBonus_Schematics_Ranged();
	void OnRep_MaxLevelBonus_Schematics_Traps();
	void OnRep_rate_per_second_collector_Token_collectionresource_nodegatetoken01();
	void OnRep_ResearchPointMaxBonus();
	void OnRep_StorageInventorySizeBonus();
	void OnRep_SupplyDrop_Level();
	void OnRep_SupplyDrop_Magnitude();
	void OnRep_WorldInventorySizeBonus();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortHomebaseSet">();
	}
	static class UFortHomebaseSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortHomebaseSet>();
	}
};
static_assert(alignof(UFortHomebaseSet) == 0x000008, "Wrong alignment on UFortHomebaseSet");
static_assert(sizeof(UFortHomebaseSet) == 0x000550, "Wrong size on UFortHomebaseSet");
static_assert(offsetof(UFortHomebaseSet, Keep_Level) == 0x000030, "Member 'UFortHomebaseSet::Keep_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Keep_AmmoStash_Level) == 0x000050, "Member 'UFortHomebaseSet::Keep_AmmoStash_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Keep_Armory_Level) == 0x000070, "Member 'UFortHomebaseSet::Keep_Armory_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Keep_Medical_Level) == 0x000090, "Member 'UFortHomebaseSet::Keep_Medical_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Keep_Storage_Level) == 0x0000B0, "Member 'UFortHomebaseSet::Keep_Storage_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Keep_Workshop_Level) == 0x0000D0, "Member 'UFortHomebaseSet::Keep_Workshop_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Keep_StructureCap) == 0x0000F0, "Member 'UFortHomebaseSet::Keep_StructureCap' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Keep_PermaniteCap) == 0x000110, "Member 'UFortHomebaseSet::Keep_PermaniteCap' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Manor_Level) == 0x000130, "Member 'UFortHomebaseSet::Manor_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Manor_StructureCap) == 0x000150, "Member 'UFortHomebaseSet::Manor_StructureCap' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, InventorySizeBonus) == 0x000170, "Member 'UFortHomebaseSet::InventorySizeBonus' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, WorldInventorySizeBonus) == 0x000190, "Member 'UFortHomebaseSet::WorldInventorySizeBonus' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, StorageInventorySizeBonus) == 0x0001B0, "Member 'UFortHomebaseSet::StorageInventorySizeBonus' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, ResearchPointMaxBonus) == 0x0001D0, "Member 'UFortHomebaseSet::ResearchPointMaxBonus' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, MaxLevelBonus_Global) == 0x0001F0, "Member 'UFortHomebaseSet::MaxLevelBonus_Global' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, MaxLevelBonus_Schematics) == 0x000210, "Member 'UFortHomebaseSet::MaxLevelBonus_Schematics' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, MaxLevelBonus_Schematics_Ranged) == 0x000230, "Member 'UFortHomebaseSet::MaxLevelBonus_Schematics_Ranged' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, MaxLevelBonus_Schematics_Melee) == 0x000250, "Member 'UFortHomebaseSet::MaxLevelBonus_Schematics_Melee' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, MaxLevelBonus_Schematics_Traps) == 0x000270, "Member 'UFortHomebaseSet::MaxLevelBonus_Schematics_Traps' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, MaxLevelBonus_Personnel) == 0x000290, "Member 'UFortHomebaseSet::MaxLevelBonus_Personnel' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, MaxLevelBonus_Alterations) == 0x0002B0, "Member 'UFortHomebaseSet::MaxLevelBonus_Alterations' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, rate_per_second_collector_Token_collectionresource_nodegatetoken01) == 0x0002D0, "Member 'UFortHomebaseSet::rate_per_second_collector_Token_collectionresource_nodegatetoken01' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, max_capacity_collector_Token_collectionresource_nodegatetoken01) == 0x0002F0, "Member 'UFortHomebaseSet::max_capacity_collector_Token_collectionresource_nodegatetoken01' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, SupplyDrop_Magnitude) == 0x000310, "Member 'UFortHomebaseSet::SupplyDrop_Magnitude' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, SupplyDrop_Level) == 0x000330, "Member 'UFortHomebaseSet::SupplyDrop_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, ExpeditionSquadOne_Power) == 0x000350, "Member 'UFortHomebaseSet::ExpeditionSquadOne_Power' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, ExpeditionSquadTwo_Power) == 0x000370, "Member 'UFortHomebaseSet::ExpeditionSquadTwo_Power' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, ExpeditionSquadThree_Power) == 0x000390, "Member 'UFortHomebaseSet::ExpeditionSquadThree_Power' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, ExpeditionSquadFour_Power) == 0x0003B0, "Member 'UFortHomebaseSet::ExpeditionSquadFour_Power' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, ExpeditionSquadFive_Power) == 0x0003D0, "Member 'UFortHomebaseSet::ExpeditionSquadFive_Power' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, ExpeditionSquadSix_Power) == 0x0003F0, "Member 'UFortHomebaseSet::ExpeditionSquadSix_Power' has a wrong offset!");

// Class FortniteGame.FortPlayerAttrSet
// 0x03F0 (0x0420 - 0x0030)
class UFortPlayerAttrSet final : public UFortAttributeSet
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortGameplayAttributeData             Stamina;                                           // 0x0038(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             StaminaRegenRate;                                  // 0x0058(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             StaminaRegenDelay;                                 // 0x0078(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             MaxStamina;                                        // 0x0098(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             StaminaCost;                                       // 0x00B8(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             SprintCost;                                        // 0x00D8(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortGameplayAttributeData             ItemRegenMaxStack;                                 // 0x0100(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             ItemRegenCooldown;                                 // 0x0120(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             ItemMaxStack;                                      // 0x0140(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             DoubleLootRollChance;                              // 0x0160(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             DoubleItemLootChance;                              // 0x0180(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             DoubleCraftChance;                                 // 0x01A0(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             CraftingTimeMultiplier;                            // 0x01C0(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             CraftItemLevelBonusMin;                            // 0x01E0(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             CraftItemLevelBonusMax;                            // 0x0200(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             ResourceHarvesting;                                // 0x0220(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             HarvestingTool;                                    // 0x0240(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             ExtraLives;                                        // 0x0260(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             ResurrectTeammateDuration;                         // 0x0280(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             Fortitude_Team;                                    // 0x02A0(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             Offense_Team;                                      // 0x02C0(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             Tech_Team;                                         // 0x02E0(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             Resistance_Team;                                   // 0x0300(0x0020)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FFortGameplayAttributeData             ActiveEffectDuration;                              // 0x0320(0x0020)(NativeAccessSpecifierPublic)
	uint8                                         Pad_340[0xE0];                                     // 0x0340(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_CraftingTimeMultiplier();
	void OnRep_CraftItemLevelBonusMax();
	void OnRep_CraftItemLevelBonusMin();
	void OnRep_DoubleCraftChance();
	void OnRep_DoubleItemLootChance();
	void OnRep_DoubleLootRollChance();
	void OnRep_ExtraLives();
	void OnRep_Fortitude_Team();
	void OnRep_HarvestingTool();
	void OnRep_ItemMaxStack();
	void OnRep_ItemRegenCooldown();
	void OnRep_ItemRegenMaxStack();
	void OnRep_MaxStamina();
	void OnRep_Offense_Team();
	void OnRep_Resistance_Team();
	void OnRep_ResourceHarvesting();
	void OnRep_ResurrectTeammateDuration();
	void OnRep_SprintCost();
	void OnRep_Stamina();
	void OnRep_StaminaCost();
	void OnRep_StaminaRegenDelay();
	void OnRep_StaminaRegenRate();
	void OnRep_Tech_Team();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerAttrSet">();
	}
	static class UFortPlayerAttrSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPlayerAttrSet>();
	}
};
static_assert(alignof(UFortPlayerAttrSet) == 0x000008, "Wrong alignment on UFortPlayerAttrSet");
static_assert(sizeof(UFortPlayerAttrSet) == 0x000420, "Wrong size on UFortPlayerAttrSet");
static_assert(offsetof(UFortPlayerAttrSet, Stamina) == 0x000038, "Member 'UFortPlayerAttrSet::Stamina' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, StaminaRegenRate) == 0x000058, "Member 'UFortPlayerAttrSet::StaminaRegenRate' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, StaminaRegenDelay) == 0x000078, "Member 'UFortPlayerAttrSet::StaminaRegenDelay' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, MaxStamina) == 0x000098, "Member 'UFortPlayerAttrSet::MaxStamina' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, StaminaCost) == 0x0000B8, "Member 'UFortPlayerAttrSet::StaminaCost' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, SprintCost) == 0x0000D8, "Member 'UFortPlayerAttrSet::SprintCost' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, ItemRegenMaxStack) == 0x000100, "Member 'UFortPlayerAttrSet::ItemRegenMaxStack' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, ItemRegenCooldown) == 0x000120, "Member 'UFortPlayerAttrSet::ItemRegenCooldown' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, ItemMaxStack) == 0x000140, "Member 'UFortPlayerAttrSet::ItemMaxStack' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, DoubleLootRollChance) == 0x000160, "Member 'UFortPlayerAttrSet::DoubleLootRollChance' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, DoubleItemLootChance) == 0x000180, "Member 'UFortPlayerAttrSet::DoubleItemLootChance' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, DoubleCraftChance) == 0x0001A0, "Member 'UFortPlayerAttrSet::DoubleCraftChance' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, CraftingTimeMultiplier) == 0x0001C0, "Member 'UFortPlayerAttrSet::CraftingTimeMultiplier' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, CraftItemLevelBonusMin) == 0x0001E0, "Member 'UFortPlayerAttrSet::CraftItemLevelBonusMin' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, CraftItemLevelBonusMax) == 0x000200, "Member 'UFortPlayerAttrSet::CraftItemLevelBonusMax' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, ResourceHarvesting) == 0x000220, "Member 'UFortPlayerAttrSet::ResourceHarvesting' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, HarvestingTool) == 0x000240, "Member 'UFortPlayerAttrSet::HarvestingTool' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, ExtraLives) == 0x000260, "Member 'UFortPlayerAttrSet::ExtraLives' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, ResurrectTeammateDuration) == 0x000280, "Member 'UFortPlayerAttrSet::ResurrectTeammateDuration' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, Fortitude_Team) == 0x0002A0, "Member 'UFortPlayerAttrSet::Fortitude_Team' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, Offense_Team) == 0x0002C0, "Member 'UFortPlayerAttrSet::Offense_Team' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, Tech_Team) == 0x0002E0, "Member 'UFortPlayerAttrSet::Tech_Team' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, Resistance_Team) == 0x000300, "Member 'UFortPlayerAttrSet::Resistance_Team' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, ActiveEffectDuration) == 0x000320, "Member 'UFortPlayerAttrSet::ActiveEffectDuration' has a wrong offset!");

// Class FortniteGame.FortDecoHelper
// 0x0178 (0x0500 - 0x0388)
class AFortDecoHelper final : public AActor
{
public:
	class AFortDecoPreview*                       DecoPreview;                                       // 0x0388(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ABuildingActor>             PlacementActorClass;                               // 0x0390(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AFortDecoTool>           DecoTool;                                          // 0x0398(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecoToolReach;                                     // 0x03A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecoToolFallbackReach;                             // 0x03A4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBuildingAttachmentType                       CurrentAttachmentType;                             // 0x03A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlacementType                                CurrentPlacementType;                              // 0x03A9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3AA[0x6];                                      // 0x03AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortDecoItemDefinition*                DecoItemDefinition;                                // 0x03B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LocationData[0x2];                                 // 0x03B8(0x000C)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               RelativeRotationData[0x2];                         // 0x03D0(0x000C)(IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               AbsoluteRotationData[0x2];                         // 0x03E8(0x000C)(IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         ScaleData[0x2];                                    // 0x0400(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_408[0x8];                                      // 0x0408(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDecoPlacementState                    PlacementInfo;                                     // 0x0410(0x0080)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bInFallbackPosition;                               // 0x0490(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_491[0x3];                                      // 0x0491(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FallbackTinyScale;                                 // 0x0494(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortDecoPlacementQueryResults                CanPlaceState;                                     // 0x0498(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_499[0x7];                                      // 0x0499(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   CustomPlacementText;                               // 0x04A0(0x0018)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	float                                         DesiredRelativeRotation;                           // 0x04B8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                DirectionChange;                                   // 0x04BC(0x000C)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GridSnapSize;                                      // 0x04C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               FreeFloorPlacementRelativeRotationOffset;          // 0x04CC(0x000C)(IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D8[0x28];                                     // 0x04D8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDecoHelper">();
	}
	static class AFortDecoHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortDecoHelper>();
	}
};
static_assert(alignof(AFortDecoHelper) == 0x000010, "Wrong alignment on AFortDecoHelper");
static_assert(sizeof(AFortDecoHelper) == 0x000500, "Wrong size on AFortDecoHelper");
static_assert(offsetof(AFortDecoHelper, DecoPreview) == 0x000388, "Member 'AFortDecoHelper::DecoPreview' has a wrong offset!");
static_assert(offsetof(AFortDecoHelper, PlacementActorClass) == 0x000390, "Member 'AFortDecoHelper::PlacementActorClass' has a wrong offset!");
static_assert(offsetof(AFortDecoHelper, DecoTool) == 0x000398, "Member 'AFortDecoHelper::DecoTool' has a wrong offset!");
static_assert(offsetof(AFortDecoHelper, DecoToolReach) == 0x0003A0, "Member 'AFortDecoHelper::DecoToolReach' has a wrong offset!");
static_assert(offsetof(AFortDecoHelper, DecoToolFallbackReach) == 0x0003A4, "Member 'AFortDecoHelper::DecoToolFallbackReach' has a wrong offset!");
static_assert(offsetof(AFortDecoHelper, CurrentAttachmentType) == 0x0003A8, "Member 'AFortDecoHelper::CurrentAttachmentType' has a wrong offset!");
static_assert(offsetof(AFortDecoHelper, CurrentPlacementType) == 0x0003A9, "Member 'AFortDecoHelper::CurrentPlacementType' has a wrong offset!");
static_assert(offsetof(AFortDecoHelper, DecoItemDefinition) == 0x0003B0, "Member 'AFortDecoHelper::DecoItemDefinition' has a wrong offset!");
static_assert(offsetof(AFortDecoHelper, LocationData) == 0x0003B8, "Member 'AFortDecoHelper::LocationData' has a wrong offset!");
static_assert(offsetof(AFortDecoHelper, RelativeRotationData) == 0x0003D0, "Member 'AFortDecoHelper::RelativeRotationData' has a wrong offset!");
static_assert(offsetof(AFortDecoHelper, AbsoluteRotationData) == 0x0003E8, "Member 'AFortDecoHelper::AbsoluteRotationData' has a wrong offset!");
static_assert(offsetof(AFortDecoHelper, ScaleData) == 0x000400, "Member 'AFortDecoHelper::ScaleData' has a wrong offset!");
static_assert(offsetof(AFortDecoHelper, PlacementInfo) == 0x000410, "Member 'AFortDecoHelper::PlacementInfo' has a wrong offset!");
static_assert(offsetof(AFortDecoHelper, bInFallbackPosition) == 0x000490, "Member 'AFortDecoHelper::bInFallbackPosition' has a wrong offset!");
static_assert(offsetof(AFortDecoHelper, FallbackTinyScale) == 0x000494, "Member 'AFortDecoHelper::FallbackTinyScale' has a wrong offset!");
static_assert(offsetof(AFortDecoHelper, CanPlaceState) == 0x000498, "Member 'AFortDecoHelper::CanPlaceState' has a wrong offset!");
static_assert(offsetof(AFortDecoHelper, CustomPlacementText) == 0x0004A0, "Member 'AFortDecoHelper::CustomPlacementText' has a wrong offset!");
static_assert(offsetof(AFortDecoHelper, DesiredRelativeRotation) == 0x0004B8, "Member 'AFortDecoHelper::DesiredRelativeRotation' has a wrong offset!");
static_assert(offsetof(AFortDecoHelper, DirectionChange) == 0x0004BC, "Member 'AFortDecoHelper::DirectionChange' has a wrong offset!");
static_assert(offsetof(AFortDecoHelper, GridSnapSize) == 0x0004C8, "Member 'AFortDecoHelper::GridSnapSize' has a wrong offset!");
static_assert(offsetof(AFortDecoHelper, FreeFloorPlacementRelativeRotationOffset) == 0x0004CC, "Member 'AFortDecoHelper::FreeFloorPlacementRelativeRotationOffset' has a wrong offset!");

// Class FortniteGame.FortBannerUtilities
// 0x0000 (0x0028 - 0x0028)
class UFortBannerUtilities final : public UBlueprintFunctionLibrary
{
public:
	static struct FHomebaseBannerColor GetBannerColor(class UFortHomebaseBannerColorItem* BannerColor);
	static class FText GetBannerColorCategoryName(const class FName& CategoryRowName);
	static class FName GetBannerColorCategoryRowName(const class FName& BannerColorRowName);
	static struct FHomebaseBannerColor GetBannerColorFromRowName(const class FName& BannerColorRowName);
	static class UFortHomebaseBannerColorItem* GetBannerColorItemFromRowName(class AFortPlayerController* FortPC, const class FName& BannerColorRowName);
	static struct FLinearColor GetBannerColorPrimaryColor(const class UFortHomebaseBannerColorItem* BannerColor);
	static struct FLinearColor GetBannerColorPrimaryColorFromRowName(const class FName& BannerColorRowName);
	static struct FLinearColor GetBannerColorSecondaryColor(const class UFortHomebaseBannerColorItem* BannerColor);
	static struct FLinearColor GetBannerColorSecondaryColorFromRowName(const class FName& BannerColorRowName);
	static void GetBannerColorsForCategory(class AFortPlayerController* FortPC, const class FName& CategoryRowName, TArray<class UFortAccountItem*>* BannerColors);
	static class FText GetBannerIconCategoryName(const class FName& CategoryRowName);
	static class FName GetBannerIconCategoryRowName(const class FName& BannerIconRowName);
	static class UFortHomebaseBannerIconItem* GetBannerIconItemFromRowName(class AFortPlayerController* FortPC, const class FName& BannerIconRowName);
	static void GetBannerIconsForCategory(class AFortPlayerController* FortPC, const class FName& CategoryRowName, TArray<class UFortAccountItem*>* BannerIcons);
	static TSoftObjectPtr<class UTexture2D> GetBannerLargeIconAsset(class UFortHomebaseBannerIconItem* BannerIcon);
	static TSoftObjectPtr<class UTexture2D> GetBannerLargeIconAssetFromRowName(const class FName& BannerIconRowName);
	static TSoftObjectPtr<class UTexture2D> GetBannerSmallIconAsset(class UFortHomebaseBannerIconItem* BannerIcon);
	static TSoftObjectPtr<class UTexture2D> GetBannerSmallIconAssetFromRowName(const class FName& BannerIconRowName);
	static struct FLinearColor GetPrimaryColor(const struct FHomebaseBannerColor& BannerColor);
	static class FName GetRowNameForBannerColorItem(class UFortHomebaseBannerColorItem* BannerColor);
	static class FName GetRowNameForBannerIconItem(class UFortHomebaseBannerIconItem* BannerIcon);
	static struct FLinearColor GetSecondaryColor(const struct FHomebaseBannerColor& BannerColor);
	static class UTexture2D* LoadAndGetBannerLargeIconFromRowName(const class FName& BannerIconRowName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBannerUtilities">();
	}
	static class UFortBannerUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBannerUtilities>();
	}
};
static_assert(alignof(UFortBannerUtilities) == 0x000008, "Wrong alignment on UFortBannerUtilities");
static_assert(sizeof(UFortBannerUtilities) == 0x000028, "Wrong size on UFortBannerUtilities");

// Class FortniteGame.FortTieredCollectionLayout
// 0x00E0 (0x0108 - 0x0028)
class UFortTieredCollectionLayout final : public UDataAsset
{
public:
	uint8                                         bUseTierAsRandomSeed : 1;                          // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bFiniteTiers : 1;                                  // 0x0028(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxNumberOfTiersAllowed;                           // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InitialTierUnlocked;                               // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTieredNamedCollectionProgressionData  SpawnWaveProgressions;                             // 0x0038(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDifficultyCollectionProgressionData   DifficultyProgressions;                            // 0x0050(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTieredNamedCollectionProgressionData  ModifierProgressions;                              // 0x0068(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FRewardBadgesCollectionProgressionData RewardBadgesProgression;                           // 0x0080(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FCollectionLootSetData                 LootSetProgression;                                // 0x0098(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   CollectionLayoutDisplayName;                       // 0x00B0(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFortTieredCollectionLayout> PrerequisiteLayout;                                // 0x00C8(0x0020)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   TierToMissionPointLookupTable;                     // 0x00E8(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGuid                                  LayoutGUID;                                        // 0x00F8(0x0010)(Edit, EditConst, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class FText GetCollectionLayoutDisplayName() const;
	int32 GetMissionPointsForTier(int32 Tier) const;
	bool ShouldUseTierAsRandomSeed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTieredCollectionLayout">();
	}
	static class UFortTieredCollectionLayout* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortTieredCollectionLayout>();
	}
};
static_assert(alignof(UFortTieredCollectionLayout) == 0x000008, "Wrong alignment on UFortTieredCollectionLayout");
static_assert(sizeof(UFortTieredCollectionLayout) == 0x000108, "Wrong size on UFortTieredCollectionLayout");
static_assert(offsetof(UFortTieredCollectionLayout, MaxNumberOfTiersAllowed) == 0x00002C, "Member 'UFortTieredCollectionLayout::MaxNumberOfTiersAllowed' has a wrong offset!");
static_assert(offsetof(UFortTieredCollectionLayout, InitialTierUnlocked) == 0x000030, "Member 'UFortTieredCollectionLayout::InitialTierUnlocked' has a wrong offset!");
static_assert(offsetof(UFortTieredCollectionLayout, SpawnWaveProgressions) == 0x000038, "Member 'UFortTieredCollectionLayout::SpawnWaveProgressions' has a wrong offset!");
static_assert(offsetof(UFortTieredCollectionLayout, DifficultyProgressions) == 0x000050, "Member 'UFortTieredCollectionLayout::DifficultyProgressions' has a wrong offset!");
static_assert(offsetof(UFortTieredCollectionLayout, ModifierProgressions) == 0x000068, "Member 'UFortTieredCollectionLayout::ModifierProgressions' has a wrong offset!");
static_assert(offsetof(UFortTieredCollectionLayout, RewardBadgesProgression) == 0x000080, "Member 'UFortTieredCollectionLayout::RewardBadgesProgression' has a wrong offset!");
static_assert(offsetof(UFortTieredCollectionLayout, LootSetProgression) == 0x000098, "Member 'UFortTieredCollectionLayout::LootSetProgression' has a wrong offset!");
static_assert(offsetof(UFortTieredCollectionLayout, CollectionLayoutDisplayName) == 0x0000B0, "Member 'UFortTieredCollectionLayout::CollectionLayoutDisplayName' has a wrong offset!");
static_assert(offsetof(UFortTieredCollectionLayout, PrerequisiteLayout) == 0x0000C8, "Member 'UFortTieredCollectionLayout::PrerequisiteLayout' has a wrong offset!");
static_assert(offsetof(UFortTieredCollectionLayout, TierToMissionPointLookupTable) == 0x0000E8, "Member 'UFortTieredCollectionLayout::TierToMissionPointLookupTable' has a wrong offset!");
static_assert(offsetof(UFortTieredCollectionLayout, LayoutGUID) == 0x0000F8, "Member 'UFortTieredCollectionLayout::LayoutGUID' has a wrong offset!");

// Class FortniteGame.FortExpeditionItem
// 0x0068 (0x01A0 - 0x0138)
class UFortExpeditionItem final : public UFortAccountItem
{
public:
	int32                                         expedition_max_target_power;                       // 0x0138(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         expedition_min_target_power;                       // 0x013C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              expedition_start_time;                             // 0x0140(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              expedition_end_time;                               // 0x0148(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              expedition_expiration_start_time;                  // 0x0150(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              expedition_expiration_end_time;                    // 0x0158(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 expedition_squad_id;                               // 0x0160(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 expedition_slot_id;                                // 0x0170(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         expedition_criteria;                               // 0x0180(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         expedition_success_chance;                         // 0x0190(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_194[0xC];                                      // 0x0194(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetBonusCriteriaBP(TArray<struct FFortCriteriaRequirementData>* OutBonusCriteria) const;
	void GetBonusCriteriaTags(TArray<struct FGameplayTag>* OutBonusCriteria) const;
	class FName GetExpeditionSquadId() const;
	float GetExpeditionSuccessChance() const;
	float GetMinTargetPowerLevelToBegin() const;
	struct FTimespan GetRemainingExpeditionDuration(const struct FTimespan& UtcNowOffset) const;
	struct FTimespan GetRemainingExpeditionExpirationDuration(const struct FTimespan& UtcNowOffset) const;
	float GetTargetPowerLevel() const;
	bool HasExpeditionExpired(const struct FTimespan& UtcNowOffset) const;
	bool IsExpeditionCompleted(const struct FTimespan& UtcNowOffset) const;
	bool IsExpeditionInProgress() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortExpeditionItem">();
	}
	static class UFortExpeditionItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortExpeditionItem>();
	}
};
static_assert(alignof(UFortExpeditionItem) == 0x000008, "Wrong alignment on UFortExpeditionItem");
static_assert(sizeof(UFortExpeditionItem) == 0x0001A0, "Wrong size on UFortExpeditionItem");
static_assert(offsetof(UFortExpeditionItem, expedition_max_target_power) == 0x000138, "Member 'UFortExpeditionItem::expedition_max_target_power' has a wrong offset!");
static_assert(offsetof(UFortExpeditionItem, expedition_min_target_power) == 0x00013C, "Member 'UFortExpeditionItem::expedition_min_target_power' has a wrong offset!");
static_assert(offsetof(UFortExpeditionItem, expedition_start_time) == 0x000140, "Member 'UFortExpeditionItem::expedition_start_time' has a wrong offset!");
static_assert(offsetof(UFortExpeditionItem, expedition_end_time) == 0x000148, "Member 'UFortExpeditionItem::expedition_end_time' has a wrong offset!");
static_assert(offsetof(UFortExpeditionItem, expedition_expiration_start_time) == 0x000150, "Member 'UFortExpeditionItem::expedition_expiration_start_time' has a wrong offset!");
static_assert(offsetof(UFortExpeditionItem, expedition_expiration_end_time) == 0x000158, "Member 'UFortExpeditionItem::expedition_expiration_end_time' has a wrong offset!");
static_assert(offsetof(UFortExpeditionItem, expedition_squad_id) == 0x000160, "Member 'UFortExpeditionItem::expedition_squad_id' has a wrong offset!");
static_assert(offsetof(UFortExpeditionItem, expedition_slot_id) == 0x000170, "Member 'UFortExpeditionItem::expedition_slot_id' has a wrong offset!");
static_assert(offsetof(UFortExpeditionItem, expedition_criteria) == 0x000180, "Member 'UFortExpeditionItem::expedition_criteria' has a wrong offset!");
static_assert(offsetof(UFortExpeditionItem, expedition_success_chance) == 0x000190, "Member 'UFortExpeditionItem::expedition_success_chance' has a wrong offset!");

// Class FortniteGame.FortWorldManager
// 0x06D8 (0x0A60 - 0x0388)
class AFortWorldManager final : public AInfo
{
public:
	uint8                                         Pad_388[0x60];                                     // 0x0388(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFortLevelStreamingInfo>        StreamedLevels;                                    // 0x03E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         bSavingEnabled : 1;                                // 0x03F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_3F9[0x3];                                      // 0x03F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        SaveFrequency_Seconds;                             // 0x03FC(0x0004)(ZeroConstructor, Transient, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bStreamInBuildings : 1;                            // 0x0400(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bConstructTileWorld : 1;                           // 0x0400(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bUseSimMaps : 1;                                   // 0x0400(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_401[0x3];                                      // 0x0401(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumNonAutoconstructedTiles;                        // 0x0404(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDataTableRowHandle                    GameDifficultyRowPIEOverride;                      // 0x0408(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortZoneTheme>             ZoneThemeForPIE;                                   // 0x0418(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFortWindIntensityAndDirection         InitialGlobalWind;                                 // 0x0420(0x0008)(Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	EFortWorldManagerState                        WorldManagerState;                                 // 0x0428(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_429[0x7];                                      // 0x0429(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UWorldTileManager*                      TileManager;                                       // 0x0430(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         X_Size;                                            // 0x0438(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         Y_Size;                                            // 0x043C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         Z_StructuralGrid_Size;                             // 0x0440(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         TileEdgeSize;                                      // 0x0444(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWorldTheme*                            Theme;                                             // 0x0448(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   DefaultLootQuotaCategory;                          // 0x0450(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFortTileLootData                      LootData;                                          // 0x0458(0x0318)(NativeAccessSpecifierPrivate)
	int32                                         MaxTiles;                                          // 0x0770(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseFixedSeed;                                     // 0x0774(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_775[0x3];                                      // 0x0775(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FixedSeed;                                         // 0x0778(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_77C[0x4];                                      // 0x077C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FWorldTileSubArray>             Y;                                                 // 0x0780(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   ExplorationActorClass;                             // 0x0790(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         NumExplorationActors;                              // 0x07B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ExplorationActorDistanceRangeMin;                  // 0x07B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ExplorationActorDistanceRangeMax;                  // 0x07B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7BC[0x4];                                      // 0x07BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  ExplorationActorRequiredTags;                      // 0x07C0(0x0020)(Edit, NativeAccessSpecifierPrivate)
	struct FVector                                FriendlyPlayerSpawnExtent;                         // 0x07E0(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                PadPlayerSpawnExtent;                              // 0x07EC(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DangerPlayerSpawnExclusionRadius;                  // 0x07F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ObjectivePlayerSpawnExclusionRadius;               // 0x07FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  OverrideInitialPlayerSpawnTags;                    // 0x0800(0x0020)(Edit, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  OverrideBackupPlayerSpawnTags;                     // 0x0820(0x0020)(Edit, NativeAccessSpecifierPrivate)
	struct FFortStartingMissionInfo               StartingMissionInfo;                               // 0x0840(0x0018)(Edit, NativeAccessSpecifierPrivate)
	class UFortWorldRecord*                       CurrentWorldRecord;                                // 0x0858(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortZoneRecord*                        CurrentZoneRecord;                                 // 0x0860(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_868[0x20];                                     // 0x0868(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortUserCloudHelperComponent*          CloudHelper;                                       // 0x0888(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CurrentZoneIndex;                                  // 0x0890(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasCreatedMissions;                               // 0x0894(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasCreatedPrimaryAdditionalFoundations;           // 0x0895(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasSpawnedActorsForMissions;                      // 0x0896(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bZoneCompleted;                                    // 0x0897(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bZoneFinished;                                     // 0x0898(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCreatedMissionRecord;                             // 0x0899(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_89A[0x6];                                      // 0x089A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortMissionManagerRecord              MissionManagerRecord;                              // 0x08A0(0x0038)(Transient, NativeAccessSpecifierPrivate)
	TArray<struct FFortMissionEntry>              ReactiveMissionsToAdd;                             // 0x08D8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FFortDeferredNewActorData>      DeferredActors;                                    // 0x08E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8F8[0x140];                                    // 0x08F8(0x0140)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         SpawnedExplorationActors;                          // 0x0A38(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	int32                                         FinalNumChosenBuildingFoundations;                 // 0x0A48(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4C[0x4];                                      // 0x0A4C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ABuildingFoundation*>            ChosenBuildingFoundations;                         // 0x0A50(0x0010)(Net, ZeroConstructor, Transient, NativeAccessSpecifierPublic)

public:
	void OnRep_InitialGlobalWind();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortWorldManager">();
	}
	static class AFortWorldManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortWorldManager>();
	}
};
static_assert(alignof(AFortWorldManager) == 0x000008, "Wrong alignment on AFortWorldManager");
static_assert(sizeof(AFortWorldManager) == 0x000A60, "Wrong size on AFortWorldManager");
static_assert(offsetof(AFortWorldManager, StreamedLevels) == 0x0003E8, "Member 'AFortWorldManager::StreamedLevels' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, SaveFrequency_Seconds) == 0x0003FC, "Member 'AFortWorldManager::SaveFrequency_Seconds' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, NumNonAutoconstructedTiles) == 0x000404, "Member 'AFortWorldManager::NumNonAutoconstructedTiles' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, GameDifficultyRowPIEOverride) == 0x000408, "Member 'AFortWorldManager::GameDifficultyRowPIEOverride' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, ZoneThemeForPIE) == 0x000418, "Member 'AFortWorldManager::ZoneThemeForPIE' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, InitialGlobalWind) == 0x000420, "Member 'AFortWorldManager::InitialGlobalWind' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, WorldManagerState) == 0x000428, "Member 'AFortWorldManager::WorldManagerState' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, TileManager) == 0x000430, "Member 'AFortWorldManager::TileManager' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, X_Size) == 0x000438, "Member 'AFortWorldManager::X_Size' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, Y_Size) == 0x00043C, "Member 'AFortWorldManager::Y_Size' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, Z_StructuralGrid_Size) == 0x000440, "Member 'AFortWorldManager::Z_StructuralGrid_Size' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, TileEdgeSize) == 0x000444, "Member 'AFortWorldManager::TileEdgeSize' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, Theme) == 0x000448, "Member 'AFortWorldManager::Theme' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, DefaultLootQuotaCategory) == 0x000450, "Member 'AFortWorldManager::DefaultLootQuotaCategory' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, LootData) == 0x000458, "Member 'AFortWorldManager::LootData' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, MaxTiles) == 0x000770, "Member 'AFortWorldManager::MaxTiles' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, bUseFixedSeed) == 0x000774, "Member 'AFortWorldManager::bUseFixedSeed' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, FixedSeed) == 0x000778, "Member 'AFortWorldManager::FixedSeed' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, Y) == 0x000780, "Member 'AFortWorldManager::Y' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, ExplorationActorClass) == 0x000790, "Member 'AFortWorldManager::ExplorationActorClass' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, NumExplorationActors) == 0x0007B0, "Member 'AFortWorldManager::NumExplorationActors' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, ExplorationActorDistanceRangeMin) == 0x0007B4, "Member 'AFortWorldManager::ExplorationActorDistanceRangeMin' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, ExplorationActorDistanceRangeMax) == 0x0007B8, "Member 'AFortWorldManager::ExplorationActorDistanceRangeMax' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, ExplorationActorRequiredTags) == 0x0007C0, "Member 'AFortWorldManager::ExplorationActorRequiredTags' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, FriendlyPlayerSpawnExtent) == 0x0007E0, "Member 'AFortWorldManager::FriendlyPlayerSpawnExtent' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, PadPlayerSpawnExtent) == 0x0007EC, "Member 'AFortWorldManager::PadPlayerSpawnExtent' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, DangerPlayerSpawnExclusionRadius) == 0x0007F8, "Member 'AFortWorldManager::DangerPlayerSpawnExclusionRadius' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, ObjectivePlayerSpawnExclusionRadius) == 0x0007FC, "Member 'AFortWorldManager::ObjectivePlayerSpawnExclusionRadius' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, OverrideInitialPlayerSpawnTags) == 0x000800, "Member 'AFortWorldManager::OverrideInitialPlayerSpawnTags' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, OverrideBackupPlayerSpawnTags) == 0x000820, "Member 'AFortWorldManager::OverrideBackupPlayerSpawnTags' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, StartingMissionInfo) == 0x000840, "Member 'AFortWorldManager::StartingMissionInfo' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, CurrentWorldRecord) == 0x000858, "Member 'AFortWorldManager::CurrentWorldRecord' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, CurrentZoneRecord) == 0x000860, "Member 'AFortWorldManager::CurrentZoneRecord' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, CloudHelper) == 0x000888, "Member 'AFortWorldManager::CloudHelper' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, CurrentZoneIndex) == 0x000890, "Member 'AFortWorldManager::CurrentZoneIndex' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, bHasCreatedMissions) == 0x000894, "Member 'AFortWorldManager::bHasCreatedMissions' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, bHasCreatedPrimaryAdditionalFoundations) == 0x000895, "Member 'AFortWorldManager::bHasCreatedPrimaryAdditionalFoundations' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, bHasSpawnedActorsForMissions) == 0x000896, "Member 'AFortWorldManager::bHasSpawnedActorsForMissions' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, bZoneCompleted) == 0x000897, "Member 'AFortWorldManager::bZoneCompleted' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, bZoneFinished) == 0x000898, "Member 'AFortWorldManager::bZoneFinished' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, bCreatedMissionRecord) == 0x000899, "Member 'AFortWorldManager::bCreatedMissionRecord' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, MissionManagerRecord) == 0x0008A0, "Member 'AFortWorldManager::MissionManagerRecord' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, ReactiveMissionsToAdd) == 0x0008D8, "Member 'AFortWorldManager::ReactiveMissionsToAdd' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, DeferredActors) == 0x0008E8, "Member 'AFortWorldManager::DeferredActors' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, SpawnedExplorationActors) == 0x000A38, "Member 'AFortWorldManager::SpawnedExplorationActors' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, FinalNumChosenBuildingFoundations) == 0x000A48, "Member 'AFortWorldManager::FinalNumChosenBuildingFoundations' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, ChosenBuildingFoundations) == 0x000A50, "Member 'AFortWorldManager::ChosenBuildingFoundations' has a wrong offset!");

// Class FortniteGame.FortOnboardingAnalytics
// 0x0000 (0x0028 - 0x0028)
class UFortOnboardingAnalytics final : public UBlueprintFunctionLibrary
{
public:
	static void FireAnalyticsEvent_CinematicSkipped(const class UObject* SourceBp, const class FString& CinematicName);
	static void FireAnalyticsEvent_MineCartDestroyed(const class UObject* SourceBp);
	static void FireAnalyticsEvent_TutorialCanceled(const class UObject* SourceBp);
	static void FireAnalyticsEvent_TutorialCompleted(const class UObject* SourceBp, bool WasSuccessful);
	static void FireAnalyticsEvent_TutorialStartupFailed(const class UObject* SourceBp, const int32 MatchmakingResult);
	static void FireAnalyticsEvent_VinderTipPlayed(const class UObject* SourceBp, const class FString& VinderTipTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortOnboardingAnalytics">();
	}
	static class UFortOnboardingAnalytics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortOnboardingAnalytics>();
	}
};
static_assert(alignof(UFortOnboardingAnalytics) == 0x000008, "Wrong alignment on UFortOnboardingAnalytics");
static_assert(sizeof(UFortOnboardingAnalytics) == 0x000028, "Wrong size on UFortOnboardingAnalytics");

// Class FortniteGame.FortDeployableBaseAnalytics
// 0x0000 (0x0028 - 0x0028)
class UFortDeployableBaseAnalytics final : public UBlueprintFunctionLibrary
{
public:
	static void FireAnalyticsEvent_CombatZone_ConsoleOpened(class AFortPlayerController* FortPC);
	static void FireAnalyticsEvent_CombatZone_TierCompleted(class AFortPlayerController* FortPC, int32 Tier, int32 FinalWave, int32 NumberOfPlayers, const TArray<class ADeployableBaseCore*>& TargetCores, const TArray<class ADeployableBaseCore*>& AllCores, const struct FFortTierCollectionLayoutOutput& CollectionData);
	static void FireAnalyticsEvent_CombatZone_TierFailed(class AFortPlayerController* FortPC, int32 Tier, int32 Wave, int32 NumberOfPlayers, const struct FFortTierCollectionLayoutOutput& CollectionData);
	static void FireAnalyticsEvent_CombatZone_TierStarted(class AFortPlayerController* FortPC, int32 Tier, int32 NumberOfPlayers, const struct FFortTierCollectionLayoutOutput& CollectionData);
	static void FireAnalyticsEvent_CombatZone_WaveFailed(class AFortPlayerController* FortPC, int32 Tier, int32 Wave, int32 NumberOfPlayers, const TArray<class ADeployableBaseCore*>& TargetCores, const TArray<class ADeployableBaseCore*>& AllCores, const struct FFortTierCollectionLayoutOutput& CollectionData);
	static void FireAnalyticsEvent_CombatZone_WaveStarted(class AFortPlayerController* FortPC, int32 Tier, int32 Wave, int32 NumberOfPlayers, const TArray<class ADeployableBaseCore*>& TargetCores, const TArray<class ADeployableBaseCore*>& AllCores, const struct FFortTierCollectionLayoutOutput& CollectionData);
	static void FireAnalyticsEvent_Neighborhood_ConsoleOpened(class AFortPlayerController* FortPC, const struct FUniqueNetIdRepl& OwnerId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDeployableBaseAnalytics">();
	}
	static class UFortDeployableBaseAnalytics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDeployableBaseAnalytics>();
	}
};
static_assert(alignof(UFortDeployableBaseAnalytics) == 0x000008, "Wrong alignment on UFortDeployableBaseAnalytics");
static_assert(sizeof(UFortDeployableBaseAnalytics) == 0x000028, "Wrong size on UFortDeployableBaseAnalytics");

// Class FortniteGame.FortCollectionBookAnalytics
// 0x0000 (0x0028 - 0x0028)
class UFortCollectionBookAnalytics final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCollectionBookAnalytics">();
	}
	static class UFortCollectionBookAnalytics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCollectionBookAnalytics>();
	}
};
static_assert(alignof(UFortCollectionBookAnalytics) == 0x000008, "Wrong alignment on UFortCollectionBookAnalytics");
static_assert(sizeof(UFortCollectionBookAnalytics) == 0x000028, "Wrong size on UFortCollectionBookAnalytics");

// Class FortniteGame.FortSurvivorAnalytics
// 0x0000 (0x0028 - 0x0028)
class UFortSurvivorAnalytics final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortSurvivorAnalytics">();
	}
	static class UFortSurvivorAnalytics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortSurvivorAnalytics>();
	}
};
static_assert(alignof(UFortSurvivorAnalytics) == 0x000008, "Wrong alignment on UFortSurvivorAnalytics");
static_assert(sizeof(UFortSurvivorAnalytics) == 0x000028, "Wrong size on UFortSurvivorAnalytics");

// Class FortniteGame.FortTwitchAnalytics
// 0x0000 (0x0028 - 0x0028)
class UFortTwitchAnalytics final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTwitchAnalytics">();
	}
	static class UFortTwitchAnalytics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortTwitchAnalytics>();
	}
};
static_assert(alignof(UFortTwitchAnalytics) == 0x000008, "Wrong alignment on UFortTwitchAnalytics");
static_assert(sizeof(UFortTwitchAnalytics) == 0x000028, "Wrong size on UFortTwitchAnalytics");

// Class FortniteGame.FortDifficultyOptionCategoryEncounter_Distance
// 0x0010 (0x0040 - 0x0030)
class UFortDifficultyOptionCategoryEncounter_Distance final : public UFortDifficultyOptionCategoryEncounter
{
public:
	TArray<TSubclassOf<class UFortDifficultyOptionEncounter_Distance>> Options;                                           // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionCategoryEncounter_Distance">();
	}
	static class UFortDifficultyOptionCategoryEncounter_Distance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionCategoryEncounter_Distance>();
	}
};
static_assert(alignof(UFortDifficultyOptionCategoryEncounter_Distance) == 0x000008, "Wrong alignment on UFortDifficultyOptionCategoryEncounter_Distance");
static_assert(sizeof(UFortDifficultyOptionCategoryEncounter_Distance) == 0x000040, "Wrong size on UFortDifficultyOptionCategoryEncounter_Distance");
static_assert(offsetof(UFortDifficultyOptionCategoryEncounter_Distance, Options) == 0x000030, "Member 'UFortDifficultyOptionCategoryEncounter_Distance::Options' has a wrong offset!");

// Class FortniteGame.FortBotStructureBuilder
// 0x0038 (0x03C0 - 0x0388)
class AFortBotStructureBuilder final : public AActor
{
public:
	class UFortBuildingInstructions*              BuildingInstructions;                              // 0x0388(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ABuildingActor*>                 BuiltActors;                                       // 0x0390(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class AActor*                                 CachedGoal;                                        // 0x03A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A8[0x18];                                     // 0x03A8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BuildAll();
	void OnBuildingDied(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, class AActor* DamageCauser, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& Momentum);
	void RunDeconstructor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBotStructureBuilder">();
	}
	static class AFortBotStructureBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortBotStructureBuilder>();
	}
};
static_assert(alignof(AFortBotStructureBuilder) == 0x000008, "Wrong alignment on AFortBotStructureBuilder");
static_assert(sizeof(AFortBotStructureBuilder) == 0x0003C0, "Wrong size on AFortBotStructureBuilder");
static_assert(offsetof(AFortBotStructureBuilder, BuildingInstructions) == 0x000388, "Member 'AFortBotStructureBuilder::BuildingInstructions' has a wrong offset!");
static_assert(offsetof(AFortBotStructureBuilder, BuiltActors) == 0x000390, "Member 'AFortBotStructureBuilder::BuiltActors' has a wrong offset!");
static_assert(offsetof(AFortBotStructureBuilder, CachedGoal) == 0x0003A0, "Member 'AFortBotStructureBuilder::CachedGoal' has a wrong offset!");

// Class FortniteGame.FortBTDecorator_GameplayAbility_HasGameplayAbility
// 0x0020 (0x0088 - 0x0068)
class UFortBTDecorator_GameplayAbility_HasGameplayAbility final : public UBTDecorator
{
public:
	struct FGameplayTagContainer                  GameplayAbilityTag;                                // 0x0068(0x0020)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTDecorator_GameplayAbility_HasGameplayAbility">();
	}
	static class UFortBTDecorator_GameplayAbility_HasGameplayAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTDecorator_GameplayAbility_HasGameplayAbility>();
	}
};
static_assert(alignof(UFortBTDecorator_GameplayAbility_HasGameplayAbility) == 0x000008, "Wrong alignment on UFortBTDecorator_GameplayAbility_HasGameplayAbility");
static_assert(sizeof(UFortBTDecorator_GameplayAbility_HasGameplayAbility) == 0x000088, "Wrong size on UFortBTDecorator_GameplayAbility_HasGameplayAbility");
static_assert(offsetof(UFortBTDecorator_GameplayAbility_HasGameplayAbility, GameplayAbilityTag) == 0x000068, "Member 'UFortBTDecorator_GameplayAbility_HasGameplayAbility::GameplayAbilityTag' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionCategoryEncounter_SpawnPointsCurve
// 0x0010 (0x0040 - 0x0030)
class UFortDifficultyOptionCategoryEncounter_SpawnPointsCurve final : public UFortDifficultyOptionCategoryEncounter
{
public:
	TArray<TSubclassOf<class UFortDifficultyOptionEncounter_SpawnPointsCurve>> Options;                                           // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionCategoryEncounter_SpawnPointsCurve">();
	}
	static class UFortDifficultyOptionCategoryEncounter_SpawnPointsCurve* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionCategoryEncounter_SpawnPointsCurve>();
	}
};
static_assert(alignof(UFortDifficultyOptionCategoryEncounter_SpawnPointsCurve) == 0x000008, "Wrong alignment on UFortDifficultyOptionCategoryEncounter_SpawnPointsCurve");
static_assert(sizeof(UFortDifficultyOptionCategoryEncounter_SpawnPointsCurve) == 0x000040, "Wrong size on UFortDifficultyOptionCategoryEncounter_SpawnPointsCurve");
static_assert(offsetof(UFortDifficultyOptionCategoryEncounter_SpawnPointsCurve, Options) == 0x000030, "Member 'UFortDifficultyOptionCategoryEncounter_SpawnPointsCurve::Options' has a wrong offset!");

// Class FortniteGame.FortBTDecorator_IsGoalPawn
// 0x0000 (0x0090 - 0x0090)
class UFortBTDecorator_IsGoalPawn final : public UBTDecorator_BlackboardBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTDecorator_IsGoalPawn">();
	}
	static class UFortBTDecorator_IsGoalPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTDecorator_IsGoalPawn>();
	}
};
static_assert(alignof(UFortBTDecorator_IsGoalPawn) == 0x000008, "Wrong alignment on UFortBTDecorator_IsGoalPawn");
static_assert(sizeof(UFortBTDecorator_IsGoalPawn) == 0x000090, "Wrong size on UFortBTDecorator_IsGoalPawn");

// Class FortniteGame.FortCollectionBookPage
// 0x0048 (0x0070 - 0x0028)
class UFortCollectionBookPage final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TemplateId;                                        // 0x0030(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 InstanceId;                                        // 0x0040(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   PageRowName;                                       // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EFortCollectionBookState                      State;                                             // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFortCollectionBookSectionState> SectionStates;                                     // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	EFortCollectionBookState GetPageState() const;
	EFortCollectionBookState GetSectionState(class FName SectionId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCollectionBookPage">();
	}
	static class UFortCollectionBookPage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCollectionBookPage>();
	}
};
static_assert(alignof(UFortCollectionBookPage) == 0x000008, "Wrong alignment on UFortCollectionBookPage");
static_assert(sizeof(UFortCollectionBookPage) == 0x000070, "Wrong size on UFortCollectionBookPage");
static_assert(offsetof(UFortCollectionBookPage, TemplateId) == 0x000030, "Member 'UFortCollectionBookPage::TemplateId' has a wrong offset!");
static_assert(offsetof(UFortCollectionBookPage, InstanceId) == 0x000040, "Member 'UFortCollectionBookPage::InstanceId' has a wrong offset!");
static_assert(offsetof(UFortCollectionBookPage, PageRowName) == 0x000050, "Member 'UFortCollectionBookPage::PageRowName' has a wrong offset!");
static_assert(offsetof(UFortCollectionBookPage, State) == 0x000058, "Member 'UFortCollectionBookPage::State' has a wrong offset!");
static_assert(offsetof(UFortCollectionBookPage, SectionStates) == 0x000060, "Member 'UFortCollectionBookPage::SectionStates' has a wrong offset!");

// Class FortniteGame.FortBTDecorator_GameplayAbility_CanHitTarget
// 0x0008 (0x00E0 - 0x00D8)
class UFortBTDecorator_GameplayAbility_CanHitTarget final : public UFortBTDecorator_QueryGameplayAbility
{
public:
	uint8                                         UseIdealYawRotationToTarget : 1;                   // 0x00D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTDecorator_GameplayAbility_CanHitTarget">();
	}
	static class UFortBTDecorator_GameplayAbility_CanHitTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTDecorator_GameplayAbility_CanHitTarget>();
	}
};
static_assert(alignof(UFortBTDecorator_GameplayAbility_CanHitTarget) == 0x000008, "Wrong alignment on UFortBTDecorator_GameplayAbility_CanHitTarget");
static_assert(sizeof(UFortBTDecorator_GameplayAbility_CanHitTarget) == 0x0000E0, "Wrong size on UFortBTDecorator_GameplayAbility_CanHitTarget");

// Class FortniteGame.FortBTDecorator_GameplayAbility_DoesTargetHaveProhibitedTags
// 0x0000 (0x00D8 - 0x00D8)
class UFortBTDecorator_GameplayAbility_DoesTargetHaveProhibitedTags final : public UFortBTDecorator_QueryGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTDecorator_GameplayAbility_DoesTargetHaveProhibitedTags">();
	}
	static class UFortBTDecorator_GameplayAbility_DoesTargetHaveProhibitedTags* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTDecorator_GameplayAbility_DoesTargetHaveProhibitedTags>();
	}
};
static_assert(alignof(UFortBTDecorator_GameplayAbility_DoesTargetHaveProhibitedTags) == 0x000008, "Wrong alignment on UFortBTDecorator_GameplayAbility_DoesTargetHaveProhibitedTags");
static_assert(sizeof(UFortBTDecorator_GameplayAbility_DoesTargetHaveProhibitedTags) == 0x0000D8, "Wrong size on UFortBTDecorator_GameplayAbility_DoesTargetHaveProhibitedTags");

// Class FortniteGame.FortBTDecorator_GameplayAbility_IsRotatedToAttackTarget
// 0x0000 (0x00D8 - 0x00D8)
class UFortBTDecorator_GameplayAbility_IsRotatedToAttackTarget final : public UFortBTDecorator_QueryGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTDecorator_GameplayAbility_IsRotatedToAttackTarget">();
	}
	static class UFortBTDecorator_GameplayAbility_IsRotatedToAttackTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTDecorator_GameplayAbility_IsRotatedToAttackTarget>();
	}
};
static_assert(alignof(UFortBTDecorator_GameplayAbility_IsRotatedToAttackTarget) == 0x000008, "Wrong alignment on UFortBTDecorator_GameplayAbility_IsRotatedToAttackTarget");
static_assert(sizeof(UFortBTDecorator_GameplayAbility_IsRotatedToAttackTarget) == 0x0000D8, "Wrong size on UFortBTDecorator_GameplayAbility_IsRotatedToAttackTarget");

// Class FortniteGame.FortCrowdManager
// 0x0008 (0x00F8 - 0x00F0)
class UFortCrowdManager final : public UCrowdManager
{
public:
	uint8                                         Pad_F0[0x8];                                       // 0x00F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCrowdManager">();
	}
	static class UFortCrowdManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCrowdManager>();
	}
};
static_assert(alignof(UFortCrowdManager) == 0x000008, "Wrong alignment on UFortCrowdManager");
static_assert(sizeof(UFortCrowdManager) == 0x0000F8, "Wrong size on UFortCrowdManager");

// Class FortniteGame.FortBTDecorator_WeaponStatus
// 0x0030 (0x0098 - 0x0068)
class UFortBTDecorator_WeaponStatus final : public UBTDecorator
{
public:
	float                                         WeaponStatusUpdateRate;                            // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bTestIfCurrentWeaponIsValid : 1;                   // 0x006C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCurrentWeaponShouldBeValid : 1;                   // 0x006C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bTestAllowedCurrentWeaponTags : 1;                 // 0x006C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  AllowedCurrentWeaponTags;                          // 0x0070(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         bTestIfCurrentWeaponIsReloading : 1;               // 0x0090(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCurrentWeaponShouldBeReloading : 1;               // 0x0090(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bTestIfCurrentWeaponHasAmmoInMagazine : 1;         // 0x0090(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCurrentWeaponShouldHaveAmmoInMagazine : 1;        // 0x0090(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bTestIfCurrentWeaponHasExtraAmmo : 1;              // 0x0090(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCurrentWeaponShouldHaveExtraAmmo : 1;             // 0x0090(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAllInterestedTestsMustPass : 1;                   // 0x0090(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTDecorator_WeaponStatus">();
	}
	static class UFortBTDecorator_WeaponStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTDecorator_WeaponStatus>();
	}
};
static_assert(alignof(UFortBTDecorator_WeaponStatus) == 0x000008, "Wrong alignment on UFortBTDecorator_WeaponStatus");
static_assert(sizeof(UFortBTDecorator_WeaponStatus) == 0x000098, "Wrong size on UFortBTDecorator_WeaponStatus");
static_assert(offsetof(UFortBTDecorator_WeaponStatus, WeaponStatusUpdateRate) == 0x000068, "Member 'UFortBTDecorator_WeaponStatus::WeaponStatusUpdateRate' has a wrong offset!");
static_assert(offsetof(UFortBTDecorator_WeaponStatus, AllowedCurrentWeaponTags) == 0x000070, "Member 'UFortBTDecorator_WeaponStatus::AllowedCurrentWeaponTags' has a wrong offset!");

// Class FortniteGame.FortDecoPreview_ComponentHarvester
// 0x0000 (0x0530 - 0x0530)
class AFortDecoPreview_ComponentHarvester : public AFortDecoPreview
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDecoPreview_ComponentHarvester">();
	}
	static class AFortDecoPreview_ComponentHarvester* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortDecoPreview_ComponentHarvester>();
	}
};
static_assert(alignof(AFortDecoPreview_ComponentHarvester) == 0x000010, "Wrong alignment on AFortDecoPreview_ComponentHarvester");
static_assert(sizeof(AFortDecoPreview_ComponentHarvester) == 0x000530, "Wrong size on AFortDecoPreview_ComponentHarvester");

// Class FortniteGame.FortBTContext_SkipNotPerceivedGoals
// 0x0000 (0x0070 - 0x0070)
class UFortBTContext_SkipNotPerceivedGoals final : public UFortBTService_ContextOverride
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTContext_SkipNotPerceivedGoals">();
	}
	static class UFortBTContext_SkipNotPerceivedGoals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTContext_SkipNotPerceivedGoals>();
	}
};
static_assert(alignof(UFortBTContext_SkipNotPerceivedGoals) == 0x000008, "Wrong alignment on UFortBTContext_SkipNotPerceivedGoals");
static_assert(sizeof(UFortBTContext_SkipNotPerceivedGoals) == 0x000070, "Wrong size on UFortBTContext_SkipNotPerceivedGoals");

// Class FortniteGame.FortBTService_UpdateBotMissionBuilding
// 0x0050 (0x00C0 - 0x0070)
class UFortBTService_UpdateBotMissionBuilding final : public UBTService
{
public:
	struct FBlackboardKeySelector                 InterestLocationKey;                               // 0x0070(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BuildOrderKey;                                     // 0x0098(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTService_UpdateBotMissionBuilding">();
	}
	static class UFortBTService_UpdateBotMissionBuilding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTService_UpdateBotMissionBuilding>();
	}
};
static_assert(alignof(UFortBTService_UpdateBotMissionBuilding) == 0x000008, "Wrong alignment on UFortBTService_UpdateBotMissionBuilding");
static_assert(sizeof(UFortBTService_UpdateBotMissionBuilding) == 0x0000C0, "Wrong size on UFortBTService_UpdateBotMissionBuilding");
static_assert(offsetof(UFortBTService_UpdateBotMissionBuilding, InterestLocationKey) == 0x000070, "Member 'UFortBTService_UpdateBotMissionBuilding::InterestLocationKey' has a wrong offset!");
static_assert(offsetof(UFortBTService_UpdateBotMissionBuilding, BuildOrderKey) == 0x000098, "Member 'UFortBTService_UpdateBotMissionBuilding::BuildOrderKey' has a wrong offset!");

// Class FortniteGame.FortBTService_UpdateBotMissionGoal
// 0x0008 (0x00A0 - 0x0098)
class UFortBTService_UpdateBotMissionGoal final : public UBTService_BlackboardBase
{
public:
	uint8                                         bRequireInteraction : 1;                           // 0x0098(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRequireInteractionOrLocator : 1;                  // 0x0098(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRequireEncounter : 1;                             // 0x0098(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPickClosest : 1;                                  // 0x0098(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTService_UpdateBotMissionGoal">();
	}
	static class UFortBTService_UpdateBotMissionGoal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTService_UpdateBotMissionGoal>();
	}
};
static_assert(alignof(UFortBTService_UpdateBotMissionGoal) == 0x000008, "Wrong alignment on UFortBTService_UpdateBotMissionGoal");
static_assert(sizeof(UFortBTService_UpdateBotMissionGoal) == 0x0000A0, "Wrong size on UFortBTService_UpdateBotMissionGoal");

// Class FortniteGame.FortBTTask_BotMissionInteract
// 0x0000 (0x0098 - 0x0098)
class UFortBTTask_BotMissionInteract final : public UBTTask_BlackboardBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTTask_BotMissionInteract">();
	}
	static class UFortBTTask_BotMissionInteract* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTTask_BotMissionInteract>();
	}
};
static_assert(alignof(UFortBTTask_BotMissionInteract) == 0x000008, "Wrong alignment on UFortBTTask_BotMissionInteract");
static_assert(sizeof(UFortBTTask_BotMissionInteract) == 0x000098, "Wrong size on UFortBTTask_BotMissionInteract");

// Class FortniteGame.FortBTTask_ExecuteGameplayAbility
// 0x0020 (0x0098 - 0x0078)
class UFortBTTask_ExecuteGameplayAbility final : public UBTTask_GameplayTaskBase
{
public:
	struct FGameplayTagContainer                  GameplayAbilityTag;                                // 0x0078(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTTask_ExecuteGameplayAbility">();
	}
	static class UFortBTTask_ExecuteGameplayAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTTask_ExecuteGameplayAbility>();
	}
};
static_assert(alignof(UFortBTTask_ExecuteGameplayAbility) == 0x000008, "Wrong alignment on UFortBTTask_ExecuteGameplayAbility");
static_assert(sizeof(UFortBTTask_ExecuteGameplayAbility) == 0x000098, "Wrong size on UFortBTTask_ExecuteGameplayAbility");
static_assert(offsetof(UFortBTTask_ExecuteGameplayAbility, GameplayAbilityTag) == 0x000078, "Member 'UFortBTTask_ExecuteGameplayAbility::GameplayAbilityTag' has a wrong offset!");

// Class FortniteGame.FortBTTask_RequestUndermining
// 0x0000 (0x0070 - 0x0070)
class UFortBTTask_RequestUndermining final : public UBTTaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTTask_RequestUndermining">();
	}
	static class UFortBTTask_RequestUndermining* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTTask_RequestUndermining>();
	}
};
static_assert(alignof(UFortBTTask_RequestUndermining) == 0x000008, "Wrong alignment on UFortBTTask_RequestUndermining");
static_assert(sizeof(UFortBTTask_RequestUndermining) == 0x000070, "Wrong size on UFortBTTask_RequestUndermining");

// Class FortniteGame.FortBTTask_Sleep
// 0x0000 (0x0070 - 0x0070)
class UFortBTTask_Sleep final : public UBTTaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTTask_Sleep">();
	}
	static class UFortBTTask_Sleep* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTTask_Sleep>();
	}
};
static_assert(alignof(UFortBTTask_Sleep) == 0x000008, "Wrong alignment on UFortBTTask_Sleep");
static_assert(sizeof(UFortBTTask_Sleep) == 0x000070, "Wrong size on UFortBTTask_Sleep");

// Class FortniteGame.FortBTTask_TakerMoveToNavmesh
// 0x0000 (0x00B0 - 0x00B0)
class UFortBTTask_TakerMoveToNavmesh final : public UBTTask_MoveTo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTTask_TakerMoveToNavmesh">();
	}
	static class UFortBTTask_TakerMoveToNavmesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTTask_TakerMoveToNavmesh>();
	}
};
static_assert(alignof(UFortBTTask_TakerMoveToNavmesh) == 0x000008, "Wrong alignment on UFortBTTask_TakerMoveToNavmesh");
static_assert(sizeof(UFortBTTask_TakerMoveToNavmesh) == 0x0000B0, "Wrong size on UFortBTTask_TakerMoveToNavmesh");

// Class FortniteGame.FortBTTask_TriggerVOEvent
// 0x0030 (0x00A0 - 0x0070)
class UFortBTTask_TriggerVOEvent final : public UBTTaskNode
{
public:
	uint8                                         bUseFeedbackBank : 1;                              // 0x0070(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CustomEventName;                                   // 0x0078(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SelectedEvent;                                     // 0x0088(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortFeedbackBank*                      FeedbackBank;                                      // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTTask_TriggerVOEvent">();
	}
	static class UFortBTTask_TriggerVOEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTTask_TriggerVOEvent>();
	}
};
static_assert(alignof(UFortBTTask_TriggerVOEvent) == 0x000008, "Wrong alignment on UFortBTTask_TriggerVOEvent");
static_assert(sizeof(UFortBTTask_TriggerVOEvent) == 0x0000A0, "Wrong size on UFortBTTask_TriggerVOEvent");
static_assert(offsetof(UFortBTTask_TriggerVOEvent, CustomEventName) == 0x000078, "Member 'UFortBTTask_TriggerVOEvent::CustomEventName' has a wrong offset!");
static_assert(offsetof(UFortBTTask_TriggerVOEvent, SelectedEvent) == 0x000088, "Member 'UFortBTTask_TriggerVOEvent::SelectedEvent' has a wrong offset!");
static_assert(offsetof(UFortBTTask_TriggerVOEvent, FeedbackBank) == 0x000098, "Member 'UFortBTTask_TriggerVOEvent::FeedbackBank' has a wrong offset!");

// Class FortniteGame.Fort3PCam_Default
// 0x0000 (0x0128 - 0x0128)
class UFort3PCam_Default : public UFort3PCameraMode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Fort3PCam_Default">();
	}
	static class UFort3PCam_Default* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFort3PCam_Default>();
	}
};
static_assert(alignof(UFort3PCam_Default) == 0x000008, "Wrong alignment on UFort3PCam_Default");
static_assert(sizeof(UFort3PCam_Default) == 0x000128, "Wrong size on UFort3PCam_Default");

// Class FortniteGame.FortCinematicCamera
// 0x0000 (0x0050 - 0x0050)
class UFortCinematicCamera : public UFortCameraMode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCinematicCamera">();
	}
	static class UFortCinematicCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCinematicCamera>();
	}
};
static_assert(alignof(UFortCinematicCamera) == 0x000008, "Wrong alignment on UFortCinematicCamera");
static_assert(sizeof(UFortCinematicCamera) == 0x000050, "Wrong size on UFortCinematicCamera");

// Class FortniteGame.FortCarriedObjectInterface
// 0x0000 (0x0028 - 0x0028)
class IFortCarriedObjectInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCarriedObjectInterface">();
	}
	static class IFortCarriedObjectInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortCarriedObjectInterface>();
	}
};
static_assert(alignof(IFortCarriedObjectInterface) == 0x000008, "Wrong alignment on IFortCarriedObjectInterface");
static_assert(sizeof(IFortCarriedObjectInterface) == 0x000028, "Wrong size on IFortCarriedObjectInterface");

// Class FortniteGame.FortFlag
// 0x0010 (0x0508 - 0x04F8)
class AFortFlag final : public AFortCarriedObject
{
public:
	class UStaticMeshComponent*                   FlagMeshComp;                                      // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCapsuleComponent*                      CollisionComp;                                     // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortFlag">();
	}
	static class AFortFlag* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortFlag>();
	}
};
static_assert(alignof(AFortFlag) == 0x000008, "Wrong alignment on AFortFlag");
static_assert(sizeof(AFortFlag) == 0x000508, "Wrong size on AFortFlag");
static_assert(offsetof(AFortFlag, FlagMeshComp) == 0x0004F8, "Member 'AFortFlag::FlagMeshComp' has a wrong offset!");
static_assert(offsetof(AFortFlag, CollisionComp) == 0x000500, "Member 'AFortFlag::CollisionComp' has a wrong offset!");

// Class FortniteGame.FortChat
// 0x0000 (0x0058 - 0x0058)
class UFortChat final : public UChatroom
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortChat">();
	}
	static class UFortChat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortChat>();
	}
};
static_assert(alignof(UFortChat) == 0x000008, "Wrong alignment on UFortChat");
static_assert(sizeof(UFortChat) == 0x000058, "Wrong size on UFortChat");

// Class FortniteGame.FortCheatManager
// 0x00D8 (0x0150 - 0x0078)
class UFortCheatManager final : public UCheatManager
{
public:
	TArray<struct FSpawnPickupEntry>              SpawnablePickups;                                  // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x10];                                      // 0x0088(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bDebugInteractTrace : 1;                           // 0x0098(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDebugPickupSpline : 1;                            // 0x0098(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDebugFloorsOnMiniMap : 1;                         // 0x0098(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableScoreboard : 1;                             // 0x0098(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDebugBounceCurve : 1;                             // 0x0098(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDebugBeautyMode : 1;                              // 0x0098(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisplayWindDebugging : 1;                         // 0x0098(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDebugStructuralSupportSystem : 1;                 // 0x0098(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInfiniteStamina : 1;                              // 0x0099(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShowGameDifficultyHUD : 1;                        // 0x0099(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShowIntensityHUD : 1;                             // 0x0099(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShowSpawnPointsHUD : 1;                           // 0x0099(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShowMaxAIHUD : 1;                                 // 0x0099(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShowItemIDsOnCards : 1;                           // 0x0099(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseNewItemCards : 1;                              // 0x0099(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_99_7 : 1;                                   // 0x0099(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         Pad_9A[0x76];                                      // 0x009A(0x0076)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bUnlimitedHealth : 1;                              // 0x0110(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUnlimitedAIHealth : 1;                            // 0x0110(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPickersUseLeftThumbstick : 1;                     // 0x0110(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFreezeAILOD : 1;                                  // 0x0110(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bForceAILOD : 1;                                   // 0x0110(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUnlockAllDefenders : 1;                           // 0x0110(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_111[0x3];                                      // 0x0111(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EFortAILODLevel                               ForcedAILODValue;                                  // 0x0114(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_115[0x3];                                      // 0x0115(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UBuildingTextureData>    TransparentTextureData;                            // 0x0118(0x0020)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_138[0x18];                                     // 0x0138(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddAllScores(int32 Amount);
	void AddBuildingScore(int32 Amount);
	void AddCombatScore(int32 Amount);
	void AddDebugSpawnAIGroupTag(class FName Tag);
	void AddKillFeedMessage();
	void AddUtilityScore(int32 Amount);
	void AllowRespawn();
	void ApplyGameplayModifier(const class FString& ModifierName);
	void ApplyWeaponAlteration(const class FString& AlterationName);
	void AthenaEndlessGame();
	void AutoSlotSurvivors();
	void BackpackSetSize(int32 Size);
	void Badass();
	void BeautyMode();
	void BotProtectBuilding(const class FString& ClassName, float PosX, float PosY, float PosZ);
	void BotStartDogpile();
	void BotStopDogpile();
	void BounceContainer();
	void BuildFree();
	void BuildWith(const class FString& ResourceTypeAndOrLevel);
	void ClearDebugSpawnAIGroupTags();
	void ClearEncounterSimulatedNumberOfPlayers();
	void ClearEncounterSpawnPointsCap();
	void ClearEncounterSpawnPointsCurve();
	void ClearKeepSave();
	void ClearMapFog();
	void ClearRespawnTimer();
	void ConstructTileWorld(int32 MaxTiles, int32 X, int32 Y);
	void CountPlayerBuiltBuildingActors();
	void CraftFree();
	void CycleCurrentEncounterToDebug();
	void CycleEncounterEQSQueryToDebug();
	void CycleTheaterDisplayed();
	void DBNO();
	void DebugAbilityTags();
	void DebugAttribute(class FString* Attribute);
	void DebugAttributeClear();
	void DebugAttributeModifiers();
	void DebugBuildingDetection();
	void DebugBuildingGroups();
	void DebugForceEnsure();
	void DebugHideLoadingScreen();
	void DebugHotSpots();
	void DebugKickPlayerDueToInactivity();
	void DebugLoadingScreen(const class FString& MissionGen);
	void DebugStructuralSupport();
	void DebugThisAI();
	void DebugUseDedicatedServer(bool bUse);
	void DevSkipTutorial();
	void DisableAI();
	void DiscardAILogging();
	void DumpActiveGameplayEffects();
	void DumpActorsWithAssetTags(const class FString& TagList);
	void DumpAllActiveMissions();
	void DumpAllActorsWithAssetTags();
	void DumpAppliedHomebaseEffectsWithCoreAttributes();
	void DumpGameStats(const class FString& FilterName);
	void EnableFixedTimeStep(int32 AsIfItWasFPS);
	void EnableNewCustomizationPanel(bool bEnable);
	void EnableSubtitles(bool bEnable);
	void EncounterCurrentUtilities();
	void EncounterInitialUtilities();
	void EncounterSetDifficultyLevel(float NewDifficulty);
	void EncounterSpawnProbabilities();
	void EncounterTopUtilityPercentages();
	void EndLiveStreamingWindow();
	void EvolveHero();
	void ExecuteNewMissionGeneration(float DifficultyLevel, const class FString& GeneratorName);
	void ForceAILODs(EFortAILODLevel inForcedAILODValue);
	void ForceHeroType(const class FString& HeroPersistentName);
	void ForceSaveMissionStateAndWorld(const class FString& SaveFilename);
	void ForceServerShutdown(int32 ExitCode);
	void ForceSetHeroRemoteCharacter(int32 PartyMemberIndex, bool bEnabled);
	void ForceUnlockHordeTiers(int32 MaxTierNumber);
	void FortniteForceCharLOD(int32 LOD);
	void GeneratePolysInPathingRange(float MaxDistance, float MinDistance);
	void GetAllReplStats();
	void GetGameStat(const class FString& StatName);
	void GetReplStat(EFortReplicatedStat Stat);
	void GetWorldDifficulty();
	void GetWorldLevel();
	void GetWTFRotations();
	void GiveAllConsumables(int32 NumItems);
	void GiveAllIngredients(int32 NumIngredients);
	void GiveAllMelee();
	void GiveAllPistols();
	void GiveAllRifles();
	void GiveAllShotguns();
	void GiveAllTraps(int32 NumItems);
	void GiveAllWeapons();
	void GiveAmmo(const class FString& AmmoNameAndAmmount);
	void GiveAthenaAmmo();
	void GiveAthenaConsumables();
	void GiveAthenaFullKit();
	void GiveAthenaTraps();
	void GiveAthenaWeapons();
	void GiveBluGlo(int32 Amount);
	void GiveCheatInventory();
	void GiveDeployablePlotAllIngredients(int32 NumIngredients);
	void GiveFounderGlider();
	void GiveFounderUmbrella();
	void GiveGadget(const class FString& GadgetName, int32 ItemLevel);
	void GiveGadgets(const class FString& GadgetName, int32 Quantity, int32 ItemLevel);
	void GiveGoodWeapons();
	void GiveHeroSpecialization(const class FString& SpecializationName);
	void GiveMetal(int32 Amount);
	void GiveResources(int32 Amount);
	void GiveSBA(const class FString& StrategicBuildingName);
	void GiveSpecificItem(const class FString& ItemPath, int32 ItemAmount, int32 ItemLevel);
	void GiveStone(int32 Amount);
	void GiveTrap(const class FString& TrapName, int32 RequestedLevel, int32 NumTrapsToGive);
	void GiveUmbrella();
	void GiveUsefulThings(int32 NumOfUsefulThings);
	void GiveWeapon(const class FString& WeaponName, int32 RequestedLevel, int32 Count);
	void GiveWeapons(class FName Tag);
	void GiveWood(int32 Amount);
	void God();
	void GrantHeroSupportAbility(const class FString& SupportHeroName, int32 Level);
	void GrantHeroTacticalAbility(const class FString& SupportHeroName, int32 Level);
	void HideGameplayCaptureUI();
	void HideHUDElement(const struct FGameplayTag& HUDElementTag);
	void KillPawns(TSubclassOf<class AFortPawn> aClass);
	void ListActiveEncounters();
	void ListAIUtilities();
	void ListAmmo();
	void ListCheats();
	void ListEmotes();
	void ListMissionGenerators();
	void ListMissions();
	void ListPlayerIDs();
	void ListSpawnGroups();
	void LiveStreamingSelectedViewers(const TArray<class FString>& Names);
	void LoadMission(const class FString& MissionName);
	void LoadMissionGenerator(const class FString& GeneratorName);
	void MakeAIsGod();
	void MakeBuildingActorsGod();
	void MakeGods(TSubclassOf<class AFortPawn> aClass);
	void McpApplyAlteration(const class FString& Schematic, const class FString& Alteration);
	void McpApplyStash(const class FString& StashName);
	void McpCheat();
	void McpClaimAllAvailableCollectionBookRewards();
	void McpClaimAllResourceCollectors(bool bDebugPrint);
	void McpCompleteCurrentPrimaryMission(int32 NumMissionPoints);
	void McpCompleteHexMission();
	void McpConvertItem(const class FString& ItemToConvert, int32 ConversionIdx);
	void McpEarnScore(int32 ScoreAmount);
	void McpEquipCharCosmetic(const class FString& CharacterId, const class FString& CosmeticId, int32 CosmeticType);
	void McpForceHttpFailRate(float Factor);
	void McpGetCachedPersistence();
	void McpGetCurrencyAmount();
	void McpGetHexMission();
	void McpGetPersonnelXP();
	void McpGetSchematicXP();
	void McpGetUnredeemedCodes();
	void McpGetVersion();
	void McpHostGetAllPlayerCachedPersistence();
	void McpHostGetPlayers();
	void McpIssueCodeToken(const class FString& TokenId);
	void McpJoinFromPartyInviteToken(const class FString& Token, bool bIsFromInvite);
	void McpLogout();
	void McpOpenCardPack(const class FString& CardPackItemId, int32 SelectionIdx);
	void McpPrintFriendInviteToken(const class FString& FriendName, bool OnlyPrintIfJoinable);
	void McpPrintPartyInviteToken(bool OnlyPrintIfJoinable);
	void McpRecycleItem(const class FString& ItemToRecycle);
	void McpRedeemPurchases();
	void McpRefreshCatalog();
	void McpRefreshProfile();
	void McpResetPersistence();
	void McpSlotItem(const class FString& ItemToSlot);
	void McpTestFriendCodes();
	void McpTestFriendCodes_OnQueryUnredeemedFriendCodes(bool bSuccess, const TArray<struct FFriendCode>& FriendCodes);
	void McpUpgradeItem(const class FString& ItemToUpgrade);
	void MissionForceFailure(const class FString& MissionName);
	void MissionForcePrimarySuccess(float FractionCompleted);
	void MissionForceSuccess(const class FString& MissionName, float FractionCompleted);
	void ModItemDurability(float InValue);
	void NoUmbrella();
	void OpenClassSelectScreen();
	void Pain(float Amount);
	void PerfMemStatMonitor(const class FString& ToggleState);
	void PrintScriptedActionManagerState();
	void PrintShotReport();
	void PrintTileWorld();
	void RefreshTheaters();
	void RegenerateZoneMissions();
	void RegenerateZoneMissionsWithDifficultyLevel(float DifficultyLevelOverride);
	void ReInitHUD();
	void ReloadUI();
	void ReloadUMG();
	void RemoveDebugSpawnAIGroupTag(class FName Tag);
	void RemoveGameplayModifier(const class FString& ModifierName);
	void ReplayLastPerfTest(const class FString& Full);
	void ReRandomizeTiles();
	void ResetEncounterWave();
	void ResetMaxAITracking();
	void RespawnPlayer();
	void RespawnPlayerServer();
	void ReviveFromDBNO();
	void RunMonteCarlo(int32 X, int32 Y, const class FString& TileGroup, int32 NumIterations);
	void RunPerfMemCheatScript(bool bStartStatFiles);
	void SendMissionEvent(const class FString& MissionEventName);
	void SendQuestEvent(class FName Type, class FName TargetTag, class FName SourceTag, class FName ContextTag);
	void SendTwitchToastNotification(const class FString& Title, const class FString& Description);
	void SetActionMappingEnabled(class FName Action, bool bEnabled);
	void SetAimMode(uint32 Mode);
	void SetAthenaHero(const class FString& NewHeroName);
	void SetCameraDistanceMultiplier(float XMultiplier, float YMultiplier, float ZMultiplier);
	void SetCameraFOVMultiplier(float Multiplier);
	void SetCameraPrototype(class FName ProtoName);
	void SetCapturePercentage(float NewCapturePercentage);
	void SetCloudAltitude(float CloudAltitude);
	void SetCombatGraphHistoryLength(int32 Seconds);
	void SetCullValues(float DefaultCullObjectSize, float DefaultCullDistance, float MinCullObjectSize, float MinCullDistance, float MaxCullObjectSize, float MaxCullDistance);
	void SetCurrentEncounterToDebug(int32 EncounterIndex);
	void SetEncounterDirections(const TArray<EFortEncounterDirection>& Directions);
	void SetEncounterGraphsHistoryLength(int32 Seconds);
	void SetEncounterSimulatedNumberOfPlayers(int32 NumPlayers);
	void SetEncounterSpawnPointsCap(int32 SpawnPointsCap);
	void SetEncounterSpawnPointsCurve(const class FString& CurveName);
	void SetEncounterTopUtilityPercentages(const class FString& UtilitiesAndPercentages);
	void SetGameDifficultyOverride(float GameDifficultyOverrideValue);
	void SetGameStat(const class FString& StatName, int32 Amount);
	void SetGlobalWind(float Magnitude, float HeadingDegrees);
	void SetHealthPercent(float Percent);
	void SetHeroClass(const class FString& NewHeroName, int32 Level);
	void SetHeroLevel(int32 Level);
	void SetHordePlotExpansionSize(int32 XSize, int32 YSize, int32 ZSize);
	void SetInputPresetName(const class FString& PresetName);
	void SetInteractExtent(float Extent);
	void SetInteractionDistances(float InteractionDistance, float InteractionHighlightDistance);
	void SetJumpStaminaCost(class FName ModeName);
	void SetMaxClouds(int32 MaxClouds);
	void SetPvPRoundTime(int32 NumSeconds, int32 CriticalThreshold);
	void SetPvPStalemateTime(int32 NumSeconds);
	void SetReplStat(EFortReplicatedStat Stat, int32 Amount);
	void SetRespawnTimerOverride(float TimeUntilRespawn);
	void SetSafeZoneLocationToPlayer();
	void SetSafeZoneRadius(float NewRadius);
	void SetWindPixelDebugExtent(float ExtentInUnrealUnits);
	void SetWorldDaysElapsed(float days);
	void SetWorldLevel(float Level);
	void ShowActiveGameplayModifiers();
	void ShowAllMinimapIcons();
	void ShowGameplayCaptureUI();
	void ShowHUDElement(const struct FGameplayTag& HUDElementTag);
	void SimulateLoot(const class FName TierGroup, int32 LootTier, int32 LootLevel);
	void SimulateLootDrops();
	void SpawnAIGroup(const class FString& SpawnGroupName);
	void SpawnAIGroupFromExternalSpawner(const class FString& SpawnGroupName);
	class AFortPawn* SpawnPawn(const class FString& PawnType);
	void StartLiveStreamingWindow(float Seconds);
	void StopDummyDebugEncounter();
	void SwapPickerThumbstick();
	void SwitchTeam();
	void TeleportToActor(const class FString& ClassOrInstanceName);
	void TeleportToLocation(float X, float Y, float Z);
	void TeleportToMissionActor();
	void TestBanhammer(const class FString& InUserId);
	void TestCancelLobby();
	void TestChangePartyPrivacy(bool bPrivate, bool bLeaderFriendsOnly, bool bLeaderInvitesOnly);
	void TestChangePartySize(int32 NewSize);
	void TestCheckBansAtMatchStart();
	void TestDisconnect();
	void TestEncryptAPI(const class FString& InUserId, const class FString& InSessionId);
	void TestInfJumps();
	void TestInvalidRPCCall();
	void TestJoin();
	void TestKnockback(float KnockbackMagnitude, float KnockbackZAngle);
	void TestLeaveGame();
	void TestOutpostUI();
	void TestSafeZoneLocations(int32 NumPasses, int32 PhaseToDraw);
	void TestSetOutpostDefenseActive(bool bActive);
	void TestStun(float StunStime);
	void TestUpgradeOutpostItem(const class FString& ItemTemplateId);
	void ToggleAIAnim();
	void ToggleAIDespawning();
	void ToggleAIDirectorLogging();
	void ToggleAISpawnCap();
	void ToggleAISpawning();
	void ToggleAutoSlotting();
	void ToggleBuildingActorsTransparency();
	void ToggleBuildingHighlights();
	void ToggleCharacterBackpack();
	void ToggleCharacterHeadAccessories();
	void ToggleCombatGraph();
	void ToggleDebugHUDObjectiveHeight();
	void ToggleDrawRunVariationDebug();
	void ToggleDrawTargetSelectionDebug();
	void ToggleDrawTargetSelectionDebugByClass(TSubclassOf<class AActor> TargetSelectionDebugSourceClass);
	void ToggleDrawTurnTransitionDebug();
	void ToggleEncounterEQSDebug();
	void ToggleEncounterModifierTags();
	void ToggleExplorationBadgeView();
	void ToggleExplorationLogging();
	void ToggleFactorGraph();
	void ToggleFloorsOnMiniMap();
	void ToggleForceUsingGamepad();
	void ToggleFreezeAILOD();
	void ToggleGameDifficultyHUD();
	void ToggleHeroVisibility();
	void ToggleIndestructibleKeep();
	void ToggleInfiniteAmmo();
	void ToggleInfiniteDurability();
	void ToggleInfiniteStamina();
	void ToggleIntensityGraph();
	void ToggleIntensityHUD();
	void ToggleInteractTrace();
	void ToggleInvincibleCornerstones();
	void ToggleInWorldScoreNumbers();
	void ToggleItemIdsOnCards();
	void ToggleLogCharacterCustomization();
	void ToggleMaxAIHUD();
	void ToggleNoCoolDown();
	void TogglePickers();
	void TogglePickupSpline();
	void TogglePIDContributionsGraph();
	void TogglePIDValuesGraph();
	void TogglePlayerNames();
	void ToggleSecondaryMissionHeaders();
	void ToggleShotLogging();
	void ToggleSpawnPointsHUD();
	void ToggleTreeVisibility();
	void ToggleUnlimitedAIHealth();
	void ToggleUnlimitedHealth();
	void ToggleUseNewItemCards();
	void ToggleUtilitiesGraph();
	void ToggleVoiceDebug();
	void ToggleWalkOnWalls();
	void ToggleWindDebugDeltaBoundsDisplay();
	void ToggleWindDebugDisplay(float NewRefreshRate);
	void ToggleWindDebugPixelDisplay();
	void ToggleWindDebugVolumeDisplay();
	void TriggerOutOfStaminaFeedback();
	void TutorialAddHidden(class FName Hidden);
	void TutorialAddHighlight(class FName Highlight);
	void TutorialListAll();
	void TutorialListHidden();
	void TutorialListHighlights();
	void TutorialRemoveHidden(class FName Hidden);
	void TutorialRemoveHighlight(class FName Highlight);
	void UnforceAILODs();
	void UnlockAllDefenders(bool inUnlockAllDefenders);
	void UnlockAllZones();
	void ViewStuck();
	void WannaGun();
	void WriteLootReport();

	void GetWindPixelDebugExtent() const;
	void ListGadgets() const;
	void ListTraps() const;
	void ListWeapons() const;
	bool ShouldUseNewItemCards() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCheatManager">();
	}
	static class UFortCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCheatManager>();
	}
};
static_assert(alignof(UFortCheatManager) == 0x000008, "Wrong alignment on UFortCheatManager");
static_assert(sizeof(UFortCheatManager) == 0x000150, "Wrong size on UFortCheatManager");
static_assert(offsetof(UFortCheatManager, SpawnablePickups) == 0x000078, "Member 'UFortCheatManager::SpawnablePickups' has a wrong offset!");
static_assert(offsetof(UFortCheatManager, ForcedAILODValue) == 0x000114, "Member 'UFortCheatManager::ForcedAILODValue' has a wrong offset!");
static_assert(offsetof(UFortCheatManager, TransparentTextureData) == 0x000118, "Member 'UFortCheatManager::TransparentTextureData' has a wrong offset!");

// Class FortniteGame.FortClientAnnouncementManager
// 0x0188 (0x0510 - 0x0388)
class AFortClientAnnouncementManager final : public AActor
{
public:
	uint8                                         Pad_388[0x88];                                     // 0x0388(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AFortClientAnnouncement*>        ClientAnnouncements;                               // 0x0410(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	TArray<class AFortClientAnnouncement*>        LocalClientAnnouncements;                          // 0x0420(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGuid>                          CancelledAnnouncements;                            // 0x0430(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FFortClientAnnouncementQueue           Channels[0x3];                                     // 0x0440(0x0010)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_470[0xA0];                                     // 0x0470(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_CancelledAnnouncements();
	void OnRep_ClientAnnouncements(TArray<class AFortClientAnnouncement*>* PreviousClientAnnouncements);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortClientAnnouncementManager">();
	}
	static class AFortClientAnnouncementManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortClientAnnouncementManager>();
	}
};
static_assert(alignof(AFortClientAnnouncementManager) == 0x000008, "Wrong alignment on AFortClientAnnouncementManager");
static_assert(sizeof(AFortClientAnnouncementManager) == 0x000510, "Wrong size on AFortClientAnnouncementManager");
static_assert(offsetof(AFortClientAnnouncementManager, ClientAnnouncements) == 0x000410, "Member 'AFortClientAnnouncementManager::ClientAnnouncements' has a wrong offset!");
static_assert(offsetof(AFortClientAnnouncementManager, LocalClientAnnouncements) == 0x000420, "Member 'AFortClientAnnouncementManager::LocalClientAnnouncements' has a wrong offset!");
static_assert(offsetof(AFortClientAnnouncementManager, CancelledAnnouncements) == 0x000430, "Member 'AFortClientAnnouncementManager::CancelledAnnouncements' has a wrong offset!");
static_assert(offsetof(AFortClientAnnouncementManager, Channels) == 0x000440, "Member 'AFortClientAnnouncementManager::Channels' has a wrong offset!");

// Class FortniteGame.FortGameModeFrontEnd
// 0x0018 (0x0790 - 0x0778)
class AFortGameModeFrontEnd final : public AFortGameMode
{
public:
	class AFortTheaterMapViewer*                  TheaterMapViewer;                                  // 0x0778(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_780[0x10];                                     // 0x0780(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameModeFrontEnd">();
	}
	static class AFortGameModeFrontEnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGameModeFrontEnd>();
	}
};
static_assert(alignof(AFortGameModeFrontEnd) == 0x000008, "Wrong alignment on AFortGameModeFrontEnd");
static_assert(sizeof(AFortGameModeFrontEnd) == 0x000790, "Wrong size on AFortGameModeFrontEnd");
static_assert(offsetof(AFortGameModeFrontEnd, TheaterMapViewer) == 0x000778, "Member 'AFortGameModeFrontEnd::TheaterMapViewer' has a wrong offset!");

// Class FortniteGame.FortOnlineAccount
// 0x01B0 (0x09B0 - 0x0800)
class UFortOnlineAccount : public UOnlineAccountCommon
{
public:
	uint8                                         Pad_800[0x74];                                     // 0x0800(0x0074)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RecommendChatFailureDelay;                         // 0x0874(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RecommendChatRandomWindow;                         // 0x0878(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RecommendChatBackoffMultiplier;                    // 0x087C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         RecommendChatFailureCountCap;                      // 0x0880(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_884[0x5];                                      // 0x0884(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShouldRequestGeneralChatRooms;                    // 0x0889(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShouldJoinGlobalChat;                             // 0x088A(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShouldJoinFounderChat;                            // 0x088B(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShouldCheckIfPlatformAllowed;                     // 0x088C(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRequireHomeSharingAccessEntitlement;              // 0x088D(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHadLoginPurchaseCheckFailure;                     // 0x088E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88F[0x1];                                      // 0x088F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         IgnoreProducts;                                    // 0x0890(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8A0[0x110];                                    // 0x08A0(0x0110)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortOnlineAccount">();
	}
	static class UFortOnlineAccount* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortOnlineAccount>();
	}
};
static_assert(alignof(UFortOnlineAccount) == 0x000008, "Wrong alignment on UFortOnlineAccount");
static_assert(sizeof(UFortOnlineAccount) == 0x0009B0, "Wrong size on UFortOnlineAccount");
static_assert(offsetof(UFortOnlineAccount, RecommendChatFailureDelay) == 0x000874, "Member 'UFortOnlineAccount::RecommendChatFailureDelay' has a wrong offset!");
static_assert(offsetof(UFortOnlineAccount, RecommendChatRandomWindow) == 0x000878, "Member 'UFortOnlineAccount::RecommendChatRandomWindow' has a wrong offset!");
static_assert(offsetof(UFortOnlineAccount, RecommendChatBackoffMultiplier) == 0x00087C, "Member 'UFortOnlineAccount::RecommendChatBackoffMultiplier' has a wrong offset!");
static_assert(offsetof(UFortOnlineAccount, RecommendChatFailureCountCap) == 0x000880, "Member 'UFortOnlineAccount::RecommendChatFailureCountCap' has a wrong offset!");
static_assert(offsetof(UFortOnlineAccount, bShouldRequestGeneralChatRooms) == 0x000889, "Member 'UFortOnlineAccount::bShouldRequestGeneralChatRooms' has a wrong offset!");
static_assert(offsetof(UFortOnlineAccount, bShouldJoinGlobalChat) == 0x00088A, "Member 'UFortOnlineAccount::bShouldJoinGlobalChat' has a wrong offset!");
static_assert(offsetof(UFortOnlineAccount, bShouldJoinFounderChat) == 0x00088B, "Member 'UFortOnlineAccount::bShouldJoinFounderChat' has a wrong offset!");
static_assert(offsetof(UFortOnlineAccount, bShouldCheckIfPlatformAllowed) == 0x00088C, "Member 'UFortOnlineAccount::bShouldCheckIfPlatformAllowed' has a wrong offset!");
static_assert(offsetof(UFortOnlineAccount, bRequireHomeSharingAccessEntitlement) == 0x00088D, "Member 'UFortOnlineAccount::bRequireHomeSharingAccessEntitlement' has a wrong offset!");
static_assert(offsetof(UFortOnlineAccount, bHadLoginPurchaseCheckFailure) == 0x00088E, "Member 'UFortOnlineAccount::bHadLoginPurchaseCheckFailure' has a wrong offset!");
static_assert(offsetof(UFortOnlineAccount, IgnoreProducts) == 0x000890, "Member 'UFortOnlineAccount::IgnoreProducts' has a wrong offset!");

// Class FortniteGame.FortPartyContext
// 0x04D0 (0x04F8 - 0x0028)
class UFortPartyContext final : public UBlueprintContextBase
{
public:
	UMulticastDelegateProperty_                   OnPartyTransitionStarted;                          // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPartyTransitionCompleted;                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPartyJoined;                                     // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPartyLeft;                                       // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnClientPartyStateChanged;                         // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnClientPlaylistChanged;                           // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnClientSquadFillChanged;                          // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnAthenaReadyStateChanged;                         // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPartyTypeChanged;                                // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnLeaderFriendsOnlyChanged;                        // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnLeaderInvitesOnlyChanged;                        // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnLocalPlayerStateChanged;                         // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPlayerStateChanged;                              // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPartyDataChanged;                                // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnActiveFriendsCountUpdated;                       // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnActiveFriendsUpdated;                            // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPartyInvitesCountChanged;                        // 0x0128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPartyInvitesUpdated;                             // 0x0138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   RejectInviteComplete;                              // 0x0148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnSocialListChanged;                               // 0x0158(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnSentPartyInvite;                                 // 0x0168(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFriendPresenceUpdated;                           // 0x0178(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_188[0xB0];                                     // 0x0188(0x00B0)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FUniqueNetIdRepl, class UFortSocialItem*> ActiveFriendsMap;                                  // 0x0238(0x0050)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<struct FUniqueNetIdRepl, class UFortSocialItem*> PartyInvitesMap;                                   // 0x0288(0x0050)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<EFortSocialItemHeaderType, class UFortSocialItem*> SocialItemCategories;                              // 0x02D8(0x0050)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_328[0x8];                                      // 0x0328(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EFortTeam, class UFortUITeamInfo*>       TeamsMap;                                          // 0x0330(0x0050)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<struct FUniqueNetIdRepl, class AFortPlayerState*> UnassignedPlayerStatesByID;                        // 0x0380(0x0050)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D0[0x20];                                     // 0x03D0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortUITeamInfo*                        LocalPlayerTeam;                                   // 0x03F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F8[0x100];                                    // 0x03F8(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool IsValidNetID(const struct FUniqueNetIdRepl& UniqueNetID);

	void AcceptFriendRequest(const struct FUniqueNetIdRepl& PlayerID);
	bool CanBeInvitedNetID(const struct FUniqueNetIdRepl& PlayerID, EFortPartyRestriction* FailReason);
	void CancelFriendRequest(const struct FUniqueNetIdRepl& PlayerID);
	void ClearPendingInvites();
	void GetActiveFriendsList(TArray<class UFortSocialItem*>* OutActiveFriends);
	bool GetLocalTeamTeamMemberInfo(class AFortPlayerState* TeamMemberState, struct FFortTeamMemberInfo* TeamMemberInfo);
	void GetPartyInvites(TArray<class UFortSocialItem*>* OutPartyInvites);
	bool GetPartyPrivacySetting(EPartyType* OutPartyType, bool* OutLeaderFriendsOnly, bool* OutLeaderInvitesOnly);
	void GetSocialItemCategories(TArray<class UFortSocialItem*>* OutSocialCategoryItems);
	void GetSocialItemList(TArray<class UFortSocialItem*>* OutSocialItems);
	class UFortUITeamInfo* GetTeamInfo(EFortTeam Team);
	void HandlePendingInvites();
	void JoinParty(class UFortSocialItem* PartyItem, bool bIsRetrying);
	void KickPartyMember(const struct FUniqueNetIdRepl& PartyMemberId);
	void LeaveParty();
	void MutePartyMember(const struct FUniqueNetIdRepl& PartyMemberId);
	void PromotePartyMemberToLeader(const struct FUniqueNetIdRepl& PartyMemberId);
	void RejectFriendRequest(const struct FUniqueNetIdRepl& PlayerID);
	void RejectPartyInvite(class UFortSocialItem* PartyInvite);
	void SendFriendRequest(const struct FUniqueNetIdRepl& PlayerID);
	void SendPartyInvite(class UFortSocialItem* SocialItem);
	void SendPartyInviteNetID(const struct FUniqueNetIdRepl& PlayerID);
	void SetChatWhisperTarget(const struct FUniqueNetIdRepl& FriendId);
	void SetFriendInvitesEnabled(bool bEnabled);
	void SetLocalPartyMemberLocation(EFortPartyMemberLocation Location);
	void SetPartyInvitesEnabled(bool bEnabled);
	void SetPartyPrivacySetting(EPartyType PartyType, bool bLeaderFriendsOnly, bool bLeaderInvitesOnly);
	void SetPartyProgression(EFortPartyState NewState);
	void ShowExternalProfile(const struct FUniqueNetIdRepl& ProfileToShow);
	void ShowLocalPlayerExternalProfile();
	void UnmutePartyMember(const struct FUniqueNetIdRepl& PartyMemberId);

	bool CanBeInvited(class UFortSocialItem* SocialItem, EFortPartyRestriction* FailReason) const;
	bool CanBeJoined(class UFortSocialItem* SocialItem, EFortPartyRestriction* FailReason) const;
	bool GetConsoleFriendRichPresenceText(const struct FUniqueNetIdRepl& FriendId, class FText* RichPresenceText) const;
	int32 GetCurrentPartyMaxSize() const;
	EFortFriendRequestStatus GetFriendRequestStatusForPlayer(const struct FUniqueNetIdRepl& PlayerID) const;
	bool GetLocalPartyMemberLocation(EFortPartyMemberLocation* Location) const;
	EFortAthenaPlaylist GetLocalPartyPlaylist() const;
	EFortPartyState GetLocalPartyProgression() const;
	bool GetLocalPartyTeamFill() const;
	class FString GetLocalPlayerDisplayName() const;
	class UFortUITeamInfo* GetLocalPlayerTeam() const;
	void GetLocalPlayerTeamMemberInfo(struct FFortTeamMemberInfo* LocalPlayerInfo) const;
	int32 GetMaxTeamSizeForSelectedTheater() const;
	int32 GetNumPlayersInLocalParty() const;
	EFortPartyMemberDisplayState GetPartyMemberDisplayState(const struct FFortTeamMemberInfo& PartyMemberInfo) const;
	bool HasPendingFriendRequest() const;
	bool HasPendingPartyInvitation(const struct FUniqueNetIdRepl& PlayerID) const;
	bool IsAthenaPartyMemberReady(const struct FUniqueNetIdRepl& MemberId) const;
	bool IsEntirePartyInFrontEnd() const;
	bool IsInLocalPlayersParty(const struct FUniqueNetIdRepl& PlayerID) const;
	bool IsLocalPlayerInParty(class UFortSocialItem* SocialItem) const;
	bool IsLocalPlayerInPersistentParty() const;
	bool IsLocalPlayerPartyLeader() const;
	bool IsPartyMemberMuted(const struct FUniqueNetIdRepl& PartyMemberId) const;
	bool IsPlayerBlocked(const struct FUniqueNetIdRepl& PlayerID) const;
	bool IsPlayerInOurParty(const struct FUniqueNetIdRepl& PlayerIdToCheck) const;
	bool IsTeamMemberFriend(const struct FFortTeamMemberInfo& TeamMemberInfo) const;
	bool ShouldPartyInvitesBeEnabled() const;
	bool ShouldShowHeroPortraits() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPartyContext">();
	}
	static class UFortPartyContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPartyContext>();
	}
};
static_assert(alignof(UFortPartyContext) == 0x000008, "Wrong alignment on UFortPartyContext");
static_assert(sizeof(UFortPartyContext) == 0x0004F8, "Wrong size on UFortPartyContext");
static_assert(offsetof(UFortPartyContext, OnPartyTransitionStarted) == 0x000028, "Member 'UFortPartyContext::OnPartyTransitionStarted' has a wrong offset!");
static_assert(offsetof(UFortPartyContext, OnPartyTransitionCompleted) == 0x000038, "Member 'UFortPartyContext::OnPartyTransitionCompleted' has a wrong offset!");
static_assert(offsetof(UFortPartyContext, OnPartyJoined) == 0x000048, "Member 'UFortPartyContext::OnPartyJoined' has a wrong offset!");
static_assert(offsetof(UFortPartyContext, OnPartyLeft) == 0x000058, "Member 'UFortPartyContext::OnPartyLeft' has a wrong offset!");
static_assert(offsetof(UFortPartyContext, OnClientPartyStateChanged) == 0x000068, "Member 'UFortPartyContext::OnClientPartyStateChanged' has a wrong offset!");
static_assert(offsetof(UFortPartyContext, OnClientPlaylistChanged) == 0x000078, "Member 'UFortPartyContext::OnClientPlaylistChanged' has a wrong offset!");
static_assert(offsetof(UFortPartyContext, OnClientSquadFillChanged) == 0x000088, "Member 'UFortPartyContext::OnClientSquadFillChanged' has a wrong offset!");
static_assert(offsetof(UFortPartyContext, OnAthenaReadyStateChanged) == 0x000098, "Member 'UFortPartyContext::OnAthenaReadyStateChanged' has a wrong offset!");
static_assert(offsetof(UFortPartyContext, OnPartyTypeChanged) == 0x0000A8, "Member 'UFortPartyContext::OnPartyTypeChanged' has a wrong offset!");
static_assert(offsetof(UFortPartyContext, OnLeaderFriendsOnlyChanged) == 0x0000B8, "Member 'UFortPartyContext::OnLeaderFriendsOnlyChanged' has a wrong offset!");
static_assert(offsetof(UFortPartyContext, OnLeaderInvitesOnlyChanged) == 0x0000C8, "Member 'UFortPartyContext::OnLeaderInvitesOnlyChanged' has a wrong offset!");
static_assert(offsetof(UFortPartyContext, OnLocalPlayerStateChanged) == 0x0000D8, "Member 'UFortPartyContext::OnLocalPlayerStateChanged' has a wrong offset!");
static_assert(offsetof(UFortPartyContext, OnPlayerStateChanged) == 0x0000E8, "Member 'UFortPartyContext::OnPlayerStateChanged' has a wrong offset!");
static_assert(offsetof(UFortPartyContext, OnPartyDataChanged) == 0x0000F8, "Member 'UFortPartyContext::OnPartyDataChanged' has a wrong offset!");
static_assert(offsetof(UFortPartyContext, OnActiveFriendsCountUpdated) == 0x000108, "Member 'UFortPartyContext::OnActiveFriendsCountUpdated' has a wrong offset!");
static_assert(offsetof(UFortPartyContext, OnActiveFriendsUpdated) == 0x000118, "Member 'UFortPartyContext::OnActiveFriendsUpdated' has a wrong offset!");
static_assert(offsetof(UFortPartyContext, OnPartyInvitesCountChanged) == 0x000128, "Member 'UFortPartyContext::OnPartyInvitesCountChanged' has a wrong offset!");
static_assert(offsetof(UFortPartyContext, OnPartyInvitesUpdated) == 0x000138, "Member 'UFortPartyContext::OnPartyInvitesUpdated' has a wrong offset!");
static_assert(offsetof(UFortPartyContext, RejectInviteComplete) == 0x000148, "Member 'UFortPartyContext::RejectInviteComplete' has a wrong offset!");
static_assert(offsetof(UFortPartyContext, OnSocialListChanged) == 0x000158, "Member 'UFortPartyContext::OnSocialListChanged' has a wrong offset!");
static_assert(offsetof(UFortPartyContext, OnSentPartyInvite) == 0x000168, "Member 'UFortPartyContext::OnSentPartyInvite' has a wrong offset!");
static_assert(offsetof(UFortPartyContext, OnFriendPresenceUpdated) == 0x000178, "Member 'UFortPartyContext::OnFriendPresenceUpdated' has a wrong offset!");
static_assert(offsetof(UFortPartyContext, ActiveFriendsMap) == 0x000238, "Member 'UFortPartyContext::ActiveFriendsMap' has a wrong offset!");
static_assert(offsetof(UFortPartyContext, PartyInvitesMap) == 0x000288, "Member 'UFortPartyContext::PartyInvitesMap' has a wrong offset!");
static_assert(offsetof(UFortPartyContext, SocialItemCategories) == 0x0002D8, "Member 'UFortPartyContext::SocialItemCategories' has a wrong offset!");
static_assert(offsetof(UFortPartyContext, TeamsMap) == 0x000330, "Member 'UFortPartyContext::TeamsMap' has a wrong offset!");
static_assert(offsetof(UFortPartyContext, UnassignedPlayerStatesByID) == 0x000380, "Member 'UFortPartyContext::UnassignedPlayerStatesByID' has a wrong offset!");
static_assert(offsetof(UFortPartyContext, LocalPlayerTeam) == 0x0003F0, "Member 'UFortPartyContext::LocalPlayerTeam' has a wrong offset!");

// Class FortniteGame.WorldTheme
// 0x01C0 (0x01E8 - 0x0028)
class UWorldTheme final : public UDataAsset
{
public:
	TArray<struct FTileGroupSelection>            TileGroups;                                        // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UWorldTileGroup*                        FillerTileGroup;                                   // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCircuitSize;                                    // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UWorld>                  BorderWorld_I;                                     // 0x0048(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UWorld>                  BorderWorld_IO;                                    // 0x0068(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UWorld>                  BorderWorld_O;                                     // 0x0088(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UWorld>                  BorderWorld_OO;                                    // 0x00A8(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UWorld>                  BorderWorld_OOO;                                   // 0x00C8(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UWorld>                  BorderWorld_OOOO;                                  // 0x00E8(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UWorld>                  BorderWorld_S;                                     // 0x0108(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UWorld>                  BorderWorld_SS;                                    // 0x0128(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UWorld>                  BorderWorld_OS;                                    // 0x0148(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UWorld>                  BorderWorld_SO;                                    // 0x0168(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UWorld>                  BorderWorld_SOO;                                   // 0x0188(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UWorld>                  BorderWorld_U;                                     // 0x01A8(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UWorld>                  BorderWorld_R;                                     // 0x01C8(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldTheme">();
	}
	static class UWorldTheme* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldTheme>();
	}
};
static_assert(alignof(UWorldTheme) == 0x000008, "Wrong alignment on UWorldTheme");
static_assert(sizeof(UWorldTheme) == 0x0001E8, "Wrong size on UWorldTheme");
static_assert(offsetof(UWorldTheme, TileGroups) == 0x000028, "Member 'UWorldTheme::TileGroups' has a wrong offset!");
static_assert(offsetof(UWorldTheme, FillerTileGroup) == 0x000038, "Member 'UWorldTheme::FillerTileGroup' has a wrong offset!");
static_assert(offsetof(UWorldTheme, MaxCircuitSize) == 0x000040, "Member 'UWorldTheme::MaxCircuitSize' has a wrong offset!");
static_assert(offsetof(UWorldTheme, BorderWorld_I) == 0x000048, "Member 'UWorldTheme::BorderWorld_I' has a wrong offset!");
static_assert(offsetof(UWorldTheme, BorderWorld_IO) == 0x000068, "Member 'UWorldTheme::BorderWorld_IO' has a wrong offset!");
static_assert(offsetof(UWorldTheme, BorderWorld_O) == 0x000088, "Member 'UWorldTheme::BorderWorld_O' has a wrong offset!");
static_assert(offsetof(UWorldTheme, BorderWorld_OO) == 0x0000A8, "Member 'UWorldTheme::BorderWorld_OO' has a wrong offset!");
static_assert(offsetof(UWorldTheme, BorderWorld_OOO) == 0x0000C8, "Member 'UWorldTheme::BorderWorld_OOO' has a wrong offset!");
static_assert(offsetof(UWorldTheme, BorderWorld_OOOO) == 0x0000E8, "Member 'UWorldTheme::BorderWorld_OOOO' has a wrong offset!");
static_assert(offsetof(UWorldTheme, BorderWorld_S) == 0x000108, "Member 'UWorldTheme::BorderWorld_S' has a wrong offset!");
static_assert(offsetof(UWorldTheme, BorderWorld_SS) == 0x000128, "Member 'UWorldTheme::BorderWorld_SS' has a wrong offset!");
static_assert(offsetof(UWorldTheme, BorderWorld_OS) == 0x000148, "Member 'UWorldTheme::BorderWorld_OS' has a wrong offset!");
static_assert(offsetof(UWorldTheme, BorderWorld_SO) == 0x000168, "Member 'UWorldTheme::BorderWorld_SO' has a wrong offset!");
static_assert(offsetof(UWorldTheme, BorderWorld_SOO) == 0x000188, "Member 'UWorldTheme::BorderWorld_SOO' has a wrong offset!");
static_assert(offsetof(UWorldTheme, BorderWorld_U) == 0x0001A8, "Member 'UWorldTheme::BorderWorld_U' has a wrong offset!");
static_assert(offsetof(UWorldTheme, BorderWorld_R) == 0x0001C8, "Member 'UWorldTheme::BorderWorld_R' has a wrong offset!");

// Class FortniteGame.FortMcpUtils
// 0x00E8 (0x0110 - 0x0028)
class UFortMcpUtils final : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CreateXboxDedicatedServerSessionUrl;               // 0x0048(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 UnredeemedCodesUrl;                                // 0x0058(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 QueryUserXuidUrl;                                  // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 RecordUserStatsUrl;                                // 0x0078(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 QueryUserStatsUrl;                                 // 0x0088(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 QueryLeaderboardUrl;                               // 0x0098(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 QueryCohortUrl;                                    // 0x00A8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x50];                                      // 0x00B8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DefaultLogTailLengthKb;                            // 0x0108(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMcpUtils">();
	}
	static class UFortMcpUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMcpUtils>();
	}
};
static_assert(alignof(UFortMcpUtils) == 0x000008, "Wrong alignment on UFortMcpUtils");
static_assert(sizeof(UFortMcpUtils) == 0x000110, "Wrong size on UFortMcpUtils");
static_assert(offsetof(UFortMcpUtils, CreateXboxDedicatedServerSessionUrl) == 0x000048, "Member 'UFortMcpUtils::CreateXboxDedicatedServerSessionUrl' has a wrong offset!");
static_assert(offsetof(UFortMcpUtils, UnredeemedCodesUrl) == 0x000058, "Member 'UFortMcpUtils::UnredeemedCodesUrl' has a wrong offset!");
static_assert(offsetof(UFortMcpUtils, QueryUserXuidUrl) == 0x000068, "Member 'UFortMcpUtils::QueryUserXuidUrl' has a wrong offset!");
static_assert(offsetof(UFortMcpUtils, RecordUserStatsUrl) == 0x000078, "Member 'UFortMcpUtils::RecordUserStatsUrl' has a wrong offset!");
static_assert(offsetof(UFortMcpUtils, QueryUserStatsUrl) == 0x000088, "Member 'UFortMcpUtils::QueryUserStatsUrl' has a wrong offset!");
static_assert(offsetof(UFortMcpUtils, QueryLeaderboardUrl) == 0x000098, "Member 'UFortMcpUtils::QueryLeaderboardUrl' has a wrong offset!");
static_assert(offsetof(UFortMcpUtils, QueryCohortUrl) == 0x0000A8, "Member 'UFortMcpUtils::QueryCohortUrl' has a wrong offset!");
static_assert(offsetof(UFortMcpUtils, DefaultLogTailLengthKb) == 0x000108, "Member 'UFortMcpUtils::DefaultLogTailLengthKb' has a wrong offset!");

// Class FortniteGame.FortClientEventData
// 0x0010 (0x0038 - 0x0028)
class UFortClientEventData final : public UDataAsset
{
public:
	TArray<struct FFortClientEventName>           ClientEventNames;                                  // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortClientEventData">();
	}
	static class UFortClientEventData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortClientEventData>();
	}
};
static_assert(alignof(UFortClientEventData) == 0x000008, "Wrong alignment on UFortClientEventData");
static_assert(sizeof(UFortClientEventData) == 0x000038, "Wrong size on UFortClientEventData");
static_assert(offsetof(UFortClientEventData, ClientEventNames) == 0x000028, "Member 'UFortClientEventData::ClientEventNames' has a wrong offset!");

// Class FortniteGame.FortDamageNumbersActor
// 0x01D0 (0x0560 - 0x0390)
class AFortDamageNumbersActor : public AFortClientOnlyActor
{
public:
	float                                         ComponentLifespan;                                 // 0x0390(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_394[0x4];                                      // 0x0394(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            MeshesByElement[0x4];                              // 0x0398(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            CritBuildingImpactMesh;                            // 0x03B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            MeshesByScoreCategory[0x3];                        // 0x03C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PlayerMaterialParameterName;                       // 0x03D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerMaterialParameterValue;                      // 0x03E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           CriticalHitPlayerColor;                            // 0x03E4(0x0010)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           StandardHitPlayerColor;                            // 0x03F4(0x0010)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           CriticalHitBuildingColor;                          // 0x0404(0x0010)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           CriticalHitEnemyColor;                             // 0x0414(0x0010)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           StandardHitColor;                                  // 0x0424(0x0010)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           CriticalHitShieldColor;                            // 0x0434(0x0010)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           ShieldHitColor;                                    // 0x0444(0x0010)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_454[0x4];                                      // 0x0454(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ColorParameterName;                                // 0x0458(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AnimationLifespanParameterName;                    // 0x0460(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   IsCriticalHitParameterName;                        // 0x0468(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpacingPercentageForOnes;                          // 0x0470(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_474[0x4];                                      // 0x0474(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           PositionParameterNames;                            // 0x0478(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         DistanceFromCameraBeforeDoublingSize;              // 0x0488(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CriticalHitSizeMultiplier;                         // 0x048C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FontXSize;                                         // 0x0490(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FontYSize;                                         // 0x0494(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NumberOfNumberRotations;                           // 0x0498(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_49C[0x4];                                      // 0x049C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ScaleRotationAngleParameterNames;                  // 0x04A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           DurationParameterNames;                            // 0x04B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         MaxScoreNumberDistance;                            // 0x04C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C4[0x4];                                      // 0x04C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPooledDamageNumberComponents          PooledComponentsByElement[0x4];                    // 0x04C8(0x0010)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FPooledDamageNumberComponents          PooledComponentsCritBuildingImpact;                // 0x0508(0x0010)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FPooledDamageNumberComponents          PooledComponentsByScoreCategory[0x3];              // 0x0518(0x0010)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FLiveDamageNumberComponent>     LiveComponents;                                    // 0x0548(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_558[0x8];                                      // 0x0558(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnNewDamageNumber(const struct FFortDamageNumberInfo& NewDamageNumberInfo);
	void SetMaterialParameters(struct FFortDamageNumberInfo& NewDamageNumberInfo, const struct FTransform& CameraTransform, const struct FVector& NumberLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDamageNumbersActor">();
	}
	static class AFortDamageNumbersActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortDamageNumbersActor>();
	}
};
static_assert(alignof(AFortDamageNumbersActor) == 0x000008, "Wrong alignment on AFortDamageNumbersActor");
static_assert(sizeof(AFortDamageNumbersActor) == 0x000560, "Wrong size on AFortDamageNumbersActor");
static_assert(offsetof(AFortDamageNumbersActor, ComponentLifespan) == 0x000390, "Member 'AFortDamageNumbersActor::ComponentLifespan' has a wrong offset!");
static_assert(offsetof(AFortDamageNumbersActor, MeshesByElement) == 0x000398, "Member 'AFortDamageNumbersActor::MeshesByElement' has a wrong offset!");
static_assert(offsetof(AFortDamageNumbersActor, CritBuildingImpactMesh) == 0x0003B8, "Member 'AFortDamageNumbersActor::CritBuildingImpactMesh' has a wrong offset!");
static_assert(offsetof(AFortDamageNumbersActor, MeshesByScoreCategory) == 0x0003C0, "Member 'AFortDamageNumbersActor::MeshesByScoreCategory' has a wrong offset!");
static_assert(offsetof(AFortDamageNumbersActor, PlayerMaterialParameterName) == 0x0003D8, "Member 'AFortDamageNumbersActor::PlayerMaterialParameterName' has a wrong offset!");
static_assert(offsetof(AFortDamageNumbersActor, PlayerMaterialParameterValue) == 0x0003E0, "Member 'AFortDamageNumbersActor::PlayerMaterialParameterValue' has a wrong offset!");
static_assert(offsetof(AFortDamageNumbersActor, CriticalHitPlayerColor) == 0x0003E4, "Member 'AFortDamageNumbersActor::CriticalHitPlayerColor' has a wrong offset!");
static_assert(offsetof(AFortDamageNumbersActor, StandardHitPlayerColor) == 0x0003F4, "Member 'AFortDamageNumbersActor::StandardHitPlayerColor' has a wrong offset!");
static_assert(offsetof(AFortDamageNumbersActor, CriticalHitBuildingColor) == 0x000404, "Member 'AFortDamageNumbersActor::CriticalHitBuildingColor' has a wrong offset!");
static_assert(offsetof(AFortDamageNumbersActor, CriticalHitEnemyColor) == 0x000414, "Member 'AFortDamageNumbersActor::CriticalHitEnemyColor' has a wrong offset!");
static_assert(offsetof(AFortDamageNumbersActor, StandardHitColor) == 0x000424, "Member 'AFortDamageNumbersActor::StandardHitColor' has a wrong offset!");
static_assert(offsetof(AFortDamageNumbersActor, CriticalHitShieldColor) == 0x000434, "Member 'AFortDamageNumbersActor::CriticalHitShieldColor' has a wrong offset!");
static_assert(offsetof(AFortDamageNumbersActor, ShieldHitColor) == 0x000444, "Member 'AFortDamageNumbersActor::ShieldHitColor' has a wrong offset!");
static_assert(offsetof(AFortDamageNumbersActor, ColorParameterName) == 0x000458, "Member 'AFortDamageNumbersActor::ColorParameterName' has a wrong offset!");
static_assert(offsetof(AFortDamageNumbersActor, AnimationLifespanParameterName) == 0x000460, "Member 'AFortDamageNumbersActor::AnimationLifespanParameterName' has a wrong offset!");
static_assert(offsetof(AFortDamageNumbersActor, IsCriticalHitParameterName) == 0x000468, "Member 'AFortDamageNumbersActor::IsCriticalHitParameterName' has a wrong offset!");
static_assert(offsetof(AFortDamageNumbersActor, SpacingPercentageForOnes) == 0x000470, "Member 'AFortDamageNumbersActor::SpacingPercentageForOnes' has a wrong offset!");
static_assert(offsetof(AFortDamageNumbersActor, PositionParameterNames) == 0x000478, "Member 'AFortDamageNumbersActor::PositionParameterNames' has a wrong offset!");
static_assert(offsetof(AFortDamageNumbersActor, DistanceFromCameraBeforeDoublingSize) == 0x000488, "Member 'AFortDamageNumbersActor::DistanceFromCameraBeforeDoublingSize' has a wrong offset!");
static_assert(offsetof(AFortDamageNumbersActor, CriticalHitSizeMultiplier) == 0x00048C, "Member 'AFortDamageNumbersActor::CriticalHitSizeMultiplier' has a wrong offset!");
static_assert(offsetof(AFortDamageNumbersActor, FontXSize) == 0x000490, "Member 'AFortDamageNumbersActor::FontXSize' has a wrong offset!");
static_assert(offsetof(AFortDamageNumbersActor, FontYSize) == 0x000494, "Member 'AFortDamageNumbersActor::FontYSize' has a wrong offset!");
static_assert(offsetof(AFortDamageNumbersActor, NumberOfNumberRotations) == 0x000498, "Member 'AFortDamageNumbersActor::NumberOfNumberRotations' has a wrong offset!");
static_assert(offsetof(AFortDamageNumbersActor, ScaleRotationAngleParameterNames) == 0x0004A0, "Member 'AFortDamageNumbersActor::ScaleRotationAngleParameterNames' has a wrong offset!");
static_assert(offsetof(AFortDamageNumbersActor, DurationParameterNames) == 0x0004B0, "Member 'AFortDamageNumbersActor::DurationParameterNames' has a wrong offset!");
static_assert(offsetof(AFortDamageNumbersActor, MaxScoreNumberDistance) == 0x0004C0, "Member 'AFortDamageNumbersActor::MaxScoreNumberDistance' has a wrong offset!");
static_assert(offsetof(AFortDamageNumbersActor, PooledComponentsByElement) == 0x0004C8, "Member 'AFortDamageNumbersActor::PooledComponentsByElement' has a wrong offset!");
static_assert(offsetof(AFortDamageNumbersActor, PooledComponentsCritBuildingImpact) == 0x000508, "Member 'AFortDamageNumbersActor::PooledComponentsCritBuildingImpact' has a wrong offset!");
static_assert(offsetof(AFortDamageNumbersActor, PooledComponentsByScoreCategory) == 0x000518, "Member 'AFortDamageNumbersActor::PooledComponentsByScoreCategory' has a wrong offset!");
static_assert(offsetof(AFortDamageNumbersActor, LiveComponents) == 0x000548, "Member 'AFortDamageNumbersActor::LiveComponents' has a wrong offset!");

// Class FortniteGame.FortLightningActor
// 0x0050 (0x03E0 - 0x0390)
class AFortLightningActor final : public AFortClientOnlyActor
{
public:
	int32                                         MaxBoltMeshes;                                     // 0x0390(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxBoltWidth;                                      // 0x0394(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BoltMaterialParamTopPct;                           // 0x0398(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BoltMaterialParamBottomPct;                        // 0x03A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 ActorToNotify;                                     // 0x03A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FVector>                        BoltLocations;                                     // 0x03B0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UStaticMeshComponent*>           BoltMeshes;                                        // 0x03C0(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UMaterialInstanceDynamic*>       BoltMIDs;                                          // 0x03D0(0x0010)(BlueprintVisible, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	void CleanupLightning();
	void GenerateBoltLocations(const struct FVector& StartLocation, const struct FVector& EndLocation, float MinLength, float MaxLength, float RandomVectorContribution, float MinSizeDecayRate, float MaxSizeDecayRate, float FalloffMultiplier);
	void InitializeLightning(class AActor* InActorToNotify);
	void OnLightingCleanup();
	void OnLightingInitialized();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortLightningActor">();
	}
	static class AFortLightningActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortLightningActor>();
	}
};
static_assert(alignof(AFortLightningActor) == 0x000008, "Wrong alignment on AFortLightningActor");
static_assert(sizeof(AFortLightningActor) == 0x0003E0, "Wrong size on AFortLightningActor");
static_assert(offsetof(AFortLightningActor, MaxBoltMeshes) == 0x000390, "Member 'AFortLightningActor::MaxBoltMeshes' has a wrong offset!");
static_assert(offsetof(AFortLightningActor, MaxBoltWidth) == 0x000394, "Member 'AFortLightningActor::MaxBoltWidth' has a wrong offset!");
static_assert(offsetof(AFortLightningActor, BoltMaterialParamTopPct) == 0x000398, "Member 'AFortLightningActor::BoltMaterialParamTopPct' has a wrong offset!");
static_assert(offsetof(AFortLightningActor, BoltMaterialParamBottomPct) == 0x0003A0, "Member 'AFortLightningActor::BoltMaterialParamBottomPct' has a wrong offset!");
static_assert(offsetof(AFortLightningActor, ActorToNotify) == 0x0003A8, "Member 'AFortLightningActor::ActorToNotify' has a wrong offset!");
static_assert(offsetof(AFortLightningActor, BoltLocations) == 0x0003B0, "Member 'AFortLightningActor::BoltLocations' has a wrong offset!");
static_assert(offsetof(AFortLightningActor, BoltMeshes) == 0x0003C0, "Member 'AFortLightningActor::BoltMeshes' has a wrong offset!");
static_assert(offsetof(AFortLightningActor, BoltMIDs) == 0x0003D0, "Member 'AFortLightningActor::BoltMIDs' has a wrong offset!");

// Class FortniteGame.FortTracerBase
// 0x0080 (0x0410 - 0x0390)
class AFortTracerBase : public AFortClientOnlyActor
{
public:
	class UMovementComp_Tracer*                   TracerMovementComponent;                           // 0x0390(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   TracerMesh;                                        // 0x0398(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FCurveTableRowHandle                   Speed;                                             // 0x03A0(0x0010)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         SpeedScaleMinRange;                                // 0x03B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpeedScaleMaxRange;                                // 0x03B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpeedScaleMinMultiplier;                           // 0x03B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpeedScaleMaxMultiplier;                           // 0x03BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                MeshScaleMult;                                     // 0x03C0(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MeshScaleTime;                                     // 0x03CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bScaleOnDeath : 1;                                 // 0x03D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bScaleSpeed : 1;                                   // 0x03D0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bScaledUp : 1;                                     // 0x03D0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDead : 1;                                         // 0x03D0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bOwnedByPool : 1;                                  // 0x03D0(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_3D1[0x33];                                     // 0x03D1(0x0033)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentScale;                                      // 0x0404(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_408[0x8];                                      // 0x0408(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(const struct FVector& Start, const struct FVector& End);
	void OnInit(const struct FVector& Start, const struct FVector& End);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTracerBase">();
	}
	static class AFortTracerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortTracerBase>();
	}
};
static_assert(alignof(AFortTracerBase) == 0x000008, "Wrong alignment on AFortTracerBase");
static_assert(sizeof(AFortTracerBase) == 0x000410, "Wrong size on AFortTracerBase");
static_assert(offsetof(AFortTracerBase, TracerMovementComponent) == 0x000390, "Member 'AFortTracerBase::TracerMovementComponent' has a wrong offset!");
static_assert(offsetof(AFortTracerBase, TracerMesh) == 0x000398, "Member 'AFortTracerBase::TracerMesh' has a wrong offset!");
static_assert(offsetof(AFortTracerBase, Speed) == 0x0003A0, "Member 'AFortTracerBase::Speed' has a wrong offset!");
static_assert(offsetof(AFortTracerBase, SpeedScaleMinRange) == 0x0003B0, "Member 'AFortTracerBase::SpeedScaleMinRange' has a wrong offset!");
static_assert(offsetof(AFortTracerBase, SpeedScaleMaxRange) == 0x0003B4, "Member 'AFortTracerBase::SpeedScaleMaxRange' has a wrong offset!");
static_assert(offsetof(AFortTracerBase, SpeedScaleMinMultiplier) == 0x0003B8, "Member 'AFortTracerBase::SpeedScaleMinMultiplier' has a wrong offset!");
static_assert(offsetof(AFortTracerBase, SpeedScaleMaxMultiplier) == 0x0003BC, "Member 'AFortTracerBase::SpeedScaleMaxMultiplier' has a wrong offset!");
static_assert(offsetof(AFortTracerBase, MeshScaleMult) == 0x0003C0, "Member 'AFortTracerBase::MeshScaleMult' has a wrong offset!");
static_assert(offsetof(AFortTracerBase, MeshScaleTime) == 0x0003CC, "Member 'AFortTracerBase::MeshScaleTime' has a wrong offset!");
static_assert(offsetof(AFortTracerBase, CurrentScale) == 0x000404, "Member 'AFortTracerBase::CurrentScale' has a wrong offset!");

// Class FortniteGame.FortCollectionBookManager
// 0x01F0 (0x0218 - 0x0028)
class UFortCollectionBookManager final : public UObject
{
public:
	UMulticastDelegateProperty_                   OnSlottedItemOperationComplete;                    // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnSlotItemComplete;                                // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnRewardClaimed;                                   // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0xF0];                                      // 0x0058(0x00F0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFortPendingSlottedItemOperation> PendingSlottedItems;                               // 0x0148(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FFortPendingSlottedItemOperation> PendingUpdatedItems;                               // 0x0158(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_168[0x8];                                      // 0x0168(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class UFortMcpProfileCollectionBook*> ProfileTable;                                      // 0x0170(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TSet<class FName>                             ActivePages;                                       // 0x01C0(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_210[0x8];                                      // 0x0210(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClaimReward(const struct FFortCollectionBookRewards& RewardToClaim, int32 RewardIndex);
	void PopulateCollectionBookRewards(TArray<struct FFortCollectionBookRewards>* OutAvailableRewards);
	bool SlotItem(const class UFortAccountItem* Item, class FName SlotId);

	int32 CalculateBookXp() const;
	int32 CalculatePageXp(class FName PageId) const;
	bool CanSlotItem(const class UFortAccountItem* AccountItem) const;
	int32 GetBookTotalXPToNextLevel(int32 CurrentLevel) const;
	float GetBookXPPercentToNextLevel(int32 CurrentLevel, int32 NewXP) const;
	class UFortItem* GetItemInSlot(class FName SlotId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCollectionBookManager">();
	}
	static class UFortCollectionBookManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCollectionBookManager>();
	}
};
static_assert(alignof(UFortCollectionBookManager) == 0x000008, "Wrong alignment on UFortCollectionBookManager");
static_assert(sizeof(UFortCollectionBookManager) == 0x000218, "Wrong size on UFortCollectionBookManager");
static_assert(offsetof(UFortCollectionBookManager, OnSlottedItemOperationComplete) == 0x000028, "Member 'UFortCollectionBookManager::OnSlottedItemOperationComplete' has a wrong offset!");
static_assert(offsetof(UFortCollectionBookManager, OnSlotItemComplete) == 0x000038, "Member 'UFortCollectionBookManager::OnSlotItemComplete' has a wrong offset!");
static_assert(offsetof(UFortCollectionBookManager, OnRewardClaimed) == 0x000048, "Member 'UFortCollectionBookManager::OnRewardClaimed' has a wrong offset!");
static_assert(offsetof(UFortCollectionBookManager, PendingSlottedItems) == 0x000148, "Member 'UFortCollectionBookManager::PendingSlottedItems' has a wrong offset!");
static_assert(offsetof(UFortCollectionBookManager, PendingUpdatedItems) == 0x000158, "Member 'UFortCollectionBookManager::PendingUpdatedItems' has a wrong offset!");
static_assert(offsetof(UFortCollectionBookManager, ProfileTable) == 0x000170, "Member 'UFortCollectionBookManager::ProfileTable' has a wrong offset!");
static_assert(offsetof(UFortCollectionBookManager, ActivePages) == 0x0001C0, "Member 'UFortCollectionBookManager::ActivePages' has a wrong offset!");

// Class FortniteGame.FortCollectionBookSection
// 0x0010 (0x0038 - 0x0028)
class UFortCollectionBookSection final : public UObject
{
public:
	class FName                                   SectionDataRowName;                                // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortCollectionBookPage*                OwningPage;                                        // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCollectionBookSection">();
	}
	static class UFortCollectionBookSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCollectionBookSection>();
	}
};
static_assert(alignof(UFortCollectionBookSection) == 0x000008, "Wrong alignment on UFortCollectionBookSection");
static_assert(sizeof(UFortCollectionBookSection) == 0x000038, "Wrong size on UFortCollectionBookSection");
static_assert(offsetof(UFortCollectionBookSection, SectionDataRowName) == 0x000028, "Member 'UFortCollectionBookSection::SectionDataRowName' has a wrong offset!");
static_assert(offsetof(UFortCollectionBookSection, OwningPage) == 0x000030, "Member 'UFortCollectionBookSection::OwningPage' has a wrong offset!");

// Class FortniteGame.FortDateTimeLibrary
// 0x0000 (0x0028 - 0x0028)
class UFortDateTimeLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FTimespan GetPlayerControllerUtcNowMcpOffset(class AFortPlayerController* FortPC);
	static struct FTimespan GetPlayerUtcNowMcpOffset(class UFortLocalPlayer* LocalPlayer);
	static class FText GetTimespanAsText(const struct FTimespan& Timespan, bool bShowSeconds, ETimespanAsTextFormat FormatType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDateTimeLibrary">();
	}
	static class UFortDateTimeLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDateTimeLibrary>();
	}
};
static_assert(alignof(UFortDateTimeLibrary) == 0x000008, "Wrong alignment on UFortDateTimeLibrary");
static_assert(sizeof(UFortDateTimeLibrary) == 0x000028, "Wrong size on UFortDateTimeLibrary");

// Class FortniteGame.FortDecoPreview_MeshHarvester
// 0x0000 (0x0530 - 0x0530)
class AFortDecoPreview_MeshHarvester final : public AFortDecoPreview_ComponentHarvester
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDecoPreview_MeshHarvester">();
	}
	static class AFortDecoPreview_MeshHarvester* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortDecoPreview_MeshHarvester>();
	}
};
static_assert(alignof(AFortDecoPreview_MeshHarvester) == 0x000010, "Wrong alignment on AFortDecoPreview_MeshHarvester");
static_assert(sizeof(AFortDecoPreview_MeshHarvester) == 0x000530, "Wrong size on AFortDecoPreview_MeshHarvester");

// Class FortniteGame.FortTrackPreview
// 0x0040 (0x0570 - 0x0530)
class AFortTrackPreview final : public AFortDecoPreview
{
public:
	class UStaticMesh*                            TrackPieceMeshesByType[0x5];                       // 0x0530(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CellSize;                                          // 0x0558(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55C[0x4];                                      // 0x055C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   TrackMeshComp;                                     // 0x0560(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_568[0x8];                                      // 0x0568(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeTrackPreview(class UStaticMeshComponent* InTrackMeshComp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTrackPreview">();
	}
	static class AFortTrackPreview* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortTrackPreview>();
	}
};
static_assert(alignof(AFortTrackPreview) == 0x000010, "Wrong alignment on AFortTrackPreview");
static_assert(sizeof(AFortTrackPreview) == 0x000570, "Wrong size on AFortTrackPreview");
static_assert(offsetof(AFortTrackPreview, TrackPieceMeshesByType) == 0x000530, "Member 'AFortTrackPreview::TrackPieceMeshesByType' has a wrong offset!");
static_assert(offsetof(AFortTrackPreview, CellSize) == 0x000558, "Member 'AFortTrackPreview::CellSize' has a wrong offset!");
static_assert(offsetof(AFortTrackPreview, TrackMeshComp) == 0x000560, "Member 'AFortTrackPreview::TrackMeshComp' has a wrong offset!");

// Class FortniteGame.FortDeployableBaseLibrary
// 0x0000 (0x0028 - 0x0028)
class UFortDeployableBaseLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ApplyTieredModifierSet(class UObject* WorldContextObject, const TArray<struct FTieredModifierSetData>& ModifierSetData, int32 Tier, int32 WaveNum, TArray<struct FActiveGameplayModifierHandle>* OutAppliedModifiers);
	static void BroadcastHordeTierComplete(class UObject* WorldContextObject, EFortCompletionResult Result);
	static void ForceClearAllDefenders(class UObject* WorldContextObject);
	static void ForceDeployableBaseHordePlayersToResetAndRespawn(class UObject* WorldContextObject);
	static void ForceRestartDeployableBasePlayers(class UObject* WorldContextObject, bool bRestartInvulnerable);
	static struct FGameDifficultyInfo GetGameDifficultyInfo(const class FName& RowName);
	static EHordeTierStartStatus GetHordeTierStartStatus(class UObject* WorldContextObject);
	static class AFortMission* GetPrimaryHordeMission(class UObject* WorldContextObject);
	static void GetTieredModifierSet(class FName TieredModifierSetName, TArray<struct FTieredModifierSetData>* OutModifierSetData);
	static void GrantPlayersCompletedWaveRewards(class UObject* WorldContextObject, int32 Tier, int32 Wave, int32 NumberOfPlayers, const TArray<class ADeployableBaseCore*>& TargetCores, const TArray<class ADeployableBaseCore*>& AllCores, const struct FFortTierCollectionLayoutOutput& CollectionData, const TArray<class FName>& TierGroups);
	static bool IsWorldItemDefValidToPersistForDeployableBasePlayerInventory(const class UFortWorldItemDefinition* ItemDefinition);
	static void OnPreHordeTierStart(class UObject* WorldContextObject, int32 Tier, int32 ModifierRRVSeed);
	static void ResetDeployableBaseHordePlayerInventories(class UObject* WorldContextObject);
	static void SetDeployableBaseMatchJoinability(class UObject* WorldContextObject, bool bMatchJoinable);
	static void SetupDeployableBaseCombatZoneInventoriesOnPlayers(class UObject* WorldContextObject, const TArray<class FName>& TierGroups, const TArray<class AFortPlayerController*>& PlayerControllers);
	static void UpdateDeployableBaseTierProgressionForPlayers(class UObject* WorldContextObject, const class UFortTieredCollectionLayout* CollectionLayout, int32 TierDefeated);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDeployableBaseLibrary">();
	}
	static class UFortDeployableBaseLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDeployableBaseLibrary>();
	}
};
static_assert(alignof(UFortDeployableBaseLibrary) == 0x000008, "Wrong alignment on UFortDeployableBaseLibrary");
static_assert(sizeof(UFortDeployableBaseLibrary) == 0x000028, "Wrong size on UFortDeployableBaseLibrary");

// Class FortniteGame.FortMissionTimerInterface
// 0x0000 (0x0028 - 0x0028)
class IFortMissionTimerInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMissionTimerInterface">();
	}
	static class IFortMissionTimerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortMissionTimerInterface>();
	}
};
static_assert(alignof(IFortMissionTimerInterface) == 0x000008, "Wrong alignment on IFortMissionTimerInterface");
static_assert(sizeof(IFortMissionTimerInterface) == 0x000028, "Wrong size on IFortMissionTimerInterface");

// Class FortniteGame.WorldTileManager
// 0x0058 (0x0080 - 0x0028)
class UWorldTileManager final : public UObject
{
public:
	class AFortWorldManager*                      WorldManager;                                      // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldTileManager">();
	}
	static class UWorldTileManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldTileManager>();
	}
};
static_assert(alignof(UWorldTileManager) == 0x000008, "Wrong alignment on UWorldTileManager");
static_assert(sizeof(UWorldTileManager) == 0x000080, "Wrong size on UWorldTileManager");
static_assert(offsetof(UWorldTileManager, WorldManager) == 0x000028, "Member 'UWorldTileManager::WorldManager' has a wrong offset!");

// Class FortniteGame.FortDeployableBaseCloudSaveItemDefinition
// 0x0010 (0x0240 - 0x0230)
class UFortDeployableBaseCloudSaveItemDefinition final : public UFortCloudSaveItemDefinition
{
public:
	struct FGuid                                  SaveFilenameGUID;                                  // 0x0228(0x0010)(Edit, EditConst, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_238[0x8];                                      // 0x0238(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDeployableBaseCloudSaveItemDefinition">();
	}
	static class UFortDeployableBaseCloudSaveItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDeployableBaseCloudSaveItemDefinition>();
	}
};
static_assert(alignof(UFortDeployableBaseCloudSaveItemDefinition) == 0x000010, "Wrong alignment on UFortDeployableBaseCloudSaveItemDefinition");
static_assert(sizeof(UFortDeployableBaseCloudSaveItemDefinition) == 0x000240, "Wrong size on UFortDeployableBaseCloudSaveItemDefinition");
static_assert(offsetof(UFortDeployableBaseCloudSaveItemDefinition, SaveFilenameGUID) == 0x000228, "Member 'UFortDeployableBaseCloudSaveItemDefinition::SaveFilenameGUID' has a wrong offset!");

// Class FortniteGame.FortDeployableBaseSkillTreeUnlocks
// 0x0040 (0x0068 - 0x0028)
class UFortDeployableBaseSkillTreeUnlocks final : public UDataAsset
{
public:
	TArray<struct FFortTaggedDeployableBasePlotExpansionUnlock> PlotSizeUnlocks;                                   // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortTaggedDeployableBaseLootUnlock> NeighborhoodLootGrantUnlocks;                      // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortTaggedDeployableBaseLootUnlock> CombatZoneStartLootGrantUnlocks;                   // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortTaggedDeployableBaseLootUnlock> CombatZoneWaveCompleteLootGrantUnlocks;            // 0x0058(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDeployableBaseSkillTreeUnlocks">();
	}
	static class UFortDeployableBaseSkillTreeUnlocks* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDeployableBaseSkillTreeUnlocks>();
	}
};
static_assert(alignof(UFortDeployableBaseSkillTreeUnlocks) == 0x000008, "Wrong alignment on UFortDeployableBaseSkillTreeUnlocks");
static_assert(sizeof(UFortDeployableBaseSkillTreeUnlocks) == 0x000068, "Wrong size on UFortDeployableBaseSkillTreeUnlocks");
static_assert(offsetof(UFortDeployableBaseSkillTreeUnlocks, PlotSizeUnlocks) == 0x000028, "Member 'UFortDeployableBaseSkillTreeUnlocks::PlotSizeUnlocks' has a wrong offset!");
static_assert(offsetof(UFortDeployableBaseSkillTreeUnlocks, NeighborhoodLootGrantUnlocks) == 0x000038, "Member 'UFortDeployableBaseSkillTreeUnlocks::NeighborhoodLootGrantUnlocks' has a wrong offset!");
static_assert(offsetof(UFortDeployableBaseSkillTreeUnlocks, CombatZoneStartLootGrantUnlocks) == 0x000048, "Member 'UFortDeployableBaseSkillTreeUnlocks::CombatZoneStartLootGrantUnlocks' has a wrong offset!");
static_assert(offsetof(UFortDeployableBaseSkillTreeUnlocks, CombatZoneWaveCompleteLootGrantUnlocks) == 0x000058, "Member 'UFortDeployableBaseSkillTreeUnlocks::CombatZoneWaveCompleteLootGrantUnlocks' has a wrong offset!");

// Class FortniteGame.FortDeployableBaseManager
// 0x02C8 (0x0650 - 0x0388)
class AFortDeployableBaseManager final : public AInfo
{
public:
	uint8                                         bRestrictedBuildingActive : 1;                     // 0x0388(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bBusyWithPlotActions : 1;                          // 0x0388(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDestroyAllBuildingPiecesOnReload : 1;             // 0x0388(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_389[0x3];                                      // 0x0389(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumPiecesDestroyedOnZoneCleanupPerUpdate;          // 0x038C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumEnvPiecesRestoredPerUpdate;                     // 0x0390(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDeployableBasesReadOnly;                          // 0x0394(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDeployableBaseUseType                        DeployableBaseUseType;                             // 0x0395(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_396[0x2];                                      // 0x0396(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FActiveTieredCollectionLayoutArray     ActiveTieredCollectionLayouts;                     // 0x0398(0x00C8)(Net, Transient, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnDeployableBasePlotsSpawned;                      // 0x0460(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnLocalPlayerEntersDeployablePlotEvent;            // 0x0470(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnLocalPlayerLeavesDeployablePlotEvent;            // 0x0480(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnLocalDeployablePlotInventoryChangedEvent;        // 0x0490(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	struct FDeployableBaseArray                   DeployableBaseArray;                               // 0x04A0(0x00C0)(Net, Transient, NativeAccessSpecifierPrivate)
	class UFortDeployableBaseCloudSaveItemDefinition* DeployableBaseItemDefinition;                      // 0x0560(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ADeployableBasePlot>        DeployableBasePlotClass;                           // 0x0568(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortDeployableBaseSkillTreeUnlocks*    SupportedSkillTreeBasedUnlocks;                    // 0x0570(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         NumExpectedPlots;                                  // 0x0578(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_57C[0x4];                                      // 0x057C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPendingDeployableBaseUser>     PendingUsers;                                      // 0x0580(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FPendingDeployableManagerAction> PendingDeployableManagerActions;                   // 0x0590(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FEnvironmentBuildingRestorationRecord> EnvironmentActorsRequiringRestoration;             // 0x05A0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         bCaptureEnvironmentActorsForRestoration : 1;       // 0x05B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bWorldInitialized : 1;                             // 0x05B0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bKeepBasesOnLogout : 1;                            // 0x05B0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_5B1[0x7];                                      // 0x05B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUniqueNetIdRepl>               PlayersPendingPlotReset;                           // 0x05B8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C8[0x88];                                     // 0x05C8(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class AFortDeployableBaseManager* GetCurrent(class UObject* WorldContextObject);

	void ReloadAllPlots();
	void SetKeepDeployableBasesOnLogout(bool bInKeepBasesOnLogout);

	void BroadcastHordeWaveStinger(EHordeWaveStingerType StingerType) const;
	void GetAllDeployableBasePlots(TArray<class ADeployableBasePlot*>* OutDeployableBasePlots) const;
	void GetAvailableTiers(TArray<struct FAvailableTierLayout>* OutAvailableTiers) const;
	class ADeployableBasePlot* GetDeployableBasePlotFromLocation(const struct FVector& Location) const;
	EDeployableBaseUseType GetDeployableBaseUseType() const;
	int32 GetHighestDefeatedTierForPlayerAndLayout(const struct FUniqueNetIdRepl& PlayerID, const class UFortTieredCollectionLayout* Layout) const;
	bool GetTierOutputForSelectedTier(int32 Tier, const class UFortTieredCollectionLayout* Layout, struct FFortTierCollectionLayoutOutput* Output) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDeployableBaseManager">();
	}
	static class AFortDeployableBaseManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortDeployableBaseManager>();
	}
};
static_assert(alignof(AFortDeployableBaseManager) == 0x000008, "Wrong alignment on AFortDeployableBaseManager");
static_assert(sizeof(AFortDeployableBaseManager) == 0x000650, "Wrong size on AFortDeployableBaseManager");
static_assert(offsetof(AFortDeployableBaseManager, NumPiecesDestroyedOnZoneCleanupPerUpdate) == 0x00038C, "Member 'AFortDeployableBaseManager::NumPiecesDestroyedOnZoneCleanupPerUpdate' has a wrong offset!");
static_assert(offsetof(AFortDeployableBaseManager, NumEnvPiecesRestoredPerUpdate) == 0x000390, "Member 'AFortDeployableBaseManager::NumEnvPiecesRestoredPerUpdate' has a wrong offset!");
static_assert(offsetof(AFortDeployableBaseManager, bDeployableBasesReadOnly) == 0x000394, "Member 'AFortDeployableBaseManager::bDeployableBasesReadOnly' has a wrong offset!");
static_assert(offsetof(AFortDeployableBaseManager, DeployableBaseUseType) == 0x000395, "Member 'AFortDeployableBaseManager::DeployableBaseUseType' has a wrong offset!");
static_assert(offsetof(AFortDeployableBaseManager, ActiveTieredCollectionLayouts) == 0x000398, "Member 'AFortDeployableBaseManager::ActiveTieredCollectionLayouts' has a wrong offset!");
static_assert(offsetof(AFortDeployableBaseManager, OnDeployableBasePlotsSpawned) == 0x000460, "Member 'AFortDeployableBaseManager::OnDeployableBasePlotsSpawned' has a wrong offset!");
static_assert(offsetof(AFortDeployableBaseManager, OnLocalPlayerEntersDeployablePlotEvent) == 0x000470, "Member 'AFortDeployableBaseManager::OnLocalPlayerEntersDeployablePlotEvent' has a wrong offset!");
static_assert(offsetof(AFortDeployableBaseManager, OnLocalPlayerLeavesDeployablePlotEvent) == 0x000480, "Member 'AFortDeployableBaseManager::OnLocalPlayerLeavesDeployablePlotEvent' has a wrong offset!");
static_assert(offsetof(AFortDeployableBaseManager, OnLocalDeployablePlotInventoryChangedEvent) == 0x000490, "Member 'AFortDeployableBaseManager::OnLocalDeployablePlotInventoryChangedEvent' has a wrong offset!");
static_assert(offsetof(AFortDeployableBaseManager, DeployableBaseArray) == 0x0004A0, "Member 'AFortDeployableBaseManager::DeployableBaseArray' has a wrong offset!");
static_assert(offsetof(AFortDeployableBaseManager, DeployableBaseItemDefinition) == 0x000560, "Member 'AFortDeployableBaseManager::DeployableBaseItemDefinition' has a wrong offset!");
static_assert(offsetof(AFortDeployableBaseManager, DeployableBasePlotClass) == 0x000568, "Member 'AFortDeployableBaseManager::DeployableBasePlotClass' has a wrong offset!");
static_assert(offsetof(AFortDeployableBaseManager, SupportedSkillTreeBasedUnlocks) == 0x000570, "Member 'AFortDeployableBaseManager::SupportedSkillTreeBasedUnlocks' has a wrong offset!");
static_assert(offsetof(AFortDeployableBaseManager, NumExpectedPlots) == 0x000578, "Member 'AFortDeployableBaseManager::NumExpectedPlots' has a wrong offset!");
static_assert(offsetof(AFortDeployableBaseManager, PendingUsers) == 0x000580, "Member 'AFortDeployableBaseManager::PendingUsers' has a wrong offset!");
static_assert(offsetof(AFortDeployableBaseManager, PendingDeployableManagerActions) == 0x000590, "Member 'AFortDeployableBaseManager::PendingDeployableManagerActions' has a wrong offset!");
static_assert(offsetof(AFortDeployableBaseManager, EnvironmentActorsRequiringRestoration) == 0x0005A0, "Member 'AFortDeployableBaseManager::EnvironmentActorsRequiringRestoration' has a wrong offset!");
static_assert(offsetof(AFortDeployableBaseManager, PlayersPendingPlotReset) == 0x0005B8, "Member 'AFortDeployableBaseManager::PlayersPendingPlotReset' has a wrong offset!");

// Class FortniteGame.FortDeveloperSettings
// 0x0000 (0x0038 - 0x0038)
class UFortDeveloperSettings final : public UDeveloperSettings
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDeveloperSettings">();
	}
	static class UFortDeveloperSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDeveloperSettings>();
	}
};
static_assert(alignof(UFortDeveloperSettings) == 0x000008, "Wrong alignment on UFortDeveloperSettings");
static_assert(sizeof(UFortDeveloperSettings) == 0x000038, "Wrong size on UFortDeveloperSettings");

// Class FortniteGame.FortDifficultyOptionEncounter_DirectionChange
// 0x0008 (0x0050 - 0x0048)
class UFortDifficultyOptionEncounter_DirectionChange final : public UFortDifficultyOptionEncounter
{
public:
	bool                                          bChangeDirectionsOnRest;                           // 0x0048(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionEncounter_DirectionChange">();
	}
	static class UFortDifficultyOptionEncounter_DirectionChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionEncounter_DirectionChange>();
	}
};
static_assert(alignof(UFortDifficultyOptionEncounter_DirectionChange) == 0x000008, "Wrong alignment on UFortDifficultyOptionEncounter_DirectionChange");
static_assert(sizeof(UFortDifficultyOptionEncounter_DirectionChange) == 0x000050, "Wrong size on UFortDifficultyOptionEncounter_DirectionChange");
static_assert(offsetof(UFortDifficultyOptionEncounter_DirectionChange, bChangeDirectionsOnRest) == 0x000048, "Member 'UFortDifficultyOptionEncounter_DirectionChange::bChangeDirectionsOnRest' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionEncounter_IntensityCurveSequence
// 0x0008 (0x0050 - 0x0048)
class UFortDifficultyOptionEncounter_IntensityCurveSequence final : public UFortDifficultyOptionEncounter
{
public:
	class UFortIntensityCurveSequence*            CurveSequence;                                     // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionEncounter_IntensityCurveSequence">();
	}
	static class UFortDifficultyOptionEncounter_IntensityCurveSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionEncounter_IntensityCurveSequence>();
	}
};
static_assert(alignof(UFortDifficultyOptionEncounter_IntensityCurveSequence) == 0x000008, "Wrong alignment on UFortDifficultyOptionEncounter_IntensityCurveSequence");
static_assert(sizeof(UFortDifficultyOptionEncounter_IntensityCurveSequence) == 0x000050, "Wrong size on UFortDifficultyOptionEncounter_IntensityCurveSequence");
static_assert(offsetof(UFortDifficultyOptionEncounter_IntensityCurveSequence, CurveSequence) == 0x000048, "Member 'UFortDifficultyOptionEncounter_IntensityCurveSequence::CurveSequence' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionEncounter_PawnNumberCap
// 0x0018 (0x0060 - 0x0048)
class UFortDifficultyOptionEncounter_PawnNumberCap final : public UFortDifficultyOptionEncounter
{
public:
	struct FFortEncounterPawnNumberCaps           PawnCapsPerPlayerCount;                            // 0x0048(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionEncounter_PawnNumberCap">();
	}
	static class UFortDifficultyOptionEncounter_PawnNumberCap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionEncounter_PawnNumberCap>();
	}
};
static_assert(alignof(UFortDifficultyOptionEncounter_PawnNumberCap) == 0x000008, "Wrong alignment on UFortDifficultyOptionEncounter_PawnNumberCap");
static_assert(sizeof(UFortDifficultyOptionEncounter_PawnNumberCap) == 0x000060, "Wrong size on UFortDifficultyOptionEncounter_PawnNumberCap");
static_assert(offsetof(UFortDifficultyOptionEncounter_PawnNumberCap, PawnCapsPerPlayerCount) == 0x000048, "Member 'UFortDifficultyOptionEncounter_PawnNumberCap::PawnCapsPerPlayerCount' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionEncounter_SpawnLimitPoints
// 0x0008 (0x0050 - 0x0048)
class UFortDifficultyOptionEncounter_SpawnLimitPoints final : public UFortDifficultyOptionEncounter
{
public:
	float                                         SpawnPointsPercentageLimit;                        // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionEncounter_SpawnLimitPoints">();
	}
	static class UFortDifficultyOptionEncounter_SpawnLimitPoints* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionEncounter_SpawnLimitPoints>();
	}
};
static_assert(alignof(UFortDifficultyOptionEncounter_SpawnLimitPoints) == 0x000008, "Wrong alignment on UFortDifficultyOptionEncounter_SpawnLimitPoints");
static_assert(sizeof(UFortDifficultyOptionEncounter_SpawnLimitPoints) == 0x000050, "Wrong size on UFortDifficultyOptionEncounter_SpawnLimitPoints");
static_assert(offsetof(UFortDifficultyOptionEncounter_SpawnLimitPoints, SpawnPointsPercentageLimit) == 0x000048, "Member 'UFortDifficultyOptionEncounter_SpawnLimitPoints::SpawnPointsPercentageLimit' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionEncounter_SpawnPointsBurst
// 0x0008 (0x0050 - 0x0048)
class UFortDifficultyOptionEncounter_SpawnPointsBurst final : public UFortDifficultyOptionEncounter
{
public:
	float                                         BurstSpawnPointsPercentage;                        // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionEncounter_SpawnPointsBurst">();
	}
	static class UFortDifficultyOptionEncounter_SpawnPointsBurst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionEncounter_SpawnPointsBurst>();
	}
};
static_assert(alignof(UFortDifficultyOptionEncounter_SpawnPointsBurst) == 0x000008, "Wrong alignment on UFortDifficultyOptionEncounter_SpawnPointsBurst");
static_assert(sizeof(UFortDifficultyOptionEncounter_SpawnPointsBurst) == 0x000050, "Wrong size on UFortDifficultyOptionEncounter_SpawnPointsBurst");
static_assert(offsetof(UFortDifficultyOptionEncounter_SpawnPointsBurst, BurstSpawnPointsPercentage) == 0x000048, "Member 'UFortDifficultyOptionEncounter_SpawnPointsBurst::BurstSpawnPointsPercentage' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionEncounter_SpawnPointsCurve
// 0x0008 (0x0050 - 0x0048)
class UFortDifficultyOptionEncounter_SpawnPointsCurve final : public UFortDifficultyOptionEncounter
{
public:
	class UFortSpawnPointsPercentageCurveSequence* CurveSequence;                                     // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionEncounter_SpawnPointsCurve">();
	}
	static class UFortDifficultyOptionEncounter_SpawnPointsCurve* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionEncounter_SpawnPointsCurve>();
	}
};
static_assert(alignof(UFortDifficultyOptionEncounter_SpawnPointsCurve) == 0x000008, "Wrong alignment on UFortDifficultyOptionEncounter_SpawnPointsCurve");
static_assert(sizeof(UFortDifficultyOptionEncounter_SpawnPointsCurve) == 0x000050, "Wrong size on UFortDifficultyOptionEncounter_SpawnPointsCurve");
static_assert(offsetof(UFortDifficultyOptionEncounter_SpawnPointsCurve, CurveSequence) == 0x000048, "Member 'UFortDifficultyOptionEncounter_SpawnPointsCurve::CurveSequence' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionEncounter_Time
// 0x0008 (0x0050 - 0x0048)
class UFortDifficultyOptionEncounter_Time final : public UFortDifficultyOptionEncounter
{
public:
	float                                         EncounterTimeSeconds;                              // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionEncounter_Time">();
	}
	static class UFortDifficultyOptionEncounter_Time* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionEncounter_Time>();
	}
};
static_assert(alignof(UFortDifficultyOptionEncounter_Time) == 0x000008, "Wrong alignment on UFortDifficultyOptionEncounter_Time");
static_assert(sizeof(UFortDifficultyOptionEncounter_Time) == 0x000050, "Wrong size on UFortDifficultyOptionEncounter_Time");
static_assert(offsetof(UFortDifficultyOptionEncounter_Time, EncounterTimeSeconds) == 0x000048, "Member 'UFortDifficultyOptionEncounter_Time::EncounterTimeSeconds' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionMission
// 0x0000 (0x0040 - 0x0040)
class UFortDifficultyOptionMission final : public UFortDifficultyOption
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionMission">();
	}
	static class UFortDifficultyOptionMission* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionMission>();
	}
};
static_assert(alignof(UFortDifficultyOptionMission) == 0x000008, "Wrong alignment on UFortDifficultyOptionMission");
static_assert(sizeof(UFortDifficultyOptionMission) == 0x000040, "Wrong size on UFortDifficultyOptionMission");

// Class FortniteGame.FortDifficultyOptionCategoryEncounter_Breathers
// 0x0010 (0x0040 - 0x0030)
class UFortDifficultyOptionCategoryEncounter_Breathers final : public UFortDifficultyOptionCategoryEncounter
{
public:
	TArray<TSubclassOf<class UFortDifficultyOptionEncounter_Breathers>> Options;                                           // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionCategoryEncounter_Breathers">();
	}
	static class UFortDifficultyOptionCategoryEncounter_Breathers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionCategoryEncounter_Breathers>();
	}
};
static_assert(alignof(UFortDifficultyOptionCategoryEncounter_Breathers) == 0x000008, "Wrong alignment on UFortDifficultyOptionCategoryEncounter_Breathers");
static_assert(sizeof(UFortDifficultyOptionCategoryEncounter_Breathers) == 0x000040, "Wrong size on UFortDifficultyOptionCategoryEncounter_Breathers");
static_assert(offsetof(UFortDifficultyOptionCategoryEncounter_Breathers, Options) == 0x000030, "Member 'UFortDifficultyOptionCategoryEncounter_Breathers::Options' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionCategoryEncounter_DirectionChange
// 0x0010 (0x0040 - 0x0030)
class UFortDifficultyOptionCategoryEncounter_DirectionChange final : public UFortDifficultyOptionCategoryEncounter
{
public:
	TArray<TSubclassOf<class UFortDifficultyOptionEncounter_DirectionChange>> Options;                                           // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionCategoryEncounter_DirectionChange">();
	}
	static class UFortDifficultyOptionCategoryEncounter_DirectionChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionCategoryEncounter_DirectionChange>();
	}
};
static_assert(alignof(UFortDifficultyOptionCategoryEncounter_DirectionChange) == 0x000008, "Wrong alignment on UFortDifficultyOptionCategoryEncounter_DirectionChange");
static_assert(sizeof(UFortDifficultyOptionCategoryEncounter_DirectionChange) == 0x000040, "Wrong size on UFortDifficultyOptionCategoryEncounter_DirectionChange");
static_assert(offsetof(UFortDifficultyOptionCategoryEncounter_DirectionChange, Options) == 0x000030, "Member 'UFortDifficultyOptionCategoryEncounter_DirectionChange::Options' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionCategoryEncounter_DirectionNumber
// 0x0010 (0x0040 - 0x0030)
class UFortDifficultyOptionCategoryEncounter_DirectionNumber final : public UFortDifficultyOptionCategoryEncounter
{
public:
	TArray<TSubclassOf<class UFortDifficultyOptionEncounter_DirectionNumber>> Options;                                           // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionCategoryEncounter_DirectionNumber">();
	}
	static class UFortDifficultyOptionCategoryEncounter_DirectionNumber* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionCategoryEncounter_DirectionNumber>();
	}
};
static_assert(alignof(UFortDifficultyOptionCategoryEncounter_DirectionNumber) == 0x000008, "Wrong alignment on UFortDifficultyOptionCategoryEncounter_DirectionNumber");
static_assert(sizeof(UFortDifficultyOptionCategoryEncounter_DirectionNumber) == 0x000040, "Wrong size on UFortDifficultyOptionCategoryEncounter_DirectionNumber");
static_assert(offsetof(UFortDifficultyOptionCategoryEncounter_DirectionNumber, Options) == 0x000030, "Member 'UFortDifficultyOptionCategoryEncounter_DirectionNumber::Options' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionCategoryEncounter_IntensityCurveSequence
// 0x0010 (0x0040 - 0x0030)
class UFortDifficultyOptionCategoryEncounter_IntensityCurveSequence final : public UFortDifficultyOptionCategoryEncounter
{
public:
	TArray<TSubclassOf<class UFortDifficultyOptionEncounter_IntensityCurveSequence>> Options;                                           // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionCategoryEncounter_IntensityCurveSequence">();
	}
	static class UFortDifficultyOptionCategoryEncounter_IntensityCurveSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionCategoryEncounter_IntensityCurveSequence>();
	}
};
static_assert(alignof(UFortDifficultyOptionCategoryEncounter_IntensityCurveSequence) == 0x000008, "Wrong alignment on UFortDifficultyOptionCategoryEncounter_IntensityCurveSequence");
static_assert(sizeof(UFortDifficultyOptionCategoryEncounter_IntensityCurveSequence) == 0x000040, "Wrong size on UFortDifficultyOptionCategoryEncounter_IntensityCurveSequence");
static_assert(offsetof(UFortDifficultyOptionCategoryEncounter_IntensityCurveSequence, Options) == 0x000030, "Member 'UFortDifficultyOptionCategoryEncounter_IntensityCurveSequence::Options' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionCategoryEncounter_ModifierTags
// 0x0010 (0x0040 - 0x0030)
class UFortDifficultyOptionCategoryEncounter_ModifierTags final : public UFortDifficultyOptionCategoryEncounter
{
public:
	TArray<TSubclassOf<class UFortDifficultyOptionEncounter_ModifierTags>> Options;                                           // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionCategoryEncounter_ModifierTags">();
	}
	static class UFortDifficultyOptionCategoryEncounter_ModifierTags* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionCategoryEncounter_ModifierTags>();
	}
};
static_assert(alignof(UFortDifficultyOptionCategoryEncounter_ModifierTags) == 0x000008, "Wrong alignment on UFortDifficultyOptionCategoryEncounter_ModifierTags");
static_assert(sizeof(UFortDifficultyOptionCategoryEncounter_ModifierTags) == 0x000040, "Wrong size on UFortDifficultyOptionCategoryEncounter_ModifierTags");
static_assert(offsetof(UFortDifficultyOptionCategoryEncounter_ModifierTags, Options) == 0x000030, "Member 'UFortDifficultyOptionCategoryEncounter_ModifierTags::Options' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionCategoryEncounter_PawnNumberCap
// 0x0010 (0x0040 - 0x0030)
class UFortDifficultyOptionCategoryEncounter_PawnNumberCap final : public UFortDifficultyOptionCategoryEncounter
{
public:
	TArray<TSubclassOf<class UFortDifficultyOptionEncounter_PawnNumberCap>> Options;                                           // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionCategoryEncounter_PawnNumberCap">();
	}
	static class UFortDifficultyOptionCategoryEncounter_PawnNumberCap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionCategoryEncounter_PawnNumberCap>();
	}
};
static_assert(alignof(UFortDifficultyOptionCategoryEncounter_PawnNumberCap) == 0x000008, "Wrong alignment on UFortDifficultyOptionCategoryEncounter_PawnNumberCap");
static_assert(sizeof(UFortDifficultyOptionCategoryEncounter_PawnNumberCap) == 0x000040, "Wrong size on UFortDifficultyOptionCategoryEncounter_PawnNumberCap");
static_assert(offsetof(UFortDifficultyOptionCategoryEncounter_PawnNumberCap, Options) == 0x000030, "Member 'UFortDifficultyOptionCategoryEncounter_PawnNumberCap::Options' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionCategoryEncounter_SpawnGroupProgression
// 0x0008 (0x0038 - 0x0030)
class UFortDifficultyOptionCategoryEncounter_SpawnGroupProgression final : public UFortDifficultyOptionCategoryEncounter
{
public:
	TSubclassOf<class UFortDifficultyOptionEncounter_SpawnGroupProgression> SpawnGroupProgression;                             // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionCategoryEncounter_SpawnGroupProgression">();
	}
	static class UFortDifficultyOptionCategoryEncounter_SpawnGroupProgression* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionCategoryEncounter_SpawnGroupProgression>();
	}
};
static_assert(alignof(UFortDifficultyOptionCategoryEncounter_SpawnGroupProgression) == 0x000008, "Wrong alignment on UFortDifficultyOptionCategoryEncounter_SpawnGroupProgression");
static_assert(sizeof(UFortDifficultyOptionCategoryEncounter_SpawnGroupProgression) == 0x000038, "Wrong size on UFortDifficultyOptionCategoryEncounter_SpawnGroupProgression");
static_assert(offsetof(UFortDifficultyOptionCategoryEncounter_SpawnGroupProgression, SpawnGroupProgression) == 0x000030, "Member 'UFortDifficultyOptionCategoryEncounter_SpawnGroupProgression::SpawnGroupProgression' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionCategoryEncounter_SpawnLimitPawns
// 0x0010 (0x0040 - 0x0030)
class UFortDifficultyOptionCategoryEncounter_SpawnLimitPawns final : public UFortDifficultyOptionCategoryEncounter
{
public:
	TArray<TSubclassOf<class UFortDifficultyOptionEncounter_SpawnLimitPawns>> Options;                                           // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionCategoryEncounter_SpawnLimitPawns">();
	}
	static class UFortDifficultyOptionCategoryEncounter_SpawnLimitPawns* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionCategoryEncounter_SpawnLimitPawns>();
	}
};
static_assert(alignof(UFortDifficultyOptionCategoryEncounter_SpawnLimitPawns) == 0x000008, "Wrong alignment on UFortDifficultyOptionCategoryEncounter_SpawnLimitPawns");
static_assert(sizeof(UFortDifficultyOptionCategoryEncounter_SpawnLimitPawns) == 0x000040, "Wrong size on UFortDifficultyOptionCategoryEncounter_SpawnLimitPawns");
static_assert(offsetof(UFortDifficultyOptionCategoryEncounter_SpawnLimitPawns, Options) == 0x000030, "Member 'UFortDifficultyOptionCategoryEncounter_SpawnLimitPawns::Options' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionCategoryEncounter_SpawnLimitPoints
// 0x0010 (0x0040 - 0x0030)
class UFortDifficultyOptionCategoryEncounter_SpawnLimitPoints final : public UFortDifficultyOptionCategoryEncounter
{
public:
	TArray<TSubclassOf<class UFortDifficultyOptionEncounter_SpawnLimitPoints>> Options;                                           // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionCategoryEncounter_SpawnLimitPoints">();
	}
	static class UFortDifficultyOptionCategoryEncounter_SpawnLimitPoints* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionCategoryEncounter_SpawnLimitPoints>();
	}
};
static_assert(alignof(UFortDifficultyOptionCategoryEncounter_SpawnLimitPoints) == 0x000008, "Wrong alignment on UFortDifficultyOptionCategoryEncounter_SpawnLimitPoints");
static_assert(sizeof(UFortDifficultyOptionCategoryEncounter_SpawnLimitPoints) == 0x000040, "Wrong size on UFortDifficultyOptionCategoryEncounter_SpawnLimitPoints");
static_assert(offsetof(UFortDifficultyOptionCategoryEncounter_SpawnLimitPoints, Options) == 0x000030, "Member 'UFortDifficultyOptionCategoryEncounter_SpawnLimitPoints::Options' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionCategoryEncounter_SpawnPointsBurst
// 0x0010 (0x0040 - 0x0030)
class UFortDifficultyOptionCategoryEncounter_SpawnPointsBurst final : public UFortDifficultyOptionCategoryEncounter
{
public:
	TArray<TSubclassOf<class UFortDifficultyOptionEncounter_SpawnPointsBurst>> Options;                                           // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionCategoryEncounter_SpawnPointsBurst">();
	}
	static class UFortDifficultyOptionCategoryEncounter_SpawnPointsBurst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionCategoryEncounter_SpawnPointsBurst>();
	}
};
static_assert(alignof(UFortDifficultyOptionCategoryEncounter_SpawnPointsBurst) == 0x000008, "Wrong alignment on UFortDifficultyOptionCategoryEncounter_SpawnPointsBurst");
static_assert(sizeof(UFortDifficultyOptionCategoryEncounter_SpawnPointsBurst) == 0x000040, "Wrong size on UFortDifficultyOptionCategoryEncounter_SpawnPointsBurst");
static_assert(offsetof(UFortDifficultyOptionCategoryEncounter_SpawnPointsBurst, Options) == 0x000030, "Member 'UFortDifficultyOptionCategoryEncounter_SpawnPointsBurst::Options' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionCategoryEncounter_SpawnPointsMultiplier
// 0x0010 (0x0040 - 0x0030)
class UFortDifficultyOptionCategoryEncounter_SpawnPointsMultiplier final : public UFortDifficultyOptionCategoryEncounter
{
public:
	TArray<TSubclassOf<class UFortDifficultyOptionEncounter_SpawnPointsMultiplier>> Options;                                           // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionCategoryEncounter_SpawnPointsMultiplier">();
	}
	static class UFortDifficultyOptionCategoryEncounter_SpawnPointsMultiplier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionCategoryEncounter_SpawnPointsMultiplier>();
	}
};
static_assert(alignof(UFortDifficultyOptionCategoryEncounter_SpawnPointsMultiplier) == 0x000008, "Wrong alignment on UFortDifficultyOptionCategoryEncounter_SpawnPointsMultiplier");
static_assert(sizeof(UFortDifficultyOptionCategoryEncounter_SpawnPointsMultiplier) == 0x000040, "Wrong size on UFortDifficultyOptionCategoryEncounter_SpawnPointsMultiplier");
static_assert(offsetof(UFortDifficultyOptionCategoryEncounter_SpawnPointsMultiplier, Options) == 0x000030, "Member 'UFortDifficultyOptionCategoryEncounter_SpawnPointsMultiplier::Options' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionCategoryEncounter_SpawnTiming
// 0x0010 (0x0040 - 0x0030)
class UFortDifficultyOptionCategoryEncounter_SpawnTiming final : public UFortDifficultyOptionCategoryEncounter
{
public:
	TArray<TSubclassOf<class UFortDifficultyOptionEncounter_SpawnTiming>> Options;                                           // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionCategoryEncounter_SpawnTiming">();
	}
	static class UFortDifficultyOptionCategoryEncounter_SpawnTiming* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionCategoryEncounter_SpawnTiming>();
	}
};
static_assert(alignof(UFortDifficultyOptionCategoryEncounter_SpawnTiming) == 0x000008, "Wrong alignment on UFortDifficultyOptionCategoryEncounter_SpawnTiming");
static_assert(sizeof(UFortDifficultyOptionCategoryEncounter_SpawnTiming) == 0x000040, "Wrong size on UFortDifficultyOptionCategoryEncounter_SpawnTiming");
static_assert(offsetof(UFortDifficultyOptionCategoryEncounter_SpawnTiming, Options) == 0x000030, "Member 'UFortDifficultyOptionCategoryEncounter_SpawnTiming::Options' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionCategoryEncounter_UtilitiesAdjustment
// 0x0010 (0x0040 - 0x0030)
class UFortDifficultyOptionCategoryEncounter_UtilitiesAdjustment final : public UFortDifficultyOptionCategoryEncounter
{
public:
	TArray<TSubclassOf<class UFortDifficultyOptionEncounter_UtilitiesAdjustment>> Options;                                           // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionCategoryEncounter_UtilitiesAdjustment">();
	}
	static class UFortDifficultyOptionCategoryEncounter_UtilitiesAdjustment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionCategoryEncounter_UtilitiesAdjustment>();
	}
};
static_assert(alignof(UFortDifficultyOptionCategoryEncounter_UtilitiesAdjustment) == 0x000008, "Wrong alignment on UFortDifficultyOptionCategoryEncounter_UtilitiesAdjustment");
static_assert(sizeof(UFortDifficultyOptionCategoryEncounter_UtilitiesAdjustment) == 0x000040, "Wrong size on UFortDifficultyOptionCategoryEncounter_UtilitiesAdjustment");
static_assert(offsetof(UFortDifficultyOptionCategoryEncounter_UtilitiesAdjustment, Options) == 0x000030, "Member 'UFortDifficultyOptionCategoryEncounter_UtilitiesAdjustment::Options' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionCategoryEncounter_UtilitiesFree
// 0x0010 (0x0040 - 0x0030)
class UFortDifficultyOptionCategoryEncounter_UtilitiesFree final : public UFortDifficultyOptionCategoryEncounter
{
public:
	TArray<TSubclassOf<class UFortDifficultyOptionEncounter_UtilitiesFree>> Options;                                           // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionCategoryEncounter_UtilitiesFree">();
	}
	static class UFortDifficultyOptionCategoryEncounter_UtilitiesFree* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionCategoryEncounter_UtilitiesFree>();
	}
};
static_assert(alignof(UFortDifficultyOptionCategoryEncounter_UtilitiesFree) == 0x000008, "Wrong alignment on UFortDifficultyOptionCategoryEncounter_UtilitiesFree");
static_assert(sizeof(UFortDifficultyOptionCategoryEncounter_UtilitiesFree) == 0x000040, "Wrong size on UFortDifficultyOptionCategoryEncounter_UtilitiesFree");
static_assert(offsetof(UFortDifficultyOptionCategoryEncounter_UtilitiesFree, Options) == 0x000030, "Member 'UFortDifficultyOptionCategoryEncounter_UtilitiesFree::Options' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionCategoryEncounter_UtilitiesLocked
// 0x0010 (0x0040 - 0x0030)
class UFortDifficultyOptionCategoryEncounter_UtilitiesLocked final : public UFortDifficultyOptionCategoryEncounter
{
public:
	TArray<TSubclassOf<class UFortDifficultyOptionEncounter_UtilitiesLocked>> Options;                                           // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionCategoryEncounter_UtilitiesLocked">();
	}
	static class UFortDifficultyOptionCategoryEncounter_UtilitiesLocked* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionCategoryEncounter_UtilitiesLocked>();
	}
};
static_assert(alignof(UFortDifficultyOptionCategoryEncounter_UtilitiesLocked) == 0x000008, "Wrong alignment on UFortDifficultyOptionCategoryEncounter_UtilitiesLocked");
static_assert(sizeof(UFortDifficultyOptionCategoryEncounter_UtilitiesLocked) == 0x000040, "Wrong size on UFortDifficultyOptionCategoryEncounter_UtilitiesLocked");
static_assert(offsetof(UFortDifficultyOptionCategoryEncounter_UtilitiesLocked, Options) == 0x000030, "Member 'UFortDifficultyOptionCategoryEncounter_UtilitiesLocked::Options' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionCategoryMission
// 0x0000 (0x0030 - 0x0030)
class UFortDifficultyOptionCategoryMission final : public UFortDifficultyOptionCategory
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionCategoryMission">();
	}
	static class UFortDifficultyOptionCategoryMission* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionCategoryMission>();
	}
};
static_assert(alignof(UFortDifficultyOptionCategoryMission) == 0x000008, "Wrong alignment on UFortDifficultyOptionCategoryMission");
static_assert(sizeof(UFortDifficultyOptionCategoryMission) == 0x000030, "Wrong size on UFortDifficultyOptionCategoryMission");

// Class FortniteGame.FortDifficultyOptionSetEncounter
// 0x00B0 (0x00D8 - 0x0028)
class UFortDifficultyOptionSetEncounter final : public UDataAsset
{
public:
	EFortEncounterPacingMode                      PacingMode;                                        // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortDifficultyOptionCategoryEncounter_IntensityCurveSequence* IntensityCurveSequenceCategory;                    // 0x0030(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortDifficultyOptionCategoryEncounter_SpawnPointsCurve* SpawnPointsPercentageCurveSequenceCategory;        // 0x0038(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortDifficultyOptionCategoryEncounter_SpawnPointsBurst* SpawnPointsBurstCategory;                          // 0x0040(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortDifficultyOptionCategoryEncounter_Breathers* BreathersCategory;                                 // 0x0048(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortDifficultyOptionCategoryEncounter_SpawnPointsMultiplier* SpawnPointsMultiplierCategory;                     // 0x0050(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortDifficultyOptionCategoryEncounter_PawnNumberCap* PawnNumberCapCategory;                             // 0x0058(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortDifficultyOptionCategoryEncounter_SpawnTiming* OptionalSpawnTimingCategory;                       // 0x0060(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortEncounterSpawnLimitType                  SpawnLimitMode;                                    // 0x0068(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortDifficultyOptionCategoryEncounter_SpawnLimitPoints* SpawnPointsLimitCategory;                          // 0x0070(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortDifficultyOptionCategoryEncounter_SpawnLimitPawns* PawnLimitCategory;                                 // 0x0078(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortEncounterUtilitiesMode                   UtilitiesMode;                                     // 0x0080(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortDifficultyOptionCategoryEncounter_UtilitiesLocked* LockedUtilitiesCategory;                           // 0x0088(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortDifficultyOptionCategoryEncounter_UtilitiesFree* FreeUtilitiesCategory;                             // 0x0090(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortDifficultyOptionCategoryEncounter_UtilitiesAdjustment* UtilitiesAdjustmentCategory;                       // 0x0098(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortEncounterSpawnLocationPlacementMode      SpawnLocationPlacementMode;                        // 0x00A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortDifficultyOptionCategoryEncounter_DirectionNumber* DirectionNumberCategory;                           // 0x00A8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortDifficultyOptionCategoryEncounter_DirectionChange* DirectionChangeCategory;                           // 0x00B0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortDifficultyOptionCategoryEncounter_Distance* DistanceCategory;                                  // 0x00B8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortDifficultyOptionCategoryEncounter_SpawnGroupProgression* SpawnGroupProgressionCategory;                     // 0x00C0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortDifficultyOptionCategoryEncounter_Time* TimeCategory;                                      // 0x00C8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortDifficultyOptionCategoryEncounter_ModifierTags* OptionalModifierTagsCategory;                      // 0x00D0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionSetEncounter">();
	}
	static class UFortDifficultyOptionSetEncounter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionSetEncounter>();
	}
};
static_assert(alignof(UFortDifficultyOptionSetEncounter) == 0x000008, "Wrong alignment on UFortDifficultyOptionSetEncounter");
static_assert(sizeof(UFortDifficultyOptionSetEncounter) == 0x0000D8, "Wrong size on UFortDifficultyOptionSetEncounter");
static_assert(offsetof(UFortDifficultyOptionSetEncounter, PacingMode) == 0x000028, "Member 'UFortDifficultyOptionSetEncounter::PacingMode' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionSetEncounter, IntensityCurveSequenceCategory) == 0x000030, "Member 'UFortDifficultyOptionSetEncounter::IntensityCurveSequenceCategory' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionSetEncounter, SpawnPointsPercentageCurveSequenceCategory) == 0x000038, "Member 'UFortDifficultyOptionSetEncounter::SpawnPointsPercentageCurveSequenceCategory' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionSetEncounter, SpawnPointsBurstCategory) == 0x000040, "Member 'UFortDifficultyOptionSetEncounter::SpawnPointsBurstCategory' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionSetEncounter, BreathersCategory) == 0x000048, "Member 'UFortDifficultyOptionSetEncounter::BreathersCategory' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionSetEncounter, SpawnPointsMultiplierCategory) == 0x000050, "Member 'UFortDifficultyOptionSetEncounter::SpawnPointsMultiplierCategory' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionSetEncounter, PawnNumberCapCategory) == 0x000058, "Member 'UFortDifficultyOptionSetEncounter::PawnNumberCapCategory' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionSetEncounter, OptionalSpawnTimingCategory) == 0x000060, "Member 'UFortDifficultyOptionSetEncounter::OptionalSpawnTimingCategory' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionSetEncounter, SpawnLimitMode) == 0x000068, "Member 'UFortDifficultyOptionSetEncounter::SpawnLimitMode' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionSetEncounter, SpawnPointsLimitCategory) == 0x000070, "Member 'UFortDifficultyOptionSetEncounter::SpawnPointsLimitCategory' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionSetEncounter, PawnLimitCategory) == 0x000078, "Member 'UFortDifficultyOptionSetEncounter::PawnLimitCategory' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionSetEncounter, UtilitiesMode) == 0x000080, "Member 'UFortDifficultyOptionSetEncounter::UtilitiesMode' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionSetEncounter, LockedUtilitiesCategory) == 0x000088, "Member 'UFortDifficultyOptionSetEncounter::LockedUtilitiesCategory' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionSetEncounter, FreeUtilitiesCategory) == 0x000090, "Member 'UFortDifficultyOptionSetEncounter::FreeUtilitiesCategory' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionSetEncounter, UtilitiesAdjustmentCategory) == 0x000098, "Member 'UFortDifficultyOptionSetEncounter::UtilitiesAdjustmentCategory' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionSetEncounter, SpawnLocationPlacementMode) == 0x0000A0, "Member 'UFortDifficultyOptionSetEncounter::SpawnLocationPlacementMode' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionSetEncounter, DirectionNumberCategory) == 0x0000A8, "Member 'UFortDifficultyOptionSetEncounter::DirectionNumberCategory' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionSetEncounter, DirectionChangeCategory) == 0x0000B0, "Member 'UFortDifficultyOptionSetEncounter::DirectionChangeCategory' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionSetEncounter, DistanceCategory) == 0x0000B8, "Member 'UFortDifficultyOptionSetEncounter::DistanceCategory' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionSetEncounter, SpawnGroupProgressionCategory) == 0x0000C0, "Member 'UFortDifficultyOptionSetEncounter::SpawnGroupProgressionCategory' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionSetEncounter, TimeCategory) == 0x0000C8, "Member 'UFortDifficultyOptionSetEncounter::TimeCategory' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionSetEncounter, OptionalModifierTagsCategory) == 0x0000D0, "Member 'UFortDifficultyOptionSetEncounter::OptionalModifierTagsCategory' has a wrong offset!");

// Class FortniteGame.FortDoorLinkComponent
// 0x0000 (0x0230 - 0x0230)
class UFortDoorLinkComponent final : public UNavLinkCustomComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDoorLinkComponent">();
	}
	static class UFortDoorLinkComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDoorLinkComponent>();
	}
};
static_assert(alignof(UFortDoorLinkComponent) == 0x000008, "Wrong alignment on UFortDoorLinkComponent");
static_assert(sizeof(UFortDoorLinkComponent) == 0x000230, "Wrong size on UFortDoorLinkComponent");

// Class FortniteGame.FortDynamicBuildingDeconstructor
// 0x0088 (0x0410 - 0x0388)
class AFortDynamicBuildingDeconstructor final : public AActor
{
public:
	struct FBoxSphereBounds                       Bounds;                                            // 0x0388(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bDebugDrawBounds;                                  // 0x03A4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSelectiveDestruction;                             // 0x03A5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreMissionActors;                              // 0x03A6(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShrinkAndDestroyEffect;                           // 0x03A7(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumOfPiecesToDestroyAtOnce;                        // 0x03A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeBetweenChunks;                                 // 0x03AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class ABuildingSMActor>> SortedBuildingActors;                              // 0x03B0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	int32                                         CurrentIndex;                                      // 0x03C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C4[0x4C];                                     // 0x03C4(0x004C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDynamicBuildingDeconstructor">();
	}
	static class AFortDynamicBuildingDeconstructor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortDynamicBuildingDeconstructor>();
	}
};
static_assert(alignof(AFortDynamicBuildingDeconstructor) == 0x000008, "Wrong alignment on AFortDynamicBuildingDeconstructor");
static_assert(sizeof(AFortDynamicBuildingDeconstructor) == 0x000410, "Wrong size on AFortDynamicBuildingDeconstructor");
static_assert(offsetof(AFortDynamicBuildingDeconstructor, Bounds) == 0x000388, "Member 'AFortDynamicBuildingDeconstructor::Bounds' has a wrong offset!");
static_assert(offsetof(AFortDynamicBuildingDeconstructor, bDebugDrawBounds) == 0x0003A4, "Member 'AFortDynamicBuildingDeconstructor::bDebugDrawBounds' has a wrong offset!");
static_assert(offsetof(AFortDynamicBuildingDeconstructor, bSelectiveDestruction) == 0x0003A5, "Member 'AFortDynamicBuildingDeconstructor::bSelectiveDestruction' has a wrong offset!");
static_assert(offsetof(AFortDynamicBuildingDeconstructor, bIgnoreMissionActors) == 0x0003A6, "Member 'AFortDynamicBuildingDeconstructor::bIgnoreMissionActors' has a wrong offset!");
static_assert(offsetof(AFortDynamicBuildingDeconstructor, bShrinkAndDestroyEffect) == 0x0003A7, "Member 'AFortDynamicBuildingDeconstructor::bShrinkAndDestroyEffect' has a wrong offset!");
static_assert(offsetof(AFortDynamicBuildingDeconstructor, NumOfPiecesToDestroyAtOnce) == 0x0003A8, "Member 'AFortDynamicBuildingDeconstructor::NumOfPiecesToDestroyAtOnce' has a wrong offset!");
static_assert(offsetof(AFortDynamicBuildingDeconstructor, TimeBetweenChunks) == 0x0003AC, "Member 'AFortDynamicBuildingDeconstructor::TimeBetweenChunks' has a wrong offset!");
static_assert(offsetof(AFortDynamicBuildingDeconstructor, SortedBuildingActors) == 0x0003B0, "Member 'AFortDynamicBuildingDeconstructor::SortedBuildingActors' has a wrong offset!");
static_assert(offsetof(AFortDynamicBuildingDeconstructor, CurrentIndex) == 0x0003C0, "Member 'AFortDynamicBuildingDeconstructor::CurrentIndex' has a wrong offset!");

// Class FortniteGame.FortEmitterCameraLensEffectDirectional
// 0x0030 (0x0470 - 0x0440)
class AFortEmitterCameraLensEffectDirectional : public AEmitterCameraLensEffectBase
{
public:
	class AFortPawn*                              DamageInstigator;                                  // 0x0440(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DamageInstigatorLocation;                          // 0x0448(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_454[0x4];                                      // 0x0454(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RotationParameterName;                             // 0x0458(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bRotateActor : 1;                                  // 0x0460(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_461[0xF];                                      // 0x0461(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortEmitterCameraLensEffectDirectional">();
	}
	static class AFortEmitterCameraLensEffectDirectional* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortEmitterCameraLensEffectDirectional>();
	}
};
static_assert(alignof(AFortEmitterCameraLensEffectDirectional) == 0x000010, "Wrong alignment on AFortEmitterCameraLensEffectDirectional");
static_assert(sizeof(AFortEmitterCameraLensEffectDirectional) == 0x000470, "Wrong size on AFortEmitterCameraLensEffectDirectional");
static_assert(offsetof(AFortEmitterCameraLensEffectDirectional, DamageInstigator) == 0x000440, "Member 'AFortEmitterCameraLensEffectDirectional::DamageInstigator' has a wrong offset!");
static_assert(offsetof(AFortEmitterCameraLensEffectDirectional, DamageInstigatorLocation) == 0x000448, "Member 'AFortEmitterCameraLensEffectDirectional::DamageInstigatorLocation' has a wrong offset!");
static_assert(offsetof(AFortEmitterCameraLensEffectDirectional, RotationParameterName) == 0x000458, "Member 'AFortEmitterCameraLensEffectDirectional::RotationParameterName' has a wrong offset!");

// Class FortniteGame.FortEngine
// 0x0000 (0x0CE0 - 0x0CE0)
class UFortEngine final : public UGameEngine
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortEngine">();
	}
	static class UFortEngine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortEngine>();
	}
};
static_assert(alignof(UFortEngine) == 0x000008, "Wrong alignment on UFortEngine");
static_assert(sizeof(UFortEngine) == 0x000CE0, "Wrong size on UFortEngine");

// Class FortniteGame.FortItemExhibitActor
// 0x0010 (0x03E0 - 0x03D0)
class AFortItemExhibitActor final : public AFortExhibitActor
{
public:
	class FString                                 ItemInstanceId;                                    // 0x03C8(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFortPickup*                            ExhibitItem;                                       // 0x03D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortItemExhibitActor">();
	}
	static class AFortItemExhibitActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortItemExhibitActor>();
	}
};
static_assert(alignof(AFortItemExhibitActor) == 0x000010, "Wrong alignment on AFortItemExhibitActor");
static_assert(sizeof(AFortItemExhibitActor) == 0x0003E0, "Wrong size on AFortItemExhibitActor");
static_assert(offsetof(AFortItemExhibitActor, ItemInstanceId) == 0x0003C8, "Member 'AFortItemExhibitActor::ItemInstanceId' has a wrong offset!");
static_assert(offsetof(AFortItemExhibitActor, ExhibitItem) == 0x0003D8, "Member 'AFortItemExhibitActor::ExhibitItem' has a wrong offset!");

// Class FortniteGame.FortExpeditionManager
// 0x0010 (0x0038 - 0x0028)
class UFortExpeditionManager final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortExpeditionManager">();
	}
	static class UFortExpeditionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortExpeditionManager>();
	}
};
static_assert(alignof(UFortExpeditionManager) == 0x000008, "Wrong alignment on UFortExpeditionManager");
static_assert(sizeof(UFortExpeditionManager) == 0x000038, "Wrong size on UFortExpeditionManager");

// Class FortniteGame.FortFastLoadConfig
// 0x0008 (0x0030 - 0x0028)
class UFortFastLoadConfig final : public UObject
{
public:
	uint8                                         bDisableStreamInBuildings : 1;                     // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bDisableStartupAIDirector : 1;                     // 0x0028(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bDisableNonDefaultFakeHeroesAtStartup : 1;         // 0x0028(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bDisableUpgradePlayerBuildingClasses : 1;          // 0x0028(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bUseMinimalPlayerBuildingClasses : 1;              // 0x0028(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bDisableStartingMissions : 1;                      // 0x0028(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bUseFastLoadDefaultInventory : 1;                  // 0x0028(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bDisableNavAgentCostData : 1;                      // 0x0028(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bDisableThreatVisualsManager : 1;                  // 0x0029(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bDisablePreLoadAssets : 1;                         // 0x0029(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortFastLoadConfig">();
	}
	static class UFortFastLoadConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortFastLoadConfig>();
	}
};
static_assert(alignof(UFortFastLoadConfig) == 0x000008, "Wrong alignment on UFortFastLoadConfig");
static_assert(sizeof(UFortFastLoadConfig) == 0x000030, "Wrong size on UFortFastLoadConfig");

// Class FortniteGame.FortFoliageSpawnerSet
// 0x0010 (0x0038 - 0x0028)
class UFortFoliageSpawnerSet final : public UDataAsset
{
public:
	TArray<class UProceduralFoliageSpawner*>      FoliageSpawners;                                   // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortFoliageSpawnerSet">();
	}
	static class UFortFoliageSpawnerSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortFoliageSpawnerSet>();
	}
};
static_assert(alignof(UFortFoliageSpawnerSet) == 0x000008, "Wrong alignment on UFortFoliageSpawnerSet");
static_assert(sizeof(UFortFoliageSpawnerSet) == 0x000038, "Wrong size on UFortFoliageSpawnerSet");
static_assert(offsetof(UFortFoliageSpawnerSet, FoliageSpawners) == 0x000028, "Member 'UFortFoliageSpawnerSet::FoliageSpawners' has a wrong offset!");

// Class FortniteGame.FortForcedLODZone
// 0x0008 (0x0390 - 0x0388)
class AFortForcedLODZone final : public AActor
{
public:
	EFortAILODLevel                               ForcedLODLevel;                                    // 0x0388(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_389[0x7];                                      // 0x0389(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortForcedLODZone">();
	}
	static class AFortForcedLODZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortForcedLODZone>();
	}
};
static_assert(alignof(AFortForcedLODZone) == 0x000008, "Wrong alignment on AFortForcedLODZone");
static_assert(sizeof(AFortForcedLODZone) == 0x000390, "Wrong size on AFortForcedLODZone");
static_assert(offsetof(AFortForcedLODZone, ForcedLODLevel) == 0x000388, "Member 'AFortForcedLODZone::ForcedLODLevel' has a wrong offset!");

// Class FortniteGame.PartyDisplayManager
// 0x00A8 (0x0430 - 0x0388)
class APartyDisplayManager : public AActor
{
public:
	TArray<class AActor*>                         PlacementActors;                                   // 0x0388(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class AActor*                                 VaultPlacementActor;                               // 0x0398(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 VaultWeaponPlacementActor;                         // 0x03A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnClickedPartyPlayer;                              // 0x03A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnBeginCursorOverPartyPlayer;                      // 0x03B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnEndCursorOverPartyPlayer;                        // 0x03C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D8[0x58];                                     // 0x03D8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginLoadingAssetsForItem(class UFortItemDefinition* ItemToView, const TArray<TSoftObjectPtr<class UObject>>& AssetsToLoad);
	void HandleLoadingAssetsForItemCompleted(class UFortItemDefinition* ItemWhoseAssetsWereLoaded, const TArray<class UObject*>& LoadedAssets);
	void HideLoading();
	void OnPawnBeginCursorOver(class AActor* TouchedActor);
	void OnPawnClicked(class AActor* TouchedActor, const struct FKey& ButtonPressed);
	void OnPawnEndCursorOver(class AActor* TouchedActor);
	void PlayEvolutionEffect();
	void PlayLevelUpEffect();
	void ShowItem(class UFortItem* ItemToView);
	void ShowLoading();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PartyDisplayManager">();
	}
	static class APartyDisplayManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<APartyDisplayManager>();
	}
};
static_assert(alignof(APartyDisplayManager) == 0x000008, "Wrong alignment on APartyDisplayManager");
static_assert(sizeof(APartyDisplayManager) == 0x000430, "Wrong size on APartyDisplayManager");
static_assert(offsetof(APartyDisplayManager, PlacementActors) == 0x000388, "Member 'APartyDisplayManager::PlacementActors' has a wrong offset!");
static_assert(offsetof(APartyDisplayManager, VaultPlacementActor) == 0x000398, "Member 'APartyDisplayManager::VaultPlacementActor' has a wrong offset!");
static_assert(offsetof(APartyDisplayManager, VaultWeaponPlacementActor) == 0x0003A0, "Member 'APartyDisplayManager::VaultWeaponPlacementActor' has a wrong offset!");
static_assert(offsetof(APartyDisplayManager, OnClickedPartyPlayer) == 0x0003A8, "Member 'APartyDisplayManager::OnClickedPartyPlayer' has a wrong offset!");
static_assert(offsetof(APartyDisplayManager, OnBeginCursorOverPartyPlayer) == 0x0003B8, "Member 'APartyDisplayManager::OnBeginCursorOverPartyPlayer' has a wrong offset!");
static_assert(offsetof(APartyDisplayManager, OnEndCursorOverPartyPlayer) == 0x0003C8, "Member 'APartyDisplayManager::OnEndCursorOverPartyPlayer' has a wrong offset!");

// Class FortniteGame.FortGameInstance
// 0x0618 (0x0700 - 0x00E8)
class UFortGameInstance final : public UGameInstance
{
public:
	uint8                                         Pad_E8[0x1];                                       // 0x00E8(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bBattleRoyaleDuoQueueEnabled;                      // 0x00E9(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EA[0x6];                                       // 0x00EA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         RegionsWithBattleRoyaleDuoQueueDisabled;           // 0x00F0(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	bool                                          bBattleRoyaleSquadQueueEnabled;                    // 0x0100(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         RegionsWithBattleRoyaleSquadQueueDisabled;         // 0x0108(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	class FString                                 AthenaCodeOfConductURL;                            // 0x0118(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TScriptInterface<class IFortUIManagerInterface> UIManagerInterface;                                // 0x0128(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	struct FStringAssetReference                  UIManagerClassPath;                                // 0x0138(0x0010)(Edit, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMcpProfileManager*                     ProfileManager;                                    // 0x0148(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_150[0x10];                                     // 0x0150(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortMatchmaking*                       Matchmaking;                                       // 0x0160(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortMatchmakingV2*                     MatchmakingV2;                                     // 0x0168(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortRejoinCheck*                       RejoinCheck;                                       // 0x0170(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortParty*                             Party;                                             // 0x0178(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_180[0x430];                                    // 0x0180(0x0430)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  GlobalUnregistrationSaveGUID;                      // 0x05B0(0x0010)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C0[0x20];                                     // 0x05C0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortTooltipManager*                    TooltipManager;                                    // 0x05E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E8[0x50];                                     // 0x05E8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UFortRegisteredPlayerInfo*>      RegisteredPlayers;                                 // 0x0638(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_648[0x78];                                     // 0x0648(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortUpdateManager*                     UpdateManager;                                     // 0x06C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortChat*                              Chatroom;                                          // 0x06C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class UFortRegisteredPlayerInfo>> RegisteredPlayerInfosAwaitingRefresh;              // 0x06D0(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6E0[0x10];                                     // 0x06E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortPushNotificationManager*           MobilePushNotificationManager;                     // 0x06F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6F8[0x8];                                      // 0x06F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameInstance">();
	}
	static class UFortGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGameInstance>();
	}
};
static_assert(alignof(UFortGameInstance) == 0x000008, "Wrong alignment on UFortGameInstance");
static_assert(sizeof(UFortGameInstance) == 0x000700, "Wrong size on UFortGameInstance");
static_assert(offsetof(UFortGameInstance, bBattleRoyaleDuoQueueEnabled) == 0x0000E9, "Member 'UFortGameInstance::bBattleRoyaleDuoQueueEnabled' has a wrong offset!");
static_assert(offsetof(UFortGameInstance, RegionsWithBattleRoyaleDuoQueueDisabled) == 0x0000F0, "Member 'UFortGameInstance::RegionsWithBattleRoyaleDuoQueueDisabled' has a wrong offset!");
static_assert(offsetof(UFortGameInstance, bBattleRoyaleSquadQueueEnabled) == 0x000100, "Member 'UFortGameInstance::bBattleRoyaleSquadQueueEnabled' has a wrong offset!");
static_assert(offsetof(UFortGameInstance, RegionsWithBattleRoyaleSquadQueueDisabled) == 0x000108, "Member 'UFortGameInstance::RegionsWithBattleRoyaleSquadQueueDisabled' has a wrong offset!");
static_assert(offsetof(UFortGameInstance, AthenaCodeOfConductURL) == 0x000118, "Member 'UFortGameInstance::AthenaCodeOfConductURL' has a wrong offset!");
static_assert(offsetof(UFortGameInstance, UIManagerInterface) == 0x000128, "Member 'UFortGameInstance::UIManagerInterface' has a wrong offset!");
static_assert(offsetof(UFortGameInstance, UIManagerClassPath) == 0x000138, "Member 'UFortGameInstance::UIManagerClassPath' has a wrong offset!");
static_assert(offsetof(UFortGameInstance, ProfileManager) == 0x000148, "Member 'UFortGameInstance::ProfileManager' has a wrong offset!");
static_assert(offsetof(UFortGameInstance, Matchmaking) == 0x000160, "Member 'UFortGameInstance::Matchmaking' has a wrong offset!");
static_assert(offsetof(UFortGameInstance, MatchmakingV2) == 0x000168, "Member 'UFortGameInstance::MatchmakingV2' has a wrong offset!");
static_assert(offsetof(UFortGameInstance, RejoinCheck) == 0x000170, "Member 'UFortGameInstance::RejoinCheck' has a wrong offset!");
static_assert(offsetof(UFortGameInstance, Party) == 0x000178, "Member 'UFortGameInstance::Party' has a wrong offset!");
static_assert(offsetof(UFortGameInstance, GlobalUnregistrationSaveGUID) == 0x0005B0, "Member 'UFortGameInstance::GlobalUnregistrationSaveGUID' has a wrong offset!");
static_assert(offsetof(UFortGameInstance, TooltipManager) == 0x0005E0, "Member 'UFortGameInstance::TooltipManager' has a wrong offset!");
static_assert(offsetof(UFortGameInstance, RegisteredPlayers) == 0x000638, "Member 'UFortGameInstance::RegisteredPlayers' has a wrong offset!");
static_assert(offsetof(UFortGameInstance, UpdateManager) == 0x0006C0, "Member 'UFortGameInstance::UpdateManager' has a wrong offset!");
static_assert(offsetof(UFortGameInstance, Chatroom) == 0x0006C8, "Member 'UFortGameInstance::Chatroom' has a wrong offset!");
static_assert(offsetof(UFortGameInstance, RegisteredPlayerInfosAwaitingRefresh) == 0x0006D0, "Member 'UFortGameInstance::RegisteredPlayerInfosAwaitingRefresh' has a wrong offset!");
static_assert(offsetof(UFortGameInstance, MobilePushNotificationManager) == 0x0006F0, "Member 'UFortGameInstance::MobilePushNotificationManager' has a wrong offset!");

// Class FortniteGame.FortGameModeEmptyDedicated
// 0x0008 (0x0780 - 0x0778)
class AFortGameModeEmptyDedicated final : public AFortGameMode
{
public:
	class AFortGameSessionDedicated*              FortGameSessionDedicated;                          // 0x0778(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameModeEmptyDedicated">();
	}
	static class AFortGameModeEmptyDedicated* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGameModeEmptyDedicated>();
	}
};
static_assert(alignof(AFortGameModeEmptyDedicated) == 0x000008, "Wrong alignment on AFortGameModeEmptyDedicated");
static_assert(sizeof(AFortGameModeEmptyDedicated) == 0x000780, "Wrong size on AFortGameModeEmptyDedicated");
static_assert(offsetof(AFortGameModeEmptyDedicated, FortGameSessionDedicated) == 0x000778, "Member 'AFortGameModeEmptyDedicated::FortGameSessionDedicated' has a wrong offset!");

// Class FortniteGame.FortVisibilityManager
// 0x00D8 (0x0460 - 0x0388)
class AFortVisibilityManager final : public AActor
{
public:
	uint8                                         Pad_388[0x10];                                     // 0x0388(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVisibiltyInfoArray                    VisibilityInfoArray;                               // 0x0398(0x00C0)(Net, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_458[0x8];                                      // 0x0458(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortVisibilityManager">();
	}
	static class AFortVisibilityManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortVisibilityManager>();
	}
};
static_assert(alignof(AFortVisibilityManager) == 0x000008, "Wrong alignment on AFortVisibilityManager");
static_assert(sizeof(AFortVisibilityManager) == 0x000460, "Wrong size on AFortVisibilityManager");
static_assert(offsetof(AFortVisibilityManager, VisibilityInfoArray) == 0x000398, "Member 'AFortVisibilityManager::VisibilityInfoArray' has a wrong offset!");

// Class FortniteGame.FortGameModeDeployableBase
// 0x0058 (0x0880 - 0x0828)
class AFortGameModeDeployableBase final : public AFortGameModeZone
{
public:
	uint8                                         Pad_828[0x58];                                     // 0x0828(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameModeDeployableBase">();
	}
	static class AFortGameModeDeployableBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGameModeDeployableBase>();
	}
};
static_assert(alignof(AFortGameModeDeployableBase) == 0x000008, "Wrong alignment on AFortGameModeDeployableBase");
static_assert(sizeof(AFortGameModeDeployableBase) == 0x000880, "Wrong size on AFortGameModeDeployableBase");

// Class FortniteGame.FortGameModeFOB
// 0x0018 (0x0840 - 0x0828)
class AFortGameModeFOB final : public AFortGameModeZone
{
public:
	class ABuildingFOBConfigActor*                ConfigurationActor;                                // 0x0828(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnPlayerLoginToFOB;                                // 0x0830(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameModeFOB">();
	}
	static class AFortGameModeFOB* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGameModeFOB>();
	}
};
static_assert(alignof(AFortGameModeFOB) == 0x000008, "Wrong alignment on AFortGameModeFOB");
static_assert(sizeof(AFortGameModeFOB) == 0x000840, "Wrong size on AFortGameModeFOB");
static_assert(offsetof(AFortGameModeFOB, ConfigurationActor) == 0x000828, "Member 'AFortGameModeFOB::ConfigurationActor' has a wrong offset!");
static_assert(offsetof(AFortGameModeFOB, OnPlayerLoginToFOB) == 0x000830, "Member 'AFortGameModeFOB::OnPlayerLoginToFOB' has a wrong offset!");

// Class FortniteGame.FortGameModeKeep
// 0x0028 (0x0850 - 0x0828)
class AFortGameModeKeep final : public AFortGameModeZone
{
public:
	uint8                                         Pad_828[0x20];                                     // 0x0828(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortKeepItemManager*                   KeepItemManager;                                   // 0x0848(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameModeKeep">();
	}
	static class AFortGameModeKeep* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGameModeKeep>();
	}
};
static_assert(alignof(AFortGameModeKeep) == 0x000008, "Wrong alignment on AFortGameModeKeep");
static_assert(sizeof(AFortGameModeKeep) == 0x000850, "Wrong size on AFortGameModeKeep");
static_assert(offsetof(AFortGameModeKeep, KeepItemManager) == 0x000848, "Member 'AFortGameModeKeep::KeepItemManager' has a wrong offset!");

// Class FortniteGame.FortGameModeSurvival
// 0x0008 (0x0830 - 0x0828)
class AFortGameModeSurvival final : public AFortGameModeZone
{
public:
	uint8                                         Pad_828[0x8];                                      // 0x0828(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FireEvent_SurvivalPeriodicReport(EFortReportDayPhase TimeOfReport, const TArray<class ABuildingActor*>& ActorsBeingDefended) const;
	void FireEvent_SurvivalVoteReport(const TArray<class ABuildingActor*>& ActorsBeingDefended) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameModeSurvival">();
	}
	static class AFortGameModeSurvival* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGameModeSurvival>();
	}
};
static_assert(alignof(AFortGameModeSurvival) == 0x000008, "Wrong alignment on AFortGameModeSurvival");
static_assert(sizeof(AFortGameModeSurvival) == 0x000830, "Wrong size on AFortGameModeSurvival");

// Class FortniteGame.FortMcpProfileAccount
// 0x0110 (0x03F0 - 0x02E0)
class UFortMcpProfileAccount final : public UFortMcpProfile
{
public:
	class FString                                 ListCatalogEntriesUrl;                             // 0x02E0(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F0[0x60];                                     // 0x02F0(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortAccountClientSettings             CachedClientSettings;                              // 0x0350(0x0010)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_360[0x90];                                     // 0x0360(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AbandonExpedition(const class FString& ExpeditionId, struct FClientUrlContext* Context);
	void ActivateConsumable(const class FString& TargetItemId, const class FString& TargetAccountId, struct FClientUrlContext* Context);
	void ApplyAlteration(const class FString& TargetItemId, const class FString& AlterationItemId, struct FClientUrlContext* Context);
	void AssignWorkerToSquad(const class FString& CharacterId, const class FString& SquadId, int32 SlotIndex, struct FClientUrlContext* Context);
	void AssignWorkerToSquadBatch(const TArray<class FString>& CharacterIds, const TArray<class FString>& SquadIds, const TArray<int32>& SlotIndices, struct FClientUrlContext* Context);
	void ClaimCollectedResources(const TArray<class FString>& CollectorsToClaim, struct FClientUrlContext* Context);
	void ClaimCollectionBookRewards(int32 RequiredXp, int32 SelectedRewardIndex, struct FClientUrlContext* Context);
	void ClaimLoginReward(struct FClientUrlContext* Context);
	void ClaimMissionAlertRewards(struct FClientUrlContext* Context);
	void ClaimQuestReward(const class FString& QuestId, int32 SelectedRewardIndex, struct FClientUrlContext* Context);
	void ClientQuestLogin(struct FClientUrlContext* Context);
	void CollectExpedition(const class FString& ExpeditionTemplate, const class FString& ExpeditionId, struct FClientUrlContext* Context);
	void ConsumeItems(const TArray<class FString>& ItemsToConsumeIds, const TArray<int32>& ItemCountsToConsume, const class FString& ConsumeReason, struct FDedicatedServerUrlContext* Context);
	void ConvertItem(const class FString& TargetItemId, int32 ConversionIndex, struct FClientUrlContext* Context);
	void EarnScore(const TArray<struct FAccountIdAndScore>& PlayersAndScores, const class FString& MatchmakingSessionId, struct FDedicatedServerUrlContext* Context);
	void EndPrimaryMission(const TArray<struct FFortQuestObjectiveCompletion>& Advance, const class FString& MatchmakingSessionId, const class FString& MissionName, const class FString& MissionStatus, const TArray<struct FFortQuestEarnedBadgeData>& EarnedBadgeData, int32 NumMissionPoints, bool bCriticalMatchBonus, struct FDedicatedServerUrlContext* Context);
	void EquipCharCosmetic(const class FString& CharacterId, const class FString& CosmeticId, int32 TypeId, struct FClientUrlContext* Context);
	void FortRerollDailyQuest(const class FString& QuestId, struct FClientUrlContext* Context);
	void GetMcpTimeForLogin(struct FClientUrlContext* Context);
	void IncrementNamedCounterStat(const class FString& CounterName, struct FClientUrlContext* Context);
	void IssueFriendCode(const class FString& CodeTokenType, struct FClientUrlContext* Context);
	void MarkItemSeen(const TArray<class FString>& ItemIds, struct FClientUrlContext* Context);
	void MarkNewQuestNotificationSent(const TArray<class FString>& ItemIds, struct FClientUrlContext* Context);
	void ModifyMission(const class FString& MatchmakingSessionId, const class FString& Difficulty, struct FDedicatedServerUrlContext* Context);
	void OpenCardPack(const class FString& CardPackItemId, int32 SelectionIdx, struct FClientUrlContext* Context);
	void OpenCardPackBatch(const TArray<class FString>& CardPackItemIds, struct FClientUrlContext* Context);
	void PurchaseHomebaseNode(const class FString& NodeID, struct FClientUrlContext* Context);
	void RecycleItem(const class FString& TargetItemId, struct FClientUrlContext* Context);
	void RecycleItemBatch(const TArray<class FString>& TargetItemIds, struct FClientUrlContext* Context);
	void RefreshExpeditions(struct FClientUrlContext* Context);
	void RequestEventFlags(struct FClientUrlContext* Context);
	void ServerQuestLogin(const class FString& MatchmakingSessionId, struct FDedicatedServerUrlContext* Context);
	void SetDefaultHeroSquad(const class FString& DefaultHeroSquadId, struct FClientUrlContext* Context);
	void SetGameplayStats(const TArray<struct FFortPersistentGameplayStatValue>& GameplayStats, struct FClientUrlContext* Context);
	void SetHeroModeLoadout(const class FString& HeroId, const struct FFortSavedModeLoadout& ModeLoadout, struct FClientUrlContext* Context);
	void SetHomebaseBanner(const class FString& HomebaseBannerIconId, const class FString& HomebaseBannerColorId, struct FClientUrlContext* Context);
	void SetHomebaseMeta(const class FString& TownName, int32 FlagPattern, float FlagColor, struct FClientUrlContext* Context);
	void SetHomebaseName(const class FString& HomebaseName, struct FClientUrlContext* Context);
	void SetItemFavoriteStatus(const class FString& TargetItemId, bool bFavorite, struct FClientUrlContext* Context);
	void SetModeLoadout(const struct FFortSavedModeLoadout& ModeLoadout, const class FString& HeroId, const struct FFortSavedModeLoadout& HeroModeLoadout, struct FClientUrlContext* Context);
	void SetMtxPlatform(const EFortMtxPlatform NewPlatform, struct FClientUrlContext* Context);
	void SetPinnedQuests(const TArray<class FString>& PinnedQuestIds, struct FClientUrlContext* Context);
	void SkipTutorial(struct FClientUrlContext* Context);
	void SlotItemInCollectionBook(const class FString& ItemId, struct FClientUrlContext* Context);
	void StartExpedition(const class FString& ExpeditionId, const class FString& SquadId, const TArray<class FString>& ItemIds, const TArray<int32>& SlotIndices, struct FClientUrlContext* Context);
	void StartPrimaryMission(const TArray<struct FFortQuestObjectiveCompletion>& Advance, const class FString& MatchmakingSessionId, const class FString& MissionName, struct FDedicatedServerUrlContext* Context);
	void TransmogItem(const class FString& TransmogKeyTemplateId, const TArray<class FString>& SacrificeItemIds, struct FClientUrlContext* Context);
	void TwitchUpdateBroadcasterRegistration(const class FString& AccessToken, const class FString& ChannelId, struct FClientUrlContext* Context);
	void UnassignAllSquads(const TArray<class FString>& SquadIds, struct FClientUrlContext* Context);
	void UnloadWarehouse(const TArray<class FString>& ResourceTypes, struct FClientUrlContext* Context);
	void UnslotAllWorkers(const TArray<class FString>& BuildingIds, struct FClientUrlContext* Context);
	void UpdateBuildingLevelAndRating(const class FString& BuildingId, int32 LastBuildingLevel, int32 LastBuildingRating, struct FClientUrlContext* Context);
	void UpdateQuestClientObjectives(const TArray<struct FFortQuestObjectiveCompletion>& Advance, struct FClientUrlContext* Context);
	void UpdateQuests(const TArray<struct FFortQuestObjectiveCompletion>& Advance, struct FDedicatedServerUrlContext* Context);
	void UpgradeItem(const class FString& TargetItemId, struct FClientUrlContext* Context);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMcpProfileAccount">();
	}
	static class UFortMcpProfileAccount* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMcpProfileAccount>();
	}
};
static_assert(alignof(UFortMcpProfileAccount) == 0x000008, "Wrong alignment on UFortMcpProfileAccount");
static_assert(sizeof(UFortMcpProfileAccount) == 0x0003F0, "Wrong size on UFortMcpProfileAccount");
static_assert(offsetof(UFortMcpProfileAccount, ListCatalogEntriesUrl) == 0x0002E0, "Member 'UFortMcpProfileAccount::ListCatalogEntriesUrl' has a wrong offset!");
static_assert(offsetof(UFortMcpProfileAccount, CachedClientSettings) == 0x000350, "Member 'UFortMcpProfileAccount::CachedClientSettings' has a wrong offset!");

// Class FortniteGame.FortMcpProfileMetadata
// 0x0000 (0x02E0 - 0x02E0)
class UFortMcpProfileMetadata final : public UFortMcpProfile
{
public:
	void CreateDeployableBaseItem(const class FString& TemplateId, struct FDedicatedServerUrlContext* Context);
	void CreateOrUpgradeOutpostItem(const class FString& TemplateId, struct FClientUrlContext* Context);
	void UpdateDeployableBaseTierProgression(const class FString& DeployableBaseItemId, const class FString& ProgressionLayoutGuid, int32 TierDefeated, struct FDedicatedServerUrlContext* Context);
	void UpdateOutpostCore(const class FString& CoreId, const struct FFortOutpostCoreInfo& CoreInfo, struct FDedicatedServerUrlContext* Context);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMcpProfileMetadata">();
	}
	static class UFortMcpProfileMetadata* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMcpProfileMetadata>();
	}
};
static_assert(alignof(UFortMcpProfileMetadata) == 0x000008, "Wrong alignment on UFortMcpProfileMetadata");
static_assert(sizeof(UFortMcpProfileMetadata) == 0x0002E0, "Wrong size on UFortMcpProfileMetadata");

// Class FortniteGame.FortPlayerInput
// 0x0148 (0x04E0 - 0x0398)
class UFortPlayerInput : public UPlayerInput
{
public:
	class FString                                 DefaultPresetName;                                 // 0x0398(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         FortPlayerInputSettingsNames;                      // 0x03A8(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B8[0xE0];                                     // 0x03B8(0x00E0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UFortPlayerInputSettings*>       AllPlayerInputSettings;                            // 0x0498(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UFortPlayerInputSettings*               DesiredPlayerInputSettings;                        // 0x04A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B0[0x10];                                     // 0x04B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FText>                           InputActionTypeFriendlyNames;                      // 0x04C0(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	TArray<struct FFortInputActionGroupContext>   InputActionGroupContexts;                          // 0x04D0(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerInput">();
	}
	static class UFortPlayerInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPlayerInput>();
	}
};
static_assert(alignof(UFortPlayerInput) == 0x000008, "Wrong alignment on UFortPlayerInput");
static_assert(sizeof(UFortPlayerInput) == 0x0004E0, "Wrong size on UFortPlayerInput");
static_assert(offsetof(UFortPlayerInput, DefaultPresetName) == 0x000398, "Member 'UFortPlayerInput::DefaultPresetName' has a wrong offset!");
static_assert(offsetof(UFortPlayerInput, FortPlayerInputSettingsNames) == 0x0003A8, "Member 'UFortPlayerInput::FortPlayerInputSettingsNames' has a wrong offset!");
static_assert(offsetof(UFortPlayerInput, AllPlayerInputSettings) == 0x000498, "Member 'UFortPlayerInput::AllPlayerInputSettings' has a wrong offset!");
static_assert(offsetof(UFortPlayerInput, DesiredPlayerInputSettings) == 0x0004A8, "Member 'UFortPlayerInput::DesiredPlayerInputSettings' has a wrong offset!");
static_assert(offsetof(UFortPlayerInput, InputActionTypeFriendlyNames) == 0x0004C0, "Member 'UFortPlayerInput::InputActionTypeFriendlyNames' has a wrong offset!");
static_assert(offsetof(UFortPlayerInput, InputActionGroupContexts) == 0x0004D0, "Member 'UFortPlayerInput::InputActionGroupContexts' has a wrong offset!");

// Class FortniteGame.FortClientSettingsRecord
// 0x01F0 (0x02C0 - 0x00D0)
class UFortClientSettingsRecord final : public UFortGenericRecord
{
public:
	uint8                                         Pad_D0[0x4];                                       // 0x00D0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              GamepadLookSensitivity;                            // 0x00D4(0x0008)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetingMultiplier;                               // 0x00DC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScopedMultiplier;                                  // 0x00E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ControllerPlatform;                                // 0x00E8(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 InputPresetNameForCampaign;                        // 0x00F8(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 InputPresetNameForAthena;                          // 0x0108(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         XboxSafeZone;                                      // 0x0118(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PendingCulture;                                    // 0x0120(0x0010)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FFortActionKeyMapping>          UserActionBindings;                                // 0x0130(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortActionKeyMapping>          DisabledActionBindings;                            // 0x0140(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bInvertedLook;                                     // 0x0150(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bToggleSprint;                                     // 0x0151(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSprintCancelsReload;                              // 0x0152(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTapInteractEnabled;                               // 0x0153(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutoEquipBetterItems;                             // 0x0154(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bForceFeedbackEnabled;                             // 0x0155(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseFirstPersonCamera;                             // 0x0156(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseGamepadAimAssist;                              // 0x0157(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseGamepadEditModeAimAssist;                      // 0x0158(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFocusOnFirstBuildingPieceWhenQuickbarSwapped;     // 0x0159(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNewFocusOnFirstBuildingPieceWhenQuickbarSwapped;  // 0x015A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15B[0x5];                                      // 0x015B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, bool>               UserHUDVisibiltyMappings;                          // 0x0160(0x0050)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	EPartyType                                    LastPartyType;                                     // 0x01B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLastLeaderInvitesOnly;                            // 0x01B1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLastLeaderFriendsOnly;                            // 0x01B2(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B3[0x1];                                      // 0x01B3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MusicVolume;                                       // 0x01B4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SoundFXVolume;                                     // 0x01B8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DialogVolume;                                      // 0x01BC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ChatVolume;                                        // 0x01C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableSubtitles;                                  // 0x01C4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableVoiceChat;                                  // 0x01C5(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableVoiceChatPTT;                               // 0x01C6(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowHeroHeadAccessories;                          // 0x01C7(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowHeroBackpack;                                 // 0x01C8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C9[0x3];                                      // 0x01C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialGammaValue;                                 // 0x01CC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 SelectedRegionId;                                  // 0x01D0(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 LastKnownBestRegionId;                             // 0x01E0(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bSaveToCloud : 1;                                  // 0x01F0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCloudIsBusy : 1;                                  // 0x01F0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1F1[0xCF];                                     // 0x01F1(0x00CF)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortClientSettingsRecord">();
	}
	static class UFortClientSettingsRecord* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortClientSettingsRecord>();
	}
};
static_assert(alignof(UFortClientSettingsRecord) == 0x000008, "Wrong alignment on UFortClientSettingsRecord");
static_assert(sizeof(UFortClientSettingsRecord) == 0x0002C0, "Wrong size on UFortClientSettingsRecord");
static_assert(offsetof(UFortClientSettingsRecord, GamepadLookSensitivity) == 0x0000D4, "Member 'UFortClientSettingsRecord::GamepadLookSensitivity' has a wrong offset!");
static_assert(offsetof(UFortClientSettingsRecord, TargetingMultiplier) == 0x0000DC, "Member 'UFortClientSettingsRecord::TargetingMultiplier' has a wrong offset!");
static_assert(offsetof(UFortClientSettingsRecord, ScopedMultiplier) == 0x0000E0, "Member 'UFortClientSettingsRecord::ScopedMultiplier' has a wrong offset!");
static_assert(offsetof(UFortClientSettingsRecord, ControllerPlatform) == 0x0000E8, "Member 'UFortClientSettingsRecord::ControllerPlatform' has a wrong offset!");
static_assert(offsetof(UFortClientSettingsRecord, InputPresetNameForCampaign) == 0x0000F8, "Member 'UFortClientSettingsRecord::InputPresetNameForCampaign' has a wrong offset!");
static_assert(offsetof(UFortClientSettingsRecord, InputPresetNameForAthena) == 0x000108, "Member 'UFortClientSettingsRecord::InputPresetNameForAthena' has a wrong offset!");
static_assert(offsetof(UFortClientSettingsRecord, XboxSafeZone) == 0x000118, "Member 'UFortClientSettingsRecord::XboxSafeZone' has a wrong offset!");
static_assert(offsetof(UFortClientSettingsRecord, PendingCulture) == 0x000120, "Member 'UFortClientSettingsRecord::PendingCulture' has a wrong offset!");
static_assert(offsetof(UFortClientSettingsRecord, UserActionBindings) == 0x000130, "Member 'UFortClientSettingsRecord::UserActionBindings' has a wrong offset!");
static_assert(offsetof(UFortClientSettingsRecord, DisabledActionBindings) == 0x000140, "Member 'UFortClientSettingsRecord::DisabledActionBindings' has a wrong offset!");
static_assert(offsetof(UFortClientSettingsRecord, bInvertedLook) == 0x000150, "Member 'UFortClientSettingsRecord::bInvertedLook' has a wrong offset!");
static_assert(offsetof(UFortClientSettingsRecord, bToggleSprint) == 0x000151, "Member 'UFortClientSettingsRecord::bToggleSprint' has a wrong offset!");
static_assert(offsetof(UFortClientSettingsRecord, bSprintCancelsReload) == 0x000152, "Member 'UFortClientSettingsRecord::bSprintCancelsReload' has a wrong offset!");
static_assert(offsetof(UFortClientSettingsRecord, bTapInteractEnabled) == 0x000153, "Member 'UFortClientSettingsRecord::bTapInteractEnabled' has a wrong offset!");
static_assert(offsetof(UFortClientSettingsRecord, bAutoEquipBetterItems) == 0x000154, "Member 'UFortClientSettingsRecord::bAutoEquipBetterItems' has a wrong offset!");
static_assert(offsetof(UFortClientSettingsRecord, bForceFeedbackEnabled) == 0x000155, "Member 'UFortClientSettingsRecord::bForceFeedbackEnabled' has a wrong offset!");
static_assert(offsetof(UFortClientSettingsRecord, bUseFirstPersonCamera) == 0x000156, "Member 'UFortClientSettingsRecord::bUseFirstPersonCamera' has a wrong offset!");
static_assert(offsetof(UFortClientSettingsRecord, bUseGamepadAimAssist) == 0x000157, "Member 'UFortClientSettingsRecord::bUseGamepadAimAssist' has a wrong offset!");
static_assert(offsetof(UFortClientSettingsRecord, bUseGamepadEditModeAimAssist) == 0x000158, "Member 'UFortClientSettingsRecord::bUseGamepadEditModeAimAssist' has a wrong offset!");
static_assert(offsetof(UFortClientSettingsRecord, bFocusOnFirstBuildingPieceWhenQuickbarSwapped) == 0x000159, "Member 'UFortClientSettingsRecord::bFocusOnFirstBuildingPieceWhenQuickbarSwapped' has a wrong offset!");
static_assert(offsetof(UFortClientSettingsRecord, bNewFocusOnFirstBuildingPieceWhenQuickbarSwapped) == 0x00015A, "Member 'UFortClientSettingsRecord::bNewFocusOnFirstBuildingPieceWhenQuickbarSwapped' has a wrong offset!");
static_assert(offsetof(UFortClientSettingsRecord, UserHUDVisibiltyMappings) == 0x000160, "Member 'UFortClientSettingsRecord::UserHUDVisibiltyMappings' has a wrong offset!");
static_assert(offsetof(UFortClientSettingsRecord, LastPartyType) == 0x0001B0, "Member 'UFortClientSettingsRecord::LastPartyType' has a wrong offset!");
static_assert(offsetof(UFortClientSettingsRecord, bLastLeaderInvitesOnly) == 0x0001B1, "Member 'UFortClientSettingsRecord::bLastLeaderInvitesOnly' has a wrong offset!");
static_assert(offsetof(UFortClientSettingsRecord, bLastLeaderFriendsOnly) == 0x0001B2, "Member 'UFortClientSettingsRecord::bLastLeaderFriendsOnly' has a wrong offset!");
static_assert(offsetof(UFortClientSettingsRecord, MusicVolume) == 0x0001B4, "Member 'UFortClientSettingsRecord::MusicVolume' has a wrong offset!");
static_assert(offsetof(UFortClientSettingsRecord, SoundFXVolume) == 0x0001B8, "Member 'UFortClientSettingsRecord::SoundFXVolume' has a wrong offset!");
static_assert(offsetof(UFortClientSettingsRecord, DialogVolume) == 0x0001BC, "Member 'UFortClientSettingsRecord::DialogVolume' has a wrong offset!");
static_assert(offsetof(UFortClientSettingsRecord, ChatVolume) == 0x0001C0, "Member 'UFortClientSettingsRecord::ChatVolume' has a wrong offset!");
static_assert(offsetof(UFortClientSettingsRecord, bEnableSubtitles) == 0x0001C4, "Member 'UFortClientSettingsRecord::bEnableSubtitles' has a wrong offset!");
static_assert(offsetof(UFortClientSettingsRecord, bEnableVoiceChat) == 0x0001C5, "Member 'UFortClientSettingsRecord::bEnableVoiceChat' has a wrong offset!");
static_assert(offsetof(UFortClientSettingsRecord, bEnableVoiceChatPTT) == 0x0001C6, "Member 'UFortClientSettingsRecord::bEnableVoiceChatPTT' has a wrong offset!");
static_assert(offsetof(UFortClientSettingsRecord, bShowHeroHeadAccessories) == 0x0001C7, "Member 'UFortClientSettingsRecord::bShowHeroHeadAccessories' has a wrong offset!");
static_assert(offsetof(UFortClientSettingsRecord, bShowHeroBackpack) == 0x0001C8, "Member 'UFortClientSettingsRecord::bShowHeroBackpack' has a wrong offset!");
static_assert(offsetof(UFortClientSettingsRecord, InitialGammaValue) == 0x0001CC, "Member 'UFortClientSettingsRecord::InitialGammaValue' has a wrong offset!");
static_assert(offsetof(UFortClientSettingsRecord, SelectedRegionId) == 0x0001D0, "Member 'UFortClientSettingsRecord::SelectedRegionId' has a wrong offset!");
static_assert(offsetof(UFortClientSettingsRecord, LastKnownBestRegionId) == 0x0001E0, "Member 'UFortClientSettingsRecord::LastKnownBestRegionId' has a wrong offset!");

// Class FortniteGame.FortPlayerControllerAthena
// 0x0930 (0x3290 - 0x2960)
class AFortPlayerControllerAthena : public AFortPlayerControllerPvP
{
public:
	TArray<class UFortHeroType*>                  DefaultHeroes;                                     // 0x2960(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnAircraftStateChange;                             // 0x2970(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FString                                 VoiceChatPlayerName;                               // 0x2980(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 VoiceChatChannel;                                  // 0x2990(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VoiceChatJoinFailCount;                            // 0x29A0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29A4[0x14];                                    // 0x29A4(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         VoiceChatReconnectCount;                           // 0x29B8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29BC[0x4];                                     // 0x29BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundMix*                              AthenaSoundMix;                                    // 0x29C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             AudioOnExitAircraft;                               // 0x29C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EmoteCooldown;                                     // 0x29D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastEmoteTime;                                     // 0x29D4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortGliderType                               GliderType;                                        // 0x29D8(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMarkedAlive;                                      // 0x29D9(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29DA[0x16];                                    // 0x29DA(0x0016)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSettingsHUDVisibilityAndText>  HUDVisibilityGameplayTags;                         // 0x29F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A00[0x150];                                   // 0x2A00(0x0150)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UFortGamepadSettings>    GamepadSettingsAssetPtr;                           // 0x2B50(0x0020)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MapCursor;                                         // 0x2B70(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MapCursorSpeed;                                    // 0x2B7C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MapCursorSpeedGamepad;                             // 0x2B80(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B84[0x3FC];                                   // 0x2B84(0x03FC)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AFortPlayerStateAthena*>         TeamMembers;                                       // 0x2F80(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           TeamMemberIndicatorColor;                          // 0x2F90(0x0010)(BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FA0[0x70];                                    // 0x2FA0(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bRevertPlayerListenerChange;                       // 0x3010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3011[0x3F];                                    // 0x3011(0x003F)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortHero*                              StrongMyHero;                                      // 0x3050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VoiceChatUpdateLimiter;                            // 0x3058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_305C[0x4];                                     // 0x305C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortPlayerStartWarmup*                 WarmupPlayerStart;                                 // 0x3060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputComponent*                        AircraftInputComponent;                            // 0x3068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputComponent*                        FullScreenMapInputComponent;                       // 0x3070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3078[0x1F0];                                   // 0x3078(0x01F0)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  PlayerToSpectateOnDeath;                           // 0x3268(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3270[0x8];                                     // 0x3270(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         ViewTargetHealth;                                  // 0x3278(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         ViewTargetShield;                                  // 0x3279(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ViewTargetDBNO;                                    // 0x327A(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_327B[0x1];                                     // 0x327B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MovementCancellableActionLeashLength;              // 0x327C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                MovementCancellableActionLeashLocation;            // 0x3280(0x000C)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_328C[0x4];                                     // 0x328C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientBotStartDogpile(const struct FVector& DogpilePosition);
	void ClientBotStopDogpile();
	void ClientNotifyTeamWon();
	void ClientNotifyWon();
	void ClientStreamOutBuildingFoundation(class ABuildingFoundation* FoundationActor);
	void ClientUnreliableSendMessage(const class FText& MESSAGE);
	void ClientVoiceChatChannelJoin(const class FString& InVoiceChatPlayerName, const class FString& InVoiceChatChannel, const class FString& JoinToken);
	void ClientVoiceChatLogin(const class FString& InVoiceChatPlayerName, const class FString& LoginToken);
	void CycleHeroBackward();
	void CycleHeroForward();
	void DumpTeamMemberState();
	void FollowNextTeammate();
	void FullscreenMapCursorHorizontal(float Value);
	void FullscreenMapCursorHorizontal_Gamepad(float Value);
	void FullscreenMapCursorPlace();
	void FullscreenMapCursorRemove();
	void FullscreenMapCursorVertical(float Value);
	void FullscreenMapCursorVertical_Gamepad(float Value);
	class FString GetSpectatingPlayerName();
	void GetTeamDBNO(TArray<bool>* DBNOStates);
	void GetTeamDead(TArray<bool>* DeadStates);
	void GetTeamHitPointFractions(TArray<float>* HealthFractions, TArray<float>* ShieldFractions);
	void GetTeamMuted(TArray<bool>* MutedStates);
	void GetTeamReviving(TArray<bool>* RevivingStates);
	void GetTeamTalking(TArray<bool>* TalkingStates);
	void OnRep_ViewTargetDBNO();
	void OnRep_ViewTargetHealth();
	void OnRep_ViewTargetShield();
	void PlayWinEffects();
	void ServerAttemptAircraftJump(const struct FRotator& ClientRotation);
	void ServerAttemptEnterExitCar();
	void ServerDBNOReviveInterrupted(class AFortPlayerPawnAthena* DBNOPawn);
	void ServerDBNOReviveStarted(class AFortPlayerPawnAthena* DBNOPawn);
	void ServerFollowNextTeammate();
	void ServerPlaceMapCursor(const struct FVector_NetQuantize& CursorPos);
	void ServerRemoveMapCursor();
	void ServerVoiceChatReconnected();
	void ServerVoiceChatRejoinChannel();
	void SpawnCar(const class FString& Command);
	void SpectateOnDeath();
	void UpdateRichPresenceTimer();
	void VoiceChatChannelJoinFailed();
	void VoiceChatReconnected();

	bool GetRevertPlayerListenerChangeFlag() const;
	bool IsInAircraft() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerControllerAthena">();
	}
	static class AFortPlayerControllerAthena* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerControllerAthena>();
	}
};
static_assert(alignof(AFortPlayerControllerAthena) == 0x000008, "Wrong alignment on AFortPlayerControllerAthena");
static_assert(sizeof(AFortPlayerControllerAthena) == 0x003290, "Wrong size on AFortPlayerControllerAthena");
static_assert(offsetof(AFortPlayerControllerAthena, DefaultHeroes) == 0x002960, "Member 'AFortPlayerControllerAthena::DefaultHeroes' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerAthena, OnAircraftStateChange) == 0x002970, "Member 'AFortPlayerControllerAthena::OnAircraftStateChange' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerAthena, VoiceChatPlayerName) == 0x002980, "Member 'AFortPlayerControllerAthena::VoiceChatPlayerName' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerAthena, VoiceChatChannel) == 0x002990, "Member 'AFortPlayerControllerAthena::VoiceChatChannel' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerAthena, VoiceChatJoinFailCount) == 0x0029A0, "Member 'AFortPlayerControllerAthena::VoiceChatJoinFailCount' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerAthena, VoiceChatReconnectCount) == 0x0029B8, "Member 'AFortPlayerControllerAthena::VoiceChatReconnectCount' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerAthena, AthenaSoundMix) == 0x0029C0, "Member 'AFortPlayerControllerAthena::AthenaSoundMix' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerAthena, AudioOnExitAircraft) == 0x0029C8, "Member 'AFortPlayerControllerAthena::AudioOnExitAircraft' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerAthena, EmoteCooldown) == 0x0029D0, "Member 'AFortPlayerControllerAthena::EmoteCooldown' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerAthena, LastEmoteTime) == 0x0029D4, "Member 'AFortPlayerControllerAthena::LastEmoteTime' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerAthena, GliderType) == 0x0029D8, "Member 'AFortPlayerControllerAthena::GliderType' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerAthena, bMarkedAlive) == 0x0029D9, "Member 'AFortPlayerControllerAthena::bMarkedAlive' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerAthena, HUDVisibilityGameplayTags) == 0x0029F0, "Member 'AFortPlayerControllerAthena::HUDVisibilityGameplayTags' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerAthena, GamepadSettingsAssetPtr) == 0x002B50, "Member 'AFortPlayerControllerAthena::GamepadSettingsAssetPtr' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerAthena, MapCursor) == 0x002B70, "Member 'AFortPlayerControllerAthena::MapCursor' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerAthena, MapCursorSpeed) == 0x002B7C, "Member 'AFortPlayerControllerAthena::MapCursorSpeed' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerAthena, MapCursorSpeedGamepad) == 0x002B80, "Member 'AFortPlayerControllerAthena::MapCursorSpeedGamepad' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerAthena, TeamMembers) == 0x002F80, "Member 'AFortPlayerControllerAthena::TeamMembers' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerAthena, TeamMemberIndicatorColor) == 0x002F90, "Member 'AFortPlayerControllerAthena::TeamMemberIndicatorColor' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerAthena, bRevertPlayerListenerChange) == 0x003010, "Member 'AFortPlayerControllerAthena::bRevertPlayerListenerChange' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerAthena, StrongMyHero) == 0x003050, "Member 'AFortPlayerControllerAthena::StrongMyHero' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerAthena, VoiceChatUpdateLimiter) == 0x003058, "Member 'AFortPlayerControllerAthena::VoiceChatUpdateLimiter' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerAthena, WarmupPlayerStart) == 0x003060, "Member 'AFortPlayerControllerAthena::WarmupPlayerStart' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerAthena, AircraftInputComponent) == 0x003068, "Member 'AFortPlayerControllerAthena::AircraftInputComponent' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerAthena, FullScreenMapInputComponent) == 0x003070, "Member 'AFortPlayerControllerAthena::FullScreenMapInputComponent' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerAthena, PlayerToSpectateOnDeath) == 0x003268, "Member 'AFortPlayerControllerAthena::PlayerToSpectateOnDeath' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerAthena, ViewTargetHealth) == 0x003278, "Member 'AFortPlayerControllerAthena::ViewTargetHealth' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerAthena, ViewTargetShield) == 0x003279, "Member 'AFortPlayerControllerAthena::ViewTargetShield' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerAthena, ViewTargetDBNO) == 0x00327A, "Member 'AFortPlayerControllerAthena::ViewTargetDBNO' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerAthena, MovementCancellableActionLeashLength) == 0x00327C, "Member 'AFortPlayerControllerAthena::MovementCancellableActionLeashLength' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerAthena, MovementCancellableActionLeashLocation) == 0x003280, "Member 'AFortPlayerControllerAthena::MovementCancellableActionLeashLocation' has a wrong offset!");

// Class FortniteGame.FortGameModeAthena
// 0x02E0 (0x0B70 - 0x0890)
class AFortGameModeAthena final : public AFortGamePvPBase
{
public:
	uint8                                         Pad_890[0x8];                                      // 0x0890(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAlwaysDBNO;                                       // 0x0898(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableVoiceChat;                                 // 0x0899(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSquadPlay;                                        // 0x089A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_89B[0x1];                                      // 0x089B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverloadedInitialConnectTimeout;                   // 0x089C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FailedMatchAssignmentTimeout;                      // 0x08A0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8A4[0x2C];                                     // 0x08A4(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           SupplyDropTimerHandle;                             // 0x08D0(0x0008)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_8D8[0x8];                                      // 0x08D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxPlayerCount;                                    // 0x08E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8E4[0x4];                                      // 0x08E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AFortPlayerControllerAthena*>    AlivePlayers;                                      // 0x08E8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         TeamAlivePlayers[0x64];                            // 0x08F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A88[0x4];                                      // 0x0A88(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         WarmupRequiredPlayerCount;                         // 0x0A8C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WarmupCountdownDuration;                           // 0x0A90(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A94[0x4];                                      // 0x0A94(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WarmupEarlyCountdownDuration;                      // 0x0A98(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSafeZoneActive;                                   // 0x0A9C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSafeZonePaused;                                   // 0x0A9D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A9E[0x2];                                      // 0x0A9E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            GE_OutsideSafeZone;                                // 0x0AA0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AFortSafeZoneIndicator>     SafeZoneIndicatorClass;                            // 0x0AA8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SafeZonePhase;                                     // 0x0AB0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AB4[0x4];                                      // 0x0AB4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortSafeZoneIndicator*                 SafeZoneIndicator;                                 // 0x0AB8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FVector>                        SafeZoneLocations;                                 // 0x0AC0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UFortServerBehaviorTrackerAthena*       BehaviorTracker;                                   // 0x0AD0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EndGameKickPlayersDelay;                           // 0x0AD8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_ADC[0x4];                                      // 0x0ADC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 VoiceChatChannelPositional;                        // 0x0AE0(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 VoiceChatChannelPrefix;                            // 0x0AF0(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FUniqueNetIdRepl, class FString>  WinningPlayersMap;                                 // 0x0B00(0x0050)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bAllowSpectateAfterDeath;                          // 0x0B50(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseRandomTimeOfDay;                               // 0x0B51(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B52[0x1E];                                     // 0x0B52(0x001E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAircraftEnteredDropZone();
	void OnAircraftExitedDropZone();
	void OnAircraftFlightEnded();
	void OnEndGameKickPlayers();
	void SafeZoneInsideChecks();
	void TrySupplyDrop();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameModeAthena">();
	}
	static class AFortGameModeAthena* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGameModeAthena>();
	}
};
static_assert(alignof(AFortGameModeAthena) == 0x000008, "Wrong alignment on AFortGameModeAthena");
static_assert(sizeof(AFortGameModeAthena) == 0x000B70, "Wrong size on AFortGameModeAthena");
static_assert(offsetof(AFortGameModeAthena, bAlwaysDBNO) == 0x000898, "Member 'AFortGameModeAthena::bAlwaysDBNO' has a wrong offset!");
static_assert(offsetof(AFortGameModeAthena, bDisableVoiceChat) == 0x000899, "Member 'AFortGameModeAthena::bDisableVoiceChat' has a wrong offset!");
static_assert(offsetof(AFortGameModeAthena, bSquadPlay) == 0x00089A, "Member 'AFortGameModeAthena::bSquadPlay' has a wrong offset!");
static_assert(offsetof(AFortGameModeAthena, OverloadedInitialConnectTimeout) == 0x00089C, "Member 'AFortGameModeAthena::OverloadedInitialConnectTimeout' has a wrong offset!");
static_assert(offsetof(AFortGameModeAthena, FailedMatchAssignmentTimeout) == 0x0008A0, "Member 'AFortGameModeAthena::FailedMatchAssignmentTimeout' has a wrong offset!");
static_assert(offsetof(AFortGameModeAthena, SupplyDropTimerHandle) == 0x0008D0, "Member 'AFortGameModeAthena::SupplyDropTimerHandle' has a wrong offset!");
static_assert(offsetof(AFortGameModeAthena, MaxPlayerCount) == 0x0008E0, "Member 'AFortGameModeAthena::MaxPlayerCount' has a wrong offset!");
static_assert(offsetof(AFortGameModeAthena, AlivePlayers) == 0x0008E8, "Member 'AFortGameModeAthena::AlivePlayers' has a wrong offset!");
static_assert(offsetof(AFortGameModeAthena, TeamAlivePlayers) == 0x0008F8, "Member 'AFortGameModeAthena::TeamAlivePlayers' has a wrong offset!");
static_assert(offsetof(AFortGameModeAthena, WarmupRequiredPlayerCount) == 0x000A8C, "Member 'AFortGameModeAthena::WarmupRequiredPlayerCount' has a wrong offset!");
static_assert(offsetof(AFortGameModeAthena, WarmupCountdownDuration) == 0x000A90, "Member 'AFortGameModeAthena::WarmupCountdownDuration' has a wrong offset!");
static_assert(offsetof(AFortGameModeAthena, WarmupEarlyCountdownDuration) == 0x000A98, "Member 'AFortGameModeAthena::WarmupEarlyCountdownDuration' has a wrong offset!");
static_assert(offsetof(AFortGameModeAthena, bSafeZoneActive) == 0x000A9C, "Member 'AFortGameModeAthena::bSafeZoneActive' has a wrong offset!");
static_assert(offsetof(AFortGameModeAthena, bSafeZonePaused) == 0x000A9D, "Member 'AFortGameModeAthena::bSafeZonePaused' has a wrong offset!");
static_assert(offsetof(AFortGameModeAthena, GE_OutsideSafeZone) == 0x000AA0, "Member 'AFortGameModeAthena::GE_OutsideSafeZone' has a wrong offset!");
static_assert(offsetof(AFortGameModeAthena, SafeZoneIndicatorClass) == 0x000AA8, "Member 'AFortGameModeAthena::SafeZoneIndicatorClass' has a wrong offset!");
static_assert(offsetof(AFortGameModeAthena, SafeZonePhase) == 0x000AB0, "Member 'AFortGameModeAthena::SafeZonePhase' has a wrong offset!");
static_assert(offsetof(AFortGameModeAthena, SafeZoneIndicator) == 0x000AB8, "Member 'AFortGameModeAthena::SafeZoneIndicator' has a wrong offset!");
static_assert(offsetof(AFortGameModeAthena, SafeZoneLocations) == 0x000AC0, "Member 'AFortGameModeAthena::SafeZoneLocations' has a wrong offset!");
static_assert(offsetof(AFortGameModeAthena, BehaviorTracker) == 0x000AD0, "Member 'AFortGameModeAthena::BehaviorTracker' has a wrong offset!");
static_assert(offsetof(AFortGameModeAthena, EndGameKickPlayersDelay) == 0x000AD8, "Member 'AFortGameModeAthena::EndGameKickPlayersDelay' has a wrong offset!");
static_assert(offsetof(AFortGameModeAthena, VoiceChatChannelPositional) == 0x000AE0, "Member 'AFortGameModeAthena::VoiceChatChannelPositional' has a wrong offset!");
static_assert(offsetof(AFortGameModeAthena, VoiceChatChannelPrefix) == 0x000AF0, "Member 'AFortGameModeAthena::VoiceChatChannelPrefix' has a wrong offset!");
static_assert(offsetof(AFortGameModeAthena, WinningPlayersMap) == 0x000B00, "Member 'AFortGameModeAthena::WinningPlayersMap' has a wrong offset!");
static_assert(offsetof(AFortGameModeAthena, bAllowSpectateAfterDeath) == 0x000B50, "Member 'AFortGameModeAthena::bAllowSpectateAfterDeath' has a wrong offset!");
static_assert(offsetof(AFortGameModeAthena, bUseRandomTimeOfDay) == 0x000B51, "Member 'AFortGameModeAthena::bUseRandomTimeOfDay' has a wrong offset!");

// Class FortniteGame.FortGameplayAbility_AIPortal
// 0x0058 (0x0AA0 - 0x0A48)
class UFortGameplayAbility_AIPortal final : public UFortGameplayAbility_Action
{
public:
	struct FVector                                PortalDirection;                                   // 0x0A48(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A54[0x20];                                     // 0x0A54(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PortalLifespan;                                    // 0x0A74(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ABuildingSMActor*>               NoCollisionBuildings;                              // 0x0A78(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A88[0x18];                                     // 0x0A88(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ModifyCollisions();

	class ABuildingSMActor* GetPortalBuilding() const;
	struct FVector GetPortalInPoint() const;
	struct FVector GetPortalOutPoint() const;
	bool HasPortalOutPoint() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameplayAbility_AIPortal">();
	}
	static class UFortGameplayAbility_AIPortal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGameplayAbility_AIPortal>();
	}
};
static_assert(alignof(UFortGameplayAbility_AIPortal) == 0x000008, "Wrong alignment on UFortGameplayAbility_AIPortal");
static_assert(sizeof(UFortGameplayAbility_AIPortal) == 0x000AA0, "Wrong size on UFortGameplayAbility_AIPortal");
static_assert(offsetof(UFortGameplayAbility_AIPortal, PortalDirection) == 0x000A48, "Member 'UFortGameplayAbility_AIPortal::PortalDirection' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility_AIPortal, PortalLifespan) == 0x000A74, "Member 'UFortGameplayAbility_AIPortal::PortalLifespan' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility_AIPortal, NoCollisionBuildings) == 0x000A78, "Member 'UFortGameplayAbility_AIPortal::NoCollisionBuildings' has a wrong offset!");

// Class FortniteGame.FortGameplayAbility_Crouch
// 0x0008 (0x0A50 - 0x0A48)
class UFortGameplayAbility_Crouch final : public UFortGameplayAbility_Action
{
public:
	uint8                                         Pad_A48[0x8];                                      // 0x0A48(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameplayAbility_Crouch">();
	}
	static class UFortGameplayAbility_Crouch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGameplayAbility_Crouch>();
	}
};
static_assert(alignof(UFortGameplayAbility_Crouch) == 0x000008, "Wrong alignment on UFortGameplayAbility_Crouch");
static_assert(sizeof(UFortGameplayAbility_Crouch) == 0x000A50, "Wrong size on UFortGameplayAbility_Crouch");

// Class FortniteGame.FortGameplayAbility_Sprint
// 0x0008 (0x0A50 - 0x0A48)
class UFortGameplayAbility_Sprint final : public UFortGameplayAbility_Action
{
public:
	uint8                                         Pad_A48[0x8];                                      // 0x0A48(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameplayAbility_Sprint">();
	}
	static class UFortGameplayAbility_Sprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGameplayAbility_Sprint>();
	}
};
static_assert(alignof(UFortGameplayAbility_Sprint) == 0x000008, "Wrong alignment on UFortGameplayAbility_Sprint");
static_assert(sizeof(UFortGameplayAbility_Sprint) == 0x000A50, "Wrong size on UFortGameplayAbility_Sprint");

// Class FortniteGame.FortGameplayAbility_AITurnTransition
// 0x0050 (0x0A90 - 0x0A40)
class UFortGameplayAbility_AITurnTransition final : public UFortGameplayAbility
{
public:
	struct FGameplayTagContainer                  RequiredWeaponTags;                                // 0x0A40(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         MinTurnTransitionYawAngle;                         // 0x0A60(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A64[0x4];                                      // 0x0A64(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTurnTransitionData>            TransitionPriorityList;                            // 0x0A68(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   PickedMontageSectionName;                          // 0x0A78(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PickedTurnYawRotationRate;                         // 0x0A80(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A84[0xC];                                      // 0x0A84(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetTurnTransitionMontageSectionNameAndYawRotationRate(class FName* MontageSectionName, float* TurnYawRotationRate) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameplayAbility_AITurnTransition">();
	}
	static class UFortGameplayAbility_AITurnTransition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGameplayAbility_AITurnTransition>();
	}
};
static_assert(alignof(UFortGameplayAbility_AITurnTransition) == 0x000008, "Wrong alignment on UFortGameplayAbility_AITurnTransition");
static_assert(sizeof(UFortGameplayAbility_AITurnTransition) == 0x000A90, "Wrong size on UFortGameplayAbility_AITurnTransition");
static_assert(offsetof(UFortGameplayAbility_AITurnTransition, RequiredWeaponTags) == 0x000A40, "Member 'UFortGameplayAbility_AITurnTransition::RequiredWeaponTags' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility_AITurnTransition, MinTurnTransitionYawAngle) == 0x000A60, "Member 'UFortGameplayAbility_AITurnTransition::MinTurnTransitionYawAngle' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility_AITurnTransition, TransitionPriorityList) == 0x000A68, "Member 'UFortGameplayAbility_AITurnTransition::TransitionPriorityList' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility_AITurnTransition, PickedMontageSectionName) == 0x000A78, "Member 'UFortGameplayAbility_AITurnTransition::PickedMontageSectionName' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility_AITurnTransition, PickedTurnYawRotationRate) == 0x000A80, "Member 'UFortGameplayAbility_AITurnTransition::PickedTurnYawRotationRate' has a wrong offset!");

// Class FortniteGame.FortGameplayAbility_CeilingFallingTrap
// 0x0030 (0x0A70 - 0x0A40)
class UFortGameplayAbility_CeilingFallingTrap final : public UFortGameplayAbility
{
public:
	TSubclassOf<class AFortProjectileBase>        TrapProjectileClass;                               // 0x0A40(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            TargetGameplayEffectTemplate;                      // 0x0A48(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ActivateTrapTag;                                   // 0x0A50(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DelayBeginTag;                                     // 0x0A58(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A60[0x10];                                     // 0x0A60(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameplayAbility_CeilingFallingTrap">();
	}
	static class UFortGameplayAbility_CeilingFallingTrap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGameplayAbility_CeilingFallingTrap>();
	}
};
static_assert(alignof(UFortGameplayAbility_CeilingFallingTrap) == 0x000008, "Wrong alignment on UFortGameplayAbility_CeilingFallingTrap");
static_assert(sizeof(UFortGameplayAbility_CeilingFallingTrap) == 0x000A70, "Wrong size on UFortGameplayAbility_CeilingFallingTrap");
static_assert(offsetof(UFortGameplayAbility_CeilingFallingTrap, TrapProjectileClass) == 0x000A40, "Member 'UFortGameplayAbility_CeilingFallingTrap::TrapProjectileClass' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility_CeilingFallingTrap, TargetGameplayEffectTemplate) == 0x000A48, "Member 'UFortGameplayAbility_CeilingFallingTrap::TargetGameplayEffectTemplate' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility_CeilingFallingTrap, ActivateTrapTag) == 0x000A50, "Member 'UFortGameplayAbility_CeilingFallingTrap::ActivateTrapTag' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility_CeilingFallingTrap, DelayBeginTag) == 0x000A58, "Member 'UFortGameplayAbility_CeilingFallingTrap::DelayBeginTag' has a wrong offset!");

// Class FortniteGame.FortGameplayAbility_PlayConversation
// 0x0010 (0x0A50 - 0x0A40)
class UFortGameplayAbility_PlayConversation final : public UFortGameplayAbility
{
public:
	class UFortConversation*                      ConversationToPlay;                                // 0x0A40(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A48[0x8];                                      // 0x0A48(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameplayAbility_PlayConversation">();
	}
	static class UFortGameplayAbility_PlayConversation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGameplayAbility_PlayConversation>();
	}
};
static_assert(alignof(UFortGameplayAbility_PlayConversation) == 0x000008, "Wrong alignment on UFortGameplayAbility_PlayConversation");
static_assert(sizeof(UFortGameplayAbility_PlayConversation) == 0x000A50, "Wrong size on UFortGameplayAbility_PlayConversation");
static_assert(offsetof(UFortGameplayAbility_PlayConversation, ConversationToPlay) == 0x000A40, "Member 'UFortGameplayAbility_PlayConversation::ConversationToPlay' has a wrong offset!");

// Class FortniteGame.FortGameplayAbility_RangedWeapon
// 0x0040 (0x0A80 - 0x0A40)
class UFortGameplayAbility_RangedWeapon final : public UFortGameplayAbility
{
public:
	float                                         FiringNoiseRange;                                  // 0x0A40(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A44[0x4];                                      // 0x0A44(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortWeaponRanged*                      CurrentWeapon;                                     // 0x0A48(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  WeaponFireCue;                                     // 0x0A50(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_A70[0x10];                                     // 0x0A70(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameplayAbility_RangedWeapon">();
	}
	static class UFortGameplayAbility_RangedWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGameplayAbility_RangedWeapon>();
	}
};
static_assert(alignof(UFortGameplayAbility_RangedWeapon) == 0x000008, "Wrong alignment on UFortGameplayAbility_RangedWeapon");
static_assert(sizeof(UFortGameplayAbility_RangedWeapon) == 0x000A80, "Wrong size on UFortGameplayAbility_RangedWeapon");
static_assert(offsetof(UFortGameplayAbility_RangedWeapon, FiringNoiseRange) == 0x000A40, "Member 'UFortGameplayAbility_RangedWeapon::FiringNoiseRange' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility_RangedWeapon, CurrentWeapon) == 0x000A48, "Member 'UFortGameplayAbility_RangedWeapon::CurrentWeapon' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility_RangedWeapon, WeaponFireCue) == 0x000A50, "Member 'UFortGameplayAbility_RangedWeapon::WeaponFireCue' has a wrong offset!");

// Class FortniteGame.FortGameplayAbility_Reload
// 0x0020 (0x0A60 - 0x0A40)
class UFortGameplayAbility_Reload final : public UFortGameplayAbility
{
public:
	int32                                         NumTimesReloaded;                                  // 0x0A40(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A44[0x1C];                                     // 0x0A44(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameplayAbility_Reload">();
	}
	static class UFortGameplayAbility_Reload* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGameplayAbility_Reload>();
	}
};
static_assert(alignof(UFortGameplayAbility_Reload) == 0x000008, "Wrong alignment on UFortGameplayAbility_Reload");
static_assert(sizeof(UFortGameplayAbility_Reload) == 0x000A60, "Wrong size on UFortGameplayAbility_Reload");
static_assert(offsetof(UFortGameplayAbility_Reload, NumTimesReloaded) == 0x000A40, "Member 'UFortGameplayAbility_Reload::NumTimesReloaded' has a wrong offset!");

// Class FortniteGame.FortGameplayCueManager
// 0x0000 (0x03B0 - 0x03B0)
class UFortGameplayCueManager final : public UGameplayCueManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameplayCueManager">();
	}
	static class UFortGameplayCueManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGameplayCueManager>();
	}
};
static_assert(alignof(UFortGameplayCueManager) == 0x000010, "Wrong alignment on UFortGameplayCueManager");
static_assert(sizeof(UFortGameplayCueManager) == 0x0003B0, "Wrong size on UFortGameplayCueManager");

// Class FortniteGame.FortGameplayCueNotify_Looping
// 0x0080 (0x0468 - 0x03E8)
class AFortGameplayCueNotify_Looping : public AGameplayCueNotify_Actor
{
public:
	class USoundBase*                             StartSound;                                        // 0x03E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             StopSound;                                         // 0x03F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        StartParticleSystem;                               // 0x03F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFortParticleSystemParamBucket         StartParticleSystemParameters;                     // 0x0400(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UParticleSystem*                        StopParticleSystem;                                // 0x0410(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFortParticleSystemParamBucket         StopParticleSystemParameters;                      // 0x0418(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FName                                   AttachPoint;                                       // 0x0428(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStayAttached;                                     // 0x0430(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseHitResult;                                     // 0x0431(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseWeapon;                                        // 0x0432(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreRotation;                                   // 0x0433(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_434[0x4];                                      // 0x0434(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  HUDElementTag;                                     // 0x0438(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UAudioComponent*                        AudioComponent;                                    // 0x0458(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystemComponent*               ParticleSystemComponent;                           // 0x0460(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnStartParticleSystemSpawned(class UParticleSystemComponent* SpawnedParticleSysComponent, const struct FGameplayCueParameters& Parameters) const;
	void OnStopParticleSystemSpawned(class UParticleSystemComponent* SpawnedParticleSysComponent, const struct FGameplayCueParameters& Parameters) const;
	void OnWhileActiveParticleSystemActivate(class UParticleSystemComponent* WhileActiveParticleSysComponent, const struct FGameplayCueParameters& Parameters) const;
	void OnWhileActiveParticleSystemDeactivate(class UParticleSystemComponent* WhileActiveParticleSysComponent, const struct FGameplayCueParameters& Parameters) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameplayCueNotify_Looping">();
	}
	static class AFortGameplayCueNotify_Looping* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGameplayCueNotify_Looping>();
	}
};
static_assert(alignof(AFortGameplayCueNotify_Looping) == 0x000008, "Wrong alignment on AFortGameplayCueNotify_Looping");
static_assert(sizeof(AFortGameplayCueNotify_Looping) == 0x000468, "Wrong size on AFortGameplayCueNotify_Looping");
static_assert(offsetof(AFortGameplayCueNotify_Looping, StartSound) == 0x0003E8, "Member 'AFortGameplayCueNotify_Looping::StartSound' has a wrong offset!");
static_assert(offsetof(AFortGameplayCueNotify_Looping, StopSound) == 0x0003F0, "Member 'AFortGameplayCueNotify_Looping::StopSound' has a wrong offset!");
static_assert(offsetof(AFortGameplayCueNotify_Looping, StartParticleSystem) == 0x0003F8, "Member 'AFortGameplayCueNotify_Looping::StartParticleSystem' has a wrong offset!");
static_assert(offsetof(AFortGameplayCueNotify_Looping, StartParticleSystemParameters) == 0x000400, "Member 'AFortGameplayCueNotify_Looping::StartParticleSystemParameters' has a wrong offset!");
static_assert(offsetof(AFortGameplayCueNotify_Looping, StopParticleSystem) == 0x000410, "Member 'AFortGameplayCueNotify_Looping::StopParticleSystem' has a wrong offset!");
static_assert(offsetof(AFortGameplayCueNotify_Looping, StopParticleSystemParameters) == 0x000418, "Member 'AFortGameplayCueNotify_Looping::StopParticleSystemParameters' has a wrong offset!");
static_assert(offsetof(AFortGameplayCueNotify_Looping, AttachPoint) == 0x000428, "Member 'AFortGameplayCueNotify_Looping::AttachPoint' has a wrong offset!");
static_assert(offsetof(AFortGameplayCueNotify_Looping, bStayAttached) == 0x000430, "Member 'AFortGameplayCueNotify_Looping::bStayAttached' has a wrong offset!");
static_assert(offsetof(AFortGameplayCueNotify_Looping, bUseHitResult) == 0x000431, "Member 'AFortGameplayCueNotify_Looping::bUseHitResult' has a wrong offset!");
static_assert(offsetof(AFortGameplayCueNotify_Looping, bUseWeapon) == 0x000432, "Member 'AFortGameplayCueNotify_Looping::bUseWeapon' has a wrong offset!");
static_assert(offsetof(AFortGameplayCueNotify_Looping, bIgnoreRotation) == 0x000433, "Member 'AFortGameplayCueNotify_Looping::bIgnoreRotation' has a wrong offset!");
static_assert(offsetof(AFortGameplayCueNotify_Looping, HUDElementTag) == 0x000438, "Member 'AFortGameplayCueNotify_Looping::HUDElementTag' has a wrong offset!");
static_assert(offsetof(AFortGameplayCueNotify_Looping, AudioComponent) == 0x000458, "Member 'AFortGameplayCueNotify_Looping::AudioComponent' has a wrong offset!");
static_assert(offsetof(AFortGameplayCueNotify_Looping, ParticleSystemComponent) == 0x000460, "Member 'AFortGameplayCueNotify_Looping::ParticleSystemComponent' has a wrong offset!");

// Class FortniteGame.FortGameplayCueNotify_Simple
// 0x0030 (0x0070 - 0x0040)
class UFortGameplayCueNotify_Simple : public UGameplayCueNotify_Static
{
public:
	class USoundBase*                             StartSound;                                        // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        StartParticleSystem;                               // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFortParticleSystemParamBucket         StartParticleSystemParameters;                     // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FName                                   AttachPoint;                                       // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStayAttached;                                     // 0x0068(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseHitResult;                                     // 0x0069(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseWeapon;                                        // 0x006A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreRotation;                                   // 0x006B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnStartParticleSystemSpawned(class UParticleSystemComponent* SpawnedParticleSysComponent, const struct FGameplayCueParameters& Parameters) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameplayCueNotify_Simple">();
	}
	static class UFortGameplayCueNotify_Simple* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGameplayCueNotify_Simple>();
	}
};
static_assert(alignof(UFortGameplayCueNotify_Simple) == 0x000008, "Wrong alignment on UFortGameplayCueNotify_Simple");
static_assert(sizeof(UFortGameplayCueNotify_Simple) == 0x000070, "Wrong size on UFortGameplayCueNotify_Simple");
static_assert(offsetof(UFortGameplayCueNotify_Simple, StartSound) == 0x000040, "Member 'UFortGameplayCueNotify_Simple::StartSound' has a wrong offset!");
static_assert(offsetof(UFortGameplayCueNotify_Simple, StartParticleSystem) == 0x000048, "Member 'UFortGameplayCueNotify_Simple::StartParticleSystem' has a wrong offset!");
static_assert(offsetof(UFortGameplayCueNotify_Simple, StartParticleSystemParameters) == 0x000050, "Member 'UFortGameplayCueNotify_Simple::StartParticleSystemParameters' has a wrong offset!");
static_assert(offsetof(UFortGameplayCueNotify_Simple, AttachPoint) == 0x000060, "Member 'UFortGameplayCueNotify_Simple::AttachPoint' has a wrong offset!");
static_assert(offsetof(UFortGameplayCueNotify_Simple, bStayAttached) == 0x000068, "Member 'UFortGameplayCueNotify_Simple::bStayAttached' has a wrong offset!");
static_assert(offsetof(UFortGameplayCueNotify_Simple, bUseHitResult) == 0x000069, "Member 'UFortGameplayCueNotify_Simple::bUseHitResult' has a wrong offset!");
static_assert(offsetof(UFortGameplayCueNotify_Simple, bUseWeapon) == 0x00006A, "Member 'UFortGameplayCueNotify_Simple::bUseWeapon' has a wrong offset!");
static_assert(offsetof(UFortGameplayCueNotify_Simple, bIgnoreRotation) == 0x00006B, "Member 'UFortGameplayCueNotify_Simple::bIgnoreRotation' has a wrong offset!");

// Class FortniteGame.FortAreaOfEffectCloud
// 0x0000 (0x0680 - 0x0680)
class AFortAreaOfEffectCloud final : public AFortGameplayEffectDeliveryActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAreaOfEffectCloud">();
	}
	static class AFortAreaOfEffectCloud* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAreaOfEffectCloud>();
	}
};
static_assert(alignof(AFortAreaOfEffectCloud) == 0x000008, "Wrong alignment on AFortAreaOfEffectCloud");
static_assert(sizeof(AFortAreaOfEffectCloud) == 0x000680, "Wrong size on AFortAreaOfEffectCloud");

// Class FortniteGame.FortProjectile_MOBATurret
// 0x0018 (0x0810 - 0x07F8)
class AFortProjectile_MOBATurret final : public AFortProjectileBase
{
public:
	TArray<struct FHitResult>                     ForcedHitResults;                                  // 0x07F8(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_808[0x8];                                      // 0x0808(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHomingTargetDied(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, class AActor* DamageCauser, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& Momentum);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortProjectile_MOBATurret">();
	}
	static class AFortProjectile_MOBATurret* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortProjectile_MOBATurret>();
	}
};
static_assert(alignof(AFortProjectile_MOBATurret) == 0x000008, "Wrong alignment on AFortProjectile_MOBATurret");
static_assert(sizeof(AFortProjectile_MOBATurret) == 0x000810, "Wrong size on AFortProjectile_MOBATurret");
static_assert(offsetof(AFortProjectile_MOBATurret, ForcedHitResults) == 0x0007F8, "Member 'AFortProjectile_MOBATurret::ForcedHitResults' has a wrong offset!");

// Class FortniteGame.FortQueryGenerator_BuildingsOnCachedPath
// 0x0098 (0x00E8 - 0x0050)
class UFortQueryGenerator_BuildingsOnCachedPath final : public UEnvQueryGenerator
{
public:
	TSubclassOf<class UEnvQueryContext>           CachedPathSource;                                  // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FAIDataProviderBoolValue               bIncludeWalls;                                     // 0x0058(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderBoolValue               bIncludeFloors;                                    // 0x0088(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderBoolValue               bIncludeCenterCell;                                // 0x00B8(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_BuildingsOnCachedPath">();
	}
	static class UFortQueryGenerator_BuildingsOnCachedPath* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_BuildingsOnCachedPath>();
	}
};
static_assert(alignof(UFortQueryGenerator_BuildingsOnCachedPath) == 0x000008, "Wrong alignment on UFortQueryGenerator_BuildingsOnCachedPath");
static_assert(sizeof(UFortQueryGenerator_BuildingsOnCachedPath) == 0x0000E8, "Wrong size on UFortQueryGenerator_BuildingsOnCachedPath");
static_assert(offsetof(UFortQueryGenerator_BuildingsOnCachedPath, CachedPathSource) == 0x000050, "Member 'UFortQueryGenerator_BuildingsOnCachedPath::CachedPathSource' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_BuildingsOnCachedPath, bIncludeWalls) == 0x000058, "Member 'UFortQueryGenerator_BuildingsOnCachedPath::bIncludeWalls' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_BuildingsOnCachedPath, bIncludeFloors) == 0x000088, "Member 'UFortQueryGenerator_BuildingsOnCachedPath::bIncludeFloors' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_BuildingsOnCachedPath, bIncludeCenterCell) == 0x0000B8, "Member 'UFortQueryGenerator_BuildingsOnCachedPath::bIncludeCenterCell' has a wrong offset!");

// Class FortniteGame.FortDamageFormulaExecutionCalculation
// 0x0008 (0x0048 - 0x0040)
class UFortDamageFormulaExecutionCalculation final : public UFortGameplayEffectExecutionCalculation
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDamageFormulaExecutionCalculation">();
	}
	static class UFortDamageFormulaExecutionCalculation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDamageFormulaExecutionCalculation>();
	}
};
static_assert(alignof(UFortDamageFormulaExecutionCalculation) == 0x000008, "Wrong alignment on UFortDamageFormulaExecutionCalculation");
static_assert(sizeof(UFortDamageFormulaExecutionCalculation) == 0x000048, "Wrong size on UFortDamageFormulaExecutionCalculation");

// Class FortniteGame.FortHealing
// 0x0000 (0x0040 - 0x0040)
class UFortHealing final : public UFortGameplayEffectExecutionCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortHealing">();
	}
	static class UFortHealing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortHealing>();
	}
};
static_assert(alignof(UFortHealing) == 0x000008, "Wrong alignment on UFortHealing");
static_assert(sizeof(UFortHealing) == 0x000040, "Wrong size on UFortHealing");

// Class FortniteGame.FromFortitudeModMagnitudeCalculation
// 0x0070 (0x00B0 - 0x0040)
class UFromFortitudeModMagnitudeCalculation final : public UFortGameplayModMagnitudeCalculation
{
public:
	uint8                                         Pad_40[0x70];                                      // 0x0040(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FromFortitudeModMagnitudeCalculation">();
	}
	static class UFromFortitudeModMagnitudeCalculation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFromFortitudeModMagnitudeCalculation>();
	}
};
static_assert(alignof(UFromFortitudeModMagnitudeCalculation) == 0x000008, "Wrong alignment on UFromFortitudeModMagnitudeCalculation");
static_assert(sizeof(UFromFortitudeModMagnitudeCalculation) == 0x0000B0, "Wrong size on UFromFortitudeModMagnitudeCalculation");

// Class FortniteGame.FortQueryGenerator_PointsAroundLine
// 0x0088 (0x0108 - 0x0080)
class UFortQueryGenerator_PointsAroundLine final : public UEnvQueryGenerator_ProjectedPoints
{
public:
	TSubclassOf<class UEnvQueryContext>           GenerateAround;                                    // 0x0080(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAIDataProviderIntValue                MaxPointsPerClusterLocation;                       // 0x0088(0x0030)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              ClusterRadius;                                     // 0x00B8(0x0030)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFortQueryData_CurvesAroundLine> CurvesAroundLineAsset;                             // 0x00E8(0x0020)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_PointsAroundLine">();
	}
	static class UFortQueryGenerator_PointsAroundLine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_PointsAroundLine>();
	}
};
static_assert(alignof(UFortQueryGenerator_PointsAroundLine) == 0x000008, "Wrong alignment on UFortQueryGenerator_PointsAroundLine");
static_assert(sizeof(UFortQueryGenerator_PointsAroundLine) == 0x000108, "Wrong size on UFortQueryGenerator_PointsAroundLine");
static_assert(offsetof(UFortQueryGenerator_PointsAroundLine, GenerateAround) == 0x000080, "Member 'UFortQueryGenerator_PointsAroundLine::GenerateAround' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsAroundLine, MaxPointsPerClusterLocation) == 0x000088, "Member 'UFortQueryGenerator_PointsAroundLine::MaxPointsPerClusterLocation' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsAroundLine, ClusterRadius) == 0x0000B8, "Member 'UFortQueryGenerator_PointsAroundLine::ClusterRadius' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsAroundLine, CurvesAroundLineAsset) == 0x0000E8, "Member 'UFortQueryGenerator_PointsAroundLine::CurvesAroundLineAsset' has a wrong offset!");

// Class FortniteGame.FromResistanceModMagnitudeCalculation
// 0x0070 (0x00B0 - 0x0040)
class UFromResistanceModMagnitudeCalculation final : public UFortGameplayModMagnitudeCalculation
{
public:
	uint8                                         Pad_40[0x70];                                      // 0x0040(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FromResistanceModMagnitudeCalculation">();
	}
	static class UFromResistanceModMagnitudeCalculation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFromResistanceModMagnitudeCalculation>();
	}
};
static_assert(alignof(UFromResistanceModMagnitudeCalculation) == 0x000008, "Wrong alignment on UFromResistanceModMagnitudeCalculation");
static_assert(sizeof(UFromResistanceModMagnitudeCalculation) == 0x0000B0, "Wrong size on UFromResistanceModMagnitudeCalculation");

// Class FortniteGame.FromTeamFortitudeModMagnitudeCalculation
// 0x0070 (0x00B0 - 0x0040)
class UFromTeamFortitudeModMagnitudeCalculation final : public UFortGameplayModMagnitudeCalculation
{
public:
	uint8                                         Pad_40[0x70];                                      // 0x0040(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FromTeamFortitudeModMagnitudeCalculation">();
	}
	static class UFromTeamFortitudeModMagnitudeCalculation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFromTeamFortitudeModMagnitudeCalculation>();
	}
};
static_assert(alignof(UFromTeamFortitudeModMagnitudeCalculation) == 0x000008, "Wrong alignment on UFromTeamFortitudeModMagnitudeCalculation");
static_assert(sizeof(UFromTeamFortitudeModMagnitudeCalculation) == 0x0000B0, "Wrong size on UFromTeamFortitudeModMagnitudeCalculation");

// Class FortniteGame.FromTeamOffenseModMagnitudeCalculation
// 0x0070 (0x00B0 - 0x0040)
class UFromTeamOffenseModMagnitudeCalculation final : public UFortGameplayModMagnitudeCalculation
{
public:
	uint8                                         Pad_40[0x70];                                      // 0x0040(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FromTeamOffenseModMagnitudeCalculation">();
	}
	static class UFromTeamOffenseModMagnitudeCalculation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFromTeamOffenseModMagnitudeCalculation>();
	}
};
static_assert(alignof(UFromTeamOffenseModMagnitudeCalculation) == 0x000008, "Wrong alignment on UFromTeamOffenseModMagnitudeCalculation");
static_assert(sizeof(UFromTeamOffenseModMagnitudeCalculation) == 0x0000B0, "Wrong size on UFromTeamOffenseModMagnitudeCalculation");

// Class FortniteGame.FromTeamTechModMagnitudeCalculation
// 0x0070 (0x00B0 - 0x0040)
class UFromTeamTechModMagnitudeCalculation final : public UFortGameplayModMagnitudeCalculation
{
public:
	uint8                                         Pad_40[0x70];                                      // 0x0040(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FromTeamTechModMagnitudeCalculation">();
	}
	static class UFromTeamTechModMagnitudeCalculation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFromTeamTechModMagnitudeCalculation>();
	}
};
static_assert(alignof(UFromTeamTechModMagnitudeCalculation) == 0x000008, "Wrong alignment on UFromTeamTechModMagnitudeCalculation");
static_assert(sizeof(UFromTeamTechModMagnitudeCalculation) == 0x0000B0, "Wrong size on UFromTeamTechModMagnitudeCalculation");

// Class FortniteGame.FromTechModMagnitudeCalculation
// 0x0070 (0x00B0 - 0x0040)
class UFromTechModMagnitudeCalculation final : public UFortGameplayModMagnitudeCalculation
{
public:
	uint8                                         Pad_40[0x70];                                      // 0x0040(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FromTechModMagnitudeCalculation">();
	}
	static class UFromTechModMagnitudeCalculation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFromTechModMagnitudeCalculation>();
	}
};
static_assert(alignof(UFromTechModMagnitudeCalculation) == 0x000008, "Wrong alignment on UFromTechModMagnitudeCalculation");
static_assert(sizeof(UFromTechModMagnitudeCalculation) == 0x0000B0, "Wrong size on UFromTechModMagnitudeCalculation");

// Class FortniteGame.PlayerTrapBonusModMagnitudeCalculation
// 0x0028 (0x0068 - 0x0040)
class UPlayerTrapBonusModMagnitudeCalculation : public UFortGameplayModMagnitudeCalculation
{
public:
	struct FGameplayAttribute                     Attribute;                                         // 0x0040(0x0020)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AttributeDefaultValue;                             // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerTrapBonusModMagnitudeCalculation">();
	}
	static class UPlayerTrapBonusModMagnitudeCalculation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerTrapBonusModMagnitudeCalculation>();
	}
};
static_assert(alignof(UPlayerTrapBonusModMagnitudeCalculation) == 0x000008, "Wrong alignment on UPlayerTrapBonusModMagnitudeCalculation");
static_assert(sizeof(UPlayerTrapBonusModMagnitudeCalculation) == 0x000068, "Wrong size on UPlayerTrapBonusModMagnitudeCalculation");
static_assert(offsetof(UPlayerTrapBonusModMagnitudeCalculation, Attribute) == 0x000040, "Member 'UPlayerTrapBonusModMagnitudeCalculation::Attribute' has a wrong offset!");
static_assert(offsetof(UPlayerTrapBonusModMagnitudeCalculation, AttributeDefaultValue) == 0x000060, "Member 'UPlayerTrapBonusModMagnitudeCalculation::AttributeDefaultValue' has a wrong offset!");

// Class FortniteGame.FortGameplayMutator_AILevelVariance
// 0x0008 (0x0398 - 0x0390)
class AFortGameplayMutator_AILevelVariance final : public AFortGameplayMutator
{
public:
	float                                         MinVariance;                                       // 0x0390(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxVariance;                                       // 0x0394(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameplayMutator_AILevelVariance">();
	}
	static class AFortGameplayMutator_AILevelVariance* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGameplayMutator_AILevelVariance>();
	}
};
static_assert(alignof(AFortGameplayMutator_AILevelVariance) == 0x000008, "Wrong alignment on AFortGameplayMutator_AILevelVariance");
static_assert(sizeof(AFortGameplayMutator_AILevelVariance) == 0x000398, "Wrong size on AFortGameplayMutator_AILevelVariance");
static_assert(offsetof(AFortGameplayMutator_AILevelVariance, MinVariance) == 0x000390, "Member 'AFortGameplayMutator_AILevelVariance::MinVariance' has a wrong offset!");
static_assert(offsetof(AFortGameplayMutator_AILevelVariance, MaxVariance) == 0x000394, "Member 'AFortGameplayMutator_AILevelVariance::MaxVariance' has a wrong offset!");

// Class FortniteGame.FortGameSession
// 0x00F0 (0x0490 - 0x03A0)
class AFortGameSession : public AGameSession
{
public:
	uint8                                         Pad_3A0[0x80];                                     // 0x03A0(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortHostSessionParams                 CurrentSessionParams;                              // 0x0420(0x0010)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_430[0x10];                                     // 0x0430(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AOnlineBeaconHostObject>    ReservationBeaconHostClass;                        // 0x0440(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AOnlineBeaconHostObject>    QosBeaconHostClass;                                // 0x0448(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_450[0x8];                                      // 0x0450(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortPartyBeaconHost*                   ReservationBeaconHost;                             // 0x0458(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortLobbyBeaconHost*                   LobbyBeaconHost;                                   // 0x0460(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FFortDisconnectedPlayerReservation> DisconnectedPlayerReservations;                    // 0x0468(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	float                                         DisconnectedReservationTimeout;                    // 0x0478(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_47C[0x14];                                     // 0x047C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DumpReservations() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameSession">();
	}
	static class AFortGameSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGameSession>();
	}
};
static_assert(alignof(AFortGameSession) == 0x000008, "Wrong alignment on AFortGameSession");
static_assert(sizeof(AFortGameSession) == 0x000490, "Wrong size on AFortGameSession");
static_assert(offsetof(AFortGameSession, CurrentSessionParams) == 0x000420, "Member 'AFortGameSession::CurrentSessionParams' has a wrong offset!");
static_assert(offsetof(AFortGameSession, ReservationBeaconHostClass) == 0x000440, "Member 'AFortGameSession::ReservationBeaconHostClass' has a wrong offset!");
static_assert(offsetof(AFortGameSession, QosBeaconHostClass) == 0x000448, "Member 'AFortGameSession::QosBeaconHostClass' has a wrong offset!");
static_assert(offsetof(AFortGameSession, ReservationBeaconHost) == 0x000458, "Member 'AFortGameSession::ReservationBeaconHost' has a wrong offset!");
static_assert(offsetof(AFortGameSession, LobbyBeaconHost) == 0x000460, "Member 'AFortGameSession::LobbyBeaconHost' has a wrong offset!");
static_assert(offsetof(AFortGameSession, DisconnectedPlayerReservations) == 0x000468, "Member 'AFortGameSession::DisconnectedPlayerReservations' has a wrong offset!");
static_assert(offsetof(AFortGameSession, DisconnectedReservationTimeout) == 0x000478, "Member 'AFortGameSession::DisconnectedReservationTimeout' has a wrong offset!");

// Class FortniteGame.FortGameSessionDedicated
// 0x02B0 (0x0740 - 0x0490)
class AFortGameSessionDedicated final : public AFortGameSession
{
public:
	uint8                                         Pad_490[0xC0];                                     // 0x0490(0x00C0)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HotfixCheckTimer;                                  // 0x0550(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HotfixCheckVariance;                               // 0x0554(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_558[0x68];                                     // 0x0558(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConsoleSessionRetryWaitSeconds;                    // 0x05C0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         IdleResetShortTimer;                               // 0x05C4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C8[0x80];                                     // 0x05C8(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReconnectToMMSDelay;                               // 0x0648(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxReconnectToMMSDelay;                            // 0x064C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_650[0x8];                                      // 0x0650(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MMSVersionCompatability;                           // 0x0658(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 MMSTicketURLServer;                                // 0x0668(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MMSPingInterval;                                   // 0x0678(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_67C[0xC4];                                     // 0x067C(0x00C4)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameSessionDedicated">();
	}
	static class AFortGameSessionDedicated* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGameSessionDedicated>();
	}
};
static_assert(alignof(AFortGameSessionDedicated) == 0x000008, "Wrong alignment on AFortGameSessionDedicated");
static_assert(sizeof(AFortGameSessionDedicated) == 0x000740, "Wrong size on AFortGameSessionDedicated");
static_assert(offsetof(AFortGameSessionDedicated, HotfixCheckTimer) == 0x000550, "Member 'AFortGameSessionDedicated::HotfixCheckTimer' has a wrong offset!");
static_assert(offsetof(AFortGameSessionDedicated, HotfixCheckVariance) == 0x000554, "Member 'AFortGameSessionDedicated::HotfixCheckVariance' has a wrong offset!");
static_assert(offsetof(AFortGameSessionDedicated, ConsoleSessionRetryWaitSeconds) == 0x0005C0, "Member 'AFortGameSessionDedicated::ConsoleSessionRetryWaitSeconds' has a wrong offset!");
static_assert(offsetof(AFortGameSessionDedicated, IdleResetShortTimer) == 0x0005C4, "Member 'AFortGameSessionDedicated::IdleResetShortTimer' has a wrong offset!");
static_assert(offsetof(AFortGameSessionDedicated, ReconnectToMMSDelay) == 0x000648, "Member 'AFortGameSessionDedicated::ReconnectToMMSDelay' has a wrong offset!");
static_assert(offsetof(AFortGameSessionDedicated, MaxReconnectToMMSDelay) == 0x00064C, "Member 'AFortGameSessionDedicated::MaxReconnectToMMSDelay' has a wrong offset!");
static_assert(offsetof(AFortGameSessionDedicated, MMSVersionCompatability) == 0x000658, "Member 'AFortGameSessionDedicated::MMSVersionCompatability' has a wrong offset!");
static_assert(offsetof(AFortGameSessionDedicated, MMSTicketURLServer) == 0x000668, "Member 'AFortGameSessionDedicated::MMSTicketURLServer' has a wrong offset!");
static_assert(offsetof(AFortGameSessionDedicated, MMSPingInterval) == 0x000678, "Member 'AFortGameSessionDedicated::MMSPingInterval' has a wrong offset!");

// Class FortniteGame.FortQueryTest_GameplayTagsPerDifficulty
// 0x0010 (0x01D0 - 0x01C0)
class UFortQueryTest_GameplayTagsPerDifficulty final : public UEnvQueryTest
{
public:
	TArray<struct FFortGameplayTagQueryPerDifficulty> TagQueriesPerDifficulty;                           // 0x01C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_GameplayTagsPerDifficulty">();
	}
	static class UFortQueryTest_GameplayTagsPerDifficulty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_GameplayTagsPerDifficulty>();
	}
};
static_assert(alignof(UFortQueryTest_GameplayTagsPerDifficulty) == 0x000008, "Wrong alignment on UFortQueryTest_GameplayTagsPerDifficulty");
static_assert(sizeof(UFortQueryTest_GameplayTagsPerDifficulty) == 0x0001D0, "Wrong size on UFortQueryTest_GameplayTagsPerDifficulty");
static_assert(offsetof(UFortQueryTest_GameplayTagsPerDifficulty, TagQueriesPerDifficulty) == 0x0001C0, "Member 'UFortQueryTest_GameplayTagsPerDifficulty::TagQueriesPerDifficulty' has a wrong offset!");

// Class FortniteGame.FortGameStateDeployableBase
// 0x0040 (0x1250 - 0x1210)
class AFortGameStateDeployableBase final : public AFortGameStateZone
{
public:
	class AFortDeployableBaseManager*             DeployableBaseManager;                             // 0x1210(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnDeployableBaseManagerCreated;                    // 0x1218(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	bool                                          bFireEndOfDayDelegate;                             // 0x1228(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInvitesRestricted;                                // 0x1229(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_122A[0x6];                                     // 0x122A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHordeDifficultyTierInfo>       TierDifficultyConfig;                              // 0x1230(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<struct FHordeDifficultyTierInfo>       PrestigeTierDifficultyConfig;                      // 0x1240(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	void OnRep_DeployableBaseManager();
	void SetGameDifficultyExplicitly(const float InGameDifficulty);
	void SetGameDifficultyRow(const struct FDataTableRowHandle& GameDifficultyInfo);

	EDeployableBaseUseType GetDeployableBaseUseType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameStateDeployableBase">();
	}
	static class AFortGameStateDeployableBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGameStateDeployableBase>();
	}
};
static_assert(alignof(AFortGameStateDeployableBase) == 0x000008, "Wrong alignment on AFortGameStateDeployableBase");
static_assert(sizeof(AFortGameStateDeployableBase) == 0x001250, "Wrong size on AFortGameStateDeployableBase");
static_assert(offsetof(AFortGameStateDeployableBase, DeployableBaseManager) == 0x001210, "Member 'AFortGameStateDeployableBase::DeployableBaseManager' has a wrong offset!");
static_assert(offsetof(AFortGameStateDeployableBase, OnDeployableBaseManagerCreated) == 0x001218, "Member 'AFortGameStateDeployableBase::OnDeployableBaseManagerCreated' has a wrong offset!");
static_assert(offsetof(AFortGameStateDeployableBase, bFireEndOfDayDelegate) == 0x001228, "Member 'AFortGameStateDeployableBase::bFireEndOfDayDelegate' has a wrong offset!");
static_assert(offsetof(AFortGameStateDeployableBase, bInvitesRestricted) == 0x001229, "Member 'AFortGameStateDeployableBase::bInvitesRestricted' has a wrong offset!");
static_assert(offsetof(AFortGameStateDeployableBase, TierDifficultyConfig) == 0x001230, "Member 'AFortGameStateDeployableBase::TierDifficultyConfig' has a wrong offset!");
static_assert(offsetof(AFortGameStateDeployableBase, PrestigeTierDifficultyConfig) == 0x001240, "Member 'AFortGameStateDeployableBase::PrestigeTierDifficultyConfig' has a wrong offset!");

// Class FortniteGame.FortGameStateFOB
// 0x0020 (0x1230 - 0x1210)
class AFortGameStateFOB final : public AFortGameStateZone
{
public:
	UMulticastDelegateProperty_                   OnBuildingDestroyedDel;                            // 0x1210(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1220[0x10];                                    // 0x1220(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetGameDifficultyExplicitly(const float InGameDifficulty);
	void SetGameDifficultyRow(const struct FDataTableRowHandle& GameDifficultyInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameStateFOB">();
	}
	static class AFortGameStateFOB* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGameStateFOB>();
	}
};
static_assert(alignof(AFortGameStateFOB) == 0x000008, "Wrong alignment on AFortGameStateFOB");
static_assert(sizeof(AFortGameStateFOB) == 0x001230, "Wrong size on AFortGameStateFOB");
static_assert(offsetof(AFortGameStateFOB, OnBuildingDestroyedDel) == 0x001210, "Member 'AFortGameStateFOB::OnBuildingDestroyedDel' has a wrong offset!");

// Class FortniteGame.FortGameStateManor
// 0x0060 (0x1270 - 0x1210)
class AFortGameStateManor final : public AFortGameStateZone
{
public:
	uint8                                         Pad_1210[0x60];                                    // 0x1210(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameStateManor">();
	}
	static class AFortGameStateManor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGameStateManor>();
	}
};
static_assert(alignof(AFortGameStateManor) == 0x000008, "Wrong alignment on AFortGameStateManor");
static_assert(sizeof(AFortGameStateManor) == 0x001270, "Wrong size on AFortGameStateManor");

// Class FortniteGame.FortGameStateOutpost
// 0x0010 (0x1220 - 0x1210)
class AFortGameStateOutpost final : public AFortGameStateZone
{
public:
	bool                                          bOutpostDefenseActive;                             // 0x1210(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1211[0xF];                                     // 0x1211(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetGameDifficultyRow(const struct FDataTableRowHandle& GameDifficultyInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameStateOutpost">();
	}
	static class AFortGameStateOutpost* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGameStateOutpost>();
	}
};
static_assert(alignof(AFortGameStateOutpost) == 0x000008, "Wrong alignment on AFortGameStateOutpost");
static_assert(sizeof(AFortGameStateOutpost) == 0x001220, "Wrong size on AFortGameStateOutpost");
static_assert(offsetof(AFortGameStateOutpost, bOutpostDefenseActive) == 0x001210, "Member 'AFortGameStateOutpost::bOutpostDefenseActive' has a wrong offset!");

// Class FortniteGame.FortGameStatePvPBaseDestruction
// 0x00F0 (0x1440 - 0x1350)
class AFortGameStatePvPBaseDestruction final : public AFortGameStatePvP
{
public:
	class FName                                   SessionXPRowName;                                  // 0x1350(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRichCurve                             TeamLevelToSessionXPCurve;                         // 0x1358(0x0070)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FRichCurve                             SessionXPToTeamLevelCurve;                         // 0x13C8(0x0070)(Transient, Protected, NativeAccessSpecifierProtected)
	int32                                         MaxTeamLevel;                                      // 0x1438(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxTeamExperience;                                 // 0x143C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	int32 GetExperienceRequiredForTeamLevel(int32 TeamLevel) const;
	int32 GetMaxTeamExperience() const;
	int32 GetMaxTeamLevel() const;
	int32 GetTeamLevelForExperienceAmount(int32 Experience) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameStatePvPBaseDestruction">();
	}
	static class AFortGameStatePvPBaseDestruction* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGameStatePvPBaseDestruction>();
	}
};
static_assert(alignof(AFortGameStatePvPBaseDestruction) == 0x000008, "Wrong alignment on AFortGameStatePvPBaseDestruction");
static_assert(sizeof(AFortGameStatePvPBaseDestruction) == 0x001440, "Wrong size on AFortGameStatePvPBaseDestruction");
static_assert(offsetof(AFortGameStatePvPBaseDestruction, SessionXPRowName) == 0x001350, "Member 'AFortGameStatePvPBaseDestruction::SessionXPRowName' has a wrong offset!");
static_assert(offsetof(AFortGameStatePvPBaseDestruction, TeamLevelToSessionXPCurve) == 0x001358, "Member 'AFortGameStatePvPBaseDestruction::TeamLevelToSessionXPCurve' has a wrong offset!");
static_assert(offsetof(AFortGameStatePvPBaseDestruction, SessionXPToTeamLevelCurve) == 0x0013C8, "Member 'AFortGameStatePvPBaseDestruction::SessionXPToTeamLevelCurve' has a wrong offset!");
static_assert(offsetof(AFortGameStatePvPBaseDestruction, MaxTeamLevel) == 0x001438, "Member 'AFortGameStatePvPBaseDestruction::MaxTeamLevel' has a wrong offset!");
static_assert(offsetof(AFortGameStatePvPBaseDestruction, MaxTeamExperience) == 0x00143C, "Member 'AFortGameStatePvPBaseDestruction::MaxTeamExperience' has a wrong offset!");

// Class FortniteGame.FortGameStateSurvival
// 0x0000 (0x1210 - 0x1210)
class AFortGameStateSurvival final : public AFortGameStateZone
{
public:
	void SetGameDifficultyRow(const struct FDataTableRowHandle& GameDifficultyInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameStateSurvival">();
	}
	static class AFortGameStateSurvival* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGameStateSurvival>();
	}
};
static_assert(alignof(AFortGameStateSurvival) == 0x000008, "Wrong alignment on AFortGameStateSurvival");
static_assert(sizeof(AFortGameStateSurvival) == 0x001210, "Wrong size on AFortGameStateSurvival");

// Class FortniteGame.FortGameUserSettings
// 0x00B8 (0x01C0 - 0x0108)
class UFortGameUserSettings final : public UGameUserSettings
{
public:
	float                                         MouseSensitivity;                                  // 0x0108(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         FortVersion;                                       // 0x010C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_110[0x70];                                     // 0x0110(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          RememberMeCheckbox;                                // 0x0180(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_181[0x7];                                      // 0x0181(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RememberMeToken;                                   // 0x0188(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LastLoginEmail;                                    // 0x0198(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMotionBlur;                                       // 0x01A8(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowGrass;                                        // 0x01A9(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowFPS;                                          // 0x01AA(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AB[0x1];                                      // 0x01AB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InitialBenchmarkState;                             // 0x01AC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableMouseAcceleration;                         // 0x01B0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B1[0x3];                                      // 0x01B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DiscreteResolutionQuality;                         // 0x01B4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastAppliedDiscreteResolutionQuality;              // 0x01B8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BC[0x4];                                      // 0x01BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameUserSettings">();
	}
	static class UFortGameUserSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGameUserSettings>();
	}
};
static_assert(alignof(UFortGameUserSettings) == 0x000008, "Wrong alignment on UFortGameUserSettings");
static_assert(sizeof(UFortGameUserSettings) == 0x0001C0, "Wrong size on UFortGameUserSettings");
static_assert(offsetof(UFortGameUserSettings, MouseSensitivity) == 0x000108, "Member 'UFortGameUserSettings::MouseSensitivity' has a wrong offset!");
static_assert(offsetof(UFortGameUserSettings, FortVersion) == 0x00010C, "Member 'UFortGameUserSettings::FortVersion' has a wrong offset!");
static_assert(offsetof(UFortGameUserSettings, RememberMeCheckbox) == 0x000180, "Member 'UFortGameUserSettings::RememberMeCheckbox' has a wrong offset!");
static_assert(offsetof(UFortGameUserSettings, RememberMeToken) == 0x000188, "Member 'UFortGameUserSettings::RememberMeToken' has a wrong offset!");
static_assert(offsetof(UFortGameUserSettings, LastLoginEmail) == 0x000198, "Member 'UFortGameUserSettings::LastLoginEmail' has a wrong offset!");
static_assert(offsetof(UFortGameUserSettings, bMotionBlur) == 0x0001A8, "Member 'UFortGameUserSettings::bMotionBlur' has a wrong offset!");
static_assert(offsetof(UFortGameUserSettings, bShowGrass) == 0x0001A9, "Member 'UFortGameUserSettings::bShowGrass' has a wrong offset!");
static_assert(offsetof(UFortGameUserSettings, bShowFPS) == 0x0001AA, "Member 'UFortGameUserSettings::bShowFPS' has a wrong offset!");
static_assert(offsetof(UFortGameUserSettings, InitialBenchmarkState) == 0x0001AC, "Member 'UFortGameUserSettings::InitialBenchmarkState' has a wrong offset!");
static_assert(offsetof(UFortGameUserSettings, bDisableMouseAcceleration) == 0x0001B0, "Member 'UFortGameUserSettings::bDisableMouseAcceleration' has a wrong offset!");
static_assert(offsetof(UFortGameUserSettings, DiscreteResolutionQuality) == 0x0001B4, "Member 'UFortGameUserSettings::DiscreteResolutionQuality' has a wrong offset!");
static_assert(offsetof(UFortGameUserSettings, LastAppliedDiscreteResolutionQuality) == 0x0001B8, "Member 'UFortGameUserSettings::LastAppliedDiscreteResolutionQuality' has a wrong offset!");

// Class FortniteGame.FortGameViewportClient
// 0x00A0 (0x0610 - 0x0570)
class UFortGameViewportClient final : public UGameViewportClient
{
public:
	class FText                                   NetworkFailureMessage;                             // 0x0570(0x0018)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_588[0x88];                                     // 0x0588(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameViewportClient">();
	}
	static class UFortGameViewportClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGameViewportClient>();
	}
};
static_assert(alignof(UFortGameViewportClient) == 0x000008, "Wrong alignment on UFortGameViewportClient");
static_assert(sizeof(UFortGameViewportClient) == 0x000610, "Wrong size on UFortGameViewportClient");
static_assert(offsetof(UFortGameViewportClient, NetworkFailureMessage) == 0x000570, "Member 'UFortGameViewportClient::NetworkFailureMessage' has a wrong offset!");

// Class FortniteGame.FortDeployableBaseRecord
// 0x0018 (0x00E8 - 0x00D0)
class UFortDeployableBaseRecord final : public UFortGenericRecord
{
public:
	TArray<struct FFortActorRecord>               Actors;                                            // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         bNeedsFullActorSave : 1;                           // 0x00E0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDeployableBaseRecord">();
	}
	static class UFortDeployableBaseRecord* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDeployableBaseRecord>();
	}
};
static_assert(alignof(UFortDeployableBaseRecord) == 0x000008, "Wrong alignment on UFortDeployableBaseRecord");
static_assert(sizeof(UFortDeployableBaseRecord) == 0x0000E8, "Wrong size on UFortDeployableBaseRecord");
static_assert(offsetof(UFortDeployableBaseRecord, Actors) == 0x0000D0, "Member 'UFortDeployableBaseRecord::Actors' has a wrong offset!");

// Class FortniteGame.FortGlobalAbilityTargetingActor
// 0x0000 (0x0388 - 0x0388)
class AFortGlobalAbilityTargetingActor : public AInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGlobalAbilityTargetingActor">();
	}
	static class AFortGlobalAbilityTargetingActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGlobalAbilityTargetingActor>();
	}
};
static_assert(alignof(AFortGlobalAbilityTargetingActor) == 0x000008, "Wrong alignment on AFortGlobalAbilityTargetingActor");
static_assert(sizeof(AFortGlobalAbilityTargetingActor) == 0x000388, "Wrong size on AFortGlobalAbilityTargetingActor");

// Class FortniteGame.FortGlobalEnvironmentAbilityActor
// 0x0018 (0x03A0 - 0x0388)
class AFortGlobalEnvironmentAbilityActor final : public AInfo
{
public:
	uint8                                         Pad_388[0x8];                                      // 0x0388(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAbilitySystemComponent*            AbilitySystemComponent;                            // 0x0390(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortDamageSet*                         DamageSet;                                         // 0x0398(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGlobalEnvironmentAbilityActor">();
	}
	static class AFortGlobalEnvironmentAbilityActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGlobalEnvironmentAbilityActor>();
	}
};
static_assert(alignof(AFortGlobalEnvironmentAbilityActor) == 0x000008, "Wrong alignment on AFortGlobalEnvironmentAbilityActor");
static_assert(sizeof(AFortGlobalEnvironmentAbilityActor) == 0x0003A0, "Wrong size on AFortGlobalEnvironmentAbilityActor");
static_assert(offsetof(AFortGlobalEnvironmentAbilityActor, AbilitySystemComponent) == 0x000390, "Member 'AFortGlobalEnvironmentAbilityActor::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(AFortGlobalEnvironmentAbilityActor, DamageSet) == 0x000398, "Member 'AFortGlobalEnvironmentAbilityActor::DamageSet' has a wrong offset!");

// Class FortniteGame.FortHealthBarComponent
// 0x0040 (0x02D0 - 0x0290)
class UFortHealthBarComponent final : public USceneComponent
{
public:
	class ABuildingActor*                         BuildingActorOwner;                                // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   DisplayText;                                       // 0x0298(0x0018)(Edit, Net, DisableEditOnInstance, RepNotify, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsHealthBarVisible;                               // 0x02B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bClampToScreen;                                    // 0x02B1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowClampToScreenArrow;                           // 0x02B2(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B3[0x5];                                      // 0x02B3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveLinearColor*                      HealthBarColorCurve;                               // 0x02B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C0[0x10];                                     // 0x02C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_DisplayText();
	void OnRep_IsVisible();
	void SetHealthBarDisplayText(const class FText& NewDisplayText);
	void SetHealthBarVisibility(bool bNewVisibleState);
	void SetHealthBarWidgetVisibility(bool bIsVisible);

	class FText GetHealthBarDisplayText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortHealthBarComponent">();
	}
	static class UFortHealthBarComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortHealthBarComponent>();
	}
};
static_assert(alignof(UFortHealthBarComponent) == 0x000008, "Wrong alignment on UFortHealthBarComponent");
static_assert(sizeof(UFortHealthBarComponent) == 0x0002D0, "Wrong size on UFortHealthBarComponent");
static_assert(offsetof(UFortHealthBarComponent, BuildingActorOwner) == 0x000290, "Member 'UFortHealthBarComponent::BuildingActorOwner' has a wrong offset!");
static_assert(offsetof(UFortHealthBarComponent, DisplayText) == 0x000298, "Member 'UFortHealthBarComponent::DisplayText' has a wrong offset!");
static_assert(offsetof(UFortHealthBarComponent, bIsHealthBarVisible) == 0x0002B0, "Member 'UFortHealthBarComponent::bIsHealthBarVisible' has a wrong offset!");
static_assert(offsetof(UFortHealthBarComponent, bClampToScreen) == 0x0002B1, "Member 'UFortHealthBarComponent::bClampToScreen' has a wrong offset!");
static_assert(offsetof(UFortHealthBarComponent, bShowClampToScreenArrow) == 0x0002B2, "Member 'UFortHealthBarComponent::bShowClampToScreenArrow' has a wrong offset!");
static_assert(offsetof(UFortHealthBarComponent, HealthBarColorCurve) == 0x0002B8, "Member 'UFortHealthBarComponent::HealthBarColorCurve' has a wrong offset!");

// Class FortniteGame.FortHexMapMarkerBase
// 0x0020 (0x03A8 - 0x0388)
class AFortHexMapMarkerBase final : public AActor
{
public:
	TArray<class UMaterialInstanceDynamic*>       CurrentMIDs;                                       // 0x0388(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UAnimationAsset*                        IdleAnimation;                                     // 0x0398(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 SkelMeshComponent;                                 // 0x03A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortHexMapMarkerBase">();
	}
	static class AFortHexMapMarkerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortHexMapMarkerBase>();
	}
};
static_assert(alignof(AFortHexMapMarkerBase) == 0x000008, "Wrong alignment on AFortHexMapMarkerBase");
static_assert(sizeof(AFortHexMapMarkerBase) == 0x0003A8, "Wrong size on AFortHexMapMarkerBase");
static_assert(offsetof(AFortHexMapMarkerBase, CurrentMIDs) == 0x000388, "Member 'AFortHexMapMarkerBase::CurrentMIDs' has a wrong offset!");
static_assert(offsetof(AFortHexMapMarkerBase, IdleAnimation) == 0x000398, "Member 'AFortHexMapMarkerBase::IdleAnimation' has a wrong offset!");
static_assert(offsetof(AFortHexMapMarkerBase, SkelMeshComponent) == 0x0003A0, "Member 'AFortHexMapMarkerBase::SkelMeshComponent' has a wrong offset!");

// Class FortniteGame.FortHomeTeleporterInterface
// 0x0000 (0x0028 - 0x0028)
class IFortHomeTeleporterInterface final : public IInterface
{
public:
	void OnHomeTeleporterBound(class AFortPlayerPawn* PlayerPawn, const class AActor* OldHomeActor);
	void OnHomeTeleporterBoundServer(class AFortPlayerPawn* PlayerPawn, const class AActor* OldHomeActor);
	void OnHomeTeleporterUnbound(class AFortPlayerPawn* PlayerPawn, const class AActor* NewHomeActor);
	void OnHomeTeleporterUnboundServer(class AFortPlayerPawn* PlayerPawn, const class AActor* NewHomeActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortHomeTeleporterInterface">();
	}
	static class IFortHomeTeleporterInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortHomeTeleporterInterface>();
	}
};
static_assert(alignof(IFortHomeTeleporterInterface) == 0x000008, "Wrong alignment on IFortHomeTeleporterInterface");
static_assert(sizeof(IFortHomeTeleporterInterface) == 0x000028, "Wrong size on IFortHomeTeleporterInterface");

// Class FortniteGame.FortHotfixManager
// 0x0000 (0x03D0 - 0x03D0)
class UFortHotfixManager final : public UOnlineHotfixManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortHotfixManager">();
	}
	static class UFortHotfixManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortHotfixManager>();
	}
};
static_assert(alignof(UFortHotfixManager) == 0x000008, "Wrong alignment on UFortHotfixManager");
static_assert(sizeof(UFortHotfixManager) == 0x0003D0, "Wrong size on UFortHotfixManager");

// Class FortniteGame.FortDamageMiniMapIndicator
// 0x0000 (0x03A0 - 0x03A0)
class UFortDamageMiniMapIndicator final : public UFortMiniMapPingIndicator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDamageMiniMapIndicator">();
	}
	static class UFortDamageMiniMapIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDamageMiniMapIndicator>();
	}
};
static_assert(alignof(UFortDamageMiniMapIndicator) == 0x000008, "Wrong alignment on UFortDamageMiniMapIndicator");
static_assert(sizeof(UFortDamageMiniMapIndicator) == 0x0003A0, "Wrong size on UFortDamageMiniMapIndicator");

// Class FortniteGame.FortVolumeMiniMapIndicator
// 0x0038 (0x0350 - 0x0318)
class UFortVolumeMiniMapIndicator final : public UFortMiniMapIndicator
{
public:
	uint8                                         Pad_318[0x38];                                     // 0x0318(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortVolumeMiniMapIndicator">();
	}
	static class UFortVolumeMiniMapIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortVolumeMiniMapIndicator>();
	}
};
static_assert(alignof(UFortVolumeMiniMapIndicator) == 0x000008, "Wrong alignment on UFortVolumeMiniMapIndicator");
static_assert(sizeof(UFortVolumeMiniMapIndicator) == 0x000350, "Wrong size on UFortVolumeMiniMapIndicator");

// Class FortniteGame.FortMissionInfoIndicator
// 0x0068 (0x00F0 - 0x0088)
class UFortMissionInfoIndicator final : public UFortSlateHUDIndicator
{
public:
	uint8                                         Pad_88[0x68];                                      // 0x0088(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMissionInfoIndicator">();
	}
	static class UFortMissionInfoIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMissionInfoIndicator>();
	}
};
static_assert(alignof(UFortMissionInfoIndicator) == 0x000008, "Wrong alignment on UFortMissionInfoIndicator");
static_assert(sizeof(UFortMissionInfoIndicator) == 0x0000F0, "Wrong size on UFortMissionInfoIndicator");

// Class FortniteGame.FortSpottedActorIndicator
// 0x0008 (0x0090 - 0x0088)
class UFortSpottedActorIndicator final : public UFortSlateHUDIndicator
{
public:
	class AFortPlayerController*                  OwnerPC;                                           // 0x0088(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortSpottedActorIndicator">();
	}
	static class UFortSpottedActorIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortSpottedActorIndicator>();
	}
};
static_assert(alignof(UFortSpottedActorIndicator) == 0x000008, "Wrong alignment on UFortSpottedActorIndicator");
static_assert(sizeof(UFortSpottedActorIndicator) == 0x000090, "Wrong size on UFortSpottedActorIndicator");
static_assert(offsetof(UFortSpottedActorIndicator, OwnerPC) == 0x000088, "Member 'UFortSpottedActorIndicator::OwnerPC' has a wrong offset!");

// Class FortniteGame.FortIndicatorManager
// 0x0018 (0x0040 - 0x0028)
class UFortIndicatorManager final : public UObject
{
public:
	TArray<class UFortIndicator*>                 Indicators;                                        // 0x0028(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortIndicatorManager">();
	}
	static class UFortIndicatorManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortIndicatorManager>();
	}
};
static_assert(alignof(UFortIndicatorManager) == 0x000008, "Wrong alignment on UFortIndicatorManager");
static_assert(sizeof(UFortIndicatorManager) == 0x000040, "Wrong size on UFortIndicatorManager");
static_assert(offsetof(UFortIndicatorManager, Indicators) == 0x000028, "Member 'UFortIndicatorManager::Indicators' has a wrong offset!");

// Class FortniteGame.FortNavSystem
// 0x01D0 (0x0630 - 0x0460)
class UFortNavSystem final : public UNavigationSystem
{
public:
	uint8                                         Pad_460[0x10];                                     // 0x0460(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   DefaultSmashableArea;                              // 0x0470(0x0020)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   JumpDownArea;                                      // 0x0490(0x0020)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   JumpDownSmashableArea;                             // 0x04B0(0x0020)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   JumpDownSmashableArea2;                            // 0x04D0(0x0020)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   JumpDownSmashableArea3;                            // 0x04F0(0x0020)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ARecastNavMesh*>                 NamedNavmeshes;                                    // 0x0510(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class UFortNavLinkBlockerComponent*>   NavLinkBlockers;                                   // 0x0520(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_530[0x10];                                     // 0x0530(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UFortPathCostEstimator*>         PathEstimators;                                    // 0x0540(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class UFortInescapableZoneTracker*>    InescapableZones;                                  // 0x0550(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         bUseStaticMeshLinks : 1;                           // 0x0560(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseStaticWorldLinksDown : 1;                      // 0x0560(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseStaticWorldLinksUp : 1;                        // 0x0560(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseJumpLinkActors : 1;                            // 0x0560(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_561[0x3];                                      // 0x0561(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DirtyAreasUpdateFreqInactive;                      // 0x0564(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_568[0x90];                                     // 0x0568(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortNavigationGraph*                   NavGraphData;                                      // 0x05F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         CompositePathGoals;                                // 0x0600(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBox>                           AtlasCells;                                        // 0x0610(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_620[0x10];                                     // 0x0620(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool IsNavmeshInRadiusInitialized(class UObject* WorldContext, const struct FVector& TestLocation, float TestRadius);

	void OnNavDataRegistered(class ANavigationData* NavData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavSystem">();
	}
	static class UFortNavSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavSystem>();
	}
};
static_assert(alignof(UFortNavSystem) == 0x000008, "Wrong alignment on UFortNavSystem");
static_assert(sizeof(UFortNavSystem) == 0x000630, "Wrong size on UFortNavSystem");
static_assert(offsetof(UFortNavSystem, DefaultSmashableArea) == 0x000470, "Member 'UFortNavSystem::DefaultSmashableArea' has a wrong offset!");
static_assert(offsetof(UFortNavSystem, JumpDownArea) == 0x000490, "Member 'UFortNavSystem::JumpDownArea' has a wrong offset!");
static_assert(offsetof(UFortNavSystem, JumpDownSmashableArea) == 0x0004B0, "Member 'UFortNavSystem::JumpDownSmashableArea' has a wrong offset!");
static_assert(offsetof(UFortNavSystem, JumpDownSmashableArea2) == 0x0004D0, "Member 'UFortNavSystem::JumpDownSmashableArea2' has a wrong offset!");
static_assert(offsetof(UFortNavSystem, JumpDownSmashableArea3) == 0x0004F0, "Member 'UFortNavSystem::JumpDownSmashableArea3' has a wrong offset!");
static_assert(offsetof(UFortNavSystem, NamedNavmeshes) == 0x000510, "Member 'UFortNavSystem::NamedNavmeshes' has a wrong offset!");
static_assert(offsetof(UFortNavSystem, NavLinkBlockers) == 0x000520, "Member 'UFortNavSystem::NavLinkBlockers' has a wrong offset!");
static_assert(offsetof(UFortNavSystem, PathEstimators) == 0x000540, "Member 'UFortNavSystem::PathEstimators' has a wrong offset!");
static_assert(offsetof(UFortNavSystem, InescapableZones) == 0x000550, "Member 'UFortNavSystem::InescapableZones' has a wrong offset!");
static_assert(offsetof(UFortNavSystem, DirtyAreasUpdateFreqInactive) == 0x000564, "Member 'UFortNavSystem::DirtyAreasUpdateFreqInactive' has a wrong offset!");
static_assert(offsetof(UFortNavSystem, NavGraphData) == 0x0005F8, "Member 'UFortNavSystem::NavGraphData' has a wrong offset!");
static_assert(offsetof(UFortNavSystem, CompositePathGoals) == 0x000600, "Member 'UFortNavSystem::CompositePathGoals' has a wrong offset!");
static_assert(offsetof(UFortNavSystem, AtlasCells) == 0x000610, "Member 'UFortNavSystem::AtlasCells' has a wrong offset!");

// Class FortniteGame.FortInfluenceMap
// 0x00D0 (0x00F8 - 0x0028)
class UFortInfluenceMap final : public UObject
{
public:
	uint8                                         Pad_28[0xB8];                                      // 0x0028(0x00B8)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortNavigationGraph*                   GraphData;                                         // 0x00E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E8[0x10];                                      // 0x00E8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void K2_AddInfluenceSource(class UObject* WorldContext, const struct FVector& Position, const class FString& SourceName, float Strength);
	static void K2_GetInfluenceSourcePositions(class UObject* WorldContext, TArray<struct FVector>* InfluenceSourcePositions);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortInfluenceMap">();
	}
	static class UFortInfluenceMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortInfluenceMap>();
	}
};
static_assert(alignof(UFortInfluenceMap) == 0x000008, "Wrong alignment on UFortInfluenceMap");
static_assert(sizeof(UFortInfluenceMap) == 0x0000F8, "Wrong size on UFortInfluenceMap");
static_assert(offsetof(UFortInfluenceMap, GraphData) == 0x0000E0, "Member 'UFortInfluenceMap::GraphData' has a wrong offset!");

// Class FortniteGame.FortInGameMapManager
// 0x0160 (0x04E8 - 0x0388)
class AFortInGameMapManager : public AActor
{
public:
	uint8                                         Pad_388[0x18];                                     // 0x0388(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTeamMapInfo>                   MapData;                                           // 0x03A0(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	float                                         DelayBetweenDispersions;                           // 0x03B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExploredRadius;                                    // 0x03B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExploredFalloffRadius;                             // 0x03B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SeenRadius;                                        // 0x03BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SeenFalloffRadius;                                 // 0x03C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         VisibilityMaxGradient;                             // 0x03C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         UnexploredOpacity;                                 // 0x03C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OffsetZ;                                           // 0x03CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MapLayerSize;                                      // 0x03D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMargin                                MapMargin;                                         // 0x03D4(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	int32                                         IconVisibilityFogThreshold;                        // 0x03E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ASceneCapture2D>            SceneCaptureClass;                                 // 0x03E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ASceneCapture2D>            SceneCaptureBlurryClass;                           // 0x03F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UMaterialInterface>      MapMaterial;                                       // 0x03F8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   CloudBrightnessCurve;                              // 0x0418(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   DesaturationFactorCurve;                           // 0x0428(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         MapOpacityWhenWalking;                             // 0x0438(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxPercentageMapExplored;                          // 0x043C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MapExplorationThresholdPercentage;                 // 0x0440(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastMapExplorationThresholdPercentageReached;      // 0x0444(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnMapFullyExplored;                                // 0x0448(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnMapExplorationThresholdReached;                  // 0x0458(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class ASceneCapture2D*                        SceneCapture;                                      // 0x0468(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASceneCapture2D*                        SceneCaptureBlurry;                                // 0x0470(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_478[0x20];                                     // 0x0478(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             FogMask;                                           // 0x0498(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A0[0x44];                                     // 0x04A0(0x0044)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MapWorldScale;                                     // 0x04E4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class AFortInGameMapManager* GetCurrent(const class UObject* WorldContextObject);

	void BroadcastExplorationEvents(const TArray<struct FTeamMapExplorationEvent>& Events);
	void OnRep_MapData();
	void PaintOnFog(const struct FVector& WorldCoords, EFortTeam Team);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortInGameMapManager">();
	}
	static class AFortInGameMapManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortInGameMapManager>();
	}
};
static_assert(alignof(AFortInGameMapManager) == 0x000008, "Wrong alignment on AFortInGameMapManager");
static_assert(sizeof(AFortInGameMapManager) == 0x0004E8, "Wrong size on AFortInGameMapManager");
static_assert(offsetof(AFortInGameMapManager, MapData) == 0x0003A0, "Member 'AFortInGameMapManager::MapData' has a wrong offset!");
static_assert(offsetof(AFortInGameMapManager, DelayBetweenDispersions) == 0x0003B0, "Member 'AFortInGameMapManager::DelayBetweenDispersions' has a wrong offset!");
static_assert(offsetof(AFortInGameMapManager, ExploredRadius) == 0x0003B4, "Member 'AFortInGameMapManager::ExploredRadius' has a wrong offset!");
static_assert(offsetof(AFortInGameMapManager, ExploredFalloffRadius) == 0x0003B8, "Member 'AFortInGameMapManager::ExploredFalloffRadius' has a wrong offset!");
static_assert(offsetof(AFortInGameMapManager, SeenRadius) == 0x0003BC, "Member 'AFortInGameMapManager::SeenRadius' has a wrong offset!");
static_assert(offsetof(AFortInGameMapManager, SeenFalloffRadius) == 0x0003C0, "Member 'AFortInGameMapManager::SeenFalloffRadius' has a wrong offset!");
static_assert(offsetof(AFortInGameMapManager, VisibilityMaxGradient) == 0x0003C4, "Member 'AFortInGameMapManager::VisibilityMaxGradient' has a wrong offset!");
static_assert(offsetof(AFortInGameMapManager, UnexploredOpacity) == 0x0003C8, "Member 'AFortInGameMapManager::UnexploredOpacity' has a wrong offset!");
static_assert(offsetof(AFortInGameMapManager, OffsetZ) == 0x0003CC, "Member 'AFortInGameMapManager::OffsetZ' has a wrong offset!");
static_assert(offsetof(AFortInGameMapManager, MapLayerSize) == 0x0003D0, "Member 'AFortInGameMapManager::MapLayerSize' has a wrong offset!");
static_assert(offsetof(AFortInGameMapManager, MapMargin) == 0x0003D4, "Member 'AFortInGameMapManager::MapMargin' has a wrong offset!");
static_assert(offsetof(AFortInGameMapManager, IconVisibilityFogThreshold) == 0x0003E4, "Member 'AFortInGameMapManager::IconVisibilityFogThreshold' has a wrong offset!");
static_assert(offsetof(AFortInGameMapManager, SceneCaptureClass) == 0x0003E8, "Member 'AFortInGameMapManager::SceneCaptureClass' has a wrong offset!");
static_assert(offsetof(AFortInGameMapManager, SceneCaptureBlurryClass) == 0x0003F0, "Member 'AFortInGameMapManager::SceneCaptureBlurryClass' has a wrong offset!");
static_assert(offsetof(AFortInGameMapManager, MapMaterial) == 0x0003F8, "Member 'AFortInGameMapManager::MapMaterial' has a wrong offset!");
static_assert(offsetof(AFortInGameMapManager, CloudBrightnessCurve) == 0x000418, "Member 'AFortInGameMapManager::CloudBrightnessCurve' has a wrong offset!");
static_assert(offsetof(AFortInGameMapManager, DesaturationFactorCurve) == 0x000428, "Member 'AFortInGameMapManager::DesaturationFactorCurve' has a wrong offset!");
static_assert(offsetof(AFortInGameMapManager, MapOpacityWhenWalking) == 0x000438, "Member 'AFortInGameMapManager::MapOpacityWhenWalking' has a wrong offset!");
static_assert(offsetof(AFortInGameMapManager, MaxPercentageMapExplored) == 0x00043C, "Member 'AFortInGameMapManager::MaxPercentageMapExplored' has a wrong offset!");
static_assert(offsetof(AFortInGameMapManager, MapExplorationThresholdPercentage) == 0x000440, "Member 'AFortInGameMapManager::MapExplorationThresholdPercentage' has a wrong offset!");
static_assert(offsetof(AFortInGameMapManager, LastMapExplorationThresholdPercentageReached) == 0x000444, "Member 'AFortInGameMapManager::LastMapExplorationThresholdPercentageReached' has a wrong offset!");
static_assert(offsetof(AFortInGameMapManager, OnMapFullyExplored) == 0x000448, "Member 'AFortInGameMapManager::OnMapFullyExplored' has a wrong offset!");
static_assert(offsetof(AFortInGameMapManager, OnMapExplorationThresholdReached) == 0x000458, "Member 'AFortInGameMapManager::OnMapExplorationThresholdReached' has a wrong offset!");
static_assert(offsetof(AFortInGameMapManager, SceneCapture) == 0x000468, "Member 'AFortInGameMapManager::SceneCapture' has a wrong offset!");
static_assert(offsetof(AFortInGameMapManager, SceneCaptureBlurry) == 0x000470, "Member 'AFortInGameMapManager::SceneCaptureBlurry' has a wrong offset!");
static_assert(offsetof(AFortInGameMapManager, FogMask) == 0x000498, "Member 'AFortInGameMapManager::FogMask' has a wrong offset!");
static_assert(offsetof(AFortInGameMapManager, MapWorldScale) == 0x0004E4, "Member 'AFortInGameMapManager::MapWorldScale' has a wrong offset!");

// Class FortniteGame.FortInGameMapManagerAthena
// 0x0008 (0x04F0 - 0x04E8)
class AFortInGameMapManagerAthena final : public AFortInGameMapManager
{
public:
	uint8                                         Pad_4E8[0x8];                                      // 0x04E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortInGameMapManagerAthena">();
	}
	static class AFortInGameMapManagerAthena* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortInGameMapManagerAthena>();
	}
};
static_assert(alignof(AFortInGameMapManagerAthena) == 0x000008, "Wrong alignment on AFortInGameMapManagerAthena");
static_assert(sizeof(AFortInGameMapManagerAthena) == 0x0004F0, "Wrong size on AFortInGameMapManagerAthena");

// Class FortniteGame.FortIntensityCurveSequenceProgression
// 0x0010 (0x0038 - 0x0028)
class UFortIntensityCurveSequenceProgression final : public UDataAsset
{
public:
	TArray<struct FFortInstensityCurveSequenceProgression> IntensityCurveSequences;                           // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortIntensityCurveSequenceProgression">();
	}
	static class UFortIntensityCurveSequenceProgression* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortIntensityCurveSequenceProgression>();
	}
};
static_assert(alignof(UFortIntensityCurveSequenceProgression) == 0x000008, "Wrong alignment on UFortIntensityCurveSequenceProgression");
static_assert(sizeof(UFortIntensityCurveSequenceProgression) == 0x000038, "Wrong size on UFortIntensityCurveSequenceProgression");
static_assert(offsetof(UFortIntensityCurveSequenceProgression, IntensityCurveSequences) == 0x000028, "Member 'UFortIntensityCurveSequenceProgression::IntensityCurveSequences' has a wrong offset!");

// Class FortniteGame.FortCustomizableAbilityDecoTool
// 0x0000 (0x0AF8 - 0x0AF8)
class AFortCustomizableAbilityDecoTool final : public AFortAbilityDecoTool
{
public:
	void BPOnEquip(class AFortWeapon* OldWeapon);
	void BPOnSetDecoObjectPreview(class AFortDecoHelper* FortDecoHelper);
	void BPOnUnEquip();
	void BPPressSecondaryFire(class AFortDecoHelper* FortDecoHelper);
	void BPPressTrigger(class AFortDecoHelper* FortDecoHelper);
	void BPReleaseSecondaryFire(class AFortDecoHelper* FortDecoHelper);
	void BPReleaseTrigger(class AFortDecoHelper* FortDecoHelper);
	void BPServerPressSecondaryFire();
	void BPServerReleaseSecondaryFire();
	void ServerPressSecondaryFire();
	void ServerPressTrigger();
	void ServerReleaseSecondaryFire();
	void ServerReleaseTrigger();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCustomizableAbilityDecoTool">();
	}
	static class AFortCustomizableAbilityDecoTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortCustomizableAbilityDecoTool>();
	}
};
static_assert(alignof(AFortCustomizableAbilityDecoTool) == 0x000008, "Wrong alignment on AFortCustomizableAbilityDecoTool");
static_assert(sizeof(AFortCustomizableAbilityDecoTool) == 0x000AF8, "Wrong size on AFortCustomizableAbilityDecoTool");

// Class FortniteGame.FortInteractContextInfo
// 0x0048 (0x0070 - 0x0028)
class UFortInteractContextInfo final : public UObject
{
public:
	class FText                                   ContextText;                                       // 0x0028(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class AActor*                                 ReceivingActor;                                    // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    InteractComponent;                                 // 0x0048(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             LongInteractSound;                                 // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InteractPoint;                                     // 0x0058(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RequiredDuration;                                  // 0x0064(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowCountDown;                                    // 0x0068(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayTextOnly;                                  // 0x0069(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x6];                                       // 0x006A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortInteractContextInfo">();
	}
	static class UFortInteractContextInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortInteractContextInfo>();
	}
};
static_assert(alignof(UFortInteractContextInfo) == 0x000008, "Wrong alignment on UFortInteractContextInfo");
static_assert(sizeof(UFortInteractContextInfo) == 0x000070, "Wrong size on UFortInteractContextInfo");
static_assert(offsetof(UFortInteractContextInfo, ContextText) == 0x000028, "Member 'UFortInteractContextInfo::ContextText' has a wrong offset!");
static_assert(offsetof(UFortInteractContextInfo, ReceivingActor) == 0x000040, "Member 'UFortInteractContextInfo::ReceivingActor' has a wrong offset!");
static_assert(offsetof(UFortInteractContextInfo, InteractComponent) == 0x000048, "Member 'UFortInteractContextInfo::InteractComponent' has a wrong offset!");
static_assert(offsetof(UFortInteractContextInfo, LongInteractSound) == 0x000050, "Member 'UFortInteractContextInfo::LongInteractSound' has a wrong offset!");
static_assert(offsetof(UFortInteractContextInfo, InteractPoint) == 0x000058, "Member 'UFortInteractContextInfo::InteractPoint' has a wrong offset!");
static_assert(offsetof(UFortInteractContextInfo, RequiredDuration) == 0x000064, "Member 'UFortInteractContextInfo::RequiredDuration' has a wrong offset!");
static_assert(offsetof(UFortInteractContextInfo, bShowCountDown) == 0x000068, "Member 'UFortInteractContextInfo::bShowCountDown' has a wrong offset!");
static_assert(offsetof(UFortInteractContextInfo, bDisplayTextOnly) == 0x000069, "Member 'UFortInteractContextInfo::bDisplayTextOnly' has a wrong offset!");

// Class FortniteGame.FortAccountBuffCreditItem
// 0x0008 (0x0140 - 0x0138)
class UFortAccountBuffCreditItem final : public UFortAccountItem
{
public:
	uint8                                         Pad_138[0x8];                                      // 0x0138(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAccountBuffCreditItem">();
	}
	static class UFortAccountBuffCreditItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAccountBuffCreditItem>();
	}
};
static_assert(alignof(UFortAccountBuffCreditItem) == 0x000008, "Wrong alignment on UFortAccountBuffCreditItem");
static_assert(sizeof(UFortAccountBuffCreditItem) == 0x000140, "Wrong size on UFortAccountBuffCreditItem");

// Class FortniteGame.FortAlterableItemDefinition
// 0x0010 (0x0280 - 0x0270)
class UFortAlterableItemDefinition : public UFortAccountItemDefinition
{
public:
	TArray<struct FFortAlterationSlots>           DefaultAlterationSlots;                            // 0x0270(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAlterableItemDefinition">();
	}
	static class UFortAlterableItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAlterableItemDefinition>();
	}
};
static_assert(alignof(UFortAlterableItemDefinition) == 0x000010, "Wrong alignment on UFortAlterableItemDefinition");
static_assert(sizeof(UFortAlterableItemDefinition) == 0x000280, "Wrong size on UFortAlterableItemDefinition");
static_assert(offsetof(UFortAlterableItemDefinition, DefaultAlterationSlots) == 0x000270, "Member 'UFortAlterableItemDefinition::DefaultAlterationSlots' has a wrong offset!");

// Class FortniteGame.FortSchematicItemDefinition
// 0x00A0 (0x0320 - 0x0280)
class UFortSchematicItemDefinition final : public UFortAlterableItemDefinition
{
public:
	struct FDataTableRowHandle                    CraftingRecipe;                                    // 0x0280(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FDataTableRowHandle                    CraftingRequirements;                              // 0x0290(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class USoundBase>              CraftingSuccessSound;                              // 0x02A0(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UFortWorldItemDefinition> Result;                                            // 0x02C0(0x0020)(Edit, AssetRegistrySearchable, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         QuantityProduced;                                  // 0x02E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConsumeOnUse;                                     // 0x02E4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E5[0x3];                                      // 0x02E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CraftingPoints;                                    // 0x02E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableCategoryHandle               LootLevelData;                                     // 0x02F0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   CraftingTimeRowName;                               // 0x0308(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSchematicDisplayName;                          // 0x0310(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_311[0xF];                                      // 0x0311(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class USoundBase* GetCraftingSuccessSound() const;
	float GetCraftingTime(int32 Level) const;
	float GetCraftingTimeForCharacter(int32 Level, const class AFortPlayerPawn* FortPawn) const;
	void GetRequirements(TArray<struct FSchematicRequirement>* Requirements) const;
	class UFortWorldItemDefinition* GetResultWorldItemDefinition() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortSchematicItemDefinition">();
	}
	static class UFortSchematicItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortSchematicItemDefinition>();
	}
};
static_assert(alignof(UFortSchematicItemDefinition) == 0x000010, "Wrong alignment on UFortSchematicItemDefinition");
static_assert(sizeof(UFortSchematicItemDefinition) == 0x000320, "Wrong size on UFortSchematicItemDefinition");
static_assert(offsetof(UFortSchematicItemDefinition, CraftingRecipe) == 0x000280, "Member 'UFortSchematicItemDefinition::CraftingRecipe' has a wrong offset!");
static_assert(offsetof(UFortSchematicItemDefinition, CraftingRequirements) == 0x000290, "Member 'UFortSchematicItemDefinition::CraftingRequirements' has a wrong offset!");
static_assert(offsetof(UFortSchematicItemDefinition, CraftingSuccessSound) == 0x0002A0, "Member 'UFortSchematicItemDefinition::CraftingSuccessSound' has a wrong offset!");
static_assert(offsetof(UFortSchematicItemDefinition, Result) == 0x0002C0, "Member 'UFortSchematicItemDefinition::Result' has a wrong offset!");
static_assert(offsetof(UFortSchematicItemDefinition, QuantityProduced) == 0x0002E0, "Member 'UFortSchematicItemDefinition::QuantityProduced' has a wrong offset!");
static_assert(offsetof(UFortSchematicItemDefinition, bConsumeOnUse) == 0x0002E4, "Member 'UFortSchematicItemDefinition::bConsumeOnUse' has a wrong offset!");
static_assert(offsetof(UFortSchematicItemDefinition, CraftingPoints) == 0x0002E8, "Member 'UFortSchematicItemDefinition::CraftingPoints' has a wrong offset!");
static_assert(offsetof(UFortSchematicItemDefinition, LootLevelData) == 0x0002F0, "Member 'UFortSchematicItemDefinition::LootLevelData' has a wrong offset!");
static_assert(offsetof(UFortSchematicItemDefinition, CraftingTimeRowName) == 0x000308, "Member 'UFortSchematicItemDefinition::CraftingTimeRowName' has a wrong offset!");
static_assert(offsetof(UFortSchematicItemDefinition, bUseSchematicDisplayName) == 0x000310, "Member 'UFortSchematicItemDefinition::bUseSchematicDisplayName' has a wrong offset!");

// Class FortniteGame.FortAlterationItem
// 0x0008 (0x0140 - 0x0138)
class UFortAlterationItem final : public UFortAccountItem
{
public:
	uint8                                         Pad_138[0x8];                                      // 0x0138(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UFortAlterationItemDefinition* GetAlterationDefinitionBP() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAlterationItem">();
	}
	static class UFortAlterationItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAlterationItem>();
	}
};
static_assert(alignof(UFortAlterationItem) == 0x000008, "Wrong alignment on UFortAlterationItem");
static_assert(sizeof(UFortAlterationItem) == 0x000140, "Wrong size on UFortAlterationItem");

// Class FortniteGame.FortCardPackItemDefinition
// 0x0070 (0x02E0 - 0x0270)
class UFortCardPackItemDefinition final : public UFortAccountItemDefinition
{
public:
	class FString                                 LootTierGroup;                                     // 0x0270(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         LootTier;                                          // 0x0280(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsChoicePack;                                     // 0x0284(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAutoOpenAsReward;                                 // 0x0285(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_286[0x2];                                      // 0x0286(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DisplayRarityLevel;                                // 0x0288(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28C[0x4];                                      // 0x028C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture>                PackImage;                                         // 0x0290(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           PackColor;                                         // 0x02B0(0x0010)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UFortPackPersonality>    PackPersonality;                                   // 0x02C0(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	struct FLinearColor GetPackColor() const;
	class UTexture* GetPackImage() const;
	class UFortPackPersonality* GetPackPersonality() const;
	bool IsChoicePack() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCardPackItemDefinition">();
	}
	static class UFortCardPackItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCardPackItemDefinition>();
	}
};
static_assert(alignof(UFortCardPackItemDefinition) == 0x000010, "Wrong alignment on UFortCardPackItemDefinition");
static_assert(sizeof(UFortCardPackItemDefinition) == 0x0002E0, "Wrong size on UFortCardPackItemDefinition");
static_assert(offsetof(UFortCardPackItemDefinition, LootTierGroup) == 0x000270, "Member 'UFortCardPackItemDefinition::LootTierGroup' has a wrong offset!");
static_assert(offsetof(UFortCardPackItemDefinition, LootTier) == 0x000280, "Member 'UFortCardPackItemDefinition::LootTier' has a wrong offset!");
static_assert(offsetof(UFortCardPackItemDefinition, bIsChoicePack) == 0x000284, "Member 'UFortCardPackItemDefinition::bIsChoicePack' has a wrong offset!");
static_assert(offsetof(UFortCardPackItemDefinition, bAutoOpenAsReward) == 0x000285, "Member 'UFortCardPackItemDefinition::bAutoOpenAsReward' has a wrong offset!");
static_assert(offsetof(UFortCardPackItemDefinition, DisplayRarityLevel) == 0x000288, "Member 'UFortCardPackItemDefinition::DisplayRarityLevel' has a wrong offset!");
static_assert(offsetof(UFortCardPackItemDefinition, PackImage) == 0x000290, "Member 'UFortCardPackItemDefinition::PackImage' has a wrong offset!");
static_assert(offsetof(UFortCardPackItemDefinition, PackColor) == 0x0002B0, "Member 'UFortCardPackItemDefinition::PackColor' has a wrong offset!");
static_assert(offsetof(UFortCardPackItemDefinition, PackPersonality) == 0x0002C0, "Member 'UFortCardPackItemDefinition::PackPersonality' has a wrong offset!");

// Class FortniteGame.FortTeamInfoAthena
// 0x0000 (0x0480 - 0x0480)
class AFortTeamInfoAthena final : public AFortTeamInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTeamInfoAthena">();
	}
	static class AFortTeamInfoAthena* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortTeamInfoAthena>();
	}
};
static_assert(alignof(AFortTeamInfoAthena) == 0x000008, "Wrong alignment on AFortTeamInfoAthena");
static_assert(sizeof(AFortTeamInfoAthena) == 0x000480, "Wrong size on AFortTeamInfoAthena");

// Class FortniteGame.FortCardPackItem
// 0x0028 (0x0160 - 0x0138)
class UFortCardPackItem final : public UFortAccountItem
{
public:
	TArray<struct FMcpLootEntry>                  Options;                                           // 0x0138(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 pack_source;                                       // 0x0148(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_158[0x8];                                      // 0x0158(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetChoices(TArray<class UFortAccountItemDefinition*>* Choices);

	bool CanStoreOpen() const;
	bool IsChoicePack() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCardPackItem">();
	}
	static class UFortCardPackItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCardPackItem>();
	}
};
static_assert(alignof(UFortCardPackItem) == 0x000008, "Wrong alignment on UFortCardPackItem");
static_assert(sizeof(UFortCardPackItem) == 0x000160, "Wrong size on UFortCardPackItem");
static_assert(offsetof(UFortCardPackItem, Options) == 0x000138, "Member 'UFortCardPackItem::Options' has a wrong offset!");
static_assert(offsetof(UFortCardPackItem, pack_source) == 0x000148, "Member 'UFortCardPackItem::pack_source' has a wrong offset!");

// Class FortniteGame.FortDefenderItem
// 0x0040 (0x0190 - 0x0150)
class UFortDefenderItem final : public UFortCharacter
{
public:
	TArray<struct FFortAlterationSlots>           alteration_slots;                                  // 0x0150(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FString>                         alterations;                                       // 0x0160(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UFortAlterationItemDefinition*>  AlterationInstances;                               // 0x0170(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_180[0x10];                                     // 0x0180(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDefenderItem">();
	}
	static class UFortDefenderItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDefenderItem>();
	}
};
static_assert(alignof(UFortDefenderItem) == 0x000008, "Wrong alignment on UFortDefenderItem");
static_assert(sizeof(UFortDefenderItem) == 0x000190, "Wrong size on UFortDefenderItem");
static_assert(offsetof(UFortDefenderItem, alteration_slots) == 0x000150, "Member 'UFortDefenderItem::alteration_slots' has a wrong offset!");
static_assert(offsetof(UFortDefenderItem, alterations) == 0x000160, "Member 'UFortDefenderItem::alterations' has a wrong offset!");
static_assert(offsetof(UFortDefenderItem, AlterationInstances) == 0x000170, "Member 'UFortDefenderItem::AlterationInstances' has a wrong offset!");

// Class FortniteGame.FortCharacterCosmeticItemDefinition
// 0x0040 (0x02B0 - 0x0270)
class UFortCharacterCosmeticItemDefinition final : public UFortAccountItemDefinition
{
public:
	EFortCharacterCosmetic                        Cosmetic_Type;                                     // 0x0270(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_271[0x7];                                      // 0x0271(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UFortHeroType>>   Hero_Types_Allowed;                                // 0x0278(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	bool                                          bModifyColor;                                      // 0x0288(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_289[0x7];                                      // 0x0289(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UCustomColorSwatch>      ColorAlteration;                                   // 0x0290(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCharacterCosmeticItemDefinition">();
	}
	static class UFortCharacterCosmeticItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCharacterCosmeticItemDefinition>();
	}
};
static_assert(alignof(UFortCharacterCosmeticItemDefinition) == 0x000010, "Wrong alignment on UFortCharacterCosmeticItemDefinition");
static_assert(sizeof(UFortCharacterCosmeticItemDefinition) == 0x0002B0, "Wrong size on UFortCharacterCosmeticItemDefinition");
static_assert(offsetof(UFortCharacterCosmeticItemDefinition, Cosmetic_Type) == 0x000270, "Member 'UFortCharacterCosmeticItemDefinition::Cosmetic_Type' has a wrong offset!");
static_assert(offsetof(UFortCharacterCosmeticItemDefinition, Hero_Types_Allowed) == 0x000278, "Member 'UFortCharacterCosmeticItemDefinition::Hero_Types_Allowed' has a wrong offset!");
static_assert(offsetof(UFortCharacterCosmeticItemDefinition, bModifyColor) == 0x000288, "Member 'UFortCharacterCosmeticItemDefinition::bModifyColor' has a wrong offset!");
static_assert(offsetof(UFortCharacterCosmeticItemDefinition, ColorAlteration) == 0x000290, "Member 'UFortCharacterCosmeticItemDefinition::ColorAlteration' has a wrong offset!");

// Class FortniteGame.FortCharacterCosmeticItem
// 0x0018 (0x0150 - 0x0138)
class UFortCharacterCosmeticItem final : public UFortAccountItem
{
public:
	class FString                                 equipped_character_id;                             // 0x0138(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_148[0x8];                                      // 0x0148(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCharacterCosmeticItem">();
	}
	static class UFortCharacterCosmeticItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCharacterCosmeticItem>();
	}
};
static_assert(alignof(UFortCharacterCosmeticItem) == 0x000008, "Wrong alignment on UFortCharacterCosmeticItem");
static_assert(sizeof(UFortCharacterCosmeticItem) == 0x000150, "Wrong size on UFortCharacterCosmeticItem");
static_assert(offsetof(UFortCharacterCosmeticItem, equipped_character_id) == 0x000138, "Member 'UFortCharacterCosmeticItem::equipped_character_id' has a wrong offset!");

// Class FortniteGame.FortCodeTokenItem
// 0x0008 (0x0140 - 0x0138)
class UFortCodeTokenItem final : public UFortAccountItem
{
public:
	uint8                                         Pad_138[0x8];                                      // 0x0138(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCodeTokenItem">();
	}
	static class UFortCodeTokenItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCodeTokenItem>();
	}
};
static_assert(alignof(UFortCodeTokenItem) == 0x000008, "Wrong alignment on UFortCodeTokenItem");
static_assert(sizeof(UFortCodeTokenItem) == 0x000140, "Wrong size on UFortCodeTokenItem");

// Class FortniteGame.FortCollectedResourceItem
// 0x0028 (0x0160 - 0x0138)
class UFortCollectedResourceItem final : public UFortAccountItem
{
public:
	double                                        stored_value;                                      // 0x0138(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 last_updated;                                      // 0x0140(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortItemDefinition*                    PayoutResource;                                    // 0x0150(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_158[0x8];                                      // 0x0158(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCollectedResourceItem">();
	}
	static class UFortCollectedResourceItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCollectedResourceItem>();
	}
};
static_assert(alignof(UFortCollectedResourceItem) == 0x000008, "Wrong alignment on UFortCollectedResourceItem");
static_assert(sizeof(UFortCollectedResourceItem) == 0x000160, "Wrong size on UFortCollectedResourceItem");
static_assert(offsetof(UFortCollectedResourceItem, stored_value) == 0x000138, "Member 'UFortCollectedResourceItem::stored_value' has a wrong offset!");
static_assert(offsetof(UFortCollectedResourceItem, last_updated) == 0x000140, "Member 'UFortCollectedResourceItem::last_updated' has a wrong offset!");
static_assert(offsetof(UFortCollectedResourceItem, PayoutResource) == 0x000150, "Member 'UFortCollectedResourceItem::PayoutResource' has a wrong offset!");

// Class FortniteGame.FortTheaterList
// 0x0010 (0x0038 - 0x0028)
class UFortTheaterList final : public UDataAsset
{
public:
	TArray<class UFortTheaterInfo*>               ActiveTheatersList;                                // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTheaterList">();
	}
	static class UFortTheaterList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortTheaterList>();
	}
};
static_assert(alignof(UFortTheaterList) == 0x000008, "Wrong alignment on UFortTheaterList");
static_assert(sizeof(UFortTheaterList) == 0x000038, "Wrong size on UFortTheaterList");
static_assert(offsetof(UFortTheaterList, ActiveTheatersList) == 0x000028, "Member 'UFortTheaterList::ActiveTheatersList' has a wrong offset!");

// Class FortniteGame.FortConsumableAccountItem
// 0x0008 (0x0140 - 0x0138)
class UFortConsumableAccountItem final : public UFortAccountItem
{
public:
	uint8                                         Pad_138[0x8];                                      // 0x0138(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanActivateOnOthers();
	bool CanActivateOnSelf();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortConsumableAccountItem">();
	}
	static class UFortConsumableAccountItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortConsumableAccountItem>();
	}
};
static_assert(alignof(UFortConsumableAccountItem) == 0x000008, "Wrong alignment on UFortConsumableAccountItem");
static_assert(sizeof(UFortConsumableAccountItem) == 0x000140, "Wrong size on UFortConsumableAccountItem");

// Class FortniteGame.FortHomebaseBannerColorItem
// 0x0008 (0x0140 - 0x0138)
class UFortHomebaseBannerColorItem final : public UFortAccountItem
{
public:
	class FName                                   ColorRowName;                                      // 0x0138(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortHomebaseBannerColorItem">();
	}
	static class UFortHomebaseBannerColorItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortHomebaseBannerColorItem>();
	}
};
static_assert(alignof(UFortHomebaseBannerColorItem) == 0x000008, "Wrong alignment on UFortHomebaseBannerColorItem");
static_assert(sizeof(UFortHomebaseBannerColorItem) == 0x000140, "Wrong size on UFortHomebaseBannerColorItem");
static_assert(offsetof(UFortHomebaseBannerColorItem, ColorRowName) == 0x000138, "Member 'UFortHomebaseBannerColorItem::ColorRowName' has a wrong offset!");

// Class FortniteGame.FortHomebaseBannerIconItem
// 0x0008 (0x0140 - 0x0138)
class UFortHomebaseBannerIconItem final : public UFortAccountItem
{
public:
	class FName                                   BannerRowName;                                     // 0x0138(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortHomebaseBannerIconItem">();
	}
	static class UFortHomebaseBannerIconItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortHomebaseBannerIconItem>();
	}
};
static_assert(alignof(UFortHomebaseBannerIconItem) == 0x000008, "Wrong alignment on UFortHomebaseBannerIconItem");
static_assert(sizeof(UFortHomebaseBannerIconItem) == 0x000140, "Wrong size on UFortHomebaseBannerIconItem");
static_assert(offsetof(UFortHomebaseBannerIconItem, BannerRowName) == 0x000138, "Member 'UFortHomebaseBannerIconItem::BannerRowName' has a wrong offset!");

// Class FortniteGame.FortHomebaseNodeItem
// 0x0028 (0x0160 - 0x0138)
class UFortHomebaseNodeItem final : public UFortAccountItem
{
public:
	uint8                                         Pad_138[0x8];                                      // 0x0138(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    NodeReference;                                     // 0x0140(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_150[0x10];                                     // 0x0150(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortHomebaseNodeItem">();
	}
	static class UFortHomebaseNodeItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortHomebaseNodeItem>();
	}
};
static_assert(alignof(UFortHomebaseNodeItem) == 0x000008, "Wrong alignment on UFortHomebaseNodeItem");
static_assert(sizeof(UFortHomebaseNodeItem) == 0x000160, "Wrong size on UFortHomebaseNodeItem");
static_assert(offsetof(UFortHomebaseNodeItem, NodeReference) == 0x000140, "Member 'UFortHomebaseNodeItem::NodeReference' has a wrong offset!");

// Class FortniteGame.FortQuotaItemDefinition
// 0x0010 (0x0280 - 0x0270)
class UFortQuotaItemDefinition final : public UFortAccountItemDefinition
{
public:
	float                                         StartingValue;                                     // 0x0270(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaximumValue;                                      // 0x0274(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnitsPerMinuteRechargeRate;                        // 0x0278(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RechargeDelayMinutes;                              // 0x027C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQuotaItemDefinition">();
	}
	static class UFortQuotaItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQuotaItemDefinition>();
	}
};
static_assert(alignof(UFortQuotaItemDefinition) == 0x000010, "Wrong alignment on UFortQuotaItemDefinition");
static_assert(sizeof(UFortQuotaItemDefinition) == 0x000280, "Wrong size on UFortQuotaItemDefinition");
static_assert(offsetof(UFortQuotaItemDefinition, StartingValue) == 0x000270, "Member 'UFortQuotaItemDefinition::StartingValue' has a wrong offset!");
static_assert(offsetof(UFortQuotaItemDefinition, MaximumValue) == 0x000274, "Member 'UFortQuotaItemDefinition::MaximumValue' has a wrong offset!");
static_assert(offsetof(UFortQuotaItemDefinition, UnitsPerMinuteRechargeRate) == 0x000278, "Member 'UFortQuotaItemDefinition::UnitsPerMinuteRechargeRate' has a wrong offset!");
static_assert(offsetof(UFortQuotaItemDefinition, RechargeDelayMinutes) == 0x00027C, "Member 'UFortQuotaItemDefinition::RechargeDelayMinutes' has a wrong offset!");

// Class FortniteGame.FortQuotaItem
// 0x0038 (0x0170 - 0x0138)
class UFortQuotaItem final : public UFortAccountItem
{
public:
	float                                         current_value;                                     // 0x0138(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 last_mod_time;                                     // 0x0140(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         units_per_minute_recharge;                         // 0x0150(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         max_quota;                                         // 0x0154(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         recharge_delay_minutes;                            // 0x0158(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15C[0x14];                                     // 0x015C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetCurrentQuotaAmount();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQuotaItem">();
	}
	static class UFortQuotaItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQuotaItem>();
	}
};
static_assert(alignof(UFortQuotaItem) == 0x000008, "Wrong alignment on UFortQuotaItem");
static_assert(sizeof(UFortQuotaItem) == 0x000170, "Wrong size on UFortQuotaItem");
static_assert(offsetof(UFortQuotaItem, current_value) == 0x000138, "Member 'UFortQuotaItem::current_value' has a wrong offset!");
static_assert(offsetof(UFortQuotaItem, last_mod_time) == 0x000140, "Member 'UFortQuotaItem::last_mod_time' has a wrong offset!");
static_assert(offsetof(UFortQuotaItem, units_per_minute_recharge) == 0x000150, "Member 'UFortQuotaItem::units_per_minute_recharge' has a wrong offset!");
static_assert(offsetof(UFortQuotaItem, max_quota) == 0x000154, "Member 'UFortQuotaItem::max_quota' has a wrong offset!");
static_assert(offsetof(UFortQuotaItem, recharge_delay_minutes) == 0x000158, "Member 'UFortQuotaItem::recharge_delay_minutes' has a wrong offset!");

// Class FortniteGame.FortQueryTest_HotspotSlotOrientation
// 0x0038 (0x01F8 - 0x01C0)
class UFortQueryTest_HotspotSlotOrientation final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           FaceToward;                                        // 0x01C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              DotThreshold;                                      // 0x01C8(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_HotspotSlotOrientation">();
	}
	static class UFortQueryTest_HotspotSlotOrientation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_HotspotSlotOrientation>();
	}
};
static_assert(alignof(UFortQueryTest_HotspotSlotOrientation) == 0x000008, "Wrong alignment on UFortQueryTest_HotspotSlotOrientation");
static_assert(sizeof(UFortQueryTest_HotspotSlotOrientation) == 0x0001F8, "Wrong size on UFortQueryTest_HotspotSlotOrientation");
static_assert(offsetof(UFortQueryTest_HotspotSlotOrientation, FaceToward) == 0x0001C0, "Member 'UFortQueryTest_HotspotSlotOrientation::FaceToward' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_HotspotSlotOrientation, DotThreshold) == 0x0001C8, "Member 'UFortQueryTest_HotspotSlotOrientation::DotThreshold' has a wrong offset!");

// Class FortniteGame.FortDeployableBaseCloudSaveItem
// 0x0010 (0x0130 - 0x0120)
class UFortDeployableBaseCloudSaveItem final : public UFortCloudSaveItem
{
public:
	struct FFortTierProgression                   tier_progression;                                  // 0x0120(0x0010)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDeployableBaseCloudSaveItem">();
	}
	static class UFortDeployableBaseCloudSaveItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDeployableBaseCloudSaveItem>();
	}
};
static_assert(alignof(UFortDeployableBaseCloudSaveItem) == 0x000008, "Wrong alignment on UFortDeployableBaseCloudSaveItem");
static_assert(sizeof(UFortDeployableBaseCloudSaveItem) == 0x000130, "Wrong size on UFortDeployableBaseCloudSaveItem");
static_assert(offsetof(UFortDeployableBaseCloudSaveItem, tier_progression) == 0x000120, "Member 'UFortDeployableBaseCloudSaveItem::tier_progression' has a wrong offset!");

// Class FortniteGame.FortOutpostItem
// 0x0020 (0x0140 - 0x0120)
class UFortOutpostItem final : public UFortCloudSaveItem
{
public:
	struct FFortOutpostCoreInfo                   outpost_core_info;                                 // 0x0120(0x0020)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortOutpostItem">();
	}
	static class UFortOutpostItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortOutpostItem>();
	}
};
static_assert(alignof(UFortOutpostItem) == 0x000008, "Wrong alignment on UFortOutpostItem");
static_assert(sizeof(UFortOutpostItem) == 0x000140, "Wrong size on UFortOutpostItem");
static_assert(offsetof(UFortOutpostItem, outpost_core_info) == 0x000120, "Member 'UFortOutpostItem::outpost_core_info' has a wrong offset!");

// Class FortniteGame.FortWorldItem
// 0x01E0 (0x02B0 - 0x00D0)
class UFortWorldItem final : public UFortItem
{
public:
	uint8                                         Pad_D0[0x100];                                     // 0x00D0(0x0100)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsTemporaryItem;                                  // 0x01D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNeedsPersistentUpdate;                            // 0x01D1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPendingPersistentDelete;                          // 0x01D2(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D3[0x5];                                      // 0x01D3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortInventory*                         OwnerInventory;                                    // 0x01D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFortItemEntry                         ItemEntry;                                         // 0x01E0(0x00A8)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_288[0x28];                                     // 0x0288(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MarkItemAsSeenInFrontend();

	void GetOwnedGameplayTags(struct FGameplayTagContainer* TagContainer) const;
	bool SeenInFrontend() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortWorldItem">();
	}
	static class UFortWorldItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortWorldItem>();
	}
};
static_assert(alignof(UFortWorldItem) == 0x000008, "Wrong alignment on UFortWorldItem");
static_assert(sizeof(UFortWorldItem) == 0x0002B0, "Wrong size on UFortWorldItem");
static_assert(offsetof(UFortWorldItem, bIsTemporaryItem) == 0x0001D0, "Member 'UFortWorldItem::bIsTemporaryItem' has a wrong offset!");
static_assert(offsetof(UFortWorldItem, bNeedsPersistentUpdate) == 0x0001D1, "Member 'UFortWorldItem::bNeedsPersistentUpdate' has a wrong offset!");
static_assert(offsetof(UFortWorldItem, bPendingPersistentDelete) == 0x0001D2, "Member 'UFortWorldItem::bPendingPersistentDelete' has a wrong offset!");
static_assert(offsetof(UFortWorldItem, OwnerInventory) == 0x0001D8, "Member 'UFortWorldItem::OwnerInventory' has a wrong offset!");
static_assert(offsetof(UFortWorldItem, ItemEntry) == 0x0001E0, "Member 'UFortWorldItem::ItemEntry' has a wrong offset!");

// Class FortniteGame.FortAccountBuffItemDefinition
// 0x0010 (0x0280 - 0x0270)
class UFortAccountBuffItemDefinition final : public UFortAccountItemDefinition
{
public:
	TArray<TSoftClassPtr<class UClass>>           BuffEffects;                                       // 0x0270(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAccountBuffItemDefinition">();
	}
	static class UFortAccountBuffItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAccountBuffItemDefinition>();
	}
};
static_assert(alignof(UFortAccountBuffItemDefinition) == 0x000010, "Wrong alignment on UFortAccountBuffItemDefinition");
static_assert(sizeof(UFortAccountBuffItemDefinition) == 0x000280, "Wrong size on UFortAccountBuffItemDefinition");
static_assert(offsetof(UFortAccountBuffItemDefinition, BuffEffects) == 0x000270, "Member 'UFortAccountBuffItemDefinition::BuffEffects' has a wrong offset!");

// Class FortniteGame.FortCollectedResourceItemDefinition
// 0x0000 (0x0270 - 0x0270)
class UFortCollectedResourceItemDefinition final : public UFortAccountItemDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCollectedResourceItemDefinition">();
	}
	static class UFortCollectedResourceItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCollectedResourceItemDefinition>();
	}
};
static_assert(alignof(UFortCollectedResourceItemDefinition) == 0x000010, "Wrong alignment on UFortCollectedResourceItemDefinition");
static_assert(sizeof(UFortCollectedResourceItemDefinition) == 0x000270, "Wrong size on UFortCollectedResourceItemDefinition");

// Class FortniteGame.FortQueryTest_MissionGameplayTagMatch
// 0x0068 (0x0228 - 0x01C0)
class UFortQueryTest_MissionGameplayTagMatch final : public UEnvQueryTest
{
public:
	struct FGameplayTagQuery                      MissionPlacementActorTagQuery;                     // 0x01C0(0x0048)(Edit, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  GameplayTagsToMatch;                               // 0x0208(0x0020)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_MissionGameplayTagMatch">();
	}
	static class UFortQueryTest_MissionGameplayTagMatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_MissionGameplayTagMatch>();
	}
};
static_assert(alignof(UFortQueryTest_MissionGameplayTagMatch) == 0x000008, "Wrong alignment on UFortQueryTest_MissionGameplayTagMatch");
static_assert(sizeof(UFortQueryTest_MissionGameplayTagMatch) == 0x000228, "Wrong size on UFortQueryTest_MissionGameplayTagMatch");
static_assert(offsetof(UFortQueryTest_MissionGameplayTagMatch, MissionPlacementActorTagQuery) == 0x0001C0, "Member 'UFortQueryTest_MissionGameplayTagMatch::MissionPlacementActorTagQuery' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_MissionGameplayTagMatch, GameplayTagsToMatch) == 0x000208, "Member 'UFortQueryTest_MissionGameplayTagMatch::GameplayTagsToMatch' has a wrong offset!");

// Class FortniteGame.FortConversionControlItemDefinition
// 0x0040 (0x02B0 - 0x0270)
class UFortConversionControlItemDefinition final : public UFortAccountItemDefinition
{
public:
	class FString                                 LootTierGroup;                                     // 0x0270(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDataTableRowHandle                    ConversionPointsToTierCosts;                       // 0x0280(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bConsumedOnConversion;                             // 0x0290(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_291[0x7];                                      // 0x0291(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   RewardName;                                        // 0x0298(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	EFortRarity GetFirstConversionTier() const;
	EFortRarity GetMaxConversionTier() const;
	int32 GetPointsForTier(EFortRarity InTier) const;
	struct FGameplayTagContainer GetRequiredCatalysts() const;
	class UFortAccountItemDefinition* GetRequiredItemDefinition() const;
	int32 GetRequiredItemQuantity(int32 SacrificePoints) const;
	class FText GetRewardName() const;
	bool GetTierFromSacrificePoints(int32 SacrificePoints, EFortRarity* CalculatedTier) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortConversionControlItemDefinition">();
	}
	static class UFortConversionControlItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortConversionControlItemDefinition>();
	}
};
static_assert(alignof(UFortConversionControlItemDefinition) == 0x000010, "Wrong alignment on UFortConversionControlItemDefinition");
static_assert(sizeof(UFortConversionControlItemDefinition) == 0x0002B0, "Wrong size on UFortConversionControlItemDefinition");
static_assert(offsetof(UFortConversionControlItemDefinition, LootTierGroup) == 0x000270, "Member 'UFortConversionControlItemDefinition::LootTierGroup' has a wrong offset!");
static_assert(offsetof(UFortConversionControlItemDefinition, ConversionPointsToTierCosts) == 0x000280, "Member 'UFortConversionControlItemDefinition::ConversionPointsToTierCosts' has a wrong offset!");
static_assert(offsetof(UFortConversionControlItemDefinition, bConsumedOnConversion) == 0x000290, "Member 'UFortConversionControlItemDefinition::bConsumedOnConversion' has a wrong offset!");
static_assert(offsetof(UFortConversionControlItemDefinition, RewardName) == 0x000298, "Member 'UFortConversionControlItemDefinition::RewardName' has a wrong offset!");

// Class FortniteGame.FortTestControllerBase
// 0x0020 (0x0050 - 0x0030)
class UFortTestControllerBase : public UGauntletTestController
{
public:
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTestControllerBase">();
	}
	static class UFortTestControllerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortTestControllerBase>();
	}
};
static_assert(alignof(UFortTestControllerBase) == 0x000008, "Wrong alignment on UFortTestControllerBase");
static_assert(sizeof(UFortTestControllerBase) == 0x000050, "Wrong size on UFortTestControllerBase");

// Class FortniteGame.FortCurrencyItemDefinition
// 0x0000 (0x0270 - 0x0270)
class UFortCurrencyItemDefinition final : public UFortAccountItemDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCurrencyItemDefinition">();
	}
	static class UFortCurrencyItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCurrencyItemDefinition>();
	}
};
static_assert(alignof(UFortCurrencyItemDefinition) == 0x000010, "Wrong alignment on UFortCurrencyItemDefinition");
static_assert(sizeof(UFortCurrencyItemDefinition) == 0x000270, "Wrong size on UFortCurrencyItemDefinition");

// Class FortniteGame.FortGameplayModifierItemDefinition
// 0x0030 (0x02A0 - 0x0270)
class UFortGameplayModifierItemDefinition final : public UFortAccountItemDefinition
{
public:
	TArray<struct FFortGameplayEffectDeliveryInfo> PersistentGameplayEffects;                         // 0x0270(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortAbilitySetDeliveryInfo>    PersistentAbilitySets;                             // 0x0280(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<TSoftClassPtr<class UClass>>           Mutators;                                          // 0x0290(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameplayModifierItemDefinition">();
	}
	static class UFortGameplayModifierItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGameplayModifierItemDefinition>();
	}
};
static_assert(alignof(UFortGameplayModifierItemDefinition) == 0x000010, "Wrong alignment on UFortGameplayModifierItemDefinition");
static_assert(sizeof(UFortGameplayModifierItemDefinition) == 0x0002A0, "Wrong size on UFortGameplayModifierItemDefinition");
static_assert(offsetof(UFortGameplayModifierItemDefinition, PersistentGameplayEffects) == 0x000270, "Member 'UFortGameplayModifierItemDefinition::PersistentGameplayEffects' has a wrong offset!");
static_assert(offsetof(UFortGameplayModifierItemDefinition, PersistentAbilitySets) == 0x000280, "Member 'UFortGameplayModifierItemDefinition::PersistentAbilitySets' has a wrong offset!");
static_assert(offsetof(UFortGameplayModifierItemDefinition, Mutators) == 0x000290, "Member 'UFortGameplayModifierItemDefinition::Mutators' has a wrong offset!");

// Class FortniteGame.FortHomebaseNodeItemDefinition
// 0x0000 (0x0270 - 0x0270)
class UFortHomebaseNodeItemDefinition final : public UFortAccountItemDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortHomebaseNodeItemDefinition">();
	}
	static class UFortHomebaseNodeItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortHomebaseNodeItemDefinition>();
	}
};
static_assert(alignof(UFortHomebaseNodeItemDefinition) == 0x000010, "Wrong alignment on UFortHomebaseNodeItemDefinition");
static_assert(sizeof(UFortHomebaseNodeItemDefinition) == 0x000270, "Wrong size on UFortHomebaseNodeItemDefinition");

// Class FortniteGame.FortPersistentResourceItemDefinition
// 0x0010 (0x0280 - 0x0270)
class UFortPersistentResourceItemDefinition final : public UFortAccountItemDefinition
{
public:
	bool                                          bIsEventItem;                                      // 0x0270(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_271[0xF];                                      // 0x0271(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsEventItem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPersistentResourceItemDefinition">();
	}
	static class UFortPersistentResourceItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPersistentResourceItemDefinition>();
	}
};
static_assert(alignof(UFortPersistentResourceItemDefinition) == 0x000010, "Wrong alignment on UFortPersistentResourceItemDefinition");
static_assert(sizeof(UFortPersistentResourceItemDefinition) == 0x000280, "Wrong size on UFortPersistentResourceItemDefinition");
static_assert(offsetof(UFortPersistentResourceItemDefinition, bIsEventItem) == 0x000270, "Member 'UFortPersistentResourceItemDefinition::bIsEventItem' has a wrong offset!");

// Class FortniteGame.FortSchematicTooltip
// 0x0000 (0x0090 - 0x0090)
class UFortSchematicTooltip final : public UFortAccountItemTooltip
{
public:
	bool GetNumericValue(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, float* OutVal) const;
	bool GetTextForToken(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, class FText* OutText) const;
	bool GetTokenizedDescriptionText(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, TArray<class FText>* OutDescription) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortSchematicTooltip">();
	}
	static class UFortSchematicTooltip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortSchematicTooltip>();
	}
};
static_assert(alignof(UFortSchematicTooltip) == 0x000008, "Wrong alignment on UFortSchematicTooltip");
static_assert(sizeof(UFortSchematicTooltip) == 0x000090, "Wrong size on UFortSchematicTooltip");

// Class FortniteGame.FortQuestItemDefinition
// 0x01A0 (0x0410 - 0x0270)
class UFortQuestItemDefinition final : public UFortAccountItemDefinition
{
public:
	EFortQuestType                                QuestType;                                         // 0x0270(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_271[0x3];                                      // 0x0271(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ExpirationDuration;                                // 0x0274(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FFortItemQuantityPair>          Rewards;                                           // 0x0278(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortHiddenRewardQuantityPair>  HiddenRewards;                                     // 0x0288(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortMcpQuestRewardInfo>        SelectableRewards;                                 // 0x0298(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	EFortQuestRewardType                          RewardType;                                        // 0x02A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A9[0x7];                                      // 0x02A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFortMcpQuestObjectiveInfo>     Objectives;                                        // 0x02B0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  Prerequisites;                                     // 0x02C0(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFortQuestItemDefinition> PrerequisiteQuest;                                 // 0x02E0(0x0020)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDataTableRowHandle                    PrerequisiteObjective;                             // 0x0300(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         Weight;                                            // 0x0310(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint16                                        GranterWindowPeriodMinutes;                        // 0x0314(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint16                                        GranterCooldownPeriodSeconds;                      // 0x0316(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsStreamingRequired;                               // 0x0318(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_319[0x7];                                      // 0x0319(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    Category;                                          // 0x0320(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFortConversation>       IntroConversation;                                 // 0x0330(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFortConversation>       SelectRewardsConversation;                         // 0x0350(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFortConversation>       ClaimConversation;                                 // 0x0370(0x0020)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   RewardHeaderText;                                  // 0x0390(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	class FText                                   RewardDescription;                                 // 0x03A8(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	class FText                                   CompletionText;                                    // 0x03C0(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	bool                                          bExpandsStormShield;                               // 0x03D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHidden;                                           // 0x03D9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutoLaunch;                                       // 0x03DA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDeprecated;                                       // 0x03DB(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3DC[0x4];                                      // 0x03DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFortQuestMissionCreationContext> MissionCreationContexts;                           // 0x03E0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FFortMissionConfigDataParams           MissionConfigMetadata;                             // 0x03F0(0x0010)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bDisableBackendConditionEvaluation;                // 0x0400(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_401[0x3];                                      // 0x0401(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        ClaimPriority;                                     // 0x0404(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowTileMatching;                                // 0x0408(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowMissionAlertMatchesBypassingTileRequirements; // 0x0409(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40A[0x6];                                      // 0x040A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AllowsTileMatching() const;
	bool ExpandsStormShield() const;
	struct FDataTableRowHandle GetCategory() const;
	class UFortConversation* GetClaimConversation() const;
	class FText GetCompletionText() const;
	TArray<struct FFortHiddenRewardQuantityPair> GetHiddenRewards_BP() const;
	class UFortConversation* GetIntroConversation() const;
	TArray<struct FFortMcpQuestObjectiveInfo> GetObjectives_BP() const;
	struct FDataTableRowHandle GetPrerequisiteObjective() const;
	class UFortQuestItemDefinition* GetPrerequisiteQuest() const;
	EFortQuestType GetQuestType() const;
	class FText GetRewardDescription() const;
	class FText GetRewardHeaderText() const;
	struct FFortRewardInfo GetRewardInfo_BP() const;
	TArray<struct FFortItemQuantityPair> GetRewards_BP() const;
	EFortQuestRewardType GetRewardType() const;
	TArray<struct FFortMcpQuestRewardInfo> GetSelectableRewards_BP() const;
	class UFortConversation* GetSelectRewardsConversation() const;
	float GetWeight() const;
	bool IsDeprecated() const;
	bool IsHidden() const;
	bool ShouldAutoLaunch() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQuestItemDefinition">();
	}
	static class UFortQuestItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQuestItemDefinition>();
	}
};
static_assert(alignof(UFortQuestItemDefinition) == 0x000010, "Wrong alignment on UFortQuestItemDefinition");
static_assert(sizeof(UFortQuestItemDefinition) == 0x000410, "Wrong size on UFortQuestItemDefinition");
static_assert(offsetof(UFortQuestItemDefinition, QuestType) == 0x000270, "Member 'UFortQuestItemDefinition::QuestType' has a wrong offset!");
static_assert(offsetof(UFortQuestItemDefinition, ExpirationDuration) == 0x000274, "Member 'UFortQuestItemDefinition::ExpirationDuration' has a wrong offset!");
static_assert(offsetof(UFortQuestItemDefinition, Rewards) == 0x000278, "Member 'UFortQuestItemDefinition::Rewards' has a wrong offset!");
static_assert(offsetof(UFortQuestItemDefinition, HiddenRewards) == 0x000288, "Member 'UFortQuestItemDefinition::HiddenRewards' has a wrong offset!");
static_assert(offsetof(UFortQuestItemDefinition, SelectableRewards) == 0x000298, "Member 'UFortQuestItemDefinition::SelectableRewards' has a wrong offset!");
static_assert(offsetof(UFortQuestItemDefinition, RewardType) == 0x0002A8, "Member 'UFortQuestItemDefinition::RewardType' has a wrong offset!");
static_assert(offsetof(UFortQuestItemDefinition, Objectives) == 0x0002B0, "Member 'UFortQuestItemDefinition::Objectives' has a wrong offset!");
static_assert(offsetof(UFortQuestItemDefinition, Prerequisites) == 0x0002C0, "Member 'UFortQuestItemDefinition::Prerequisites' has a wrong offset!");
static_assert(offsetof(UFortQuestItemDefinition, PrerequisiteQuest) == 0x0002E0, "Member 'UFortQuestItemDefinition::PrerequisiteQuest' has a wrong offset!");
static_assert(offsetof(UFortQuestItemDefinition, PrerequisiteObjective) == 0x000300, "Member 'UFortQuestItemDefinition::PrerequisiteObjective' has a wrong offset!");
static_assert(offsetof(UFortQuestItemDefinition, Weight) == 0x000310, "Member 'UFortQuestItemDefinition::Weight' has a wrong offset!");
static_assert(offsetof(UFortQuestItemDefinition, GranterWindowPeriodMinutes) == 0x000314, "Member 'UFortQuestItemDefinition::GranterWindowPeriodMinutes' has a wrong offset!");
static_assert(offsetof(UFortQuestItemDefinition, GranterCooldownPeriodSeconds) == 0x000316, "Member 'UFortQuestItemDefinition::GranterCooldownPeriodSeconds' has a wrong offset!");
static_assert(offsetof(UFortQuestItemDefinition, IsStreamingRequired) == 0x000318, "Member 'UFortQuestItemDefinition::IsStreamingRequired' has a wrong offset!");
static_assert(offsetof(UFortQuestItemDefinition, Category) == 0x000320, "Member 'UFortQuestItemDefinition::Category' has a wrong offset!");
static_assert(offsetof(UFortQuestItemDefinition, IntroConversation) == 0x000330, "Member 'UFortQuestItemDefinition::IntroConversation' has a wrong offset!");
static_assert(offsetof(UFortQuestItemDefinition, SelectRewardsConversation) == 0x000350, "Member 'UFortQuestItemDefinition::SelectRewardsConversation' has a wrong offset!");
static_assert(offsetof(UFortQuestItemDefinition, ClaimConversation) == 0x000370, "Member 'UFortQuestItemDefinition::ClaimConversation' has a wrong offset!");
static_assert(offsetof(UFortQuestItemDefinition, RewardHeaderText) == 0x000390, "Member 'UFortQuestItemDefinition::RewardHeaderText' has a wrong offset!");
static_assert(offsetof(UFortQuestItemDefinition, RewardDescription) == 0x0003A8, "Member 'UFortQuestItemDefinition::RewardDescription' has a wrong offset!");
static_assert(offsetof(UFortQuestItemDefinition, CompletionText) == 0x0003C0, "Member 'UFortQuestItemDefinition::CompletionText' has a wrong offset!");
static_assert(offsetof(UFortQuestItemDefinition, bExpandsStormShield) == 0x0003D8, "Member 'UFortQuestItemDefinition::bExpandsStormShield' has a wrong offset!");
static_assert(offsetof(UFortQuestItemDefinition, bHidden) == 0x0003D9, "Member 'UFortQuestItemDefinition::bHidden' has a wrong offset!");
static_assert(offsetof(UFortQuestItemDefinition, bAutoLaunch) == 0x0003DA, "Member 'UFortQuestItemDefinition::bAutoLaunch' has a wrong offset!");
static_assert(offsetof(UFortQuestItemDefinition, bDeprecated) == 0x0003DB, "Member 'UFortQuestItemDefinition::bDeprecated' has a wrong offset!");
static_assert(offsetof(UFortQuestItemDefinition, MissionCreationContexts) == 0x0003E0, "Member 'UFortQuestItemDefinition::MissionCreationContexts' has a wrong offset!");
static_assert(offsetof(UFortQuestItemDefinition, MissionConfigMetadata) == 0x0003F0, "Member 'UFortQuestItemDefinition::MissionConfigMetadata' has a wrong offset!");
static_assert(offsetof(UFortQuestItemDefinition, bDisableBackendConditionEvaluation) == 0x000400, "Member 'UFortQuestItemDefinition::bDisableBackendConditionEvaluation' has a wrong offset!");
static_assert(offsetof(UFortQuestItemDefinition, ClaimPriority) == 0x000404, "Member 'UFortQuestItemDefinition::ClaimPriority' has a wrong offset!");
static_assert(offsetof(UFortQuestItemDefinition, bAllowTileMatching) == 0x000408, "Member 'UFortQuestItemDefinition::bAllowTileMatching' has a wrong offset!");
static_assert(offsetof(UFortQuestItemDefinition, bAllowMissionAlertMatchesBypassingTileRequirements) == 0x000409, "Member 'UFortQuestItemDefinition::bAllowMissionAlertMatchesBypassingTileRequirements' has a wrong offset!");

// Class FortniteGame.FortAmmoItemDefinition
// 0x0400 (0x0820 - 0x0420)
class UFortAmmoItemDefinition final : public UFortWorldItemDefinition
{
public:
	struct FSlateBrush                            ClipIconBrush;                                     // 0x0420(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bIsConsumed;                                       // 0x04B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B1[0x3];                                      // 0x04B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RegenCooldown;                                     // 0x04B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFortMultiSizeBrush                    AmmoIconBrush;                                     // 0x04B8(0x0360)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_818[0x8];                                      // 0x0818(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAmmoItemDefinition">();
	}
	static class UFortAmmoItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAmmoItemDefinition>();
	}
};
static_assert(alignof(UFortAmmoItemDefinition) == 0x000010, "Wrong alignment on UFortAmmoItemDefinition");
static_assert(sizeof(UFortAmmoItemDefinition) == 0x000820, "Wrong size on UFortAmmoItemDefinition");
static_assert(offsetof(UFortAmmoItemDefinition, ClipIconBrush) == 0x000420, "Member 'UFortAmmoItemDefinition::ClipIconBrush' has a wrong offset!");
static_assert(offsetof(UFortAmmoItemDefinition, bIsConsumed) == 0x0004B0, "Member 'UFortAmmoItemDefinition::bIsConsumed' has a wrong offset!");
static_assert(offsetof(UFortAmmoItemDefinition, RegenCooldown) == 0x0004B4, "Member 'UFortAmmoItemDefinition::RegenCooldown' has a wrong offset!");
static_assert(offsetof(UFortAmmoItemDefinition, AmmoIconBrush) == 0x0004B8, "Member 'UFortAmmoItemDefinition::AmmoIconBrush' has a wrong offset!");

// Class FortniteGame.FortBackpackItemDefinition
// 0x0000 (0x0420 - 0x0420)
class UFortBackpackItemDefinition final : public UFortWorldItemDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBackpackItemDefinition">();
	}
	static class UFortBackpackItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBackpackItemDefinition>();
	}
};
static_assert(alignof(UFortBackpackItemDefinition) == 0x000010, "Wrong alignment on UFortBackpackItemDefinition");
static_assert(sizeof(UFortBackpackItemDefinition) == 0x000420, "Wrong size on UFortBackpackItemDefinition");

// Class FortniteGame.FortAbilitySystemComponentTooltip
// 0x0008 (0x0098 - 0x0090)
class UFortAbilitySystemComponentTooltip final : public UFortTooltip
{
public:
	class UFortTooltipContext*                    CachedContext;                                     // 0x0090(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool GetNumericValue(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, float* OutVal) const;
	bool GetTextForToken(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, class FText* OutText) const;
	bool GetTokenizedDescriptionText(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, TArray<class FText>* OutDescription) const;
	bool GetValueData(const class UObject* ObjectToDescribe, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, struct FFortTooltipValueData* OutData) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAbilitySystemComponentTooltip">();
	}
	static class UFortAbilitySystemComponentTooltip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAbilitySystemComponentTooltip>();
	}
};
static_assert(alignof(UFortAbilitySystemComponentTooltip) == 0x000008, "Wrong alignment on UFortAbilitySystemComponentTooltip");
static_assert(sizeof(UFortAbilitySystemComponentTooltip) == 0x000098, "Wrong size on UFortAbilitySystemComponentTooltip");
static_assert(offsetof(UFortAbilitySystemComponentTooltip, CachedContext) == 0x000090, "Member 'UFortAbilitySystemComponentTooltip::CachedContext' has a wrong offset!");

// Class FortniteGame.FortBadgeItemDefinition
// 0x0080 (0x04A0 - 0x0420)
class UFortBadgeItemDefinition final : public UFortWorldItemDefinition
{
public:
	class FText                                   DisplayText;                                       // 0x0420(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   FailedDisplayText;                                 // 0x0438(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FLinearColor                           BadgeColor;                                        // 0x0450(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    BadgeScoringValuesHandle;                          // 0x0460(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UFortCardPackItemDefinition> BadgeCardPackReward;                               // 0x0470(0x0020)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FFortItemQuantityPair>          ItemRewards;                                       // 0x0490(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	EStatCategory GetBadgeScoreCategory() const;
	int32 GetBadgeScoreThreshold() const;
	int32 GetMissionPoints() const;
	int32 GetScoreAwarded(const class APlayerController* PlayerController) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBadgeItemDefinition">();
	}
	static class UFortBadgeItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBadgeItemDefinition>();
	}
};
static_assert(alignof(UFortBadgeItemDefinition) == 0x000010, "Wrong alignment on UFortBadgeItemDefinition");
static_assert(sizeof(UFortBadgeItemDefinition) == 0x0004A0, "Wrong size on UFortBadgeItemDefinition");
static_assert(offsetof(UFortBadgeItemDefinition, DisplayText) == 0x000420, "Member 'UFortBadgeItemDefinition::DisplayText' has a wrong offset!");
static_assert(offsetof(UFortBadgeItemDefinition, FailedDisplayText) == 0x000438, "Member 'UFortBadgeItemDefinition::FailedDisplayText' has a wrong offset!");
static_assert(offsetof(UFortBadgeItemDefinition, BadgeColor) == 0x000450, "Member 'UFortBadgeItemDefinition::BadgeColor' has a wrong offset!");
static_assert(offsetof(UFortBadgeItemDefinition, BadgeScoringValuesHandle) == 0x000460, "Member 'UFortBadgeItemDefinition::BadgeScoringValuesHandle' has a wrong offset!");
static_assert(offsetof(UFortBadgeItemDefinition, BadgeCardPackReward) == 0x000470, "Member 'UFortBadgeItemDefinition::BadgeCardPackReward' has a wrong offset!");
static_assert(offsetof(UFortBadgeItemDefinition, ItemRewards) == 0x000490, "Member 'UFortBadgeItemDefinition::ItemRewards' has a wrong offset!");

// Class FortniteGame.FortConsumableItemDefinition
// 0x0040 (0x0460 - 0x0420)
class UFortConsumableItemDefinition final : public UFortWorldItemDefinition
{
public:
	TArray<struct FConsumeEffectData>             ConsumeEffects;                                    // 0x0420(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UAnimMontage>            UseAnimation;                                      // 0x0430(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         UseTime;                                           // 0x0450(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRequiresMissingHealth;                            // 0x0454(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_455[0xB];                                      // 0x0455(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ConsumeItem(const struct FGameplayEventData& EventData);

	float GetAnimPlayRate() const;
	float GetHealthRestored(int32 ItemLevel) const;
	class UAnimMontage* GetUseAnimation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortConsumableItemDefinition">();
	}
	static class UFortConsumableItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortConsumableItemDefinition>();
	}
};
static_assert(alignof(UFortConsumableItemDefinition) == 0x000010, "Wrong alignment on UFortConsumableItemDefinition");
static_assert(sizeof(UFortConsumableItemDefinition) == 0x000460, "Wrong size on UFortConsumableItemDefinition");
static_assert(offsetof(UFortConsumableItemDefinition, ConsumeEffects) == 0x000420, "Member 'UFortConsumableItemDefinition::ConsumeEffects' has a wrong offset!");
static_assert(offsetof(UFortConsumableItemDefinition, UseAnimation) == 0x000430, "Member 'UFortConsumableItemDefinition::UseAnimation' has a wrong offset!");
static_assert(offsetof(UFortConsumableItemDefinition, UseTime) == 0x000450, "Member 'UFortConsumableItemDefinition::UseTime' has a wrong offset!");
static_assert(offsetof(UFortConsumableItemDefinition, bRequiresMissingHealth) == 0x000454, "Member 'UFortConsumableItemDefinition::bRequiresMissingHealth' has a wrong offset!");

// Class FortniteGame.FortGadgetItemDefinition
// 0x0090 (0x04B0 - 0x0420)
class UFortGadgetItemDefinition final : public UFortWorldItemDefinition
{
public:
	uint8                                         Pad_420[0x8];                                      // 0x0420(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   GameplayAbility;                                   // 0x0428(0x0020)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasChargeUp;                                      // 0x0448(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_449[0x7];                                      // 0x0449(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UFortDecoItemDefinition> DecoItemDefinition;                                // 0x0450(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayAttribute                     LevelAttribute;                                    // 0x0470(0x0020)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDataTableRowHandle                    DamageStatHandle;                                  // 0x0490(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bCanChangePreviewImageDuringGame;                  // 0x04A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4A1[0xF];                                      // 0x04A1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UFortDecoItemDefinition* GetDecoItemDefinition() const;
	TSubclassOf<class UFortGameplayAbility> GetGameplayAbility() const;
	struct FGameplayAttribute GetLevelAttribute() const;
	bool HasChargeUp() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGadgetItemDefinition">();
	}
	static class UFortGadgetItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGadgetItemDefinition>();
	}
};
static_assert(alignof(UFortGadgetItemDefinition) == 0x000010, "Wrong alignment on UFortGadgetItemDefinition");
static_assert(sizeof(UFortGadgetItemDefinition) == 0x0004B0, "Wrong size on UFortGadgetItemDefinition");
static_assert(offsetof(UFortGadgetItemDefinition, GameplayAbility) == 0x000428, "Member 'UFortGadgetItemDefinition::GameplayAbility' has a wrong offset!");
static_assert(offsetof(UFortGadgetItemDefinition, bHasChargeUp) == 0x000448, "Member 'UFortGadgetItemDefinition::bHasChargeUp' has a wrong offset!");
static_assert(offsetof(UFortGadgetItemDefinition, DecoItemDefinition) == 0x000450, "Member 'UFortGadgetItemDefinition::DecoItemDefinition' has a wrong offset!");
static_assert(offsetof(UFortGadgetItemDefinition, LevelAttribute) == 0x000470, "Member 'UFortGadgetItemDefinition::LevelAttribute' has a wrong offset!");
static_assert(offsetof(UFortGadgetItemDefinition, DamageStatHandle) == 0x000490, "Member 'UFortGadgetItemDefinition::DamageStatHandle' has a wrong offset!");
static_assert(offsetof(UFortGadgetItemDefinition, bCanChangePreviewImageDuringGame) == 0x0004A0, "Member 'UFortGadgetItemDefinition::bCanChangePreviewImageDuringGame' has a wrong offset!");

// Class FortniteGame.FortIngredientItemDefinition
// 0x0000 (0x0420 - 0x0420)
class UFortIngredientItemDefinition final : public UFortWorldItemDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortIngredientItemDefinition">();
	}
	static class UFortIngredientItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortIngredientItemDefinition>();
	}
};
static_assert(alignof(UFortIngredientItemDefinition) == 0x000010, "Wrong alignment on UFortIngredientItemDefinition");
static_assert(sizeof(UFortIngredientItemDefinition) == 0x000420, "Wrong size on UFortIngredientItemDefinition");

// Class FortniteGame.FortQuestObjectiveTooltip
// 0x0000 (0x0090 - 0x0090)
class UFortQuestObjectiveTooltip final : public UFortTooltip
{
public:
	bool GetNumericValue(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, float* OutVal) const;
	bool GetTextForToken(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, class FText* OutText) const;
	bool GetTokenizedDescriptionText(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, TArray<class FText>* OutDescription) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQuestObjectiveTooltip">();
	}
	static class UFortQuestObjectiveTooltip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQuestObjectiveTooltip>();
	}
};
static_assert(alignof(UFortQuestObjectiveTooltip) == 0x000008, "Wrong alignment on UFortQuestObjectiveTooltip");
static_assert(sizeof(UFortQuestObjectiveTooltip) == 0x000090, "Wrong size on UFortQuestObjectiveTooltip");

// Class FortniteGame.FortMissionItemDefinition
// 0x0000 (0x0420 - 0x0420)
class UFortMissionItemDefinition final : public UFortWorldItemDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMissionItemDefinition">();
	}
	static class UFortMissionItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMissionItemDefinition>();
	}
};
static_assert(alignof(UFortMissionItemDefinition) == 0x000010, "Wrong alignment on UFortMissionItemDefinition");
static_assert(sizeof(UFortMissionItemDefinition) == 0x000420, "Wrong size on UFortMissionItemDefinition");

// Class FortniteGame.FortResourceItemDefinition
// 0x0010 (0x0430 - 0x0420)
class UFortResourceItemDefinition final : public UFortWorldItemDefinition
{
public:
	EFortResourceType                             ResourceType;                                      // 0x0420(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_421[0xF];                                      // 0x0421(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortResourceItemDefinition">();
	}
	static class UFortResourceItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortResourceItemDefinition>();
	}
};
static_assert(alignof(UFortResourceItemDefinition) == 0x000010, "Wrong alignment on UFortResourceItemDefinition");
static_assert(sizeof(UFortResourceItemDefinition) == 0x000430, "Wrong size on UFortResourceItemDefinition");
static_assert(offsetof(UFortResourceItemDefinition, ResourceType) == 0x000420, "Member 'UFortResourceItemDefinition::ResourceType' has a wrong offset!");

// Class FortniteGame.FortBuildingItemDefinition
// 0x0020 (0x0650 - 0x0630)
class UFortBuildingItemDefinition final : public UFortWeaponItemDefinition
{
public:
	TSoftObjectPtr<class UBuildingEditModeMetadata> BuildingMetaData;                                  // 0x0628(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_648[0x8];                                      // 0x0648(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBuildingItemDefinition">();
	}
	static class UFortBuildingItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBuildingItemDefinition>();
	}
};
static_assert(alignof(UFortBuildingItemDefinition) == 0x000010, "Wrong alignment on UFortBuildingItemDefinition");
static_assert(sizeof(UFortBuildingItemDefinition) == 0x000650, "Wrong size on UFortBuildingItemDefinition");
static_assert(offsetof(UFortBuildingItemDefinition, BuildingMetaData) == 0x000628, "Member 'UFortBuildingItemDefinition::BuildingMetaData' has a wrong offset!");

// Class FortniteGame.FortDecoItemDefinition
// 0x0060 (0x0690 - 0x0630)
class UFortDecoItemDefinition : public UFortWeaponItemDefinition
{
public:
	TSoftClassPtr<class UClass>                   BlueprintClass;                                    // 0x0628(0x0020)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   PlacementPreviewClass;                             // 0x0648(0x0020)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GridSnapSizeOverride;                              // 0x0668(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RotationAngleIncrement;                            // 0x066C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlacementType                                PlacementTypeOverride;                             // 0x0670(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_671[0x3];                                      // 0x0671(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bForceIgnoreOverlapTest : 1;                       // 0x0674(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bForceIgnoreBuildingOverlaps : 1;                  // 0x0674(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDisableLocationLerpWhilePlacing : 1;              // 0x0674(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDisableRotationLerpWhilePlacing : 1;              // 0x0674(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDisableScaleLerpWhilePlacing : 1;                 // 0x0674(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAttachWhenPlacing : 1;                            // 0x0674(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAllowPlacementOnWorldGeometry : 1;                // 0x0674(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAllowPlacementOnBuildings : 1;                    // 0x0674(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDestroySmallObjectsWhenPlaced : 1;                // 0x0675(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bConsumeWhenPlaced : 1;                            // 0x0675(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCancelToolWhenPlaced : 1;                         // 0x0675(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCancelAbilityOnUnequip : 1;                       // 0x0675(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bRequiresPlayerPlaceableAttachmentActors : 1;      // 0x0675(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUseRelativeCameraRotation : 1;                    // 0x0675(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAllowStairsWhenAttachingToFloors : 1;             // 0x0675(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bSnapYawToHorizontalAxes : 1;                      // 0x0675(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAllowAnyFloorPlacement : 1;                       // 0x0676(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bRequiresPermissionToEditWorld : 1;                // 0x0676(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_677[0x1];                                      // 0x0677(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UBuildingEditModeMetadata>> AllowedShapes;                                     // 0x0678(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	int32                                         MaxPlacementDistance;                              // 0x0688(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_68C[0x4];                                      // 0x068C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TSubclassOf<class ABuildingActor> GetBlueprintClass() const;
	float GetGridSnapSizeOverride() const;
	int32 GetMaxPlacementDistance() const;
	TSubclassOf<class AFortDecoPreview> GetPlacementPreviewClass() const;
	EPlacementType GetPlacementTypeOverride() const;
	float GetRotationAngleIncrement() const;
	bool RequiresPermissionToEditWorld() const;
	bool RequiresPlayerPlaceableAttachmentActors() const;
	bool ShouldAllowAnyFloorPlacement() const;
	bool ShouldAllowPlacementOnBuildings() const;
	bool ShouldAllowPlacementOnWorldGeometry() const;
	bool ShouldAllowStairsWhenAttachingToFloors() const;
	bool ShouldAttachWhenPlacing() const;
	bool ShouldCancelAbilityOnUnequip() const;
	bool ShouldCancelToolWhenPlaced() const;
	bool ShouldConsumeWhenPlaced() const;
	bool ShouldDestroySmallObjectsWhenPlaced() const;
	bool ShouldDisableLocationLerpWhilePlacing() const;
	bool ShouldDisableRotationLerpWhilePlacing() const;
	bool ShouldDisableScaleLerpWhilePlacing() const;
	bool ShouldForceIgnoreBuildingOverlaps() const;
	bool ShouldForceIgnoreOverlapTest() const;
	bool ShouldSnapYawToHorizontalAxes() const;
	bool ShouldUseRelativeCameraRotation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDecoItemDefinition">();
	}
	static class UFortDecoItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDecoItemDefinition>();
	}
};
static_assert(alignof(UFortDecoItemDefinition) == 0x000010, "Wrong alignment on UFortDecoItemDefinition");
static_assert(sizeof(UFortDecoItemDefinition) == 0x000690, "Wrong size on UFortDecoItemDefinition");
static_assert(offsetof(UFortDecoItemDefinition, BlueprintClass) == 0x000628, "Member 'UFortDecoItemDefinition::BlueprintClass' has a wrong offset!");
static_assert(offsetof(UFortDecoItemDefinition, PlacementPreviewClass) == 0x000648, "Member 'UFortDecoItemDefinition::PlacementPreviewClass' has a wrong offset!");
static_assert(offsetof(UFortDecoItemDefinition, GridSnapSizeOverride) == 0x000668, "Member 'UFortDecoItemDefinition::GridSnapSizeOverride' has a wrong offset!");
static_assert(offsetof(UFortDecoItemDefinition, RotationAngleIncrement) == 0x00066C, "Member 'UFortDecoItemDefinition::RotationAngleIncrement' has a wrong offset!");
static_assert(offsetof(UFortDecoItemDefinition, PlacementTypeOverride) == 0x000670, "Member 'UFortDecoItemDefinition::PlacementTypeOverride' has a wrong offset!");
static_assert(offsetof(UFortDecoItemDefinition, AllowedShapes) == 0x000678, "Member 'UFortDecoItemDefinition::AllowedShapes' has a wrong offset!");
static_assert(offsetof(UFortDecoItemDefinition, MaxPlacementDistance) == 0x000688, "Member 'UFortDecoItemDefinition::MaxPlacementDistance' has a wrong offset!");

// Class FortniteGame.FortFOBCoreDecoItemDefinition
// 0x0040 (0x06D0 - 0x0690)
class UFortFOBCoreDecoItemDefinition final : public UFortDecoItemDefinition
{
public:
	class FText                                   ExtendedDescription;                               // 0x0690(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   FlavorText;                                        // 0x06A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGuid                                  SaveFilenameGUID;                                  // 0x06C0(0x0010)(Edit, EditConst, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	int32 GetMaximumHealth() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortFOBCoreDecoItemDefinition">();
	}
	static class UFortFOBCoreDecoItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortFOBCoreDecoItemDefinition>();
	}
};
static_assert(alignof(UFortFOBCoreDecoItemDefinition) == 0x000010, "Wrong alignment on UFortFOBCoreDecoItemDefinition");
static_assert(sizeof(UFortFOBCoreDecoItemDefinition) == 0x0006D0, "Wrong size on UFortFOBCoreDecoItemDefinition");
static_assert(offsetof(UFortFOBCoreDecoItemDefinition, ExtendedDescription) == 0x000690, "Member 'UFortFOBCoreDecoItemDefinition::ExtendedDescription' has a wrong offset!");
static_assert(offsetof(UFortFOBCoreDecoItemDefinition, FlavorText) == 0x0006A8, "Member 'UFortFOBCoreDecoItemDefinition::FlavorText' has a wrong offset!");
static_assert(offsetof(UFortFOBCoreDecoItemDefinition, SaveFilenameGUID) == 0x0006C0, "Member 'UFortFOBCoreDecoItemDefinition::SaveFilenameGUID' has a wrong offset!");

// Class FortniteGame.FortTrapItemDefinition
// 0x0010 (0x06A0 - 0x0690)
class UFortTrapItemDefinition final : public UFortDecoItemDefinition
{
public:
	struct FRotator                               KnockbackDirOverride;                              // 0x0690(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bKnockBackUsingPawnDir;                            // 0x069C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69D[0x3];                                      // 0x069D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTrapItemDefinition">();
	}
	static class UFortTrapItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortTrapItemDefinition>();
	}
};
static_assert(alignof(UFortTrapItemDefinition) == 0x000010, "Wrong alignment on UFortTrapItemDefinition");
static_assert(sizeof(UFortTrapItemDefinition) == 0x0006A0, "Wrong size on UFortTrapItemDefinition");
static_assert(offsetof(UFortTrapItemDefinition, KnockbackDirOverride) == 0x000690, "Member 'UFortTrapItemDefinition::KnockbackDirOverride' has a wrong offset!");
static_assert(offsetof(UFortTrapItemDefinition, bKnockBackUsingPawnDir) == 0x00069C, "Member 'UFortTrapItemDefinition::bKnockBackUsingPawnDir' has a wrong offset!");

// Class FortniteGame.FortWeaponMeleeItemDefinition
// 0x0000 (0x0630 - 0x0630)
class UFortWeaponMeleeItemDefinition final : public UFortWeaponItemDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortWeaponMeleeItemDefinition">();
	}
	static class UFortWeaponMeleeItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortWeaponMeleeItemDefinition>();
	}
};
static_assert(alignof(UFortWeaponMeleeItemDefinition) == 0x000010, "Wrong alignment on UFortWeaponMeleeItemDefinition");
static_assert(sizeof(UFortWeaponMeleeItemDefinition) == 0x000630, "Wrong size on UFortWeaponMeleeItemDefinition");

// Class FortniteGame.FortWeaponRangedItemDefinition
// 0x0050 (0x0680 - 0x0630)
class UFortWeaponRangedItemDefinition final : public UFortWeaponItemDefinition
{
public:
	TSoftClassPtr<class UClass>                   ProjectileTemplate;                                // 0x0628(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseNativeWeaponTrace;                             // 0x0648(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bTraceThroughPawns;                                // 0x0649(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_64A[0x6];                                      // 0x064A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UParticleSystem>         BulletShellFXTemplate;                             // 0x0650(0x0020)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShouldSpawnBulletShellFX;                         // 0x0670(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShouldUsePerfectAimWhenTargetingMinSpread;        // 0x0671(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_672[0xE];                                      // 0x0672(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UParticleSystem* GetBulletShellFXTemplate() const;
	TSubclassOf<class AFortProjectileBase> GetProjectileTemplate() const;
	bool ShouldSpawnBulletShellFX() const;
	bool ShouldTraceThroughPawns() const;
	bool ShouldUseNativeWeaponTrace() const;
	bool ShouldUsePerfectAimWhenTargetingMinSpread() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortWeaponRangedItemDefinition">();
	}
	static class UFortWeaponRangedItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortWeaponRangedItemDefinition>();
	}
};
static_assert(alignof(UFortWeaponRangedItemDefinition) == 0x000010, "Wrong alignment on UFortWeaponRangedItemDefinition");
static_assert(sizeof(UFortWeaponRangedItemDefinition) == 0x000680, "Wrong size on UFortWeaponRangedItemDefinition");
static_assert(offsetof(UFortWeaponRangedItemDefinition, ProjectileTemplate) == 0x000628, "Member 'UFortWeaponRangedItemDefinition::ProjectileTemplate' has a wrong offset!");
static_assert(offsetof(UFortWeaponRangedItemDefinition, bUseNativeWeaponTrace) == 0x000648, "Member 'UFortWeaponRangedItemDefinition::bUseNativeWeaponTrace' has a wrong offset!");
static_assert(offsetof(UFortWeaponRangedItemDefinition, bTraceThroughPawns) == 0x000649, "Member 'UFortWeaponRangedItemDefinition::bTraceThroughPawns' has a wrong offset!");
static_assert(offsetof(UFortWeaponRangedItemDefinition, BulletShellFXTemplate) == 0x000650, "Member 'UFortWeaponRangedItemDefinition::BulletShellFXTemplate' has a wrong offset!");
static_assert(offsetof(UFortWeaponRangedItemDefinition, bShouldSpawnBulletShellFX) == 0x000670, "Member 'UFortWeaponRangedItemDefinition::bShouldSpawnBulletShellFX' has a wrong offset!");
static_assert(offsetof(UFortWeaponRangedItemDefinition, bShouldUsePerfectAimWhenTargetingMinSpread) == 0x000671, "Member 'UFortWeaponRangedItemDefinition::bShouldUsePerfectAimWhenTargetingMinSpread' has a wrong offset!");

// Class FortniteGame.FortJumpDownLink
// 0x0000 (0x03D8 - 0x03D8)
class AFortJumpDownLink final : public ANavLinkProxy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortJumpDownLink">();
	}
	static class AFortJumpDownLink* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortJumpDownLink>();
	}
};
static_assert(alignof(AFortJumpDownLink) == 0x000008, "Wrong alignment on AFortJumpDownLink");
static_assert(sizeof(AFortJumpDownLink) == 0x0003D8, "Wrong size on AFortJumpDownLink");

// Class FortniteGame.FortKeepEventInfo
// 0x0028 (0x0050 - 0x0028)
class UFortKeepEventInfo final : public UDataAsset
{
public:
	class FText                                   EventDescription;                                  // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FKeepEventWaveData>             Waves;                                             // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	const struct FKeepEventWaveData GetWave(int32 Index_0);
	int32 NumberOfWaves();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortKeepEventInfo">();
	}
	static class UFortKeepEventInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortKeepEventInfo>();
	}
};
static_assert(alignof(UFortKeepEventInfo) == 0x000008, "Wrong alignment on UFortKeepEventInfo");
static_assert(sizeof(UFortKeepEventInfo) == 0x000050, "Wrong size on UFortKeepEventInfo");
static_assert(offsetof(UFortKeepEventInfo, EventDescription) == 0x000028, "Member 'UFortKeepEventInfo::EventDescription' has a wrong offset!");
static_assert(offsetof(UFortKeepEventInfo, Waves) == 0x000040, "Member 'UFortKeepEventInfo::Waves' has a wrong offset!");

// Class FortniteGame.FortKeepEventList
// 0x0010 (0x0038 - 0x0028)
class UFortKeepEventList final : public UDataAsset
{
public:
	TArray<struct FKeepEventInfo>                 Events;                                            // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	struct FKeepEventInfo GetEvent(int32 Idx);
	class FText GetEventDescription(int32 Idx);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortKeepEventList">();
	}
	static class UFortKeepEventList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortKeepEventList>();
	}
};
static_assert(alignof(UFortKeepEventList) == 0x000008, "Wrong alignment on UFortKeepEventList");
static_assert(sizeof(UFortKeepEventList) == 0x000038, "Wrong size on UFortKeepEventList");
static_assert(offsetof(UFortKeepEventList, Events) == 0x000028, "Member 'UFortKeepEventList::Events' has a wrong offset!");

// Class FortniteGame.FortKeepItemManager
// 0x0320 (0x0348 - 0x0028)
class UFortKeepItemManager final : public UObject
{
public:
	uint8                                         Pad_28[0x320];                                     // 0x0028(0x0320)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortKeepItemManager">();
	}
	static class UFortKeepItemManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortKeepItemManager>();
	}
};
static_assert(alignof(UFortKeepItemManager) == 0x000008, "Wrong alignment on UFortKeepItemManager");
static_assert(sizeof(UFortKeepItemManager) == 0x000348, "Wrong size on UFortKeepItemManager");

// Class FortniteGame.FortKismetLibrary
// 0x0000 (0x0028 - 0x0028)
class UFortKismetLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FFortEncounterSettings ApplyEncounterOptionOverridesFromWaveDataToEncounterSettings(const struct FTieredWaveSetData& WaveData, struct FFortEncounterSettings& EncounterSettings);
	static void ApplyGlobalEnvironmentDamageToActor(class AActor* DamageTargetActor, float EnvironmentDamage, const struct FGameplayTagContainer& AdditionalContextTags, TSubclassOf<class UGameplayEffect> EnvironmentDamageGE);
	static struct FActiveGameplayEffectHandle ApplyGlobalEnvironmentGameplayEffectToActor(class AActor* EffectTargetActor, TSubclassOf<class UGameplayEffect> GameplayEffect, int32 GameplayEffectLevel, const struct FGameplayTagContainer& AdditionalContextTags);
	static TArray<class AFortPlayerPawn*> AuthorityGetFortPossessedPlayerPawns(class UObject* WorldContextObject);
	static void BroadcastMessage(class UObject* WorldContextObject, const class FText& MESSAGE);
	static bool BroadcastPlayerImpactAtLocation(class UObject* WorldContextObject, class APlayerController* Player, const struct FVector& Position, float* Loudness, float* Duration, bool bRelativePosition);
	static void BroadcastSound(class UObject* WorldContextObject, class USoundBase* InSound, float VolumeMultiplier, float PitchMultiplier);
	static void BroadcastSoundAtLocation(class UObject* WorldContextObject, class USoundBase* InSound, const struct FVector& Location, float VolumeMultiplier, float PitchMultiplier);
	static void ClearTutorialHighlights(class UObject* WorldContextObject);
	static void ClientRequestSetTimeOfDay(class AFortPlayerController* FortPC, float TimeOfDay);
	static void CloseTalkingHead(class UObject* WorldContextObject);
	static float ConvertToGameTime(class UObject* WorldContextObject, float InRealTime);
	static float ConvertToRealTime(class UObject* WorldContextObject, float InGameTime);
	static class UFortSpline* CreateNewSplineObject(class UObject* Outer_0);
	static void DisableTutorialHighlight(class UObject* WorldContextObject, class FName WidgetName);
	static void EffectContextAddSourceObject(const struct FGameplayEffectContextHandle& EffectContext, class UObject* Src);
	static bool EmptyQuickBarSlot(class UObject* WorldContextObject, EFortQuickBars QuickBarType, int32 SlotIndex);
	static void EnableTutorialHighlight(class UObject* WorldContextObject, class FName WidgetName);
	static void EndWaitForConfirmationDialog(class UObject* WorldContextObject, struct FFortDialogExternalLatentActionHandle& Handle);
	static bool EqualEqual_FFortDialogWaitingForLatentActionHandle(const struct FFortDialogExternalLatentActionHandle& A, const struct FFortDialogExternalLatentActionHandle& B);
	static bool EqualEqual_UniqueNetIdReplUniqueNetIdRepl(const struct FUniqueNetIdRepl& A, const struct FUniqueNetIdRepl& B);
	static struct FFortAbilitySetHandle EquipFortAbilitySet(TScriptInterface<class IAbilitySystemInterface> AbilitySystemInterfaceActor, class UFortAbilitySet* AbilitySet, class UObject* OverrideSourceObject);
	static bool EquipItemToQuickBarSlot(class UObject* WorldContextObject, const class UFortItemDefinition* ItemDefinition, EFortQuickBars QuickBarType, int32 SlotIndex);
	static bool EvaluateCurveTableRow(const struct FCurveTableRowHandle& CurveTableRowHandle, float InXY, float* OutXY, const class FString& ContextString);
	static void ExecuteClientEvent(class UObject* WorldContextObject, const struct FFortClientEventName& EventType, class UObject* EventSource, class UObject* EventFocus);
	static bool FilterSingleTargetActor(class UObject* WorldContextObject, const struct FFortTargetFilter& Filter, const class AActor* RequestingActor, class AActor* TargetActor);
	static bool FilterSingleTargetHitResult(class UObject* WorldContextObject, const struct FFortTargetFilter& Filter, const class AActor* RequestingActor, const struct FHitResult& HitResult);
	static TArray<class AActor*> FilterTargetActorList(class UObject* WorldContextObject, const struct FFortTargetFilter& Filter, const class AActor* RequestingActor, const TArray<class AActor*>& ActorsToFilter, bool* bAtLeastOneActorLeft);
	static TArray<struct FHitResult> FilterTargetHitResultList(class UObject* WorldContextObject, const struct FFortTargetFilter& Filter, const class AActor* RequestingActor, const TArray<struct FHitResult>& HitResultsToFilter, bool* bAtLeastOneActorLeft);
	static EFortTeam GetActorTeam(const class AActor* Actor);
	static class AFortTeamInfo* GetActorTeamInfo(class AActor* Actor);
	static class AFortAIDirector* GetAIDirector(class UObject* WorldContextObject);
	static class AFortAIGoalManager* GetAIGoalManager(const class UObject* WorldContextObject);
	static TArray<class AFortPlayerController*> GetAllFortPlayerControllers(class UObject* WorldContextObject, bool bIncludeNonSpectators, bool bIncludeSpectators);
	static void GetAllFortPlayerPawns(class UObject* WorldContextObject, TArray<class AFortPlayerPawn*>* OutFortPlayerPawns);
	static float GetBroadcasterGrantWindowSecondsRemaining(class UObject* WorldContextObject);
	static float GetBuildingHealthPercentage(const class ABuildingActor* BuildingActor);
	static void GetBuildingStructuralSupportSystem(class UObject* WorldContextObject, class UBuildingStructuralSupportSystem** BuildingStructuralSupportSystem);
	static float GetCalculatedGameDifficulty(class UObject* WorldContextObject);
	static class AActor* GetClosestActorFromArray(const class AActor* Actor, const TArray<class AActor*>& ArrayOfActors);
	static class ABuildingSMActor* GetClosestBuildingActorFromArray(const class AActor* Actor, const TArray<class ABuildingSMActor*>& ArrayOfBuildings);
	static class AFortPlayerPawn* GetClosestFortPlayerPawn(class UObject* WorldContextObject, const struct FVector& Position);
	static EFortDayPhase GetCurrentDayPhase(class UObject* WorldContextObject);
	static struct FLinearColor GetDayNightDirectionalLightColor(class UObject* WorldContextObject);
	static struct FVector GetDayNightDirectionalLightVector(class UObject* WorldContextObject);
	static class FString GetDebugStringForUniqueId(const struct FUniqueNetIdRepl& UniqueId);
	static float GetDefaultAbsoluteTimeOfDaySpeed(class UObject* WorldContextObject);
	static struct FRotator GetDirectionActorToActor(class AActor* SourceActor, class AActor* TargetActor);
	static float GetFloatHoursUntilDayPhase(class UObject* WorldContextObject, EFortDayPhase DayPhase);
	static EPhysicalSurface GetFortPhysicalSurface(const struct FHitResult& Hit);
	static TArray<class AFortPlayerPawn*> GetFortPlayerPawns(class UObject* WorldContextObject);
	static float GetGameDifficulty();
	static class UFortAbilityKit* GetGrantedAbilityKit(const struct FFortSpecializationSlot& Slot);
	static float GetHostilityPercentage(class UObject* WorldContextObject);
	static int32 GetHoursUntilDayPhase(class UObject* WorldContextObject, EFortDayPhase DayPhase);
	static class FString GetHumanReadableName(class AActor* Actor);
	static void GetImpulseData(const struct FGameplayEffectContextHandle& EffectContext, struct FVector* ImpulseDirection, float* KnockbackMagnitude, float* KnockbackZAngle);
	static TArray<class AFortPlayerController*> GetLocalFortPlayerControllers(class UObject* WorldContextObject, bool bIncludeNonSpectators, bool bIncludeSpectators);
	static bool GetLocalPlayerHasHeroBackpack(class UObject* WorldContextObject);
	static bool GetLocalPlayerHasHeroHeadAccessories(class UObject* WorldContextObject);
	static int32 GetLootLevel(class UObject* WorldContextObject);
	static void GetMatchmakingDifficultyRangeFromDifficultyInfo(const struct FGameDifficultyInfo& DifficultyInfo, float* OutMinDifficulty, float* OutMaxDifficulty);
	static bool GetMeleeWeaponStatsRow(const struct FDataTableRowHandle& DataTableRowHandle, struct FFortMeleeWeaponStats* OutRow);
	static class UMaterialInstanceDynamic* GetMIDForSkeletalMeshComponent(class USkeletalMeshComponent* SkeletalMeshComponent, int32 ElementIndex);
	static bool GetNumericCVar(const class FString& CVar, float* OutValue);
	static bool GetPawnStatsRow(const struct FDataTableRowHandle& DataTableRowHandle, struct FFortPawnStats* OutRow);
	static class UFortRegisteredPlayerInfo* GetPlayerInfoFromUniqueID(class UObject* WorldContextObject, const struct FUniqueNetIdRepl& UniqueId);
	static EFortDayPhase GetPreviousDayPhase(class UObject* WorldContextObject);
	static class UGameplayAbility* GetPrimaryInstance(const struct FGameplayAbilitySpec& Spec);
	static class FText GetRandomLiveStreamingViewerName(class UObject* WorldContextObject, bool bRemoveFromList);
	static class FText GetRandomSurvivorName(class UObject* WorldContextObject, EFortDisplayGender Gender, bool bRemoveFromList);
	static bool GetRangedWeaponStatsRow(const struct FDataTableRowHandle& DataTableRowHandle, struct FFortRangedWeaponStats* OutRow);
	static class UFortAbilityKit* GetRemovedAbilityKit(const struct FFortSpecializationSlot& Slot);
	static bool GetShowHeroBackpackForLocalPlayer(class UObject* WorldContextObject);
	static bool GetShowHeroHeadAccessoriesForLocalPlayer(class UObject* WorldContextObject);
	static float GetStunTime(const struct FGameplayEffectContextHandle& EffectContext);
	static EFortTeamAffiliation GetTeamAffiliation(const class AActor* ActorA, const class AActor* ActorB);
	static EFortTeamAffiliation GetTeamAffiliationBetweenTeams(EFortTeam TeamA, EFortTeam TeamB);
	static class AFortTeamInfo* GetTeamInfo(class UObject* WorldContextObject, EFortTeam Team);
	static class AFortThreatVisualsManager* GetThreatVisualsManager(class UObject* WorldContextObject);
	static float GetTimeDayPhaseBegins(class UObject* WorldContextObject, EFortDayPhase DayPhase);
	static float GetTimeOfDay(class UObject* WorldContextObject);
	static float GetTimeOfDayAccumulator(class UObject* WorldContextObject);
	static float GetTimeOfDaySpeed(class UObject* WorldContextObject);
	static float GetTimeUntilInRealTimeSeconds(class UObject* WorldContextObject, float GameTime);
	static bool GetTooltipDescription(class UObject* WorldContextObject, const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, TArray<class FText>* Description);
	static bool GetTooltipDescriptionFromTooltipClass(class UObject* WorldContextObject, const class UObject* ObjectToDescribe, TSubclassOf<class UFortTooltip> TooltipClass, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, TArray<class FText>* Description);
	static bool GetTooltipNumericValue(class UObject* WorldContextObject, const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, float* Value);
	static bool GetTooltipNumericValueFromTooltipClass(class UObject* WorldContextObject, const class UObject* ObjectToDescribe, TSubclassOf<class UFortTooltip> TooltipClass, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, float* Value);
	static bool GetTooltipTextFromToken(class UObject* WorldContextObject, const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, class FText* OutText);
	static bool GetTooltipTextFromTokenFromTooltipClass(class UObject* WorldContextObject, const class UObject* ObjectToDescribe, TSubclassOf<class UFortTooltip> TooltipClass, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, class FText* OutText);
	static bool GetTrapStatsRow(const struct FDataTableRowHandle& DataTableRowHandle, struct FFortTrapStats* OutRow);
	static bool GetWeaponDurabilityByRarityStatsRow(const struct FDataTableRowHandle& DataTableRowHandle, struct FFortWeaponDurabilityByRarityStats* OutRow);
	static bool GetWeaponStatsRow(const struct FDataTableRowHandle& DataTableRowHandle, struct FFortBaseWeaponStats* OutRow);
	static void GiveItemToInventoryOwner(TScriptInterface<class IFortInventoryOwnerInterface> InventoryOwner, const class UFortWorldItemDefinition* ItemDefinition, int32 NumberToGive, bool bNotifyPlayer);
	static bool HasMultipleVisibleRewards(const struct FFortRewardInfo& RewardInfo);
	static bool HasOpenBroadcasterGrantWindow(class UObject* WorldContextObject);
	static bool HasRewards(const struct FFortRewardInfo& RewardInfo);
	static bool HasSelectableRewards(const struct FFortRewardInfo& RewardInfo);
	static void HideTutorialWidget(class UObject* WorldContextObject, class FName WidgetName);
	static void InvalidateLatentActionHandle(struct FFortDialogExternalLatentActionHandle& Handle);
	static bool IsAssetNull(TSoftObjectPtr<class UObject> Asset);
	static bool IsCriticalHit(const struct FGameplayEffectContextHandle& EffectContext);
	static bool IsFatalHit(const struct FGameplayEffectContextHandle& EffectContext);
	static bool IsFullBodyHit(const struct FGameplayEffectContextHandle& EffectContext);
	static bool IsLatentActionHandleValid(const struct FFortDialogExternalLatentActionHandle& Handle);
	static bool IsLinkingStreamedAccountsEnabled();
	static bool IsValid(const struct FAttributeInfo& AttributeInfo);
	static bool IsValid_UniqueNetIdRepl(const struct FUniqueNetIdRepl& InUniqueNetIdRepl);
	static TArray<class UObject*> JonLHack_GetAllObjectsOfClassFromPath(const class FString& Path, class UClass* Class_0);
	static struct FVector K2_GetClosestAxisXY(const struct FVector& InVector);
	static int32 K2_GetItemQuantityOnPlayer(class AFortPlayerController* PlayerController, class UFortItemDefinition* ItemDefinition);
	static void K2_GiveItemToAllPlayers(class UObject* WorldContextObject, class UFortWorldItemDefinition* ItemDefinition, int32 NumberToGive, bool bNotifyPlayer);
	static void K2_GiveItemToPlayer(class AFortPlayerController* PlayerController, const class UFortWorldItemDefinition* ItemDefinition, int32 NumberToGive, bool bNotifyPlayer);
	static void K2_RemoveItemFromAllPlayers(class UObject* WorldContextObject, class UFortWorldItemDefinition* ItemDefinition, int32 AmountToRemove);
	static int32 K2_RemoveItemFromPlayer(class AFortPlayerController* PlayerController, class UFortWorldItemDefinition* ItemDefinition, int32 AmountToRemove);
	static class AFortPickup* K2_SpawnPickupInWorld(class UObject* WorldContextObject, class UFortWorldItemDefinition* ItemDefinition, int32 NumberToSpawn, const struct FVector& Position, const struct FVector& Direction, int32 OverrideMaxStackCount);
	static void MakeAllPlayersTalkToSelf(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class USoundBase* Audio, float Delay, bool bInterruptCurrentLine, bool bCanBeInterrupted, bool bCanCue, EFortFeedbackBroadcastFilter BroadcastFilter, bool bLatent);
	static EFortBuildingState MakeBuildingState(EFortBuildingState Value);
	static EFortDayPhase MakeDayNightPhase(EFortDayPhase Value);
	static struct FFortGameplayEffectContainerSpec MakeGameplayEffectContainerSpecFromAbility(const struct FFortGameplayEffectContainer& EffectContainer, class UGameplayAbility* Ability, int32 GameplayEffectLevel);
	static struct FFortGameplayEffectContainerSpec MakeGameplayEffectContainerSpecFromAbilityComponent(const struct FFortGameplayEffectContainer& EffectContainer, class UAbilitySystemComponent* AbilityComp, int32 GameplayEffectLevel);
	static EFortMovementStyle MakeMovementStyle(EFortMovementStyle Value);
	static EFortResourceType MakeResourceType(EFortResourceType Value);
	static EFortWeaponCoreAnimation MakeWeaponCoreAnimation(EFortWeaponCoreAnimation Value);
	static bool NotEqual_FFortDialogWaitingForLatentActionHandle(const struct FFortDialogExternalLatentActionHandle& A, const struct FFortDialogExternalLatentActionHandle& B);
	static bool NotEqual_UniqueNetIdReplUniqueNetIdRepl(const struct FUniqueNetIdRepl& A, const struct FUniqueNetIdRepl& B);
	static bool OnSameTeam(const class AActor* ActorA, const class AActor* ActorB);
	static void OpenTalkingHead(class UObject* WorldContextObject, class UTexture2D* Image, const class FText& Title, const class FText& SpeechText, EFortAnnouncementDisplayPreference DisplayPreference);
	static bool PickLootDrops(TArray<struct FFortItemEntry>* OutLootToDrop, const class FName TierGroupName, const int32 WorldLevel, const int32 ForcedLootTier);
	static void PlayLocalForceFeedbackAtLocation(class UObject* WorldContextObject, class UForceFeedbackEffect* ForceFeedbackEffect, const struct FVector& Location, float Radius, class FName Tag);
	static void PlayLocalForceFeedbackAtLocationMulti(class UObject* WorldContextObject, class UForceFeedbackEffect* NearForceFeedbackEffect, class UForceFeedbackEffect* FarForceFeedbackEffect, const struct FVector& Location, float InnerRadius, float OuterRadius, class FName Tag);
	static struct FVector PushOffHitLocation(class AActor* RequestedBy, const struct FHitResult& Hit, float Distance);
	static struct FTransform PushOffTransformByHitLocation(class AActor* RequestedBy, const struct FTransform& InTransform, const struct FHitResult& Hit, float Distance);
	static void RegisterDayPhaseHitCallback(class UObject* Object, const class FString& FunctionName, EFortDayPhase Phase, bool bRecurring, bool bBlockTriggeringThisCycle);
	static void RegisterDayTimeHitCallback(class UObject* Object, const class FString& FunctionName, float TimeInHours, bool bRecurring, bool bBlockTriggeringThisCycle);
	static void RemoveActorsOfClassFromBuildingSMActorArray(const TArray<class ABuildingSMActor*>& ArrayToRemoveClassFrom, TSubclassOf<class ABuildingSMActor> ClassToRemove, TArray<class ABuildingSMActor*>* ArrayWithClassRemoved);
	static class UMaterialInstance* SelectMaterialInstance(class UMaterialInstance* A, class UMaterialInstance* B, bool bSelectA);
	static void SetCanBeDamaged(class AActor* Actor, bool bCanBeDamaged);
	static void SetTimeOfDay(class UObject* WorldContextObject, float TimeOfDay);
	static void SetTimeOfDaySpeed(class UObject* WorldContextObject, float TimeOfDaySpeedFactor);
	static bool ShouldHideTutorialWidget(class FName WidgetName);
	static class AFortAreaOfEffectCloud* SpawnAreaOfEffectCloud(TSubclassOf<class AFortAreaOfEffectCloud> AreaOfEffectClass, class AActor* RequestedBy, const struct FVector& SpawnLocation, const struct FRotator& SpawnRotation, const struct FFortGameplayEffectContainerSpec& EffectContainerSpecToApplyOnHit, const struct FFortGameplayEffectContainerSpec& EffectContainerSpecToApplyOnExplode);
	static class ABuildingGameplayActor* SpawnBuildingGameplayActor(TSubclassOf<class ABuildingGameplayActor> BGAClass, const struct FTransform& Transform, class AFortPawn* Instigator);
	static class AFortProjectileBase* SpawnProjectile(TSubclassOf<class AFortProjectileBase> ProjectileClass, class AActor* RequestedBy, const struct FVector& SpawnLocation, const struct FRotator& SpawnRotation, const struct FRotator& SpawnDirection, const struct FFortGameplayEffectContainerSpec& EffectContainerSpecToApplyOnHit, const struct FFortGameplayEffectContainerSpec& EffectContainerSpecToApplyOnExplode, bool bUseDefaultPhysics, class AActor* HomingTarget, float InitialSpeed, float GravityScale, float ChargePercent);
	static class AFortTracerBase* SpawnTracerFromPool(class UObject* WorldContextObject, TSubclassOf<class AFortTracerBase> TracerClass, const struct FVector& Origin, const struct FVector& Destination, class AFortPawn* Instigator);
	static bool SwitchHeroType(class AFortPlayerController* FortPC, const class FString& NewHeroName);
	static void TriggerFeedbackEvent(class UObject* WorldContextObject, const struct FFortFeedbackHandle& EventHandle, class AFortPawn* InstigatorPawn, class AFortPawn* Recipient, float OverriddenDelay, bool bOverriddenQueuing, bool bAllowReplication);
	static void UnequipFortAbilitySet(struct FFortAbilitySetHandle& AbilitySetHandle);
	static void UnhideAllTutorialWidgets(class UObject* WorldContextObject);
	static void UnhideTutorialWidget(class UObject* WorldContextObject, class FName WidgetName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortKismetLibrary">();
	}
	static class UFortKismetLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortKismetLibrary>();
	}
};
static_assert(alignof(UFortKismetLibrary) == 0x000008, "Wrong alignment on UFortKismetLibrary");
static_assert(sizeof(UFortKismetLibrary) == 0x000028, "Wrong size on UFortKismetLibrary");

// Class FortniteGame.FortLeaderboardRowProxyInstance
// 0x0038 (0x0060 - 0x0028)
class UFortLeaderboardRowProxyInstance final : public UObject
{
public:
	struct FLeaderboardRowData                    RowData;                                           // 0x0028(0x0038)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortLeaderboardRowProxyInstance">();
	}
	static class UFortLeaderboardRowProxyInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortLeaderboardRowProxyInstance>();
	}
};
static_assert(alignof(UFortLeaderboardRowProxyInstance) == 0x000008, "Wrong alignment on UFortLeaderboardRowProxyInstance");
static_assert(sizeof(UFortLeaderboardRowProxyInstance) == 0x000060, "Wrong size on UFortLeaderboardRowProxyInstance");
static_assert(offsetof(UFortLeaderboardRowProxyInstance, RowData) == 0x000028, "Member 'UFortLeaderboardRowProxyInstance::RowData' has a wrong offset!");

// Class FortniteGame.FortLevelScriptActor
// 0x0010 (0x03A0 - 0x0390)
class AFortLevelScriptActor : public ALevelScriptActor
{
public:
	uint8                                         Pad_390[0x8];                                      // 0x0390(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bWorldReadyCalled : 1;                             // 0x0398(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_399[0x7];                                      // 0x0399(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMatchStarted();
	void OnWorldReady();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortLevelScriptActor">();
	}
	static class AFortLevelScriptActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortLevelScriptActor>();
	}
};
static_assert(alignof(AFortLevelScriptActor) == 0x000008, "Wrong alignment on AFortLevelScriptActor");
static_assert(sizeof(AFortLevelScriptActor) == 0x0003A0, "Wrong size on AFortLevelScriptActor");

// Class FortniteGame.FortLinkedAccount
// 0x0008 (0x0030 - 0x0028)
class UFortLinkedAccount : public UObject
{
public:
	class UFortLinkedAccountManager*              Manager;                                           // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortLinkedAccount">();
	}
	static class UFortLinkedAccount* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortLinkedAccount>();
	}
};
static_assert(alignof(UFortLinkedAccount) == 0x000008, "Wrong alignment on UFortLinkedAccount");
static_assert(sizeof(UFortLinkedAccount) == 0x000030, "Wrong size on UFortLinkedAccount");
static_assert(offsetof(UFortLinkedAccount, Manager) == 0x000028, "Member 'UFortLinkedAccount::Manager' has a wrong offset!");

// Class FortniteGame.FortMcpResource
// 0x0018 (0x0040 - 0x0028)
class UFortMcpResource : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMcpResource">();
	}
	static class UFortMcpResource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMcpResource>();
	}
};
static_assert(alignof(UFortMcpResource) == 0x000008, "Wrong alignment on UFortMcpResource");
static_assert(sizeof(UFortMcpResource) == 0x000040, "Wrong size on UFortMcpResource");

// Class FortniteGame.FortMcpTwitch
// 0x0000 (0x0040 - 0x0040)
class UFortMcpTwitch final : public UFortMcpResource
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMcpTwitch">();
	}
	static class UFortMcpTwitch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMcpTwitch>();
	}
};
static_assert(alignof(UFortMcpTwitch) == 0x000008, "Wrong alignment on UFortMcpTwitch");
static_assert(sizeof(UFortMcpTwitch) == 0x000040, "Wrong size on UFortMcpTwitch");

// Class FortniteGame.FortQueryGenerator_AssignmentGoal
// 0x0000 (0x0050 - 0x0050)
class UFortQueryGenerator_AssignmentGoal final : public UEnvQueryGenerator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_AssignmentGoal">();
	}
	static class UFortQueryGenerator_AssignmentGoal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_AssignmentGoal>();
	}
};
static_assert(alignof(UFortQueryGenerator_AssignmentGoal) == 0x000008, "Wrong alignment on UFortQueryGenerator_AssignmentGoal");
static_assert(sizeof(UFortQueryGenerator_AssignmentGoal) == 0x000050, "Wrong size on UFortQueryGenerator_AssignmentGoal");

// Class FortniteGame.HeartbeatManager
// 0x0040 (0x0068 - 0x0028)
class UHeartbeatManager final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShouldTrackLocation;                              // 0x0040(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TrackLocationFrequencySec;                         // 0x0044(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShouldSendPerMinuteResourceAndDamageEvents;       // 0x0048(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_49[0x1F];                                      // 0x0049(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HeartbeatManager">();
	}
	static class UHeartbeatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHeartbeatManager>();
	}
};
static_assert(alignof(UHeartbeatManager) == 0x000008, "Wrong alignment on UHeartbeatManager");
static_assert(sizeof(UHeartbeatManager) == 0x000068, "Wrong size on UHeartbeatManager");
static_assert(offsetof(UHeartbeatManager, bShouldTrackLocation) == 0x000040, "Member 'UHeartbeatManager::bShouldTrackLocation' has a wrong offset!");
static_assert(offsetof(UHeartbeatManager, TrackLocationFrequencySec) == 0x000044, "Member 'UHeartbeatManager::TrackLocationFrequencySec' has a wrong offset!");
static_assert(offsetof(UHeartbeatManager, bShouldSendPerMinuteResourceAndDamageEvents) == 0x000048, "Member 'UHeartbeatManager::bShouldSendPerMinuteResourceAndDamageEvents' has a wrong offset!");

// Class FortniteGame.FortTwitchAccount
// 0x02D0 (0x0300 - 0x0030)
class UFortTwitchAccount final : public UFortLinkedAccount
{
public:
	uint8                                         Pad_30[0x2D0];                                     // 0x0030(0x02D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleQuestsUpdated();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTwitchAccount">();
	}
	static class UFortTwitchAccount* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortTwitchAccount>();
	}
};
static_assert(alignof(UFortTwitchAccount) == 0x000008, "Wrong alignment on UFortTwitchAccount");
static_assert(sizeof(UFortTwitchAccount) == 0x000300, "Wrong size on UFortTwitchAccount");

// Class FortniteGame.FortLobbyBeaconClientPvE
// 0x0000 (0x05E0 - 0x05E0)
class AFortLobbyBeaconClientPvE final : public AFortLobbyBeaconClient
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortLobbyBeaconClientPvE">();
	}
	static class AFortLobbyBeaconClientPvE* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortLobbyBeaconClientPvE>();
	}
};
static_assert(alignof(AFortLobbyBeaconClientPvE) == 0x000008, "Wrong alignment on AFortLobbyBeaconClientPvE");
static_assert(sizeof(AFortLobbyBeaconClientPvE) == 0x0005E0, "Wrong size on AFortLobbyBeaconClientPvE");

// Class FortniteGame.FortQueryGenerator_InfluenceMapPoints
// 0x0040 (0x00C0 - 0x0080)
class UFortQueryGenerator_InfluenceMapPoints final : public UEnvQueryGenerator_ProjectedPoints
{
public:
	struct FAIDataProviderIntValue                Density;                                           // 0x0080(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bOnlyFlatSurface : 1;                              // 0x00B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UEnvQueryContext>           GenerateAround;                                    // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_InfluenceMapPoints">();
	}
	static class UFortQueryGenerator_InfluenceMapPoints* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_InfluenceMapPoints>();
	}
};
static_assert(alignof(UFortQueryGenerator_InfluenceMapPoints) == 0x000008, "Wrong alignment on UFortQueryGenerator_InfluenceMapPoints");
static_assert(sizeof(UFortQueryGenerator_InfluenceMapPoints) == 0x0000C0, "Wrong size on UFortQueryGenerator_InfluenceMapPoints");
static_assert(offsetof(UFortQueryGenerator_InfluenceMapPoints, Density) == 0x000080, "Member 'UFortQueryGenerator_InfluenceMapPoints::Density' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_InfluenceMapPoints, GenerateAround) == 0x0000B8, "Member 'UFortQueryGenerator_InfluenceMapPoints::GenerateAround' has a wrong offset!");

// Class FortniteGame.NavGraphDebugActor
// 0x0000 (0x0388 - 0x0388)
class ANavGraphDebugActor final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavGraphDebugActor">();
	}
	static class ANavGraphDebugActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANavGraphDebugActor>();
	}
};
static_assert(alignof(ANavGraphDebugActor) == 0x000008, "Wrong alignment on ANavGraphDebugActor");
static_assert(sizeof(ANavGraphDebugActor) == 0x000388, "Wrong size on ANavGraphDebugActor");

// Class FortniteGame.FortLobbyBeaconClientPvP
// 0x0070 (0x0650 - 0x05E0)
class AFortLobbyBeaconClientPvP final : public AFortLobbyBeaconClient
{
public:
	uint8                                         Pad_5E0[0x70];                                     // 0x05E0(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ServerReadyUp();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortLobbyBeaconClientPvP">();
	}
	static class AFortLobbyBeaconClientPvP* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortLobbyBeaconClientPvP>();
	}
};
static_assert(alignof(AFortLobbyBeaconClientPvP) == 0x000008, "Wrong alignment on AFortLobbyBeaconClientPvP");
static_assert(sizeof(AFortLobbyBeaconClientPvP) == 0x000650, "Wrong size on AFortLobbyBeaconClientPvP");

// Class FortniteGame.FortLobbyBeaconHostPvP
// 0x0000 (0x03F8 - 0x03F8)
class AFortLobbyBeaconHostPvP final : public AFortLobbyBeaconHost
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortLobbyBeaconHostPvP">();
	}
	static class AFortLobbyBeaconHostPvP* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortLobbyBeaconHostPvP>();
	}
};
static_assert(alignof(AFortLobbyBeaconHostPvP) == 0x000008, "Wrong alignment on AFortLobbyBeaconHostPvP");
static_assert(sizeof(AFortLobbyBeaconHostPvP) == 0x0003F8, "Wrong size on AFortLobbyBeaconHostPvP");

// Class FortniteGame.FortLobbyBeaconHostRM
// 0x0000 (0x03F8 - 0x03F8)
class AFortLobbyBeaconHostRM final : public AFortLobbyBeaconHost
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortLobbyBeaconHostRM">();
	}
	static class AFortLobbyBeaconHostRM* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortLobbyBeaconHostRM>();
	}
};
static_assert(alignof(AFortLobbyBeaconHostRM) == 0x000008, "Wrong alignment on AFortLobbyBeaconHostRM");
static_assert(sizeof(AFortLobbyBeaconHostRM) == 0x0003F8, "Wrong size on AFortLobbyBeaconHostRM");

// Class FortniteGame.FortAbilitySetTooltip
// 0x0000 (0x0090 - 0x0090)
class UFortAbilitySetTooltip final : public UFortTooltip
{
public:
	bool GetTextForToken(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, class FText* OutText) const;
	bool GetTokenizedDescriptionText(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, TArray<class FText>* OutDescription) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAbilitySetTooltip">();
	}
	static class UFortAbilitySetTooltip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAbilitySetTooltip>();
	}
};
static_assert(alignof(UFortAbilitySetTooltip) == 0x000008, "Wrong alignment on UFortAbilitySetTooltip");
static_assert(sizeof(UFortAbilitySetTooltip) == 0x000090, "Wrong size on UFortAbilitySetTooltip");

// Class FortniteGame.FortLobbyBeaconPlayerStatePvE
// 0x0000 (0x0690 - 0x0690)
class AFortLobbyBeaconPlayerStatePvE final : public AFortLobbyBeaconPlayerState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortLobbyBeaconPlayerStatePvE">();
	}
	static class AFortLobbyBeaconPlayerStatePvE* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortLobbyBeaconPlayerStatePvE>();
	}
};
static_assert(alignof(AFortLobbyBeaconPlayerStatePvE) == 0x000008, "Wrong alignment on AFortLobbyBeaconPlayerStatePvE");
static_assert(sizeof(AFortLobbyBeaconPlayerStatePvE) == 0x000690, "Wrong size on AFortLobbyBeaconPlayerStatePvE");

// Class FortniteGame.FortLobbyBeaconPlayerStatePvP
// 0x0010 (0x06A0 - 0x0690)
class AFortLobbyBeaconPlayerStatePvP final : public AFortLobbyBeaconPlayerState
{
public:
	uint8                                         bReadiedUp : 1;                                    // 0x0690(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_691[0xF];                                      // 0x0691(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_bReadiedUp();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortLobbyBeaconPlayerStatePvP">();
	}
	static class AFortLobbyBeaconPlayerStatePvP* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortLobbyBeaconPlayerStatePvP>();
	}
};
static_assert(alignof(AFortLobbyBeaconPlayerStatePvP) == 0x000008, "Wrong alignment on AFortLobbyBeaconPlayerStatePvP");
static_assert(sizeof(AFortLobbyBeaconPlayerStatePvP) == 0x0006A0, "Wrong size on AFortLobbyBeaconPlayerStatePvP");

// Class FortniteGame.FortLobbyBeaconPlayerStateRM
// 0x0010 (0x06A0 - 0x0690)
class AFortLobbyBeaconPlayerStateRM final : public AFortLobbyBeaconPlayerState
{
public:
	uint8                                         Pad_690[0x10];                                     // 0x0690(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortLobbyBeaconPlayerStateRM">();
	}
	static class AFortLobbyBeaconPlayerStateRM* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortLobbyBeaconPlayerStateRM>();
	}
};
static_assert(alignof(AFortLobbyBeaconPlayerStateRM) == 0x000008, "Wrong alignment on AFortLobbyBeaconPlayerStateRM");
static_assert(sizeof(AFortLobbyBeaconPlayerStateRM) == 0x0006A0, "Wrong size on AFortLobbyBeaconPlayerStateRM");

// Class FortniteGame.FortLobbyBeaconStatePvE
// 0x0000 (0x06D0 - 0x06D0)
class AFortLobbyBeaconStatePvE : public AFortLobbyBeaconState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortLobbyBeaconStatePvE">();
	}
	static class AFortLobbyBeaconStatePvE* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortLobbyBeaconStatePvE>();
	}
};
static_assert(alignof(AFortLobbyBeaconStatePvE) == 0x000008, "Wrong alignment on AFortLobbyBeaconStatePvE");
static_assert(sizeof(AFortLobbyBeaconStatePvE) == 0x0006D0, "Wrong size on AFortLobbyBeaconStatePvE");

// Class FortniteGame.FortTrapItemDefinitionTooltip
// 0x0000 (0x0090 - 0x0090)
class UFortTrapItemDefinitionTooltip final : public UFortWeaponItemDefinitionTooltip
{
public:
	bool GetNumericValue(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, float* OutVal) const;
	bool GetTextForToken(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, class FText* OutText) const;
	bool GetTokenizedDescriptionText(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, TArray<class FText>* OutDescription) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTrapItemDefinitionTooltip">();
	}
	static class UFortTrapItemDefinitionTooltip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortTrapItemDefinitionTooltip>();
	}
};
static_assert(alignof(UFortTrapItemDefinitionTooltip) == 0x000008, "Wrong alignment on UFortTrapItemDefinitionTooltip");
static_assert(sizeof(UFortTrapItemDefinitionTooltip) == 0x000090, "Wrong size on UFortTrapItemDefinitionTooltip");

// Class FortniteGame.FortLobbyBeaconStateOutpost
// 0x0000 (0x06D0 - 0x06D0)
class AFortLobbyBeaconStateOutpost final : public AFortLobbyBeaconStatePvE
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortLobbyBeaconStateOutpost">();
	}
	static class AFortLobbyBeaconStateOutpost* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortLobbyBeaconStateOutpost>();
	}
};
static_assert(alignof(AFortLobbyBeaconStateOutpost) == 0x000008, "Wrong alignment on AFortLobbyBeaconStateOutpost");
static_assert(sizeof(AFortLobbyBeaconStateOutpost) == 0x0006D0, "Wrong size on AFortLobbyBeaconStateOutpost");

// Class FortniteGame.FortLobbyBeaconStateRM
// 0x0010 (0x06E0 - 0x06D0)
class AFortLobbyBeaconStateRM final : public AFortLobbyBeaconState
{
public:
	uint8                                         Pad_6D0[0x4];                                      // 0x06D0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LobbyTimeRemaining;                                // 0x06D4(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6D8[0x8];                                      // 0x06D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_LobbyTimeRemaining();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortLobbyBeaconStateRM">();
	}
	static class AFortLobbyBeaconStateRM* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortLobbyBeaconStateRM>();
	}
};
static_assert(alignof(AFortLobbyBeaconStateRM) == 0x000008, "Wrong alignment on AFortLobbyBeaconStateRM");
static_assert(sizeof(AFortLobbyBeaconStateRM) == 0x0006E0, "Wrong size on AFortLobbyBeaconStateRM");
static_assert(offsetof(AFortLobbyBeaconStateRM, LobbyTimeRemaining) == 0x0006D4, "Member 'AFortLobbyBeaconStateRM::LobbyTimeRemaining' has a wrong offset!");

// Class FortniteGame.FortLocalPlayer
// 0x03F8 (0x05C0 - 0x01C8)
class UFortLocalPlayer final : public ULocalPlayer
{
public:
	uint8                                         Pad_1C8[0x10];                                     // 0x01C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortOnlineAccount*                     FortOnlineAccount;                                 // 0x01D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UFortOnlineAccount>         OnlineAccountClassOverride;                        // 0x01E0(0x0008)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E8[0x10];                                     // 0x01E8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortRewardReport                      CachedRewardReport;                                // 0x01F8(0x0068)(NativeAccessSpecifierPublic)
	TArray<struct FFortPlayerScoreReport>         CachedScoreReports;                                // 0x0260(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTimespan                              LocalPlayersUtcOffset;                             // 0x0270(0x0008)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortClientSettingsRecord*              ClientSettingsRecord;                              // 0x0278(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_280[0x2];                                      // 0x0280(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bControllerAttached;                               // 0x0282(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_283[0x325];                                    // 0x0283(0x0325)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUniqueNetIdRepl                       PlatformUID;                                       // 0x05A8(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetLocalPlayersUtcOffset(const struct FTimespan& Offset);

	struct FTimespan GetLocalPlayersUtcOffset() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortLocalPlayer">();
	}
	static class UFortLocalPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortLocalPlayer>();
	}
};
static_assert(alignof(UFortLocalPlayer) == 0x000008, "Wrong alignment on UFortLocalPlayer");
static_assert(sizeof(UFortLocalPlayer) == 0x0005C0, "Wrong size on UFortLocalPlayer");
static_assert(offsetof(UFortLocalPlayer, FortOnlineAccount) == 0x0001D8, "Member 'UFortLocalPlayer::FortOnlineAccount' has a wrong offset!");
static_assert(offsetof(UFortLocalPlayer, OnlineAccountClassOverride) == 0x0001E0, "Member 'UFortLocalPlayer::OnlineAccountClassOverride' has a wrong offset!");
static_assert(offsetof(UFortLocalPlayer, CachedRewardReport) == 0x0001F8, "Member 'UFortLocalPlayer::CachedRewardReport' has a wrong offset!");
static_assert(offsetof(UFortLocalPlayer, CachedScoreReports) == 0x000260, "Member 'UFortLocalPlayer::CachedScoreReports' has a wrong offset!");
static_assert(offsetof(UFortLocalPlayer, LocalPlayersUtcOffset) == 0x000270, "Member 'UFortLocalPlayer::LocalPlayersUtcOffset' has a wrong offset!");
static_assert(offsetof(UFortLocalPlayer, ClientSettingsRecord) == 0x000278, "Member 'UFortLocalPlayer::ClientSettingsRecord' has a wrong offset!");
static_assert(offsetof(UFortLocalPlayer, bControllerAttached) == 0x000282, "Member 'UFortLocalPlayer::bControllerAttached' has a wrong offset!");
static_assert(offsetof(UFortLocalPlayer, PlatformUID) == 0x0005A8, "Member 'UFortLocalPlayer::PlatformUID' has a wrong offset!");

// Class FortniteGame.FortLOSComponent
// 0x00B0 (0x01A0 - 0x00F0)
class UFortLOSComponent final : public UActorComponent
{
public:
	float                                         LOSMaxDistance;                                    // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FOVInDegrees;                                      // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeBetweenChecks;                                 // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopAfterHasBeenFound;                            // 0x00FC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDistanceCheckOnly;                                // 0x00FD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FE[0x2];                                       // 0x00FE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnHasBeenFound;                                    // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bHasBeenFound;                                     // 0x0110(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_111[0x8F];                                     // 0x0111(0x008F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortLOSComponent">();
	}
	static class UFortLOSComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortLOSComponent>();
	}
};
static_assert(alignof(UFortLOSComponent) == 0x000008, "Wrong alignment on UFortLOSComponent");
static_assert(sizeof(UFortLOSComponent) == 0x0001A0, "Wrong size on UFortLOSComponent");
static_assert(offsetof(UFortLOSComponent, LOSMaxDistance) == 0x0000F0, "Member 'UFortLOSComponent::LOSMaxDistance' has a wrong offset!");
static_assert(offsetof(UFortLOSComponent, FOVInDegrees) == 0x0000F4, "Member 'UFortLOSComponent::FOVInDegrees' has a wrong offset!");
static_assert(offsetof(UFortLOSComponent, TimeBetweenChecks) == 0x0000F8, "Member 'UFortLOSComponent::TimeBetweenChecks' has a wrong offset!");
static_assert(offsetof(UFortLOSComponent, bStopAfterHasBeenFound) == 0x0000FC, "Member 'UFortLOSComponent::bStopAfterHasBeenFound' has a wrong offset!");
static_assert(offsetof(UFortLOSComponent, bDistanceCheckOnly) == 0x0000FD, "Member 'UFortLOSComponent::bDistanceCheckOnly' has a wrong offset!");
static_assert(offsetof(UFortLOSComponent, OnHasBeenFound) == 0x000100, "Member 'UFortLOSComponent::OnHasBeenFound' has a wrong offset!");
static_assert(offsetof(UFortLOSComponent, bHasBeenFound) == 0x000110, "Member 'UFortLOSComponent::bHasBeenFound' has a wrong offset!");

// Class FortniteGame.FortMatchmaking
// 0x0768 (0x0790 - 0x0028)
class UFortMatchmaking final : public UObject
{
public:
	uint8                                         Pad_28[0x548];                                     // 0x0028(0x0548)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class APartyBeaconClient>         ReservationBeaconClientClass;                      // 0x0570(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFortPartyBeaconClient*                 ReservationBeaconClient;                           // 0x0578(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFortLobbyBeaconClient*                 LobbyBeaconClient;                                 // 0x0580(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_588[0x68];                                     // 0x0588(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ControllerId;                                      // 0x05F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5F4[0x4];                                      // 0x05F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TempZoneInstanceId;                                // 0x05F8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFortCachedMatchmakingSearchParams     CachedMatchmakingSearchParams;                     // 0x0608(0x00A8)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_6B0[0xB8];                                     // 0x06B0(0x00B8)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortMatchmakingPolicy*                 Matchmaking;                                       // 0x0768(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 LastCriticalMissionSessionId;                      // 0x0770(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EFortMatchmakingPrivacyConfiguration          LastMatchmakingPrivacyConfiguration;               // 0x0780(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_781[0xF];                                      // 0x0781(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMatchmaking">();
	}
	static class UFortMatchmaking* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMatchmaking>();
	}
};
static_assert(alignof(UFortMatchmaking) == 0x000008, "Wrong alignment on UFortMatchmaking");
static_assert(sizeof(UFortMatchmaking) == 0x000790, "Wrong size on UFortMatchmaking");
static_assert(offsetof(UFortMatchmaking, ReservationBeaconClientClass) == 0x000570, "Member 'UFortMatchmaking::ReservationBeaconClientClass' has a wrong offset!");
static_assert(offsetof(UFortMatchmaking, ReservationBeaconClient) == 0x000578, "Member 'UFortMatchmaking::ReservationBeaconClient' has a wrong offset!");
static_assert(offsetof(UFortMatchmaking, LobbyBeaconClient) == 0x000580, "Member 'UFortMatchmaking::LobbyBeaconClient' has a wrong offset!");
static_assert(offsetof(UFortMatchmaking, ControllerId) == 0x0005F0, "Member 'UFortMatchmaking::ControllerId' has a wrong offset!");
static_assert(offsetof(UFortMatchmaking, TempZoneInstanceId) == 0x0005F8, "Member 'UFortMatchmaking::TempZoneInstanceId' has a wrong offset!");
static_assert(offsetof(UFortMatchmaking, CachedMatchmakingSearchParams) == 0x000608, "Member 'UFortMatchmaking::CachedMatchmakingSearchParams' has a wrong offset!");
static_assert(offsetof(UFortMatchmaking, Matchmaking) == 0x000768, "Member 'UFortMatchmaking::Matchmaking' has a wrong offset!");
static_assert(offsetof(UFortMatchmaking, LastCriticalMissionSessionId) == 0x000770, "Member 'UFortMatchmaking::LastCriticalMissionSessionId' has a wrong offset!");
static_assert(offsetof(UFortMatchmaking, LastMatchmakingPrivacyConfiguration) == 0x000780, "Member 'UFortMatchmaking::LastMatchmakingPrivacyConfiguration' has a wrong offset!");

// Class FortniteGame.FortMatchmakingContext
// 0x0180 (0x01A8 - 0x0028)
class UFortMatchmakingContext final : public UBlueprintContextBase
{
public:
	UMulticastDelegateProperty_                   OnMatchmakingStarted;                              // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMatchmakingComplete;                             // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMatchmakingStateChange;                          // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnLobbyConnectionAttemptStarted;                   // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnLobbyConnectionAttemptFailed;                    // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnLobbyConnectionAttemptProceedToLobby;            // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnLobbyWaitingForPlayers;                          // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnLobbyWaitingForPlayersTimeUpdate;                // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnLobbyStarted;                                    // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnLobbyDisconnected;                               // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnLobbyConnectingToGame;                           // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnLobbyTimeUpdated;                                // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnLobbyTimeExpired;                                // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnLocalReadyUpStatusChange;                        // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnWorldRecordLoadedChanged;                        // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnRejoinCheckCompleted;                            // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_128[0x4];                                      // 0x0128(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortMatchmakingConfig                 NormalConfig;                                      // 0x012C(0x0010)(Config, NoDestructor, NativeAccessSpecifierPrivate)
	struct FFortMatchmakingConfig                 CriticalConfig;                                    // 0x013C(0x0010)(Config, NoDestructor, NativeAccessSpecifierPrivate)
	struct FFortMatchmakingConfig                 QuickPlayConfig;                                   // 0x014C(0x0010)(Config, NoDestructor, NativeAccessSpecifierPrivate)
	struct FFortMatchmakingConfig                 OnboardingConfig;                                  // 0x015C(0x0010)(Config, NoDestructor, NativeAccessSpecifierPrivate)
	struct FFortMatchmakingConfig                 OutpostConfig;                                     // 0x016C(0x0010)(Config, NoDestructor, NativeAccessSpecifierPrivate)
	struct FFortMatchmakingConfig                 PvPConfig;                                         // 0x017C(0x0010)(Config, NoDestructor, NativeAccessSpecifierPrivate)
	int32                                         MatchmakingRecommendedRatingOffset;                // 0x018C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnOutpostDiscoveryFailure;                         // 0x0190(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A0[0x8];                                      // 0x01A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelMatchmaking();
	void CheckRejoinStatus();
	void DisconnectFromLobby();
	void EnterOutpost();
	void EnterPvPFOB();
	float GetLobbyWaitForPlayersTimeRemaining();
	bool IsJoinableGameAvailable();
	bool IsWorldRecordLoaded();
	void JoinFromLobby();
	bool NeedToCheckRejoinStatus();
	void ReadyUp();
	void StartCriticalMission(float MinMissionDifficulty, float MaxMissionDifficulty);
	void StartMatchmaking();
	bool StartOnboardingMission();
	void StartQuickPlay(float MinMissionDifficulty, float MaxMissionDifficulty);

	class AFortLobbyBeaconClient* GetLobbyBeaconClient() const;
	bool IsConnectedToGame() const;
	bool IsInLobby() const;
	bool IsMatchmakingLocal() const;
	bool IsOutpostPermitted() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMatchmakingContext">();
	}
	static class UFortMatchmakingContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMatchmakingContext>();
	}
};
static_assert(alignof(UFortMatchmakingContext) == 0x000008, "Wrong alignment on UFortMatchmakingContext");
static_assert(sizeof(UFortMatchmakingContext) == 0x0001A8, "Wrong size on UFortMatchmakingContext");
static_assert(offsetof(UFortMatchmakingContext, OnMatchmakingStarted) == 0x000028, "Member 'UFortMatchmakingContext::OnMatchmakingStarted' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingContext, OnMatchmakingComplete) == 0x000038, "Member 'UFortMatchmakingContext::OnMatchmakingComplete' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingContext, OnMatchmakingStateChange) == 0x000048, "Member 'UFortMatchmakingContext::OnMatchmakingStateChange' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingContext, OnLobbyConnectionAttemptStarted) == 0x000058, "Member 'UFortMatchmakingContext::OnLobbyConnectionAttemptStarted' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingContext, OnLobbyConnectionAttemptFailed) == 0x000068, "Member 'UFortMatchmakingContext::OnLobbyConnectionAttemptFailed' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingContext, OnLobbyConnectionAttemptProceedToLobby) == 0x000078, "Member 'UFortMatchmakingContext::OnLobbyConnectionAttemptProceedToLobby' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingContext, OnLobbyWaitingForPlayers) == 0x000088, "Member 'UFortMatchmakingContext::OnLobbyWaitingForPlayers' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingContext, OnLobbyWaitingForPlayersTimeUpdate) == 0x000098, "Member 'UFortMatchmakingContext::OnLobbyWaitingForPlayersTimeUpdate' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingContext, OnLobbyStarted) == 0x0000A8, "Member 'UFortMatchmakingContext::OnLobbyStarted' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingContext, OnLobbyDisconnected) == 0x0000B8, "Member 'UFortMatchmakingContext::OnLobbyDisconnected' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingContext, OnLobbyConnectingToGame) == 0x0000C8, "Member 'UFortMatchmakingContext::OnLobbyConnectingToGame' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingContext, OnLobbyTimeUpdated) == 0x0000D8, "Member 'UFortMatchmakingContext::OnLobbyTimeUpdated' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingContext, OnLobbyTimeExpired) == 0x0000E8, "Member 'UFortMatchmakingContext::OnLobbyTimeExpired' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingContext, OnLocalReadyUpStatusChange) == 0x0000F8, "Member 'UFortMatchmakingContext::OnLocalReadyUpStatusChange' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingContext, OnWorldRecordLoadedChanged) == 0x000108, "Member 'UFortMatchmakingContext::OnWorldRecordLoadedChanged' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingContext, OnRejoinCheckCompleted) == 0x000118, "Member 'UFortMatchmakingContext::OnRejoinCheckCompleted' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingContext, NormalConfig) == 0x00012C, "Member 'UFortMatchmakingContext::NormalConfig' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingContext, CriticalConfig) == 0x00013C, "Member 'UFortMatchmakingContext::CriticalConfig' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingContext, QuickPlayConfig) == 0x00014C, "Member 'UFortMatchmakingContext::QuickPlayConfig' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingContext, OnboardingConfig) == 0x00015C, "Member 'UFortMatchmakingContext::OnboardingConfig' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingContext, OutpostConfig) == 0x00016C, "Member 'UFortMatchmakingContext::OutpostConfig' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingContext, PvPConfig) == 0x00017C, "Member 'UFortMatchmakingContext::PvPConfig' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingContext, MatchmakingRecommendedRatingOffset) == 0x00018C, "Member 'UFortMatchmakingContext::MatchmakingRecommendedRatingOffset' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingContext, OnOutpostDiscoveryFailure) == 0x000190, "Member 'UFortMatchmakingContext::OnOutpostDiscoveryFailure' has a wrong offset!");

// Class FortniteGame.FortMatchmakingPvE
// 0x0000 (0x0190 - 0x0190)
class UFortMatchmakingPvE final : public UFortMatchmakingCommon
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMatchmakingPvE">();
	}
	static class UFortMatchmakingPvE* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMatchmakingPvE>();
	}
};
static_assert(alignof(UFortMatchmakingPvE) == 0x000008, "Wrong alignment on UFortMatchmakingPvE");
static_assert(sizeof(UFortMatchmakingPvE) == 0x000190, "Wrong size on UFortMatchmakingPvE");

// Class FortniteGame.FortMatchmakingGather
// 0x0028 (0x01A0 - 0x0178)
class UFortMatchmakingGather final : public UFortMatchmakingPolicy
{
public:
	float                                         ChanceToJoinInProgress;                            // 0x0178(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_17C[0x24];                                     // 0x017C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMatchmakingGather">();
	}
	static class UFortMatchmakingGather* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMatchmakingGather>();
	}
};
static_assert(alignof(UFortMatchmakingGather) == 0x000008, "Wrong alignment on UFortMatchmakingGather");
static_assert(sizeof(UFortMatchmakingGather) == 0x0001A0, "Wrong size on UFortMatchmakingGather");
static_assert(offsetof(UFortMatchmakingGather, ChanceToJoinInProgress) == 0x000178, "Member 'UFortMatchmakingGather::ChanceToJoinInProgress' has a wrong offset!");

// Class FortniteGame.FortMatchmakingQuickPlay
// 0x0000 (0x0190 - 0x0190)
class UFortMatchmakingQuickPlay final : public UFortMatchmakingMissionCommon
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMatchmakingQuickPlay">();
	}
	static class UFortMatchmakingQuickPlay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMatchmakingQuickPlay>();
	}
};
static_assert(alignof(UFortMatchmakingQuickPlay) == 0x000008, "Wrong alignment on UFortMatchmakingQuickPlay");
static_assert(sizeof(UFortMatchmakingQuickPlay) == 0x000190, "Wrong size on UFortMatchmakingQuickPlay");

// Class FortniteGame.FortPartyBeaconState
// 0x0080 (0x00F0 - 0x0070)
class UFortPartyBeaconState final : public UPartyBeaconState
{
public:
	struct FUniqueNetIdRepl                       GameSessionOwner;                                  // 0x0070(0x0018)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FEmptyServerReservation                ReservationData;                                   // 0x0088(0x0048)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x20];                                      // 0x00D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPartyBeaconState">();
	}
	static class UFortPartyBeaconState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPartyBeaconState>();
	}
};
static_assert(alignof(UFortPartyBeaconState) == 0x000008, "Wrong alignment on UFortPartyBeaconState");
static_assert(sizeof(UFortPartyBeaconState) == 0x0000F0, "Wrong size on UFortPartyBeaconState");
static_assert(offsetof(UFortPartyBeaconState, GameSessionOwner) == 0x000070, "Member 'UFortPartyBeaconState::GameSessionOwner' has a wrong offset!");
static_assert(offsetof(UFortPartyBeaconState, ReservationData) == 0x000088, "Member 'UFortPartyBeaconState::ReservationData' has a wrong offset!");

// Class FortniteGame.FortSessionHelper
// 0x01B8 (0x01E0 - 0x0028)
class UFortSessionHelper final : public UObject
{
public:
	class UClass*                                 BeaconClientClass;                                 // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFortPartyBeaconClient*                 PartyBeaconClient;                                 // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0xD8];                                      // 0x0038(0x00D8)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CurrentSessionName;                                // 0x0110(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPartyReservationResult                       LastBeaconResponse;                                // 0x0118(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EFortSessionHelperJoinState                   CurrentJoinState;                                  // 0x0119(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EFortSessionHelperJoinResult                  CurrentJoinResult;                                 // 0x011A(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11B[0xC5];                                     // 0x011B(0x00C5)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortSessionHelper">();
	}
	static class UFortSessionHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortSessionHelper>();
	}
};
static_assert(alignof(UFortSessionHelper) == 0x000008, "Wrong alignment on UFortSessionHelper");
static_assert(sizeof(UFortSessionHelper) == 0x0001E0, "Wrong size on UFortSessionHelper");
static_assert(offsetof(UFortSessionHelper, BeaconClientClass) == 0x000028, "Member 'UFortSessionHelper::BeaconClientClass' has a wrong offset!");
static_assert(offsetof(UFortSessionHelper, PartyBeaconClient) == 0x000030, "Member 'UFortSessionHelper::PartyBeaconClient' has a wrong offset!");
static_assert(offsetof(UFortSessionHelper, CurrentSessionName) == 0x000110, "Member 'UFortSessionHelper::CurrentSessionName' has a wrong offset!");
static_assert(offsetof(UFortSessionHelper, LastBeaconResponse) == 0x000118, "Member 'UFortSessionHelper::LastBeaconResponse' has a wrong offset!");
static_assert(offsetof(UFortSessionHelper, CurrentJoinState) == 0x000119, "Member 'UFortSessionHelper::CurrentJoinState' has a wrong offset!");
static_assert(offsetof(UFortSessionHelper, CurrentJoinResult) == 0x00011A, "Member 'UFortSessionHelper::CurrentJoinResult' has a wrong offset!");

// Class FortniteGame.FortMatchmakingSingleSession
// 0x0048 (0x01C0 - 0x0178)
class UFortMatchmakingSingleSession final : public UFortMatchmakingPolicy
{
public:
	struct FFortInviteSessionParams               CurrentSessionParams;                              // 0x0178(0x0038)(Transient, NativeAccessSpecifierPrivate)
	class UFortSessionHelper*                     SessionHelper;                                     // 0x01B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B8[0x8];                                      // 0x01B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMatchmakingSingleSession">();
	}
	static class UFortMatchmakingSingleSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMatchmakingSingleSession>();
	}
};
static_assert(alignof(UFortMatchmakingSingleSession) == 0x000008, "Wrong alignment on UFortMatchmakingSingleSession");
static_assert(sizeof(UFortMatchmakingSingleSession) == 0x0001C0, "Wrong size on UFortMatchmakingSingleSession");
static_assert(offsetof(UFortMatchmakingSingleSession, CurrentSessionParams) == 0x000178, "Member 'UFortMatchmakingSingleSession::CurrentSessionParams' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingSingleSession, SessionHelper) == 0x0001B0, "Member 'UFortMatchmakingSingleSession::SessionHelper' has a wrong offset!");

// Class FortniteGame.FortMatchmakingV2
// 0x05D8 (0x0600 - 0x0028)
class UFortMatchmakingV2 final : public UObject
{
public:
	class FString                                 MMSVersionCompatability;                           // 0x0028(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 MMSTicketURLClient;                                // 0x0038(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MMSPingInterval;                                   // 0x0048(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C[0x5B4];                                     // 0x004C(0x05B4)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMatchmakingV2">();
	}
	static class UFortMatchmakingV2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMatchmakingV2>();
	}
};
static_assert(alignof(UFortMatchmakingV2) == 0x000008, "Wrong alignment on UFortMatchmakingV2");
static_assert(sizeof(UFortMatchmakingV2) == 0x000600, "Wrong size on UFortMatchmakingV2");
static_assert(offsetof(UFortMatchmakingV2, MMSVersionCompatability) == 0x000028, "Member 'UFortMatchmakingV2::MMSVersionCompatability' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingV2, MMSTicketURLClient) == 0x000038, "Member 'UFortMatchmakingV2::MMSTicketURLClient' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingV2, MMSPingInterval) == 0x000048, "Member 'UFortMatchmakingV2::MMSPingInterval' has a wrong offset!");

// Class FortniteGame.FortMcpProfileWorld
// 0x0170 (0x0450 - 0x02E0)
class UFortMcpProfileWorld final : public UFortMcpProfile
{
public:
	struct FFortWorldPlayerLoadout                CachedPlayerLoadout;                               // 0x02E0(0x0140)(Protected, NativeAccessSpecifierProtected)
	class AFortInventory*                         FortInventory;                                     // 0x0420(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UFortWorldItem*>                 WorldItemsCachedForRejoin;                         // 0x0428(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortWorldProfileUpdateRequest> UpdateRequests;                                    // 0x0438(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsInventoryInitialized;                           // 0x0448(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_449[0x7];                                      // 0x0449(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AbortDisintegration(struct FDedicatedServerUrlContext* Context);
	void BatchUpdatePlayer(const struct FMcpProfileChangeRequest& TheaterItemUpdate, const struct FMcpProfileChangeRequest& OutpostItemUpdate, const TArray<struct FFortQuestObjectiveCompletion>& QuestObjectiveUpdates, struct FDedicatedServerUrlContext* Context);
	void BatchUpdatePlayerDeployableBase(const struct FMcpProfileChangeRequest& TheaterItemUpdate, const struct FMcpProfileChangeRequest& OutpostItemUpdate, const TArray<struct FFortQuestObjectiveCompletion>& QuestObjectiveUpdates, const class FString& DeployableBaseItemId, const struct FFortCloudSaveInfo& CloudSaveInfo, struct FDedicatedServerUrlContext* Context);
	void BatchUpdatePlayerOutpost(const struct FMcpProfileChangeRequest& TheaterItemUpdate, const struct FMcpProfileChangeRequest& OutpostItemUpdate, const TArray<struct FFortQuestObjectiveCompletion>& QuestObjectiveUpdates, const class FString& OutpostId, const struct FFortOutpostCoreInfo& OutpostInfo, const struct FFortCloudSaveInfo& CloudSaveInfo, struct FDedicatedServerUrlContext* Context);
	void BatchUpdatePlayers(const TArray<struct FFortBatchUpdatePlayer_Update>& Updates, struct FDedicatedServerUrlContext* Context);
	void BatchUpdatePlayers_DeployableBase(const TArray<struct FFortBatchUpdatePlayer_Update>& Updates, const TArray<struct FFortBatchUpdatePlayer_DeployableBaseUpdate>& DeployableBaseUpdates, struct FDedicatedServerUrlContext* Context);
	void BatchUpdatePlayers_Outpost(const TArray<struct FFortBatchUpdatePlayer_Update>& Updates, const class FString& OutpostId, const struct FFortOutpostCoreInfo& OutpostInfo, const struct FFortCloudSaveInfo& CloudSaveInfo, struct FDedicatedServerUrlContext* Context);
	void DepositPostResources(const TArray<class FString>& itemsToDepositIds, const TArray<int32>& itemCountsToDeposit, struct FDedicatedServerUrlContext* Context);
	void DisintegrateItems(const TArray<class FString>& itemsToDisintegrateIds, const TArray<int32>& itemCountsToDisintegrate, struct FDedicatedServerUrlContext* Context);
	void FabricateItem(const class FString& TemplateId, struct FDedicatedServerUrlContext* Context);
	void InitializeTheater(const class FString& TheaterGuid, struct FDedicatedServerUrlContext* Context);
	void LockProfiles(const class FString& Code, int32 Timeout, struct FDedicatedServerUrlContext* Context);
	void UnlockProfiles(const class FString& Code, struct FDedicatedServerUrlContext* Context);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMcpProfileWorld">();
	}
	static class UFortMcpProfileWorld* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMcpProfileWorld>();
	}
};
static_assert(alignof(UFortMcpProfileWorld) == 0x000008, "Wrong alignment on UFortMcpProfileWorld");
static_assert(sizeof(UFortMcpProfileWorld) == 0x000450, "Wrong size on UFortMcpProfileWorld");
static_assert(offsetof(UFortMcpProfileWorld, CachedPlayerLoadout) == 0x0002E0, "Member 'UFortMcpProfileWorld::CachedPlayerLoadout' has a wrong offset!");
static_assert(offsetof(UFortMcpProfileWorld, FortInventory) == 0x000420, "Member 'UFortMcpProfileWorld::FortInventory' has a wrong offset!");
static_assert(offsetof(UFortMcpProfileWorld, WorldItemsCachedForRejoin) == 0x000428, "Member 'UFortMcpProfileWorld::WorldItemsCachedForRejoin' has a wrong offset!");
static_assert(offsetof(UFortMcpProfileWorld, UpdateRequests) == 0x000438, "Member 'UFortMcpProfileWorld::UpdateRequests' has a wrong offset!");
static_assert(offsetof(UFortMcpProfileWorld, bIsInventoryInitialized) == 0x000448, "Member 'UFortMcpProfileWorld::bIsInventoryInitialized' has a wrong offset!");

// Class FortniteGame.FortMcpWorlds
// 0x0038 (0x0078 - 0x0040)
class UFortMcpWorlds final : public UFortMcpResource
{
public:
	struct FFortActiveTheaterInfo                 TheaterInfo;                                       // 0x0040(0x0030)(NativeAccessSpecifierPrivate)
	int32                                         TheaterQueryRetry;                                 // 0x0070(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMcpWorlds">();
	}
	static class UFortMcpWorlds* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMcpWorlds>();
	}
};
static_assert(alignof(UFortMcpWorlds) == 0x000008, "Wrong alignment on UFortMcpWorlds");
static_assert(sizeof(UFortMcpWorlds) == 0x000078, "Wrong size on UFortMcpWorlds");
static_assert(offsetof(UFortMcpWorlds, TheaterInfo) == 0x000040, "Member 'UFortMcpWorlds::TheaterInfo' has a wrong offset!");
static_assert(offsetof(UFortMcpWorlds, TheaterQueryRetry) == 0x000070, "Member 'UFortMcpWorlds::TheaterQueryRetry' has a wrong offset!");

// Class FortniteGame.FortQueryContext_EncounterGoalsCenterLocation
// 0x0000 (0x0028 - 0x0028)
class UFortQueryContext_EncounterGoalsCenterLocation final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_EncounterGoalsCenterLocation">();
	}
	static class UFortQueryContext_EncounterGoalsCenterLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_EncounterGoalsCenterLocation>();
	}
};
static_assert(alignof(UFortQueryContext_EncounterGoalsCenterLocation) == 0x000008, "Wrong alignment on UFortQueryContext_EncounterGoalsCenterLocation");
static_assert(sizeof(UFortQueryContext_EncounterGoalsCenterLocation) == 0x000028, "Wrong size on UFortQueryContext_EncounterGoalsCenterLocation");

// Class FortniteGame.FortMetaNavArea
// 0x0010 (0x0050 - 0x0040)
class UFortMetaNavArea : public UNavAreaMeta
{
public:
	TArray<struct FNavAgentData>                  AgentData;                                         // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMetaNavArea">();
	}
	static class UFortMetaNavArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMetaNavArea>();
	}
};
static_assert(alignof(UFortMetaNavArea) == 0x000008, "Wrong alignment on UFortMetaNavArea");
static_assert(sizeof(UFortMetaNavArea) == 0x000050, "Wrong size on UFortMetaNavArea");
static_assert(offsetof(UFortMetaNavArea, AgentData) == 0x000040, "Member 'UFortMetaNavArea::AgentData' has a wrong offset!");

// Class FortniteGame.FortQueryGenerator_PointsInVolume
// 0x0040 (0x0090 - 0x0050)
class UFortQueryGenerator_PointsInVolume final : public UEnvQueryGenerator
{
public:
	struct FAIDataProviderIntValue                NumberOfPoints;                                    // 0x0050(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EFortNamedNavmesh                             NavMeshToUse;                                      // 0x0080(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UEnvQueryContext>           GenerateIn;                                        // 0x0088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_PointsInVolume">();
	}
	static class UFortQueryGenerator_PointsInVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_PointsInVolume>();
	}
};
static_assert(alignof(UFortQueryGenerator_PointsInVolume) == 0x000008, "Wrong alignment on UFortQueryGenerator_PointsInVolume");
static_assert(sizeof(UFortQueryGenerator_PointsInVolume) == 0x000090, "Wrong size on UFortQueryGenerator_PointsInVolume");
static_assert(offsetof(UFortQueryGenerator_PointsInVolume, NumberOfPoints) == 0x000050, "Member 'UFortQueryGenerator_PointsInVolume::NumberOfPoints' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsInVolume, NavMeshToUse) == 0x000080, "Member 'UFortQueryGenerator_PointsInVolume::NavMeshToUse' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsInVolume, GenerateIn) == 0x000088, "Member 'UFortQueryGenerator_PointsInVolume::GenerateIn' has a wrong offset!");

// Class FortniteGame.FortMetaNavArea_Wall
// 0x0000 (0x0050 - 0x0050)
class UFortMetaNavArea_Wall final : public UFortMetaNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMetaNavArea_Wall">();
	}
	static class UFortMetaNavArea_Wall* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMetaNavArea_Wall>();
	}
};
static_assert(alignof(UFortMetaNavArea_Wall) == 0x000008, "Wrong alignment on UFortMetaNavArea_Wall");
static_assert(sizeof(UFortMetaNavArea_Wall) == 0x000050, "Wrong size on UFortMetaNavArea_Wall");

// Class FortniteGame.FortMetaNavArea_Obstacles
// 0x0008 (0x0048 - 0x0040)
class UFortMetaNavArea_Obstacles final : public UNavAreaMeta
{
public:
	int32                                         HealthThreshold;                                   // 0x0040(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMetaNavArea_Obstacles">();
	}
	static class UFortMetaNavArea_Obstacles* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMetaNavArea_Obstacles>();
	}
};
static_assert(alignof(UFortMetaNavArea_Obstacles) == 0x000008, "Wrong alignment on UFortMetaNavArea_Obstacles");
static_assert(sizeof(UFortMetaNavArea_Obstacles) == 0x000048, "Wrong size on UFortMetaNavArea_Obstacles");
static_assert(offsetof(UFortMetaNavArea_Obstacles, HealthThreshold) == 0x000040, "Member 'UFortMetaNavArea_Obstacles::HealthThreshold' has a wrong offset!");

// Class FortniteGame.FortMissionOutpostQuestConfigData
// 0x0008 (0x0030 - 0x0028)
class UFortMissionOutpostQuestConfigData final : public UFortMissionConfigData
{
public:
	struct FGameplayTag                           LegTag;                                            // 0x0028(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMissionOutpostQuestConfigData">();
	}
	static class UFortMissionOutpostQuestConfigData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMissionOutpostQuestConfigData>();
	}
};
static_assert(alignof(UFortMissionOutpostQuestConfigData) == 0x000008, "Wrong alignment on UFortMissionOutpostQuestConfigData");
static_assert(sizeof(UFortMissionOutpostQuestConfigData) == 0x000030, "Wrong size on UFortMissionOutpostQuestConfigData");
static_assert(offsetof(UFortMissionOutpostQuestConfigData, LegTag) == 0x000028, "Member 'UFortMissionOutpostQuestConfigData::LegTag' has a wrong offset!");

// Class FortniteGame.FortMissionGenerationManager
// 0x0008 (0x0390 - 0x0388)
class AFortMissionGenerationManager final : public AActor
{
public:
	EFortCheatMissionGenType                      CheatMissionGenType;                               // 0x0388(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_389[0x7];                                      // 0x0389(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMissionGenerationManager">();
	}
	static class AFortMissionGenerationManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortMissionGenerationManager>();
	}
};
static_assert(alignof(AFortMissionGenerationManager) == 0x000008, "Wrong alignment on AFortMissionGenerationManager");
static_assert(sizeof(AFortMissionGenerationManager) == 0x000390, "Wrong size on AFortMissionGenerationManager");
static_assert(offsetof(AFortMissionGenerationManager, CheatMissionGenType) == 0x000388, "Member 'AFortMissionGenerationManager::CheatMissionGenType' has a wrong offset!");

// Class FortniteGame.FortQueryContext_NearbyFriends
// 0x0000 (0x0028 - 0x0028)
class UFortQueryContext_NearbyFriends final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_NearbyFriends">();
	}
	static class UFortQueryContext_NearbyFriends* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_NearbyFriends>();
	}
};
static_assert(alignof(UFortQueryContext_NearbyFriends) == 0x000008, "Wrong alignment on UFortQueryContext_NearbyFriends");
static_assert(sizeof(UFortQueryContext_NearbyFriends) == 0x000028, "Wrong size on UFortQueryContext_NearbyFriends");

// Class FortniteGame.FortMissionInterface
// 0x0000 (0x0028 - 0x0028)
class IFortMissionInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMissionInterface">();
	}
	static class IFortMissionInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortMissionInterface>();
	}
};
static_assert(alignof(IFortMissionInterface) == 0x000008, "Wrong alignment on IFortMissionInterface");
static_assert(sizeof(IFortMissionInterface) == 0x000028, "Wrong size on IFortMissionInterface");

// Class FortniteGame.FortMissionManager
// 0x0328 (0x06B0 - 0x0388)
class AFortMissionManager : public AActor
{
public:
	TArray<struct FFortMissionEventName>          MissionEventNames;                                 // 0x0388(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   BluGloManagerClass;                                // 0x0398(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PrimaryMissionGE;                                  // 0x03B8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D8[0x8];                                      // 0x03D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortBluGloManager*                     BluGloManager;                                     // 0x03E0(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AFortMission*>                   Missions;                                          // 0x03E8(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F8[0x50];                                     // 0x03F8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFortMissionUIActorHandle>      MissionUIActors;                                   // 0x0448(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	class AFortMission*                           CurrentUIFocusedMission;                           // 0x0458(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortMission*                           MissionClosestToPar;                               // 0x0460(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnMissionsUpdated;                                 // 0x0468(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_478[0x78];                                     // 0x0478(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEarnedBadgeEntryArray                 EarnedBadgesArray;                                 // 0x04F0(0x00C0)(Net, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B0[0xE8];                                     // 0x05B0(0x00E8)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnShouldShowSecondaryMissionHeadersChanged;        // 0x0698(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bDisplaySecondaryMissionHeaders;                   // 0x06A8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A9[0x7];                                      // 0x06A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool GetSpawnLocationActorsMatchingEntryItemQuery(class UObject* WorldContextObject, const struct FGameplayTagQuery& TagQuery, TArray<class AActor*>* SpawnLocationActors);
	static bool GetSpawnLocationActorsThatHaveAddedTagsMatchingQuery(class UObject* WorldContextObject, const struct FGameplayTagQuery& TagQuery, TArray<class AActor*>* SpawnLocationActors);

	void OnRep_CurrentUIFocusedMission();
	void OnRep_EarnedBadgesArray();
	void OnRep_Missions();
	void OnRep_MissionUIActors();

	bool ShouldShowSecondaryMissionHeaders() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMissionManager">();
	}
	static class AFortMissionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortMissionManager>();
	}
};
static_assert(alignof(AFortMissionManager) == 0x000008, "Wrong alignment on AFortMissionManager");
static_assert(sizeof(AFortMissionManager) == 0x0006B0, "Wrong size on AFortMissionManager");
static_assert(offsetof(AFortMissionManager, MissionEventNames) == 0x000388, "Member 'AFortMissionManager::MissionEventNames' has a wrong offset!");
static_assert(offsetof(AFortMissionManager, BluGloManagerClass) == 0x000398, "Member 'AFortMissionManager::BluGloManagerClass' has a wrong offset!");
static_assert(offsetof(AFortMissionManager, PrimaryMissionGE) == 0x0003B8, "Member 'AFortMissionManager::PrimaryMissionGE' has a wrong offset!");
static_assert(offsetof(AFortMissionManager, BluGloManager) == 0x0003E0, "Member 'AFortMissionManager::BluGloManager' has a wrong offset!");
static_assert(offsetof(AFortMissionManager, Missions) == 0x0003E8, "Member 'AFortMissionManager::Missions' has a wrong offset!");
static_assert(offsetof(AFortMissionManager, MissionUIActors) == 0x000448, "Member 'AFortMissionManager::MissionUIActors' has a wrong offset!");
static_assert(offsetof(AFortMissionManager, CurrentUIFocusedMission) == 0x000458, "Member 'AFortMissionManager::CurrentUIFocusedMission' has a wrong offset!");
static_assert(offsetof(AFortMissionManager, MissionClosestToPar) == 0x000460, "Member 'AFortMissionManager::MissionClosestToPar' has a wrong offset!");
static_assert(offsetof(AFortMissionManager, OnMissionsUpdated) == 0x000468, "Member 'AFortMissionManager::OnMissionsUpdated' has a wrong offset!");
static_assert(offsetof(AFortMissionManager, EarnedBadgesArray) == 0x0004F0, "Member 'AFortMissionManager::EarnedBadgesArray' has a wrong offset!");
static_assert(offsetof(AFortMissionManager, OnShouldShowSecondaryMissionHeadersChanged) == 0x000698, "Member 'AFortMissionManager::OnShouldShowSecondaryMissionHeadersChanged' has a wrong offset!");
static_assert(offsetof(AFortMissionManager, bDisplaySecondaryMissionHeaders) == 0x0006A8, "Member 'AFortMissionManager::bDisplaySecondaryMissionHeaders' has a wrong offset!");

// Class FortniteGame.FortQueryItemType_Goal
// 0x0000 (0x0030 - 0x0030)
class UFortQueryItemType_Goal final : public UEnvQueryItemType_ActorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryItemType_Goal">();
	}
	static class UFortQueryItemType_Goal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryItemType_Goal>();
	}
};
static_assert(alignof(UFortQueryItemType_Goal) == 0x000008, "Wrong alignment on UFortQueryItemType_Goal");
static_assert(sizeof(UFortQueryItemType_Goal) == 0x000030, "Wrong size on UFortQueryItemType_Goal");

// Class FortniteGame.FortPvPMissionManager
// 0x0000 (0x06B0 - 0x06B0)
class AFortPvPMissionManager final : public AFortMissionManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPvPMissionManager">();
	}
	static class AFortPvPMissionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPvPMissionManager>();
	}
};
static_assert(alignof(AFortPvPMissionManager) == 0x000008, "Wrong alignment on AFortPvPMissionManager");
static_assert(sizeof(AFortPvPMissionManager) == 0x0006B0, "Wrong size on AFortPvPMissionManager");

// Class FortniteGame.FortPvPMission_CTF
// 0x0018 (0x0700 - 0x06E8)
class AFortPvPMission_CTF final : public AFortPvPMission
{
public:
	TArray<int32>                                 TeamCaptureTotals;                                 // 0x06E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	int32                                         TotalCapturesToWin;                                // 0x06F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6FC[0x4];                                      // 0x06FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPvPMission_CTF">();
	}
	static class AFortPvPMission_CTF* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPvPMission_CTF>();
	}
};
static_assert(alignof(AFortPvPMission_CTF) == 0x000008, "Wrong alignment on AFortPvPMission_CTF");
static_assert(sizeof(AFortPvPMission_CTF) == 0x000700, "Wrong size on AFortPvPMission_CTF");
static_assert(offsetof(AFortPvPMission_CTF, TeamCaptureTotals) == 0x0006E8, "Member 'AFortPvPMission_CTF::TeamCaptureTotals' has a wrong offset!");
static_assert(offsetof(AFortPvPMission_CTF, TotalCapturesToWin) == 0x0006F8, "Member 'AFortPvPMission_CTF::TotalCapturesToWin' has a wrong offset!");

// Class FortniteGame.FortPvPMission_EnemyBaseDestruction
// 0x0000 (0x06E8 - 0x06E8)
class AFortPvPMission_EnemyBaseDestruction final : public AFortPvPMission
{
public:
	class AFortPvPBaseCornerstone* GetCornerstoneForTeam(EFortTeam InTeam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPvPMission_EnemyBaseDestruction">();
	}
	static class AFortPvPMission_EnemyBaseDestruction* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPvPMission_EnemyBaseDestruction>();
	}
};
static_assert(alignof(AFortPvPMission_EnemyBaseDestruction) == 0x000008, "Wrong alignment on AFortPvPMission_EnemyBaseDestruction");
static_assert(sizeof(AFortPvPMission_EnemyBaseDestruction) == 0x0006E8, "Wrong size on AFortPvPMission_EnemyBaseDestruction");

// Class FortniteGame.FortQuestManager
// 0x0308 (0x0330 - 0x0028)
class UFortQuestManager final : public UObject
{
public:
	UMulticastDelegateProperty_                   OnQuestsUpdated;                                   // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnQuestsCompleted;                                 // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnQuestsGranted;                                   // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnQuestRewardClaimed;                              // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnQuestSeen;                                       // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnNoQuestRewardsToClaim;                           // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPinnedQuestsChanged;                             // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnDailyQuestRerolled;                              // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnDisplayDynamicQuestUpdate;                       // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UFortQuestItem*>                 CurrentQuests;                                     // 0x00B8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, class UFortQuestCategory*>  CurrentCategorizedQuestsMap;                       // 0x00C8(0x0050)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortQuestObjectiveCompletion>  PendingChanges;                                    // 0x0118(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_128[0x88];                                     // 0x0128(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ActiveEventFlags;                                  // 0x01B0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C0[0x170];                                    // 0x01C0(0x0170)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForceTriggerQuestsUpdated();
	class UFortQuestItem* GetBroadcasterQuestWithOpenWindow();
	void GetCompletedQuests(TArray<class UFortQuestItem*>* OutCompletedQuests);
	void GetCurrentQuests(TArray<class UFortQuestItem*>* OutCurrentQuests);
	class UFortQuestItem* GetNextUnseenQuest(EFortQuestType QuestType);
	void GetPinnedQuests(TArray<class UFortQuestItem*>* OutPinnedQuestItems);
	void GrantFirstDailyQuest();
	bool IsMainQuest(class UFortQuestItem* Quest);
	void SendCustomStatEvent(const struct FDataTableRowHandle& ObjectiveStat, int32 Count, bool bForceFlush);
	bool SetQuestPinned(class UFortQuestItem* Quest, bool bEnabled);

	void ClaimNextCompletedQuestReward(EFortQuestType QuestType) const;
	void ClaimQuestReward(const class UFortQuestItem* Quest) const;
	void ClaimSelectedQuestReward(const class UFortQuestItem* Quest, int32 RewardIndex) const;
	void GetCurrentQuestsCategories(TArray<class UFortQuestCategory*>* Categories) const;
	class UFortQuestItem* GetMainQuest() const;
	const class UFortQuestCategory* GetQuestCategory(class UFortQuestItem* QuestItem) const;
	class UFortQuestItem* GetQuestWithDefinition(const class UFortQuestItemDefinition* Definition) const;
	int32 GetRemainingDailyQuestRerolls() const;
	void GetSourceAndContextTags(struct FGameplayTagContainer* OutSourceTags, struct FGameplayTagContainer* OutContextTags) const;
	bool HasCompletedObjective(const class UFortQuestItemDefinition* Definition, const struct FDataTableRowHandle& ObjectiveStatHandle) const;
	bool HasCompletedObjectiveWithName(const class UFortQuestItemDefinition* Definition, class FName BackendName) const;
	bool HasCompletedQuest(const class UFortQuestItemDefinition* Definition) const;
	bool HasQuestBeenSeenLocally(const class UFortQuestItem* Quest) const;
	bool HasUnsavedPrimaryMissionProgress() const;
	bool HasUnseenQuests() const;
	bool IsObjectiveInProgress(const class UFortQuestItemDefinition* Definition, const struct FDataTableRowHandle& ObjectiveStatHandle) const;
	bool IsObjectiveWithNameInProgress(const class UFortQuestItemDefinition* Definition, class FName BackendName) const;
	bool IsQuestInProgress(const class UFortQuestItemDefinition* Definition) const;
	void MarkQuestSeen(class UFortQuestItem* Quest) const;
	void MarkQuestsSeen(bool bOnlyMarkPendingSeenQuests) const;
	void RerollDailyQuest(const class UFortQuestItem* QuestToDiscard) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQuestManager">();
	}
	static class UFortQuestManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQuestManager>();
	}
};
static_assert(alignof(UFortQuestManager) == 0x000008, "Wrong alignment on UFortQuestManager");
static_assert(sizeof(UFortQuestManager) == 0x000330, "Wrong size on UFortQuestManager");
static_assert(offsetof(UFortQuestManager, OnQuestsUpdated) == 0x000028, "Member 'UFortQuestManager::OnQuestsUpdated' has a wrong offset!");
static_assert(offsetof(UFortQuestManager, OnQuestsCompleted) == 0x000038, "Member 'UFortQuestManager::OnQuestsCompleted' has a wrong offset!");
static_assert(offsetof(UFortQuestManager, OnQuestsGranted) == 0x000048, "Member 'UFortQuestManager::OnQuestsGranted' has a wrong offset!");
static_assert(offsetof(UFortQuestManager, OnQuestRewardClaimed) == 0x000058, "Member 'UFortQuestManager::OnQuestRewardClaimed' has a wrong offset!");
static_assert(offsetof(UFortQuestManager, OnQuestSeen) == 0x000068, "Member 'UFortQuestManager::OnQuestSeen' has a wrong offset!");
static_assert(offsetof(UFortQuestManager, OnNoQuestRewardsToClaim) == 0x000078, "Member 'UFortQuestManager::OnNoQuestRewardsToClaim' has a wrong offset!");
static_assert(offsetof(UFortQuestManager, OnPinnedQuestsChanged) == 0x000088, "Member 'UFortQuestManager::OnPinnedQuestsChanged' has a wrong offset!");
static_assert(offsetof(UFortQuestManager, OnDailyQuestRerolled) == 0x000098, "Member 'UFortQuestManager::OnDailyQuestRerolled' has a wrong offset!");
static_assert(offsetof(UFortQuestManager, OnDisplayDynamicQuestUpdate) == 0x0000A8, "Member 'UFortQuestManager::OnDisplayDynamicQuestUpdate' has a wrong offset!");
static_assert(offsetof(UFortQuestManager, CurrentQuests) == 0x0000B8, "Member 'UFortQuestManager::CurrentQuests' has a wrong offset!");
static_assert(offsetof(UFortQuestManager, CurrentCategorizedQuestsMap) == 0x0000C8, "Member 'UFortQuestManager::CurrentCategorizedQuestsMap' has a wrong offset!");
static_assert(offsetof(UFortQuestManager, PendingChanges) == 0x000118, "Member 'UFortQuestManager::PendingChanges' has a wrong offset!");
static_assert(offsetof(UFortQuestManager, ActiveEventFlags) == 0x0001B0, "Member 'UFortQuestManager::ActiveEventFlags' has a wrong offset!");

// Class FortniteGame.FortPvPObjective
// 0x0008 (0x0458 - 0x0450)
class AFortPvPObjective : public AFortObjectiveBase
{
public:
	EFortTeam                                     Team;                                              // 0x0450(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_451[0x7];                                      // 0x0451(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPvPObjective">();
	}
	static class AFortPvPObjective* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPvPObjective>();
	}
};
static_assert(alignof(AFortPvPObjective) == 0x000008, "Wrong alignment on AFortPvPObjective");
static_assert(sizeof(AFortPvPObjective) == 0x000458, "Wrong size on AFortPvPObjective");
static_assert(offsetof(AFortPvPObjective, Team) == 0x000450, "Member 'AFortPvPObjective::Team' has a wrong offset!");

// Class FortniteGame.FortPvPObjective_3PtDomination
// 0x0000 (0x0458 - 0x0458)
class AFortPvPObjective_3PtDomination final : public AFortPvPObjective
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPvPObjective_3PtDomination">();
	}
	static class AFortPvPObjective_3PtDomination* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPvPObjective_3PtDomination>();
	}
};
static_assert(alignof(AFortPvPObjective_3PtDomination) == 0x000008, "Wrong alignment on AFortPvPObjective_3PtDomination");
static_assert(sizeof(AFortPvPObjective_3PtDomination) == 0x000458, "Wrong size on AFortPvPObjective_3PtDomination");

// Class FortniteGame.FortPvPObjective_CTF
// 0x0000 (0x0458 - 0x0458)
class AFortPvPObjective_CTF final : public AFortPvPObjective
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPvPObjective_CTF">();
	}
	static class AFortPvPObjective_CTF* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPvPObjective_CTF>();
	}
};
static_assert(alignof(AFortPvPObjective_CTF) == 0x000008, "Wrong alignment on AFortPvPObjective_CTF");
static_assert(sizeof(AFortPvPObjective_CTF) == 0x000458, "Wrong size on AFortPvPObjective_CTF");

// Class FortniteGame.FortQueryTest_AssignmentTypeInterest
// 0x0180 (0x0358 - 0x01D8)
class UFortQueryTest_AssignmentTypeInterest final : public UFortQueryTest_GoalBase
{
public:
	struct FAIDataProviderFloatValue              InvalidTypeStartInterest;                          // 0x01D8(0x0030)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              InvalidTypeEndInterest;                            // 0x0208(0x0030)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              InvalidTypeTimeBeforeLerp;                         // 0x0238(0x0030)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              InvalidTypeLerpDuration;                           // 0x0268(0x0030)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              ValidTypeStartInterest;                            // 0x0298(0x0030)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              ValidTypeEndInterest;                              // 0x02C8(0x0030)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              ValidTypeTimeBeforeLerp;                           // 0x02F8(0x0030)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              ValidTypeLerpDuration;                             // 0x0328(0x0030)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_AssignmentTypeInterest">();
	}
	static class UFortQueryTest_AssignmentTypeInterest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_AssignmentTypeInterest>();
	}
};
static_assert(alignof(UFortQueryTest_AssignmentTypeInterest) == 0x000008, "Wrong alignment on UFortQueryTest_AssignmentTypeInterest");
static_assert(sizeof(UFortQueryTest_AssignmentTypeInterest) == 0x000358, "Wrong size on UFortQueryTest_AssignmentTypeInterest");
static_assert(offsetof(UFortQueryTest_AssignmentTypeInterest, InvalidTypeStartInterest) == 0x0001D8, "Member 'UFortQueryTest_AssignmentTypeInterest::InvalidTypeStartInterest' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_AssignmentTypeInterest, InvalidTypeEndInterest) == 0x000208, "Member 'UFortQueryTest_AssignmentTypeInterest::InvalidTypeEndInterest' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_AssignmentTypeInterest, InvalidTypeTimeBeforeLerp) == 0x000238, "Member 'UFortQueryTest_AssignmentTypeInterest::InvalidTypeTimeBeforeLerp' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_AssignmentTypeInterest, InvalidTypeLerpDuration) == 0x000268, "Member 'UFortQueryTest_AssignmentTypeInterest::InvalidTypeLerpDuration' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_AssignmentTypeInterest, ValidTypeStartInterest) == 0x000298, "Member 'UFortQueryTest_AssignmentTypeInterest::ValidTypeStartInterest' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_AssignmentTypeInterest, ValidTypeEndInterest) == 0x0002C8, "Member 'UFortQueryTest_AssignmentTypeInterest::ValidTypeEndInterest' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_AssignmentTypeInterest, ValidTypeTimeBeforeLerp) == 0x0002F8, "Member 'UFortQueryTest_AssignmentTypeInterest::ValidTypeTimeBeforeLerp' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_AssignmentTypeInterest, ValidTypeLerpDuration) == 0x000328, "Member 'UFortQueryTest_AssignmentTypeInterest::ValidTypeLerpDuration' has a wrong offset!");

// Class FortniteGame.FortPvPObjective_EnemyBaseDestruction
// 0x0000 (0x0458 - 0x0458)
class AFortPvPObjective_EnemyBaseDestruction final : public AFortPvPObjective
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPvPObjective_EnemyBaseDestruction">();
	}
	static class AFortPvPObjective_EnemyBaseDestruction* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPvPObjective_EnemyBaseDestruction>();
	}
};
static_assert(alignof(AFortPvPObjective_EnemyBaseDestruction) == 0x000008, "Wrong alignment on AFortPvPObjective_EnemyBaseDestruction");
static_assert(sizeof(AFortPvPObjective_EnemyBaseDestruction) == 0x000458, "Wrong size on AFortPvPObjective_EnemyBaseDestruction");

// Class FortniteGame.FortMissionTimerComponent
// 0x0078 (0x0168 - 0x00F0)
class UFortMissionTimerComponent final : public UActorComponent
{
public:
	UMulticastDelegateProperty_                   OnMissionTimerComponentUpdated;                    // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TArray<struct FMissionTimeDisplayData>        DisplayData;                                       // 0x0100(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FMissionTimerData                      TimerData;                                         // 0x0110(0x0028)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class FText                                   TimerLabelText;                                    // 0x0138(0x0018)(Edit, Net, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bDisplayInTimeFormat;                              // 0x0150(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETimerOverrideSetting                         TimerVisibilityOverrideSetting;                    // 0x0151(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_152[0x16];                                     // 0x0152(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearMissionTimer();
	void DummyTimer();
	void OnRep_TimerData();
	void OnRep_TimerVisibilityOverride();
	void PauseMissionTimer();
	void ResetMissionTimer();
	void SetMissionTimer(const class FString& FunctionName, float TimerLength, class AActor* CallbackActor);
	void SetTimerDisplayFormat(bool bNewDisplayInTimeFormat);
	void SetTimerLabelText(const class FText& NewLabelText);
	void SetTimerVisibilityOverrideSetting(ETimerOverrideSetting NewVisibilitySetting);
	void UnpauseMissionTimer();

	struct FMissionTimeDisplayData GetCorrectTimeDisplayData() const;
	float GetMissionTimerTimeRemaining() const;
	float GetNormalizedTime() const;
	class FText GetTimeText() const;
	bool IsMissionTimerPaused() const;
	bool IsMissionTimerSet() const;
	bool IsTimerVisible() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMissionTimerComponent">();
	}
	static class UFortMissionTimerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMissionTimerComponent>();
	}
};
static_assert(alignof(UFortMissionTimerComponent) == 0x000008, "Wrong alignment on UFortMissionTimerComponent");
static_assert(sizeof(UFortMissionTimerComponent) == 0x000168, "Wrong size on UFortMissionTimerComponent");
static_assert(offsetof(UFortMissionTimerComponent, OnMissionTimerComponentUpdated) == 0x0000F0, "Member 'UFortMissionTimerComponent::OnMissionTimerComponentUpdated' has a wrong offset!");
static_assert(offsetof(UFortMissionTimerComponent, DisplayData) == 0x000100, "Member 'UFortMissionTimerComponent::DisplayData' has a wrong offset!");
static_assert(offsetof(UFortMissionTimerComponent, TimerData) == 0x000110, "Member 'UFortMissionTimerComponent::TimerData' has a wrong offset!");
static_assert(offsetof(UFortMissionTimerComponent, TimerLabelText) == 0x000138, "Member 'UFortMissionTimerComponent::TimerLabelText' has a wrong offset!");
static_assert(offsetof(UFortMissionTimerComponent, bDisplayInTimeFormat) == 0x000150, "Member 'UFortMissionTimerComponent::bDisplayInTimeFormat' has a wrong offset!");
static_assert(offsetof(UFortMissionTimerComponent, TimerVisibilityOverrideSetting) == 0x000151, "Member 'UFortMissionTimerComponent::TimerVisibilityOverrideSetting' has a wrong offset!");

// Class FortniteGame.FortMovementComp_Character
// 0x0030 (0x0760 - 0x0730)
#pragma pack(push, 0x1)
class alignas(0x10) UFortMovementComp_Character : public UCharacterMovementComponent
{
public:
	float                                         MaxFallSpeed;                                      // 0x0728(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72C[0x4];                                      // 0x072C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AFortPawn>                  PushBumpedPawnClass;                               // 0x0730(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_738[0x10];                                     // 0x0738(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NetworkSmoothingVisibilityThreshold;               // 0x0748(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallingStartedZ;                                   // 0x074C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_750[0x4];                                      // 0x0750(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bTriggeredFallingFeedbackSinceLanded : 1;          // 0x0754(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_755[0x3];                                      // 0x0755(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMovementComp_Character">();
	}
	static class UFortMovementComp_Character* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMovementComp_Character>();
	}
};
#pragma pack(pop)
static_assert(alignof(UFortMovementComp_Character) == 0x000010, "Wrong alignment on UFortMovementComp_Character");
static_assert(sizeof(UFortMovementComp_Character) == 0x000760, "Wrong size on UFortMovementComp_Character");
static_assert(offsetof(UFortMovementComp_Character, MaxFallSpeed) == 0x000728, "Member 'UFortMovementComp_Character::MaxFallSpeed' has a wrong offset!");
static_assert(offsetof(UFortMovementComp_Character, PushBumpedPawnClass) == 0x000730, "Member 'UFortMovementComp_Character::PushBumpedPawnClass' has a wrong offset!");
static_assert(offsetof(UFortMovementComp_Character, NetworkSmoothingVisibilityThreshold) == 0x000748, "Member 'UFortMovementComp_Character::NetworkSmoothingVisibilityThreshold' has a wrong offset!");
static_assert(offsetof(UFortMovementComp_Character, FallingStartedZ) == 0x00074C, "Member 'UFortMovementComp_Character::FallingStartedZ' has a wrong offset!");

// Class FortniteGame.FortMovementComp_CharacterAthena
// 0x0360 (0x0AC0 - 0x0760)
class UFortMovementComp_CharacterAthena final : public UFortMovementComp_Character
{
public:
	TArray<struct FAthenaJumpPenalty>             JumpPenalties;                                     // 0x0758(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         JumpPenaltyResetTime;                              // 0x0768(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_76C[0x8];                                      // 0x076C(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FallingSlopeSafeSlideAngle;                        // 0x0774(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallingSlopeSafeSlideMaxSpeed;                     // 0x0778(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallingSlopeDamageScalarMin;                       // 0x077C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallingSlopeSafeSlideNormalZ;                      // 0x0780(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_784[0x4];                                      // 0x0784(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAirControlParams                      SkydivingControlParamsPassive;                     // 0x0788(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FAirControlParams                      SkydivingControlParamsActive;                      // 0x0850(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FAirControlParams                      ParachuteControlParamsSkydive;                     // 0x0918(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FAirControlParams                      ParachuteControlParamsJump;                        // 0x09E0(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_AA8[0x18];                                     // 0x0AA8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsActivelySkydiving() const;
	bool IsActivelyStrafingInAir() const;
	bool IsPassivelySkydiving() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMovementComp_CharacterAthena">();
	}
	static class UFortMovementComp_CharacterAthena* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMovementComp_CharacterAthena>();
	}
};
static_assert(alignof(UFortMovementComp_CharacterAthena) == 0x000010, "Wrong alignment on UFortMovementComp_CharacterAthena");
static_assert(sizeof(UFortMovementComp_CharacterAthena) == 0x000AC0, "Wrong size on UFortMovementComp_CharacterAthena");
static_assert(offsetof(UFortMovementComp_CharacterAthena, JumpPenalties) == 0x000758, "Member 'UFortMovementComp_CharacterAthena::JumpPenalties' has a wrong offset!");
static_assert(offsetof(UFortMovementComp_CharacterAthena, JumpPenaltyResetTime) == 0x000768, "Member 'UFortMovementComp_CharacterAthena::JumpPenaltyResetTime' has a wrong offset!");
static_assert(offsetof(UFortMovementComp_CharacterAthena, FallingSlopeSafeSlideAngle) == 0x000774, "Member 'UFortMovementComp_CharacterAthena::FallingSlopeSafeSlideAngle' has a wrong offset!");
static_assert(offsetof(UFortMovementComp_CharacterAthena, FallingSlopeSafeSlideMaxSpeed) == 0x000778, "Member 'UFortMovementComp_CharacterAthena::FallingSlopeSafeSlideMaxSpeed' has a wrong offset!");
static_assert(offsetof(UFortMovementComp_CharacterAthena, FallingSlopeDamageScalarMin) == 0x00077C, "Member 'UFortMovementComp_CharacterAthena::FallingSlopeDamageScalarMin' has a wrong offset!");
static_assert(offsetof(UFortMovementComp_CharacterAthena, FallingSlopeSafeSlideNormalZ) == 0x000780, "Member 'UFortMovementComp_CharacterAthena::FallingSlopeSafeSlideNormalZ' has a wrong offset!");
static_assert(offsetof(UFortMovementComp_CharacterAthena, SkydivingControlParamsPassive) == 0x000788, "Member 'UFortMovementComp_CharacterAthena::SkydivingControlParamsPassive' has a wrong offset!");
static_assert(offsetof(UFortMovementComp_CharacterAthena, SkydivingControlParamsActive) == 0x000850, "Member 'UFortMovementComp_CharacterAthena::SkydivingControlParamsActive' has a wrong offset!");
static_assert(offsetof(UFortMovementComp_CharacterAthena, ParachuteControlParamsSkydive) == 0x000918, "Member 'UFortMovementComp_CharacterAthena::ParachuteControlParamsSkydive' has a wrong offset!");
static_assert(offsetof(UFortMovementComp_CharacterAthena, ParachuteControlParamsJump) == 0x0009E0, "Member 'UFortMovementComp_CharacterAthena::ParachuteControlParamsJump' has a wrong offset!");

// Class FortniteGame.HoverDronePawn
// 0x0010 (0x0428 - 0x0418)
class AHoverDronePawn final : public AFortReplaySpectatorPawnBase
{
public:
	uint8                                         Pad_418[0x10];                                     // 0x0418(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetAltitude() const;
	bool IsMaintainingConstantAltitude() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HoverDronePawn">();
	}
	static class AHoverDronePawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHoverDronePawn>();
	}
};
static_assert(alignof(AHoverDronePawn) == 0x000008, "Wrong alignment on AHoverDronePawn");
static_assert(sizeof(AHoverDronePawn) == 0x000428, "Wrong size on AHoverDronePawn");

// Class FortniteGame.FortMusicManager
// 0x0040 (0x03C8 - 0x0388)
class AFortMusicManager : public AActor
{
public:
	class AFortPlayerController*                  ControllerOwner;                                   // 0x0388(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAudioComponent*                        MusicChannels[0x3];                                // 0x0390(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A8[0x20];                                     // 0x03A8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeMusic(class USoundBase* NewMusic, EMusicFadeStyles FadeStyle, float FadeTime, class USoundBase* Stinger);
	float GetEventHeatPercent(EFortCombatEvents CombatEvent);
	float GetEventHeatPercentTotal(EFortCombatEvents CombatEvent);
	void OnDayPhaseChanged(EFortDayPhase CurrentDayPhase, EFortDayPhase PreviousDayPhase, bool bAtCreation);
	void OnThresholdChange(EFortCombatThresholds OldThreshold, EFortCombatThresholds NewThreshold);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMusicManager">();
	}
	static class AFortMusicManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortMusicManager>();
	}
};
static_assert(alignof(AFortMusicManager) == 0x000008, "Wrong alignment on AFortMusicManager");
static_assert(sizeof(AFortMusicManager) == 0x0003C8, "Wrong size on AFortMusicManager");
static_assert(offsetof(AFortMusicManager, ControllerOwner) == 0x000388, "Member 'AFortMusicManager::ControllerOwner' has a wrong offset!");
static_assert(offsetof(AFortMusicManager, MusicChannels) == 0x000390, "Member 'AFortMusicManager::MusicChannels' has a wrong offset!");

// Class FortniteGame.FortNavArea_StoneWall
// 0x0000 (0x0048 - 0x0048)
class UFortNavArea_StoneWall final : public UFortNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_StoneWall">();
	}
	static class UFortNavArea_StoneWall* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_StoneWall>();
	}
};
static_assert(alignof(UFortNavArea_StoneWall) == 0x000008, "Wrong alignment on UFortNavArea_StoneWall");
static_assert(sizeof(UFortNavArea_StoneWall) == 0x000048, "Wrong size on UFortNavArea_StoneWall");

// Class FortniteGame.FortNavAgentCostData
// 0x0018 (0x0040 - 0x0028)
class UFortNavAgentCostData final : public UPrimaryDataAsset
{
public:
	class FName                                   NavAgentName;                                      // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UNavArea>>           NavAreaStrengthBuckets;                            // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavAgentCostData">();
	}
	static class UFortNavAgentCostData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavAgentCostData>();
	}
};
static_assert(alignof(UFortNavAgentCostData) == 0x000008, "Wrong alignment on UFortNavAgentCostData");
static_assert(sizeof(UFortNavAgentCostData) == 0x000040, "Wrong size on UFortNavAgentCostData");
static_assert(offsetof(UFortNavAgentCostData, NavAgentName) == 0x000028, "Member 'UFortNavAgentCostData::NavAgentName' has a wrong offset!");
static_assert(offsetof(UFortNavAgentCostData, NavAreaStrengthBuckets) == 0x000030, "Member 'UFortNavAgentCostData::NavAreaStrengthBuckets' has a wrong offset!");

// Class FortniteGame.FortNavArea_CheapObstacle
// 0x0000 (0x0048 - 0x0048)
class UFortNavArea_CheapObstacle final : public UFortNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_CheapObstacle">();
	}
	static class UFortNavArea_CheapObstacle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_CheapObstacle>();
	}
};
static_assert(alignof(UFortNavArea_CheapObstacle) == 0x000008, "Wrong alignment on UFortNavArea_CheapObstacle");
static_assert(sizeof(UFortNavArea_CheapObstacle) == 0x000048, "Wrong size on UFortNavArea_CheapObstacle");

// Class FortniteGame.FortNavArea_LowSmashable
// 0x0000 (0x0048 - 0x0048)
class UFortNavArea_LowSmashable final : public UFortNavArea_DefaultSmashable
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_LowSmashable">();
	}
	static class UFortNavArea_LowSmashable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_LowSmashable>();
	}
};
static_assert(alignof(UFortNavArea_LowSmashable) == 0x000008, "Wrong alignment on UFortNavArea_LowSmashable");
static_assert(sizeof(UFortNavArea_LowSmashable) == 0x000048, "Wrong size on UFortNavArea_LowSmashable");

// Class FortniteGame.FortQueryGenerator_ValidSpawnRiftActors
// 0x0030 (0x0080 - 0x0050)
class UFortQueryGenerator_ValidSpawnRiftActors final : public UEnvQueryGenerator
{
public:
	struct FAIDataProviderIntValue                NumAIForGroup;                                     // 0x0050(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_ValidSpawnRiftActors">();
	}
	static class UFortQueryGenerator_ValidSpawnRiftActors* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_ValidSpawnRiftActors>();
	}
};
static_assert(alignof(UFortQueryGenerator_ValidSpawnRiftActors) == 0x000008, "Wrong alignment on UFortQueryGenerator_ValidSpawnRiftActors");
static_assert(sizeof(UFortQueryGenerator_ValidSpawnRiftActors) == 0x000080, "Wrong size on UFortQueryGenerator_ValidSpawnRiftActors");
static_assert(offsetof(UFortQueryGenerator_ValidSpawnRiftActors, NumAIForGroup) == 0x000050, "Member 'UFortQueryGenerator_ValidSpawnRiftActors::NumAIForGroup' has a wrong offset!");

// Class FortniteGame.WorldTileType
// 0x0038 (0x0060 - 0x0028)
class UWorldTileType final : public UDataAsset
{
public:
	class FString                                 TileID;                                            // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         TileGroups;                                        // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         TileWeight;                                        // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortTileEdgeType                             North;                                             // 0x004C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortTileEdgeType                             East;                                              // 0x004D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortTileEdgeType                             South;                                             // 0x004E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortTileEdgeType                             West;                                              // 0x004F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         MapNames;                                          // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldTileType">();
	}
	static class UWorldTileType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldTileType>();
	}
};
static_assert(alignof(UWorldTileType) == 0x000008, "Wrong alignment on UWorldTileType");
static_assert(sizeof(UWorldTileType) == 0x000060, "Wrong size on UWorldTileType");
static_assert(offsetof(UWorldTileType, TileID) == 0x000028, "Member 'UWorldTileType::TileID' has a wrong offset!");
static_assert(offsetof(UWorldTileType, TileGroups) == 0x000038, "Member 'UWorldTileType::TileGroups' has a wrong offset!");
static_assert(offsetof(UWorldTileType, TileWeight) == 0x000048, "Member 'UWorldTileType::TileWeight' has a wrong offset!");
static_assert(offsetof(UWorldTileType, North) == 0x00004C, "Member 'UWorldTileType::North' has a wrong offset!");
static_assert(offsetof(UWorldTileType, East) == 0x00004D, "Member 'UWorldTileType::East' has a wrong offset!");
static_assert(offsetof(UWorldTileType, South) == 0x00004E, "Member 'UWorldTileType::South' has a wrong offset!");
static_assert(offsetof(UWorldTileType, West) == 0x00004F, "Member 'UWorldTileType::West' has a wrong offset!");
static_assert(offsetof(UWorldTileType, MapNames) == 0x000050, "Member 'UWorldTileType::MapNames' has a wrong offset!");

// Class FortniteGame.FortNavArea_TraceSmashable
// 0x0000 (0x0048 - 0x0048)
class UFortNavArea_TraceSmashable final : public UFortNavArea_DefaultSmashable
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_TraceSmashable">();
	}
	static class UFortNavArea_TraceSmashable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_TraceSmashable>();
	}
};
static_assert(alignof(UFortNavArea_TraceSmashable) == 0x000008, "Wrong alignment on UFortNavArea_TraceSmashable");
static_assert(sizeof(UFortNavArea_TraceSmashable) == 0x000048, "Wrong size on UFortNavArea_TraceSmashable");

// Class FortniteGame.FortNavArea_DefenderNull
// 0x0000 (0x0048 - 0x0048)
class UFortNavArea_DefenderNull final : public UFortNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_DefenderNull">();
	}
	static class UFortNavArea_DefenderNull* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_DefenderNull>();
	}
};
static_assert(alignof(UFortNavArea_DefenderNull) == 0x000008, "Wrong alignment on UFortNavArea_DefenderNull");
static_assert(sizeof(UFortNavArea_DefenderNull) == 0x000048, "Wrong size on UFortNavArea_DefenderNull");

// Class FortniteGame.FortNavArea_LowJump
// 0x0000 (0x0048 - 0x0048)
class UFortNavArea_LowJump final : public UFortNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_LowJump">();
	}
	static class UFortNavArea_LowJump* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_LowJump>();
	}
};
static_assert(alignof(UFortNavArea_LowJump) == 0x000008, "Wrong alignment on UFortNavArea_LowJump");
static_assert(sizeof(UFortNavArea_LowJump) == 0x000048, "Wrong size on UFortNavArea_LowJump");

// Class FortniteGame.FortNavArea_Obstacle
// 0x0000 (0x0048 - 0x0048)
class UFortNavArea_Obstacle final : public UFortNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_Obstacle">();
	}
	static class UFortNavArea_Obstacle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_Obstacle>();
	}
};
static_assert(alignof(UFortNavArea_Obstacle) == 0x000008, "Wrong alignment on UFortNavArea_Obstacle");
static_assert(sizeof(UFortNavArea_Obstacle) == 0x000048, "Wrong size on UFortNavArea_Obstacle");

// Class FortniteGame.FortNavArea_PortalOrSmash
// 0x0000 (0x0048 - 0x0048)
class UFortNavArea_PortalOrSmash final : public UFortNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_PortalOrSmash">();
	}
	static class UFortNavArea_PortalOrSmash* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_PortalOrSmash>();
	}
};
static_assert(alignof(UFortNavArea_PortalOrSmash) == 0x000008, "Wrong alignment on UFortNavArea_PortalOrSmash");
static_assert(sizeof(UFortNavArea_PortalOrSmash) == 0x000048, "Wrong size on UFortNavArea_PortalOrSmash");

// Class FortniteGame.FortNavArea_TakerOnly
// 0x0000 (0x0048 - 0x0048)
class UFortNavArea_TakerOnly final : public UFortNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_TakerOnly">();
	}
	static class UFortNavArea_TakerOnly* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_TakerOnly>();
	}
};
static_assert(alignof(UFortNavArea_TakerOnly) == 0x000008, "Wrong alignment on UFortNavArea_TakerOnly");
static_assert(sizeof(UFortNavArea_TakerOnly) == 0x000048, "Wrong size on UFortNavArea_TakerOnly");

// Class FortniteGame.FortQueryTest_CanHitWithGameplayAbility
// 0x0030 (0x01F0 - 0x01C0)
class UFortQueryTest_CanHitWithGameplayAbility final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           AIsUsingAbility;                                   // 0x01C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           AbilityTargets;                                    // 0x01C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  GameplayAbilityTag;                                // 0x01D0(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_CanHitWithGameplayAbility">();
	}
	static class UFortQueryTest_CanHitWithGameplayAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_CanHitWithGameplayAbility>();
	}
};
static_assert(alignof(UFortQueryTest_CanHitWithGameplayAbility) == 0x000008, "Wrong alignment on UFortQueryTest_CanHitWithGameplayAbility");
static_assert(sizeof(UFortQueryTest_CanHitWithGameplayAbility) == 0x0001F0, "Wrong size on UFortQueryTest_CanHitWithGameplayAbility");
static_assert(offsetof(UFortQueryTest_CanHitWithGameplayAbility, AIsUsingAbility) == 0x0001C0, "Member 'UFortQueryTest_CanHitWithGameplayAbility::AIsUsingAbility' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_CanHitWithGameplayAbility, AbilityTargets) == 0x0001C8, "Member 'UFortQueryTest_CanHitWithGameplayAbility::AbilityTargets' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_CanHitWithGameplayAbility, GameplayAbilityTag) == 0x0001D0, "Member 'UFortQueryTest_CanHitWithGameplayAbility::GameplayAbilityTag' has a wrong offset!");

// Class FortniteGame.FortNavArea_Unwalkable
// 0x0000 (0x0048 - 0x0048)
class UFortNavArea_Unwalkable final : public UFortNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_Unwalkable">();
	}
	static class UFortNavArea_Unwalkable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_Unwalkable>();
	}
};
static_assert(alignof(UFortNavArea_Unwalkable) == 0x000008, "Wrong alignment on UFortNavArea_Unwalkable");
static_assert(sizeof(UFortNavArea_Unwalkable) == 0x000048, "Wrong size on UFortNavArea_Unwalkable");

// Class FortniteGame.FortNavArea_WoodenWall
// 0x0000 (0x0048 - 0x0048)
class UFortNavArea_WoodenWall final : public UFortNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_WoodenWall">();
	}
	static class UFortNavArea_WoodenWall* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_WoodenWall>();
	}
};
static_assert(alignof(UFortNavArea_WoodenWall) == 0x000008, "Wrong alignment on UFortNavArea_WoodenWall");
static_assert(sizeof(UFortNavArea_WoodenWall) == 0x000048, "Wrong size on UFortNavArea_WoodenWall");

// Class FortniteGame.FortNavAreaAutomatic
// 0x0018 (0x0060 - 0x0048)
class UFortNavAreaAutomatic : public UFortNavArea
{
public:
	struct FCurveTableRowHandle                   NavCostCurveHandle;                                // 0x0048(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	int32                                         NavAreaStrength;                                   // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AutomaticNavCost;                                  // 0x005C(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavAreaAutomatic">();
	}
	static class UFortNavAreaAutomatic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavAreaAutomatic>();
	}
};
static_assert(alignof(UFortNavAreaAutomatic) == 0x000008, "Wrong alignment on UFortNavAreaAutomatic");
static_assert(sizeof(UFortNavAreaAutomatic) == 0x000060, "Wrong size on UFortNavAreaAutomatic");
static_assert(offsetof(UFortNavAreaAutomatic, NavCostCurveHandle) == 0x000048, "Member 'UFortNavAreaAutomatic::NavCostCurveHandle' has a wrong offset!");
static_assert(offsetof(UFortNavAreaAutomatic, NavAreaStrength) == 0x000058, "Member 'UFortNavAreaAutomatic::NavAreaStrength' has a wrong offset!");
static_assert(offsetof(UFortNavAreaAutomatic, AutomaticNavCost) == 0x00005C, "Member 'UFortNavAreaAutomatic::AutomaticNavCost' has a wrong offset!");

// Class FortniteGame.FortNavGraphGoal
// 0x0010 (0x0398 - 0x0388)
class AFortNavGraphGoal final : public AActor
{
public:
	uint8                                         Pad_388[0x8];                                      // 0x0388(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GraphRadius;                                       // 0x0390(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_394[0x4];                                      // 0x0394(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavGraphGoal">();
	}
	static class AFortNavGraphGoal* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortNavGraphGoal>();
	}
};
static_assert(alignof(AFortNavGraphGoal) == 0x000008, "Wrong alignment on AFortNavGraphGoal");
static_assert(sizeof(AFortNavGraphGoal) == 0x000398, "Wrong size on AFortNavGraphGoal");
static_assert(offsetof(AFortNavGraphGoal, GraphRadius) == 0x000390, "Member 'AFortNavGraphGoal::GraphRadius' has a wrong offset!");

// Class FortniteGame.FortNavigationFilter_IgnoreSmashingCost
// 0x0000 (0x0048 - 0x0048)
class UFortNavigationFilter_IgnoreSmashingCost final : public UNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavigationFilter_IgnoreSmashingCost">();
	}
	static class UFortNavigationFilter_IgnoreSmashingCost* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavigationFilter_IgnoreSmashingCost>();
	}
};
static_assert(alignof(UFortNavigationFilter_IgnoreSmashingCost) == 0x000008, "Wrong alignment on UFortNavigationFilter_IgnoreSmashingCost");
static_assert(sizeof(UFortNavigationFilter_IgnoreSmashingCost) == 0x000048, "Wrong size on UFortNavigationFilter_IgnoreSmashingCost");

// Class FortniteGame.FortPlayerStateAthena
// 0x0038 (0x0DD0 - 0x0D98)
class AFortPlayerStateAthena final : public AFortPlayerStatePvP
{
public:
	struct FDeathInfo                             DeathInfo;                                         // 0x0D98(0x0010)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	EFortTeam                                     TeamIndex;                                         // 0x0DA8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasWonAGame;                                      // 0x0DA9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DAA[0x2];                                      // 0x0DAA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Place;                                             // 0x0DAC(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Kills;                                             // 0x0DB0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Downs;                                             // 0x0DB4(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MapIndicatorPos;                                   // 0x0DB8(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTalking;                                        // 0x0DC0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMuted;                                          // 0x0DC1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC2[0x2];                                      // 0x0DC2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SecondsAlive;                                      // 0x0DC4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_DC8[0x8];                                      // 0x0DC8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientReportDBNO(const class FString& DBNOPlayersName);
	void ClientReportKill(const class FString& KilledPlayersName);
	void OnRep_DeathInfo();
	void OnRep_Downs();
	void OnRep_Kills();
	void OnRep_Place();
	void OnRep_TeamIndex();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerStateAthena">();
	}
	static class AFortPlayerStateAthena* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerStateAthena>();
	}
};
static_assert(alignof(AFortPlayerStateAthena) == 0x000008, "Wrong alignment on AFortPlayerStateAthena");
static_assert(sizeof(AFortPlayerStateAthena) == 0x000DD0, "Wrong size on AFortPlayerStateAthena");
static_assert(offsetof(AFortPlayerStateAthena, DeathInfo) == 0x000D98, "Member 'AFortPlayerStateAthena::DeathInfo' has a wrong offset!");
static_assert(offsetof(AFortPlayerStateAthena, TeamIndex) == 0x000DA8, "Member 'AFortPlayerStateAthena::TeamIndex' has a wrong offset!");
static_assert(offsetof(AFortPlayerStateAthena, bHasWonAGame) == 0x000DA9, "Member 'AFortPlayerStateAthena::bHasWonAGame' has a wrong offset!");
static_assert(offsetof(AFortPlayerStateAthena, Place) == 0x000DAC, "Member 'AFortPlayerStateAthena::Place' has a wrong offset!");
static_assert(offsetof(AFortPlayerStateAthena, Kills) == 0x000DB0, "Member 'AFortPlayerStateAthena::Kills' has a wrong offset!");
static_assert(offsetof(AFortPlayerStateAthena, Downs) == 0x000DB4, "Member 'AFortPlayerStateAthena::Downs' has a wrong offset!");
static_assert(offsetof(AFortPlayerStateAthena, MapIndicatorPos) == 0x000DB8, "Member 'AFortPlayerStateAthena::MapIndicatorPos' has a wrong offset!");
static_assert(offsetof(AFortPlayerStateAthena, bIsTalking) == 0x000DC0, "Member 'AFortPlayerStateAthena::bIsTalking' has a wrong offset!");
static_assert(offsetof(AFortPlayerStateAthena, bIsMuted) == 0x000DC1, "Member 'AFortPlayerStateAthena::bIsMuted' has a wrong offset!");
static_assert(offsetof(AFortPlayerStateAthena, SecondsAlive) == 0x000DC4, "Member 'AFortPlayerStateAthena::SecondsAlive' has a wrong offset!");

// Class FortniteGame.FortNavigationFilter_NoSmashing
// 0x0000 (0x0048 - 0x0048)
class UFortNavigationFilter_NoSmashing final : public UNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavigationFilter_NoSmashing">();
	}
	static class UFortNavigationFilter_NoSmashing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavigationFilter_NoSmashing>();
	}
};
static_assert(alignof(UFortNavigationFilter_NoSmashing) == 0x000008, "Wrong alignment on UFortNavigationFilter_NoSmashing");
static_assert(sizeof(UFortNavigationFilter_NoSmashing) == 0x000048, "Wrong size on UFortNavigationFilter_NoSmashing");

// Class FortniteGame.FortNavigationFilter_NoSmashingIncludeLow
// 0x0000 (0x0048 - 0x0048)
class UFortNavigationFilter_NoSmashingIncludeLow final : public UNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavigationFilter_NoSmashingIncludeLow">();
	}
	static class UFortNavigationFilter_NoSmashingIncludeLow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavigationFilter_NoSmashingIncludeLow>();
	}
};
static_assert(alignof(UFortNavigationFilter_NoSmashingIncludeLow) == 0x000008, "Wrong alignment on UFortNavigationFilter_NoSmashingIncludeLow");
static_assert(sizeof(UFortNavigationFilter_NoSmashingIncludeLow) == 0x000048, "Wrong size on UFortNavigationFilter_NoSmashingIncludeLow");

// Class FortniteGame.FortNavigationFilter_TetherZone
// 0x0000 (0x0048 - 0x0048)
class UFortNavigationFilter_TetherZone final : public UNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavigationFilter_TetherZone">();
	}
	static class UFortNavigationFilter_TetherZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavigationFilter_TetherZone>();
	}
};
static_assert(alignof(UFortNavigationFilter_TetherZone) == 0x000008, "Wrong alignment on UFortNavigationFilter_TetherZone");
static_assert(sizeof(UFortNavigationFilter_TetherZone) == 0x000048, "Wrong size on UFortNavigationFilter_TetherZone");

// Class FortniteGame.FortNavigationMetaFilter
// 0x0000 (0x0048 - 0x0048)
class UFortNavigationMetaFilter : public UNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavigationMetaFilter">();
	}
	static class UFortNavigationMetaFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavigationMetaFilter>();
	}
};
static_assert(alignof(UFortNavigationMetaFilter) == 0x000008, "Wrong alignment on UFortNavigationMetaFilter");
static_assert(sizeof(UFortNavigationMetaFilter) == 0x000048, "Wrong size on UFortNavigationMetaFilter");

// Class FortniteGame.FortNavigationFilter_Hunting
// 0x0000 (0x0048 - 0x0048)
class UFortNavigationFilter_Hunting final : public UFortNavigationMetaFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavigationFilter_Hunting">();
	}
	static class UFortNavigationFilter_Hunting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavigationFilter_Hunting>();
	}
};
static_assert(alignof(UFortNavigationFilter_Hunting) == 0x000008, "Wrong alignment on UFortNavigationFilter_Hunting");
static_assert(sizeof(UFortNavigationFilter_Hunting) == 0x000048, "Wrong size on UFortNavigationFilter_Hunting");

// Class FortniteGame.FortNavLinkBlockerComponent
// 0x0000 (0x06A0 - 0x06A0)
class UFortNavLinkBlockerComponent final : public UBoxComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavLinkBlockerComponent">();
	}
	static class UFortNavLinkBlockerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavLinkBlockerComponent>();
	}
};
static_assert(alignof(UFortNavLinkBlockerComponent) == 0x000010, "Wrong alignment on UFortNavLinkBlockerComponent");
static_assert(sizeof(UFortNavLinkBlockerComponent) == 0x0006A0, "Wrong size on UFortNavLinkBlockerComponent");

// Class FortniteGame.FortPushNotificationManager
// 0x0008 (0x0030 - 0x0028)
class UFortPushNotificationManager final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPushNotificationManager">();
	}
	static class UFortPushNotificationManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPushNotificationManager>();
	}
};
static_assert(alignof(UFortPushNotificationManager) == 0x000008, "Wrong alignment on UFortPushNotificationManager");
static_assert(sizeof(UFortPushNotificationManager) == 0x000030, "Wrong size on UFortPushNotificationManager");

// Class FortniteGame.FortNavLinkContainer
// 0x0000 (0x0388 - 0x0388)
class AFortNavLinkContainer final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavLinkContainer">();
	}
	static class AFortNavLinkContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortNavLinkContainer>();
	}
};
static_assert(alignof(AFortNavLinkContainer) == 0x000008, "Wrong alignment on AFortNavLinkContainer");
static_assert(sizeof(AFortNavLinkContainer) == 0x000388, "Wrong size on AFortNavLinkContainer");

// Class FortniteGame.FortNavLinkDefinition
// 0x0030 (0x0080 - 0x0050)
class UFortNavLinkDefinition : public UNavLinkDefinition
{
public:
	struct FFortNavLinkPattern                    Pattern;                                           // 0x0050(0x0008)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FFortNavLinkPattern>            AdditionalPatterns;                                // 0x0058(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<EBuildingStairsRailing>                StairsRailing;                                     // 0x0068(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EBuildingFloorRailing                         FloorRailing;                                      // 0x0078(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortNavLinkPattern                           PatternType;                                       // 0x0079(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A[0x6];                                       // 0x007A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavLinkDefinition">();
	}
	static class UFortNavLinkDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavLinkDefinition>();
	}
};
static_assert(alignof(UFortNavLinkDefinition) == 0x000008, "Wrong alignment on UFortNavLinkDefinition");
static_assert(sizeof(UFortNavLinkDefinition) == 0x000080, "Wrong size on UFortNavLinkDefinition");
static_assert(offsetof(UFortNavLinkDefinition, Pattern) == 0x000050, "Member 'UFortNavLinkDefinition::Pattern' has a wrong offset!");
static_assert(offsetof(UFortNavLinkDefinition, AdditionalPatterns) == 0x000058, "Member 'UFortNavLinkDefinition::AdditionalPatterns' has a wrong offset!");
static_assert(offsetof(UFortNavLinkDefinition, StairsRailing) == 0x000068, "Member 'UFortNavLinkDefinition::StairsRailing' has a wrong offset!");
static_assert(offsetof(UFortNavLinkDefinition, FloorRailing) == 0x000078, "Member 'UFortNavLinkDefinition::FloorRailing' has a wrong offset!");
static_assert(offsetof(UFortNavLinkDefinition, PatternType) == 0x000079, "Member 'UFortNavLinkDefinition::PatternType' has a wrong offset!");

// Class FortniteGame.FortNavMesh
// 0x0008 (0x0630 - 0x0628)
class AFortNavMesh final : public ARecastNavMesh
{
public:
	class UFortAIHotSpotManager*                  HotSpotManager;                                    // 0x0628(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavMesh">();
	}
	static class AFortNavMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortNavMesh>();
	}
};
static_assert(alignof(AFortNavMesh) == 0x000008, "Wrong alignment on AFortNavMesh");
static_assert(sizeof(AFortNavMesh) == 0x000630, "Wrong size on AFortNavMesh");
static_assert(offsetof(AFortNavMesh, HotSpotManager) == 0x000628, "Member 'AFortNavMesh::HotSpotManager' has a wrong offset!");

// Class FortniteGame.FortDialogNotificationHandler
// 0x01A0 (0x01E0 - 0x0040)
class UFortDialogNotificationHandler : public UFortNotificationHandler
{
public:
	UMulticastDelegateProperty_                   OnAccepted;                                        // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnDeclined;                                        // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnTimedOut;                                        // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	struct FFortDialogDescription                 DialogDescription;                                 // 0x0070(0x0170)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void Accept();
	void Decline();
	void SetDialogDescription(const struct FFortDialogDescription& InDialogDescription);
	void Timeout();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDialogNotificationHandler">();
	}
	static class UFortDialogNotificationHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDialogNotificationHandler>();
	}
};
static_assert(alignof(UFortDialogNotificationHandler) == 0x000010, "Wrong alignment on UFortDialogNotificationHandler");
static_assert(sizeof(UFortDialogNotificationHandler) == 0x0001E0, "Wrong size on UFortDialogNotificationHandler");
static_assert(offsetof(UFortDialogNotificationHandler, OnAccepted) == 0x000040, "Member 'UFortDialogNotificationHandler::OnAccepted' has a wrong offset!");
static_assert(offsetof(UFortDialogNotificationHandler, OnDeclined) == 0x000050, "Member 'UFortDialogNotificationHandler::OnDeclined' has a wrong offset!");
static_assert(offsetof(UFortDialogNotificationHandler, OnTimedOut) == 0x000060, "Member 'UFortDialogNotificationHandler::OnTimedOut' has a wrong offset!");
static_assert(offsetof(UFortDialogNotificationHandler, DialogDescription) == 0x000070, "Member 'UFortDialogNotificationHandler::DialogDescription' has a wrong offset!");

// Class FortniteGame.FortNotificationMessage
// 0x0000 (0x0028 - 0x0028)
class UFortNotificationMessage final : public ULocalMessage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNotificationMessage">();
	}
	static class UFortNotificationMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNotificationMessage>();
	}
};
static_assert(alignof(UFortNotificationMessage) == 0x000008, "Wrong alignment on UFortNotificationMessage");
static_assert(sizeof(UFortNotificationMessage) == 0x000028, "Wrong size on UFortNotificationMessage");

// Class FortniteGame.FortOnlineAccountMobile
// 0x0000 (0x09B0 - 0x09B0)
class UFortOnlineAccountMobile final : public UFortOnlineAccount
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortOnlineAccountMobile">();
	}
	static class UFortOnlineAccountMobile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortOnlineAccountMobile>();
	}
};
static_assert(alignof(UFortOnlineAccountMobile) == 0x000008, "Wrong alignment on UFortOnlineAccountMobile");
static_assert(sizeof(UFortOnlineAccountMobile) == 0x0009B0, "Wrong size on UFortOnlineAccountMobile");

// Class FortniteGame.FortOnlineBeaconHost
// 0x0000 (0x0468 - 0x0468)
class AFortOnlineBeaconHost final : public AOnlineBeaconHost
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortOnlineBeaconHost">();
	}
	static class AFortOnlineBeaconHost* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortOnlineBeaconHost>();
	}
};
static_assert(alignof(AFortOnlineBeaconHost) == 0x000008, "Wrong alignment on AFortOnlineBeaconHost");
static_assert(sizeof(AFortOnlineBeaconHost) == 0x000468, "Wrong size on AFortOnlineBeaconHost");

// Class FortniteGame.FortOnlineSessionClient
// 0x0170 (0x0430 - 0x02C0)
class UFortOnlineSessionClient final : public UOnlineSessionClient
{
public:
	uint8                                         Pad_2C0[0x170];                                    // 0x02C0(0x0170)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortOnlineSessionClient">();
	}
	static class UFortOnlineSessionClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortOnlineSessionClient>();
	}
};
static_assert(alignof(UFortOnlineSessionClient) == 0x000008, "Wrong alignment on UFortOnlineSessionClient");
static_assert(sizeof(UFortOnlineSessionClient) == 0x000430, "Wrong size on UFortOnlineSessionClient");

// Class FortniteGame.FortQueryTest_MissionSameMap
// 0x0048 (0x0208 - 0x01C0)
class UFortQueryTest_MissionSameMap final : public UEnvQueryTest
{
public:
	struct FGameplayTagQuery                      MissionPlacementActorTagQuery;                     // 0x01C0(0x0048)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_MissionSameMap">();
	}
	static class UFortQueryTest_MissionSameMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_MissionSameMap>();
	}
};
static_assert(alignof(UFortQueryTest_MissionSameMap) == 0x000008, "Wrong alignment on UFortQueryTest_MissionSameMap");
static_assert(sizeof(UFortQueryTest_MissionSameMap) == 0x000208, "Wrong size on UFortQueryTest_MissionSameMap");
static_assert(offsetof(UFortQueryTest_MissionSameMap, MissionPlacementActorTagQuery) == 0x0001C0, "Member 'UFortQueryTest_MissionSameMap::MissionPlacementActorTagQuery' has a wrong offset!");

// Class FortniteGame.FortOutpostContext
// 0x0040 (0x0068 - 0x0028)
class UFortOutpostContext final : public UBlueprintContextBase
{
public:
	UMulticastDelegateProperty_                   OnBuildingLevelChanged;                            // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnItemsNeedRefresh;                                // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnGooContentNeedRefresh;                           // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnCraftingTableActivationBonusChanged;             // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void DepositPOSTResource(const class UFortItemDefinition* ResourceItem, int32 Count);
	void UpgradeBuilding(EOutpostBuildings OutpostBuilding);
	void UpgradeBuildingByDefinition(class UFortOutpostItemDefinition* BuildingToUpgrade);
	void UpgradePOST();

	bool CanUpgradeBuilding(EOutpostBuildings OutpostBuilding, bool bLog) const;
	bool CanUpgradeBuildingFromDefinition(class UFortOutpostItemDefinition* OutpostBuilding, bool bLog) const;
	bool CanUpgradePOST() const;
	int32 GetBuildingLevel(EOutpostBuildings OutpostBuilding) const;
	int32 GetBuildingLevelFromDefinition(class UFortOutpostItemDefinition* OutpostBuilding) const;
	int32 GetBuildingMaxLevel(EOutpostBuildings OutpostBuilding) const;
	int32 GetBuildingMaxLevelFromDefinition(class UFortOutpostItemDefinition* OutpostBuilding) const;
	void GetBuildingUpgradeCost(EOutpostBuildings OutpostBuilding, TArray<struct FFortItemQuantityPair>* OutWorldItems, TArray<struct FFortItemQuantityPair>* OutAccountItems) const;
	void GetBuildingUpgradeCostFromDefinition(class UFortOutpostItemDefinition* OutpostBuilding, TArray<struct FFortItemQuantityPair>* OutWorldItems, TArray<struct FFortItemQuantityPair>* OutAccountItems) const;
	class UFortWorldItemDefinition* GetHarvestingToolForLevel(int32 InHarvestingOptimizerLevel) const;
	TArray<class UOutpostPOSTRequirementData*> GetNextPOSTLevelRequirements() const;
	int32 GetOutpostCoreLevel() const;
	float GetPOSTBuildingHealthMod(int32 POSTLevel) const;
	void LeaveOutpostAsParty() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortOutpostContext">();
	}
	static class UFortOutpostContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortOutpostContext>();
	}
};
static_assert(alignof(UFortOutpostContext) == 0x000008, "Wrong alignment on UFortOutpostContext");
static_assert(sizeof(UFortOutpostContext) == 0x000068, "Wrong size on UFortOutpostContext");
static_assert(offsetof(UFortOutpostContext, OnBuildingLevelChanged) == 0x000028, "Member 'UFortOutpostContext::OnBuildingLevelChanged' has a wrong offset!");
static_assert(offsetof(UFortOutpostContext, OnItemsNeedRefresh) == 0x000038, "Member 'UFortOutpostContext::OnItemsNeedRefresh' has a wrong offset!");
static_assert(offsetof(UFortOutpostContext, OnGooContentNeedRefresh) == 0x000048, "Member 'UFortOutpostContext::OnGooContentNeedRefresh' has a wrong offset!");
static_assert(offsetof(UFortOutpostContext, OnCraftingTableActivationBonusChanged) == 0x000058, "Member 'UFortOutpostContext::OnCraftingTableActivationBonusChanged' has a wrong offset!");

// Class FortniteGame.FortPackPersonality
// 0x00E0 (0x0108 - 0x0028)
class UFortPackPersonality final : public UDataAsset
{
public:
	class USoundCue*                              TickleVOSound;                                     // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              TickleSFXSound;                                    // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              HoverVOSound;                                      // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              BuySFXSound;                                       // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              OpenGenericVO_Sound;                               // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              OpenGenericSFX_Sound;                              // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              UpgradeSilverVO_Sound;                             // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              UpgradeSilverSFX_Sound;                            // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              OpenSilverVO_Sound;                                // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              OpenSilverSFX_Sound;                               // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              UpgradeGoldVO_Sound;                               // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              UpgradeGoldSFX_Sound;                              // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              OpenGoldVO_Sound;                                  // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              OpenGoldSFX_Sound;                                 // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              GreetGenericVO_Sound;                              // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              GreetAxeVO_Sound;                                  // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              GreetBaseballBatVO_Sound;                          // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              GreetGardenHoeVO_Sound;                            // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              GreetGardenRakeVO_Sound;                           // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              GreetHockeyStickVO_Sound;                          // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              GreetPickAxeVO_Sound;                              // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              GreetPitchforkVO_Sound;                            // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              GreetScytheVO_Sound;                               // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              GreetSledgehammerVO_Sound;                         // 0x00E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              GreetSwordVO_Sound;                                // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              PreHitVO_Sound;                                    // 0x00F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              DropMusic_Sound;                                   // 0x00F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              OpenMusic_Sound;                                   // 0x0100(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPackPersonality">();
	}
	static class UFortPackPersonality* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPackPersonality>();
	}
};
static_assert(alignof(UFortPackPersonality) == 0x000008, "Wrong alignment on UFortPackPersonality");
static_assert(sizeof(UFortPackPersonality) == 0x000108, "Wrong size on UFortPackPersonality");
static_assert(offsetof(UFortPackPersonality, TickleVOSound) == 0x000028, "Member 'UFortPackPersonality::TickleVOSound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, TickleSFXSound) == 0x000030, "Member 'UFortPackPersonality::TickleSFXSound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, HoverVOSound) == 0x000038, "Member 'UFortPackPersonality::HoverVOSound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, BuySFXSound) == 0x000040, "Member 'UFortPackPersonality::BuySFXSound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, OpenGenericVO_Sound) == 0x000048, "Member 'UFortPackPersonality::OpenGenericVO_Sound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, OpenGenericSFX_Sound) == 0x000050, "Member 'UFortPackPersonality::OpenGenericSFX_Sound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, UpgradeSilverVO_Sound) == 0x000058, "Member 'UFortPackPersonality::UpgradeSilverVO_Sound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, UpgradeSilverSFX_Sound) == 0x000060, "Member 'UFortPackPersonality::UpgradeSilverSFX_Sound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, OpenSilverVO_Sound) == 0x000068, "Member 'UFortPackPersonality::OpenSilverVO_Sound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, OpenSilverSFX_Sound) == 0x000070, "Member 'UFortPackPersonality::OpenSilverSFX_Sound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, UpgradeGoldVO_Sound) == 0x000078, "Member 'UFortPackPersonality::UpgradeGoldVO_Sound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, UpgradeGoldSFX_Sound) == 0x000080, "Member 'UFortPackPersonality::UpgradeGoldSFX_Sound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, OpenGoldVO_Sound) == 0x000088, "Member 'UFortPackPersonality::OpenGoldVO_Sound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, OpenGoldSFX_Sound) == 0x000090, "Member 'UFortPackPersonality::OpenGoldSFX_Sound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, GreetGenericVO_Sound) == 0x000098, "Member 'UFortPackPersonality::GreetGenericVO_Sound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, GreetAxeVO_Sound) == 0x0000A0, "Member 'UFortPackPersonality::GreetAxeVO_Sound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, GreetBaseballBatVO_Sound) == 0x0000A8, "Member 'UFortPackPersonality::GreetBaseballBatVO_Sound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, GreetGardenHoeVO_Sound) == 0x0000B0, "Member 'UFortPackPersonality::GreetGardenHoeVO_Sound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, GreetGardenRakeVO_Sound) == 0x0000B8, "Member 'UFortPackPersonality::GreetGardenRakeVO_Sound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, GreetHockeyStickVO_Sound) == 0x0000C0, "Member 'UFortPackPersonality::GreetHockeyStickVO_Sound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, GreetPickAxeVO_Sound) == 0x0000C8, "Member 'UFortPackPersonality::GreetPickAxeVO_Sound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, GreetPitchforkVO_Sound) == 0x0000D0, "Member 'UFortPackPersonality::GreetPitchforkVO_Sound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, GreetScytheVO_Sound) == 0x0000D8, "Member 'UFortPackPersonality::GreetScytheVO_Sound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, GreetSledgehammerVO_Sound) == 0x0000E0, "Member 'UFortPackPersonality::GreetSledgehammerVO_Sound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, GreetSwordVO_Sound) == 0x0000E8, "Member 'UFortPackPersonality::GreetSwordVO_Sound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, PreHitVO_Sound) == 0x0000F0, "Member 'UFortPackPersonality::PreHitVO_Sound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, DropMusic_Sound) == 0x0000F8, "Member 'UFortPackPersonality::DropMusic_Sound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, OpenMusic_Sound) == 0x000100, "Member 'UFortPackPersonality::OpenMusic_Sound' has a wrong offset!");

// Class FortniteGame.FortParty
// 0x0438 (0x08C0 - 0x0488)
class UFortParty final : public UParty
{
public:
	bool                                          bTutorialCompleted;                                // 0x0488(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsLeavingConsoleSession;                          // 0x0489(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bWasKickedFromLastParty;                           // 0x048A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48B[0x435];                                    // 0x048B(0x0435)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortParty">();
	}
	static class UFortParty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortParty>();
	}
};
static_assert(alignof(UFortParty) == 0x000008, "Wrong alignment on UFortParty");
static_assert(sizeof(UFortParty) == 0x0008C0, "Wrong size on UFortParty");
static_assert(offsetof(UFortParty, bTutorialCompleted) == 0x000488, "Member 'UFortParty::bTutorialCompleted' has a wrong offset!");
static_assert(offsetof(UFortParty, bIsLeavingConsoleSession) == 0x000489, "Member 'UFortParty::bIsLeavingConsoleSession' has a wrong offset!");
static_assert(offsetof(UFortParty, bWasKickedFromLastParty) == 0x00048A, "Member 'UFortParty::bWasKickedFromLastParty' has a wrong offset!");

// Class FortniteGame.FortPartyBeaconClient
// 0x00E0 (0x0650 - 0x0570)
class AFortPartyBeaconClient final : public APartyBeaconClient
{
public:
	struct FEmptyServerReservation                PendingEmptyReservation;                           // 0x0570(0x0048)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B8[0x88];                                     // 0x05B8(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReconnectionInitialTimeout;                        // 0x0640(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReconnectionTimeout;                               // 0x0644(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasReconnected;                                   // 0x0648(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_649[0x7];                                      // 0x0649(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientAbandonResponse(EPartyReservationResult ReservationResponse);
	void ClientAllowedToProceedFromReservation();
	void ClientAllowedToProceedFromReservationTimeout();
	void ClientReconnectResponse(EPartyReservationResult ReservationResponse);
	void ServerAbandonExistingReservation(const class FString& InSessionId, const struct FUniqueNetIdRepl& RequestingPlayer);
	void ServerEmptyServerReservationRequest(const class FString& InSessionId, const struct FEmptyServerReservation& ReservationData, const struct FPartyReservation& Reservation);
	void ServerReconnectExistingReservation(const class FString& InSessionId, const struct FUniqueNetIdRepl& RequestingPlayer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPartyBeaconClient">();
	}
	static class AFortPartyBeaconClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPartyBeaconClient>();
	}
};
static_assert(alignof(AFortPartyBeaconClient) == 0x000008, "Wrong alignment on AFortPartyBeaconClient");
static_assert(sizeof(AFortPartyBeaconClient) == 0x000650, "Wrong size on AFortPartyBeaconClient");
static_assert(offsetof(AFortPartyBeaconClient, PendingEmptyReservation) == 0x000570, "Member 'AFortPartyBeaconClient::PendingEmptyReservation' has a wrong offset!");
static_assert(offsetof(AFortPartyBeaconClient, ReconnectionInitialTimeout) == 0x000640, "Member 'AFortPartyBeaconClient::ReconnectionInitialTimeout' has a wrong offset!");
static_assert(offsetof(AFortPartyBeaconClient, ReconnectionTimeout) == 0x000644, "Member 'AFortPartyBeaconClient::ReconnectionTimeout' has a wrong offset!");
static_assert(offsetof(AFortPartyBeaconClient, bHasReconnected) == 0x000648, "Member 'AFortPartyBeaconClient::bHasReconnected' has a wrong offset!");

// Class FortniteGame.FortPartyBeaconHost
// 0x00D0 (0x05E0 - 0x0510)
class AFortPartyBeaconHost final : public APartyBeaconHost
{
public:
	uint8                                         Pad_510[0xD0];                                     // 0x0510(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPartyBeaconHost">();
	}
	static class AFortPartyBeaconHost* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPartyBeaconHost>();
	}
};
static_assert(alignof(AFortPartyBeaconHost) == 0x000008, "Wrong alignment on AFortPartyBeaconHost");
static_assert(sizeof(AFortPartyBeaconHost) == 0x0005E0, "Wrong size on AFortPartyBeaconHost");

// Class FortniteGame.FortPartyGameState
// 0x07F8 (0x0DD0 - 0x05D8)
class UFortPartyGameState final : public UPartyGameState
{
public:
	struct FFortPartyRepState                     PartyState;                                        // 0x05D8(0x0078)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_650[0x780];                                    // 0x0650(0x0780)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPartyGameState">();
	}
	static class UFortPartyGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPartyGameState>();
	}
};
static_assert(alignof(UFortPartyGameState) == 0x000008, "Wrong alignment on UFortPartyGameState");
static_assert(sizeof(UFortPartyGameState) == 0x000DD0, "Wrong size on UFortPartyGameState");
static_assert(offsetof(UFortPartyGameState, PartyState) == 0x0005D8, "Member 'UFortPartyGameState::PartyState' has a wrong offset!");

// Class FortniteGame.FortPartyMemberState
// 0x0088 (0x0100 - 0x0078)
class UFortPartyMemberState final : public UPartyMemberState
{
public:
	struct FFortPartyMemberRepState               MemberState;                                       // 0x0078(0x0080)(Transient, NativeAccessSpecifierPrivate)
	class UFortHeroType*                          HeroType;                                          // 0x00F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPartyMemberState">();
	}
	static class UFortPartyMemberState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPartyMemberState>();
	}
};
static_assert(alignof(UFortPartyMemberState) == 0x000008, "Wrong alignment on UFortPartyMemberState");
static_assert(sizeof(UFortPartyMemberState) == 0x000100, "Wrong size on UFortPartyMemberState");
static_assert(offsetof(UFortPartyMemberState, MemberState) == 0x000078, "Member 'UFortPartyMemberState::MemberState' has a wrong offset!");
static_assert(offsetof(UFortPartyMemberState, HeroType) == 0x0000F8, "Member 'UFortPartyMemberState::HeroType' has a wrong offset!");

// Class FortniteGame.FortBotPawn
// 0x0000 (0x1AF0 - 0x1AF0)
class AFortBotPawn : public AFortAIPawn
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBotPawn">();
	}
	static class AFortBotPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortBotPawn>();
	}
};
static_assert(alignof(AFortBotPawn) == 0x000010, "Wrong alignment on AFortBotPawn");
static_assert(sizeof(AFortBotPawn) == 0x001AF0, "Wrong size on AFortBotPawn");

// Class FortniteGame.FortPawn_Flinger
// 0x0000 (0x1AF0 - 0x1AF0)
class AFortPawn_Flinger final : public AFortAIPawn
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPawn_Flinger">();
	}
	static class AFortPawn_Flinger* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPawn_Flinger>();
	}
};
static_assert(alignof(AFortPawn_Flinger) == 0x000010, "Wrong alignment on AFortPawn_Flinger");
static_assert(sizeof(AFortPawn_Flinger) == 0x001AF0, "Wrong size on AFortPawn_Flinger");

// Class FortniteGame.FortRegisteredPlayerInfoTooltip
// 0x0000 (0x0090 - 0x0090)
class UFortRegisteredPlayerInfoTooltip final : public UFortTooltip
{
public:
	bool GetNumericValue(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, float* OutVal) const;
	bool GetTextForToken(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, class FText* OutText) const;
	bool GetTokenizedDescriptionText(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, TArray<class FText>* OutDescription) const;
	bool GetValueData(const class UObject* ObjectToDescribe, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, struct FFortTooltipValueData* OutData) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortRegisteredPlayerInfoTooltip">();
	}
	static class UFortRegisteredPlayerInfoTooltip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortRegisteredPlayerInfoTooltip>();
	}
};
static_assert(alignof(UFortRegisteredPlayerInfoTooltip) == 0x000008, "Wrong alignment on UFortRegisteredPlayerInfoTooltip");
static_assert(sizeof(UFortRegisteredPlayerInfoTooltip) == 0x000090, "Wrong size on UFortRegisteredPlayerInfoTooltip");

// Class FortniteGame.FortPawn_InteractablePawn
// 0x0010 (0x1B00 - 0x1AF0)
class AFortPawn_InteractablePawn final : public AFortAIPawn
{
public:
	struct FGuid                                  MyGuid;                                            // 0x1AE8(0x0010)(SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AF8[0x8];                                     // 0x1AF8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BlueprintOnBeginInteract();
	void BlueprintOnInteract(const class AFortPawn* InteractingPawn);

	bool BlueprintCanInteract(const class AFortPawn* InteractingPawn) const;
	class FText BlueprintGetInteractionString(const class AFortPawn* InteractingPawn) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPawn_InteractablePawn">();
	}
	static class AFortPawn_InteractablePawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPawn_InteractablePawn>();
	}
};
static_assert(alignof(AFortPawn_InteractablePawn) == 0x000010, "Wrong alignment on AFortPawn_InteractablePawn");
static_assert(sizeof(AFortPawn_InteractablePawn) == 0x001B00, "Wrong size on AFortPawn_InteractablePawn");
static_assert(offsetof(AFortPawn_InteractablePawn, MyGuid) == 0x001AE8, "Member 'AFortPawn_InteractablePawn::MyGuid' has a wrong offset!");

// Class FortniteGame.FortPawn_FeedbackAnnouncer
// 0x0000 (0x0EE0 - 0x0EE0)
class AFortPawn_FeedbackAnnouncer : public AFortPawn
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPawn_FeedbackAnnouncer">();
	}
	static class AFortPawn_FeedbackAnnouncer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPawn_FeedbackAnnouncer>();
	}
};
static_assert(alignof(AFortPawn_FeedbackAnnouncer) == 0x000010, "Wrong alignment on AFortPawn_FeedbackAnnouncer");
static_assert(sizeof(AFortPawn_FeedbackAnnouncer) == 0x000EE0, "Wrong size on AFortPawn_FeedbackAnnouncer");

// Class FortniteGame.FortQueryTest_GoalFrustrationDiscouragement
// 0x0000 (0x01D8 - 0x01D8)
class UFortQueryTest_GoalFrustrationDiscouragement final : public UFortQueryTest_GoalBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_GoalFrustrationDiscouragement">();
	}
	static class UFortQueryTest_GoalFrustrationDiscouragement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_GoalFrustrationDiscouragement>();
	}
};
static_assert(alignof(UFortQueryTest_GoalFrustrationDiscouragement) == 0x000008, "Wrong alignment on UFortQueryTest_GoalFrustrationDiscouragement");
static_assert(sizeof(UFortQueryTest_GoalFrustrationDiscouragement) == 0x0001D8, "Wrong size on UFortQueryTest_GoalFrustrationDiscouragement");

// Class FortniteGame.FortPermaniteStructureInterface
// 0x0000 (0x0028 - 0x0028)
class IFortPermaniteStructureInterface final : public IInterface
{
public:
	void OnBoundariesChanged(int32 MinLevel, int32 MaxLevel, int32 CurrentLevel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPermaniteStructureInterface">();
	}
	static class IFortPermaniteStructureInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortPermaniteStructureInterface>();
	}
};
static_assert(alignof(IFortPermaniteStructureInterface) == 0x000008, "Wrong alignment on IFortPermaniteStructureInterface");
static_assert(sizeof(IFortPermaniteStructureInterface) == 0x000028, "Wrong size on IFortPermaniteStructureInterface");

// Class FortniteGame.FortDeployableBasePickup
// 0x0018 (0x05A0 - 0x0588)
class AFortDeployableBasePickup final : public AFortPickup
{
public:
	struct FUniqueNetIdRepl                       AssociatedPlotOccupant;                            // 0x0588(0x0018)(Net, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDeployableBasePickup">();
	}
	static class AFortDeployableBasePickup* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortDeployableBasePickup>();
	}
};
static_assert(alignof(AFortDeployableBasePickup) == 0x000008, "Wrong alignment on AFortDeployableBasePickup");
static_assert(sizeof(AFortDeployableBasePickup) == 0x0005A0, "Wrong size on AFortDeployableBasePickup");
static_assert(offsetof(AFortDeployableBasePickup, AssociatedPlotOccupant) == 0x000588, "Member 'AFortDeployableBasePickup::AssociatedPlotOccupant' has a wrong offset!");

// Class FortniteGame.FortPickupBackpack
// 0x0000 (0x0588 - 0x0588)
class AFortPickupBackpack final : public AFortPickup
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPickupBackpack">();
	}
	static class AFortPickupBackpack* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPickupBackpack>();
	}
};
static_assert(alignof(AFortPickupBackpack) == 0x000008, "Wrong alignment on AFortPickupBackpack");
static_assert(sizeof(AFortPickupBackpack) == 0x000588, "Wrong size on AFortPickupBackpack");

// Class FortniteGame.FortPlacedPawnMarker
// 0x0000 (0x03B0 - 0x03B0)
class AFortPlacedPawnMarker final : public ANavigationObjectBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlacedPawnMarker">();
	}
	static class AFortPlacedPawnMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlacedPawnMarker>();
	}
};
static_assert(alignof(AFortPlacedPawnMarker) == 0x000008, "Wrong alignment on AFortPlacedPawnMarker");
static_assert(sizeof(AFortPlacedPawnMarker) == 0x0003B0, "Wrong size on AFortPlacedPawnMarker");

// Class FortniteGame.FortQueryContext_AllEnemies
// 0x0000 (0x0028 - 0x0028)
class UFortQueryContext_AllEnemies final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_AllEnemies">();
	}
	static class UFortQueryContext_AllEnemies* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_AllEnemies>();
	}
};
static_assert(alignof(UFortQueryContext_AllEnemies) == 0x000008, "Wrong alignment on UFortQueryContext_AllEnemies");
static_assert(sizeof(UFortQueryContext_AllEnemies) == 0x000028, "Wrong size on UFortQueryContext_AllEnemies");

// Class FortniteGame.FortPlayerAttributesProxyActor
// 0x0058 (0x03E0 - 0x0388)
class AFortPlayerAttributesProxyActor final : public AActor
{
public:
	uint8                                         Pad_388[0x8];                                      // 0x0388(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortPlayerAttributeSets               AttributeSets;                                     // 0x0390(0x0048)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UFortAbilitySystemComponent*            AbilitySystemComponent;                            // 0x03D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerAttributesProxyActor">();
	}
	static class AFortPlayerAttributesProxyActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerAttributesProxyActor>();
	}
};
static_assert(alignof(AFortPlayerAttributesProxyActor) == 0x000008, "Wrong alignment on AFortPlayerAttributesProxyActor");
static_assert(sizeof(AFortPlayerAttributesProxyActor) == 0x0003E0, "Wrong size on AFortPlayerAttributesProxyActor");
static_assert(offsetof(AFortPlayerAttributesProxyActor, AttributeSets) == 0x000390, "Member 'AFortPlayerAttributesProxyActor::AttributeSets' has a wrong offset!");
static_assert(offsetof(AFortPlayerAttributesProxyActor, AbilitySystemComponent) == 0x0003D8, "Member 'AFortPlayerAttributesProxyActor::AbilitySystemComponent' has a wrong offset!");

// Class FortniteGame.FortFrontEndCameraManager
// 0x0060 (0x1FE0 - 0x1F80)
class AFortFrontEndCameraManager final : public AFortPlayerCameraBase
{
public:
	EFrontEndCamera                               CurrentCamera;                                     // 0x1F78(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F79[0x7];                                     // 0x1F79(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AFrontEndSettings*                      FrontEndSettings;                                  // 0x1F80(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F88[0x58];                                    // 0x1F88(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCamera(EFrontEndCamera NewCamera);

	EFrontEndCamera GetCamera() const;
	class AFortCameraBase* GetCameraActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortFrontEndCameraManager">();
	}
	static class AFortFrontEndCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortFrontEndCameraManager>();
	}
};
static_assert(alignof(AFortFrontEndCameraManager) == 0x000010, "Wrong alignment on AFortFrontEndCameraManager");
static_assert(sizeof(AFortFrontEndCameraManager) == 0x001FE0, "Wrong size on AFortFrontEndCameraManager");
static_assert(offsetof(AFortFrontEndCameraManager, CurrentCamera) == 0x001F78, "Member 'AFortFrontEndCameraManager::CurrentCamera' has a wrong offset!");
static_assert(offsetof(AFortFrontEndCameraManager, FrontEndSettings) == 0x001F80, "Member 'AFortFrontEndCameraManager::FrontEndSettings' has a wrong offset!");

// Class FortniteGame.FortReplaySpectator
// 0x00A0 (0x2570 - 0x24D0)
class AFortReplaySpectator final : public AFortPlayerControllerGameplay
{
public:
	class AFortPlayerPawn*                        FollowedPawn;                                      // 0x24D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 PlaybackSpeedLUT;                                  // 0x24D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_24E8[0x8];                                     // 0x24E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UPostProcessComponent*                  OutsideSafeZonePPComponent;                        // 0x24F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24F8[0x18];                                    // 0x24F8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortReplaySpectatorCameraComponent*    CurrentViewTargetSpectatorCameraComponent;         // 0x2510(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<ESpectatorCameraType, class ASpectatorPawn*> PawnMap;                                           // 0x2518(0x0050)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2568[0x8];                                     // 0x2568(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCloudAltitudes(float NewCloudAltitude);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortReplaySpectator">();
	}
	static class AFortReplaySpectator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortReplaySpectator>();
	}
};
static_assert(alignof(AFortReplaySpectator) == 0x000008, "Wrong alignment on AFortReplaySpectator");
static_assert(sizeof(AFortReplaySpectator) == 0x002570, "Wrong size on AFortReplaySpectator");
static_assert(offsetof(AFortReplaySpectator, FollowedPawn) == 0x0024D0, "Member 'AFortReplaySpectator::FollowedPawn' has a wrong offset!");
static_assert(offsetof(AFortReplaySpectator, PlaybackSpeedLUT) == 0x0024D8, "Member 'AFortReplaySpectator::PlaybackSpeedLUT' has a wrong offset!");
static_assert(offsetof(AFortReplaySpectator, OutsideSafeZonePPComponent) == 0x0024F0, "Member 'AFortReplaySpectator::OutsideSafeZonePPComponent' has a wrong offset!");
static_assert(offsetof(AFortReplaySpectator, CurrentViewTargetSpectatorCameraComponent) == 0x002510, "Member 'AFortReplaySpectator::CurrentViewTargetSpectatorCameraComponent' has a wrong offset!");
static_assert(offsetof(AFortReplaySpectator, PawnMap) == 0x002518, "Member 'AFortReplaySpectator::PawnMap' has a wrong offset!");

// Class FortniteGame.FortStaticMeshActor
// 0x0018 (0x03B0 - 0x0398)
class AFortStaticMeshActor final : public AStaticMeshActor
{
public:
	TArray<class UNavRelevantComponent*>          LinkComps;                                         // 0x0398(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bUseDefaultCullDistance : 1;                       // 0x03A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3A9[0x7];                                      // 0x03A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortStaticMeshActor">();
	}
	static class AFortStaticMeshActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortStaticMeshActor>();
	}
};
static_assert(alignof(AFortStaticMeshActor) == 0x000008, "Wrong alignment on AFortStaticMeshActor");
static_assert(sizeof(AFortStaticMeshActor) == 0x0003B0, "Wrong size on AFortStaticMeshActor");
static_assert(offsetof(AFortStaticMeshActor, LinkComps) == 0x000398, "Member 'AFortStaticMeshActor::LinkComps' has a wrong offset!");

// Class FortniteGame.FortPlayerCameraSpectator
// 0x0010 (0x19E0 - 0x19D0)
class AFortPlayerCameraSpectator final : public APlayerCameraManager
{
public:
	uint8                                         Pad_19C8[0x18];                                    // 0x19C8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerCameraSpectator">();
	}
	static class AFortPlayerCameraSpectator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerCameraSpectator>();
	}
};
static_assert(alignof(AFortPlayerCameraSpectator) == 0x000010, "Wrong alignment on AFortPlayerCameraSpectator");
static_assert(sizeof(AFortPlayerCameraSpectator) == 0x0019E0, "Wrong size on AFortPlayerCameraSpectator");

// Class FortniteGame.FortQueryContext_EncounterRandomDirection
// 0x0000 (0x0028 - 0x0028)
class UFortQueryContext_EncounterRandomDirection final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_EncounterRandomDirection">();
	}
	static class UFortQueryContext_EncounterRandomDirection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_EncounterRandomDirection>();
	}
};
static_assert(alignof(UFortQueryContext_EncounterRandomDirection) == 0x000008, "Wrong alignment on UFortQueryContext_EncounterRandomDirection");
static_assert(sizeof(UFortQueryContext_EncounterRandomDirection) == 0x000028, "Wrong size on UFortQueryContext_EncounterRandomDirection");

// Class FortniteGame.FortPlayerControllerFrontEnd
// 0x0000 (0x2440 - 0x2440)
class AFortPlayerControllerFrontEnd final : public AFortPlayerController
{
public:
	bool                                          bUnlockAllZones;                                   // 0x243C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_243D[0x3];                                     // 0x243D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerControllerFrontEnd">();
	}
	static class AFortPlayerControllerFrontEnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerControllerFrontEnd>();
	}
};
static_assert(alignof(AFortPlayerControllerFrontEnd) == 0x000008, "Wrong alignment on AFortPlayerControllerFrontEnd");
static_assert(sizeof(AFortPlayerControllerFrontEnd) == 0x002440, "Wrong size on AFortPlayerControllerFrontEnd");
static_assert(offsetof(AFortPlayerControllerFrontEnd, bUnlockAllZones) == 0x00243C, "Member 'AFortPlayerControllerFrontEnd::bUnlockAllZones' has a wrong offset!");

// Class FortniteGame.FortPlayerControllerDeployableBase
// 0x0170 (0x2AD0 - 0x2960)
class AFortPlayerControllerDeployableBase final : public AFortPlayerControllerZone
{
public:
	class ADeployableBasePlot*                    CurrentPlot;                                       // 0x2960(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ADeployableBasePlot*                    PreviousPlot;                                      // 0x2968(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2970[0x160];                                   // 0x2970(0x0160)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientOnHordeTierComplete(EFortCompletionResult Result);
	void ClientOnHordeTierInitialized(const TArray<struct FItemAndCount>& Items);
	void ClientOnHordeWaveComplete(const int32 Wave, const TArray<struct FItemAndCount>& Rewards);
	void MoveAllItemsFromDeployableBase();
	void MoveAllItemsToDeployableBase();
	void MoveItemFromDeployableBase(const struct FGuid& ItemOnPlot, const int32 Count);
	void MoveItemToDeployableBase(const struct FGuid& ItemOnPlayer, const int32 Count);
	void ServerMoveAllItemsFromDeployableBase(const class ADeployableBasePlot* ExpectedPlot);
	void ServerMoveAllItemsToDeployableBase(const class ADeployableBasePlot* ExpectedPlot);
	void ServerMoveItemFromDeployableBase(const struct FGuid& ItemOnPlot, const int32 Count, const class ADeployableBasePlot* ExpectedPlot);
	void ServerMoveItemToDeployableBase(const struct FGuid& ItemOnPlayer, const int32 Count, const class ADeployableBasePlot* ExpectedPlot);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerControllerDeployableBase">();
	}
	static class AFortPlayerControllerDeployableBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerControllerDeployableBase>();
	}
};
static_assert(alignof(AFortPlayerControllerDeployableBase) == 0x000008, "Wrong alignment on AFortPlayerControllerDeployableBase");
static_assert(sizeof(AFortPlayerControllerDeployableBase) == 0x002AD0, "Wrong size on AFortPlayerControllerDeployableBase");
static_assert(offsetof(AFortPlayerControllerDeployableBase, CurrentPlot) == 0x002960, "Member 'AFortPlayerControllerDeployableBase::CurrentPlot' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerDeployableBase, PreviousPlot) == 0x002968, "Member 'AFortPlayerControllerDeployableBase::PreviousPlot' has a wrong offset!");

// Class FortniteGame.FortPlayerControllerKeep
// 0x0020 (0x2980 - 0x2960)
class AFortPlayerControllerKeep final : public AFortPlayerControllerZone
{
public:
	uint8                                         Pad_2960[0x4];                                     // 0x2960(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         WorkshopPickedItems;                               // 0x2964(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ArmoryPickedItems;                                 // 0x2968(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_296C[0x14];                                    // 0x296C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientSetPermaniteAvailability(bool bAvailable);
	void ClientUnloadFoundations();
	void DumpItemData();
	void ResetContainers();
	void RestoreContainers();
	void SetPermaniteAvailability(bool bAvailable);
	void StreamInStuff();
	void StreamOutStuff();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerControllerKeep">();
	}
	static class AFortPlayerControllerKeep* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerControllerKeep>();
	}
};
static_assert(alignof(AFortPlayerControllerKeep) == 0x000008, "Wrong alignment on AFortPlayerControllerKeep");
static_assert(sizeof(AFortPlayerControllerKeep) == 0x002980, "Wrong size on AFortPlayerControllerKeep");
static_assert(offsetof(AFortPlayerControllerKeep, WorkshopPickedItems) == 0x002964, "Member 'AFortPlayerControllerKeep::WorkshopPickedItems' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerKeep, ArmoryPickedItems) == 0x002968, "Member 'AFortPlayerControllerKeep::ArmoryPickedItems' has a wrong offset!");

// Class FortniteGame.FortPlayerControllerManor
// 0x0040 (0x29A0 - 0x2960)
class AFortPlayerControllerManor final : public AFortPlayerControllerZone
{
public:
	uint8                                         Pad_2960[0x40];                                    // 0x2960(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientOpenManorPortalUnlockMenu(class AManorPortal* ManorPortal);
	void ServerOnUnlockPortalComplete(class AManorPortal* ManorPortal);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerControllerManor">();
	}
	static class AFortPlayerControllerManor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerControllerManor>();
	}
};
static_assert(alignof(AFortPlayerControllerManor) == 0x000008, "Wrong alignment on AFortPlayerControllerManor");
static_assert(sizeof(AFortPlayerControllerManor) == 0x0029A0, "Wrong size on AFortPlayerControllerManor");

// Class FortniteGame.FortQueryTest_GoalActorDot
// 0x0018 (0x01F0 - 0x01D8)
class UFortQueryTest_GoalActorDot final : public UFortQueryTest_GoalBase
{
public:
	TSubclassOf<class UEnvQueryContext>           LineATo;                                           // 0x01D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UEnvQueryContext>           LineBTo;                                           // 0x01E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortTestGoalActorDot                         TestMode;                                          // 0x01E8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAbsoluteValue;                                    // 0x01E9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1EA[0x6];                                      // 0x01EA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_GoalActorDot">();
	}
	static class UFortQueryTest_GoalActorDot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_GoalActorDot>();
	}
};
static_assert(alignof(UFortQueryTest_GoalActorDot) == 0x000008, "Wrong alignment on UFortQueryTest_GoalActorDot");
static_assert(sizeof(UFortQueryTest_GoalActorDot) == 0x0001F0, "Wrong size on UFortQueryTest_GoalActorDot");
static_assert(offsetof(UFortQueryTest_GoalActorDot, LineATo) == 0x0001D8, "Member 'UFortQueryTest_GoalActorDot::LineATo' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalActorDot, LineBTo) == 0x0001E0, "Member 'UFortQueryTest_GoalActorDot::LineBTo' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalActorDot, TestMode) == 0x0001E8, "Member 'UFortQueryTest_GoalActorDot::TestMode' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalActorDot, bAbsoluteValue) == 0x0001E9, "Member 'UFortQueryTest_GoalActorDot::bAbsoluteValue' has a wrong offset!");

// Class FortniteGame.FortPlayerControllerOutpost
// 0x0080 (0x29E0 - 0x2960)
class AFortPlayerControllerOutpost : public AFortPlayerControllerZone
{
public:
	UMulticastDelegateProperty_                   OnItemFabricated;                                  // 0x2960(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UFortOutpostItemDefinition*             BuildingBeingUpgraded;                             // 0x2970(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         LevelBeforeUpgrade;                                // 0x2978(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOutpostRefundDialogPending;                       // 0x297C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_297D[0x3];                                     // 0x297D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortWorldItemDefinition*               ItemPendingToFabricate;                            // 0x2980(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2988[0x10];                                    // 0x2988(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortWorldItem*                         FabricatedItemPendingForNotification;              // 0x2998(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29A0[0x8];                                     // 0x29A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         DisintegrationStartTime;                           // 0x29A8(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         QuantumGooCompleted;                               // 0x29B0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         QuantumGooIncoming;                                // 0x29B4(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29B8[0x8];                                     // 0x29B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFortDepositedResources>        PostDepositedResources;                            // 0x29C0(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsOutpostOwnerInPIE;                              // 0x29D0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29D1[0xF];                                     // 0x29D1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientOnBuildingLevelChanged(class UFortOutpostItemDefinition* UpgradedBuilding, int32 InLevelBeforeUpgrade);
	void ClientOnOutpostRefundOccurred();
	void DumpInventory();
	void OnRep_DisintegrationStartTime();
	void OnRep_PostDepositedResources();
	void OnRep_QuantumGooCompleted();
	void OnRep_QuantumGooIncoming();
	void ServeMoveItemFromStorageVault(const struct FFortItemEntry& NewlyCollectedItem);
	void ServeMoveItemToStorageVault(const struct FFortItemEntry& NewlyStoredItem);
	void ServerAbortDisintegration();
	void ServerActivateCraftingTable();
	void ServerDeactivateCraftingTable();
	void ServerDepositPOSTResource(const struct FGuid& ItemGuid, int32 Count);
	void ServerDisintegrateItem(const struct FGuid& ItemGuid, int32 Count);
	void ServerFabricateItem(const class UFortWorldItemDefinition* ItemDef);
	void ServerLeaveOutpostAsParty();
	void ServerNotifyPendingFabricationCompleted();
	void ServerUpgradeBuilding(class UFortOutpostItemDefinition* BuildingToUpgrade);
	void ServerUpgradePOST();
	void ToggleOwnerInPIE();
	void UpgradeBuilding(EOutpostBuildings OutpostBuilding);
	void UpgradeBuildingByDefinition(class UFortOutpostItemDefinition* OutpostBuilding);

	bool CanUpgradeBuilding(EOutpostBuildings OutpostBuilding, bool bLog) const;
	bool CanUpgradeBuildingFromDefinition(class UFortOutpostItemDefinition* OutpostBuilding, bool bLog) const;
	int32 GetBuildingLevel(EOutpostBuildings OutpostBuilding) const;
	int32 GetBuildingLevelFromDefinition(class UFortOutpostItemDefinition* OutpostBuilding) const;
	int32 GetBuildingMaxLevel(EOutpostBuildings OutpostBuilding) const;
	int32 GetBuildingMaxLevelFromDefinition(class UFortOutpostItemDefinition* OutpostBuilding) const;
	void GetBuildingUpgradeCost(EOutpostBuildings OutpostBuilding, TArray<struct FFortItemQuantityPair>* OutWorldItems, TArray<struct FFortItemQuantityPair>* OutAccountItems) const;
	void GetBuildingUpgradeCostFromDefinition(class UFortOutpostItemDefinition* OutpostBuilding, TArray<struct FFortItemQuantityPair>* OutWorldItems, TArray<struct FFortItemQuantityPair>* OutAccountItems) const;
	int32 GetOutpostCoreLevel() const;
	float GetPendingFabricationProgress() const;
	class UFortWorldItemDefinition* GetPendingItemToFabricate() const;
	bool IsFabricationPending() const;
	bool IsOutpostOwner() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerControllerOutpost">();
	}
	static class AFortPlayerControllerOutpost* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerControllerOutpost>();
	}
};
static_assert(alignof(AFortPlayerControllerOutpost) == 0x000008, "Wrong alignment on AFortPlayerControllerOutpost");
static_assert(sizeof(AFortPlayerControllerOutpost) == 0x0029E0, "Wrong size on AFortPlayerControllerOutpost");
static_assert(offsetof(AFortPlayerControllerOutpost, OnItemFabricated) == 0x002960, "Member 'AFortPlayerControllerOutpost::OnItemFabricated' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerOutpost, BuildingBeingUpgraded) == 0x002970, "Member 'AFortPlayerControllerOutpost::BuildingBeingUpgraded' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerOutpost, LevelBeforeUpgrade) == 0x002978, "Member 'AFortPlayerControllerOutpost::LevelBeforeUpgrade' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerOutpost, bOutpostRefundDialogPending) == 0x00297C, "Member 'AFortPlayerControllerOutpost::bOutpostRefundDialogPending' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerOutpost, ItemPendingToFabricate) == 0x002980, "Member 'AFortPlayerControllerOutpost::ItemPendingToFabricate' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerOutpost, FabricatedItemPendingForNotification) == 0x002998, "Member 'AFortPlayerControllerOutpost::FabricatedItemPendingForNotification' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerOutpost, DisintegrationStartTime) == 0x0029A8, "Member 'AFortPlayerControllerOutpost::DisintegrationStartTime' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerOutpost, QuantumGooCompleted) == 0x0029B0, "Member 'AFortPlayerControllerOutpost::QuantumGooCompleted' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerOutpost, QuantumGooIncoming) == 0x0029B4, "Member 'AFortPlayerControllerOutpost::QuantumGooIncoming' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerOutpost, PostDepositedResources) == 0x0029C0, "Member 'AFortPlayerControllerOutpost::PostDepositedResources' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerOutpost, bIsOutpostOwnerInPIE) == 0x0029D0, "Member 'AFortPlayerControllerOutpost::bIsOutpostOwnerInPIE' has a wrong offset!");

// Class FortniteGame.FortPlayerInputAthena
// 0x0038 (0x0518 - 0x04E0)
class UFortPlayerInputAthena final : public UFortPlayerInput
{
public:
	bool                                          bIsTargeting;                                      // 0x04E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsScoped;                                         // 0x04E1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E2[0x2];                                      // 0x04E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TargetingMultiplier;                               // 0x04E4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScopedMultiplier;                                  // 0x04E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4EC[0x4];                                      // 0x04EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortGamepadSettings*                   GamepadSettings;                                   // 0x04F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F8[0x20];                                     // 0x04F8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerInputAthena">();
	}
	static class UFortPlayerInputAthena* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPlayerInputAthena>();
	}
};
static_assert(alignof(UFortPlayerInputAthena) == 0x000008, "Wrong alignment on UFortPlayerInputAthena");
static_assert(sizeof(UFortPlayerInputAthena) == 0x000518, "Wrong size on UFortPlayerInputAthena");
static_assert(offsetof(UFortPlayerInputAthena, bIsTargeting) == 0x0004E0, "Member 'UFortPlayerInputAthena::bIsTargeting' has a wrong offset!");
static_assert(offsetof(UFortPlayerInputAthena, bIsScoped) == 0x0004E1, "Member 'UFortPlayerInputAthena::bIsScoped' has a wrong offset!");
static_assert(offsetof(UFortPlayerInputAthena, TargetingMultiplier) == 0x0004E4, "Member 'UFortPlayerInputAthena::TargetingMultiplier' has a wrong offset!");
static_assert(offsetof(UFortPlayerInputAthena, ScopedMultiplier) == 0x0004E8, "Member 'UFortPlayerInputAthena::ScopedMultiplier' has a wrong offset!");
static_assert(offsetof(UFortPlayerInputAthena, GamepadSettings) == 0x0004F0, "Member 'UFortPlayerInputAthena::GamepadSettings' has a wrong offset!");

// Class FortniteGame.FortPlayerInputSettings
// 0x0058 (0x0080 - 0x0028)
class UFortPlayerInputSettings final : public UObject
{
public:
	class FText                                   FriendlyName;                                      // 0x0028(0x0018)(Config, NativeAccessSpecifierPublic)
	TArray<struct FInputActionKeyMapping>         ActionMappings;                                    // 0x0040(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FFortInputActionKeyAlias>       ActionKeyAliases;                                  // 0x0050(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	float                                         HoldInputTime;                                     // 0x0060(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoldCraftAmmoTime;                                 // 0x0064(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoldHudChatTime;                                   // 0x0068(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBuildingPickerOnlyChoosesCategories;              // 0x006C(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWeaponPickerShowOnlySlottedItems;                 // 0x006D(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTrapPickerUsesRadial;                             // 0x006E(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRadialClosesOnRelease;                            // 0x006F(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumActiveTrapSlots;                                // 0x0070(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWeaponSlotsAreSharedWhenUsingGamepad;             // 0x0074(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEditModeUsableFromCombatMode;                     // 0x0075(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyShowNextPrevBuildingSlotKeybinds;             // 0x0076(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabledForCampaign;                               // 0x0077(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabledForAthena;                                 // 0x0078(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerInputSettings">();
	}
	static class UFortPlayerInputSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPlayerInputSettings>();
	}
};
static_assert(alignof(UFortPlayerInputSettings) == 0x000008, "Wrong alignment on UFortPlayerInputSettings");
static_assert(sizeof(UFortPlayerInputSettings) == 0x000080, "Wrong size on UFortPlayerInputSettings");
static_assert(offsetof(UFortPlayerInputSettings, FriendlyName) == 0x000028, "Member 'UFortPlayerInputSettings::FriendlyName' has a wrong offset!");
static_assert(offsetof(UFortPlayerInputSettings, ActionMappings) == 0x000040, "Member 'UFortPlayerInputSettings::ActionMappings' has a wrong offset!");
static_assert(offsetof(UFortPlayerInputSettings, ActionKeyAliases) == 0x000050, "Member 'UFortPlayerInputSettings::ActionKeyAliases' has a wrong offset!");
static_assert(offsetof(UFortPlayerInputSettings, HoldInputTime) == 0x000060, "Member 'UFortPlayerInputSettings::HoldInputTime' has a wrong offset!");
static_assert(offsetof(UFortPlayerInputSettings, HoldCraftAmmoTime) == 0x000064, "Member 'UFortPlayerInputSettings::HoldCraftAmmoTime' has a wrong offset!");
static_assert(offsetof(UFortPlayerInputSettings, HoldHudChatTime) == 0x000068, "Member 'UFortPlayerInputSettings::HoldHudChatTime' has a wrong offset!");
static_assert(offsetof(UFortPlayerInputSettings, bBuildingPickerOnlyChoosesCategories) == 0x00006C, "Member 'UFortPlayerInputSettings::bBuildingPickerOnlyChoosesCategories' has a wrong offset!");
static_assert(offsetof(UFortPlayerInputSettings, bWeaponPickerShowOnlySlottedItems) == 0x00006D, "Member 'UFortPlayerInputSettings::bWeaponPickerShowOnlySlottedItems' has a wrong offset!");
static_assert(offsetof(UFortPlayerInputSettings, bTrapPickerUsesRadial) == 0x00006E, "Member 'UFortPlayerInputSettings::bTrapPickerUsesRadial' has a wrong offset!");
static_assert(offsetof(UFortPlayerInputSettings, bRadialClosesOnRelease) == 0x00006F, "Member 'UFortPlayerInputSettings::bRadialClosesOnRelease' has a wrong offset!");
static_assert(offsetof(UFortPlayerInputSettings, NumActiveTrapSlots) == 0x000070, "Member 'UFortPlayerInputSettings::NumActiveTrapSlots' has a wrong offset!");
static_assert(offsetof(UFortPlayerInputSettings, bWeaponSlotsAreSharedWhenUsingGamepad) == 0x000074, "Member 'UFortPlayerInputSettings::bWeaponSlotsAreSharedWhenUsingGamepad' has a wrong offset!");
static_assert(offsetof(UFortPlayerInputSettings, bEditModeUsableFromCombatMode) == 0x000075, "Member 'UFortPlayerInputSettings::bEditModeUsableFromCombatMode' has a wrong offset!");
static_assert(offsetof(UFortPlayerInputSettings, bOnlyShowNextPrevBuildingSlotKeybinds) == 0x000076, "Member 'UFortPlayerInputSettings::bOnlyShowNextPrevBuildingSlotKeybinds' has a wrong offset!");
static_assert(offsetof(UFortPlayerInputSettings, bEnabledForCampaign) == 0x000077, "Member 'UFortPlayerInputSettings::bEnabledForCampaign' has a wrong offset!");
static_assert(offsetof(UFortPlayerInputSettings, bEnabledForAthena) == 0x000078, "Member 'UFortPlayerInputSettings::bEnabledForAthena' has a wrong offset!");

// Class FortniteGame.FortPlayerMannequin
// 0x0188 (0x0598 - 0x0410)
class AFortPlayerMannequin final : public ASkeletalMeshActor
{
public:
	uint8                                         Pad_410[0x8];                                      // 0x0410(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortHeroType*                          FortHeroType;                                      // 0x0418(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCustomCharacterPart*                   CharacterParts[0x7];                               // 0x0420(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLightingChannels                      MannequinLightingChannels;                         // 0x0458(0x0001)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_459[0x7];                                      // 0x0459(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCustomCharacterPart*                   CharacterPartList[0x6];                            // 0x0460(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCustomColorSwatch*                     CharacterPartColorSwatches[0x7];                   // 0x0490(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCustomColorSwatch*                     ColorSwatchesForCharacterParts[0x6];               // 0x04C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCustomColorComponent*                  AccessoryColorSwatchHandler[0x6];                  // 0x04F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCustomColorSwatch*                     ColorSwatches[0x2];                                // 0x0528(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMesh*                          WeaponSkeletalMesh;                                // 0x0538(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   WeaponAttachSocket;                                // 0x0540(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_548[0x38];                                     // 0x0548(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMorphValuePair>                MorphTargets;                                      // 0x0580(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bInitialized;                                      // 0x0590(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_591[0x7];                                      // 0x0591(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CyclePartBP(EFortCustomPartType Part, bool bNextPart);
	void GetAllPartSkeletalMeshComponents(TArray<class USkeletalMeshComponent*>* SkeletalMeshComponents);
	bool RemovePart(EFortCustomPartType Part);
	void SetHeroType(class UFortHeroType* NewHeroType);
	bool SetPart(EFortCustomPartType Part, class UCustomCharacterPart* PartAsset);
	void SetSkeletalMesh(class USkeletalMesh* SkeletalMesh);
	bool SetWeaponSkeletalMesh(class USkeletalMesh* SkeletalMesh);
	void ToggleGenderBP();
	void UpdateMorphTargets();

	EFortCustomGender GetGender() const;
	class USkeletalMeshComponent* GetPartSkeletalMeshComponent(EFortCustomPartType Part) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerMannequin">();
	}
	static class AFortPlayerMannequin* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerMannequin>();
	}
};
static_assert(alignof(AFortPlayerMannequin) == 0x000008, "Wrong alignment on AFortPlayerMannequin");
static_assert(sizeof(AFortPlayerMannequin) == 0x000598, "Wrong size on AFortPlayerMannequin");
static_assert(offsetof(AFortPlayerMannequin, FortHeroType) == 0x000418, "Member 'AFortPlayerMannequin::FortHeroType' has a wrong offset!");
static_assert(offsetof(AFortPlayerMannequin, CharacterParts) == 0x000420, "Member 'AFortPlayerMannequin::CharacterParts' has a wrong offset!");
static_assert(offsetof(AFortPlayerMannequin, MannequinLightingChannels) == 0x000458, "Member 'AFortPlayerMannequin::MannequinLightingChannels' has a wrong offset!");
static_assert(offsetof(AFortPlayerMannequin, CharacterPartList) == 0x000460, "Member 'AFortPlayerMannequin::CharacterPartList' has a wrong offset!");
static_assert(offsetof(AFortPlayerMannequin, CharacterPartColorSwatches) == 0x000490, "Member 'AFortPlayerMannequin::CharacterPartColorSwatches' has a wrong offset!");
static_assert(offsetof(AFortPlayerMannequin, ColorSwatchesForCharacterParts) == 0x0004C8, "Member 'AFortPlayerMannequin::ColorSwatchesForCharacterParts' has a wrong offset!");
static_assert(offsetof(AFortPlayerMannequin, AccessoryColorSwatchHandler) == 0x0004F8, "Member 'AFortPlayerMannequin::AccessoryColorSwatchHandler' has a wrong offset!");
static_assert(offsetof(AFortPlayerMannequin, ColorSwatches) == 0x000528, "Member 'AFortPlayerMannequin::ColorSwatches' has a wrong offset!");
static_assert(offsetof(AFortPlayerMannequin, WeaponSkeletalMesh) == 0x000538, "Member 'AFortPlayerMannequin::WeaponSkeletalMesh' has a wrong offset!");
static_assert(offsetof(AFortPlayerMannequin, WeaponAttachSocket) == 0x000540, "Member 'AFortPlayerMannequin::WeaponAttachSocket' has a wrong offset!");
static_assert(offsetof(AFortPlayerMannequin, MorphTargets) == 0x000580, "Member 'AFortPlayerMannequin::MorphTargets' has a wrong offset!");
static_assert(offsetof(AFortPlayerMannequin, bInitialized) == 0x000590, "Member 'AFortPlayerMannequin::bInitialized' has a wrong offset!");

// Class FortniteGame.FortPlayerStart
// 0x0008 (0x03C0 - 0x03B8)
class AFortPlayerStart final : public APlayerStart
{
public:
	class UParticleSystemComponent*               StartParticleComponent;                            // 0x03B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerStart">();
	}
	static class AFortPlayerStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerStart>();
	}
};
static_assert(alignof(AFortPlayerStart) == 0x000008, "Wrong alignment on AFortPlayerStart");
static_assert(sizeof(AFortPlayerStart) == 0x0003C0, "Wrong size on AFortPlayerStart");
static_assert(offsetof(AFortPlayerStart, StartParticleComponent) == 0x0003B8, "Member 'AFortPlayerStart::StartParticleComponent' has a wrong offset!");

// Class FortniteGame.FortQueryTest_GoalStickiness
// 0x00F0 (0x02C8 - 0x01D8)
class UFortQueryTest_GoalStickiness final : public UFortQueryTest_GoalBase
{
public:
	struct FAIDataProviderFloatValue              StartValueForGoal;                                 // 0x01D8(0x0030)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              EndValueForGoal;                                   // 0x0208(0x0030)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              TimeBeforeValueLerp;                               // 0x0238(0x0030)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              ValueLerpDuration;                                 // 0x0268(0x0030)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderBoolValue               ApplyStickinessToAllGoalsWithSameActor;            // 0x0298(0x0030)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_GoalStickiness">();
	}
	static class UFortQueryTest_GoalStickiness* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_GoalStickiness>();
	}
};
static_assert(alignof(UFortQueryTest_GoalStickiness) == 0x000008, "Wrong alignment on UFortQueryTest_GoalStickiness");
static_assert(sizeof(UFortQueryTest_GoalStickiness) == 0x0002C8, "Wrong size on UFortQueryTest_GoalStickiness");
static_assert(offsetof(UFortQueryTest_GoalStickiness, StartValueForGoal) == 0x0001D8, "Member 'UFortQueryTest_GoalStickiness::StartValueForGoal' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalStickiness, EndValueForGoal) == 0x000208, "Member 'UFortQueryTest_GoalStickiness::EndValueForGoal' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalStickiness, TimeBeforeValueLerp) == 0x000238, "Member 'UFortQueryTest_GoalStickiness::TimeBeforeValueLerp' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalStickiness, ValueLerpDuration) == 0x000268, "Member 'UFortQueryTest_GoalStickiness::ValueLerpDuration' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalStickiness, ApplyStickinessToAllGoalsWithSameActor) == 0x000298, "Member 'UFortQueryTest_GoalStickiness::ApplyStickinessToAllGoalsWithSameActor' has a wrong offset!");

// Class FortniteGame.FortPlayerStartWarmup
// 0x0008 (0x03C0 - 0x03B8)
class AFortPlayerStartWarmup final : public APlayerStart
{
public:
	uint8                                         Pad_3B8[0x8];                                      // 0x03B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerStartWarmup">();
	}
	static class AFortPlayerStartWarmup* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerStartWarmup>();
	}
};
static_assert(alignof(AFortPlayerStartWarmup) == 0x000008, "Wrong alignment on AFortPlayerStartWarmup");
static_assert(sizeof(AFortPlayerStartWarmup) == 0x0003C0, "Wrong size on AFortPlayerStartWarmup");

// Class FortniteGame.FortHoverDroneCameraComponent
// 0x0020 (0x0860 - 0x0840)
class UFortHoverDroneCameraComponent final : public UFortReplaySpectatorCameraComponent
{
public:
	float                                         DroneTiltInterpSpeed_Accel;                        // 0x0838(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DroneTiltInterpSpeed_Decel;                        // 0x083C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_840[0xC];                                      // 0x0840(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TiltUpVector;                                      // 0x084C(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_858[0x8];                                      // 0x0858(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortHoverDroneCameraComponent">();
	}
	static class UFortHoverDroneCameraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortHoverDroneCameraComponent>();
	}
};
static_assert(alignof(UFortHoverDroneCameraComponent) == 0x000010, "Wrong alignment on UFortHoverDroneCameraComponent");
static_assert(sizeof(UFortHoverDroneCameraComponent) == 0x000860, "Wrong size on UFortHoverDroneCameraComponent");
static_assert(offsetof(UFortHoverDroneCameraComponent, DroneTiltInterpSpeed_Accel) == 0x000838, "Member 'UFortHoverDroneCameraComponent::DroneTiltInterpSpeed_Accel' has a wrong offset!");
static_assert(offsetof(UFortHoverDroneCameraComponent, DroneTiltInterpSpeed_Decel) == 0x00083C, "Member 'UFortHoverDroneCameraComponent::DroneTiltInterpSpeed_Decel' has a wrong offset!");
static_assert(offsetof(UFortHoverDroneCameraComponent, TiltUpVector) == 0x00084C, "Member 'UFortHoverDroneCameraComponent::TiltUpVector' has a wrong offset!");

// Class FortniteGame.FortPlayerStateFOB
// 0x0008 (0x0D20 - 0x0D18)
class AFortPlayerStateFOB final : public AFortPlayerStateZone
{
public:
	uint8                                         Pad_D18[0x8];                                      // 0x0D18(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerStateFOB">();
	}
	static class AFortPlayerStateFOB* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerStateFOB>();
	}
};
static_assert(alignof(AFortPlayerStateFOB) == 0x000008, "Wrong alignment on AFortPlayerStateFOB");
static_assert(sizeof(AFortPlayerStateFOB) == 0x000D20, "Wrong size on AFortPlayerStateFOB");

// Class FortniteGame.FortPlayerStateKeep
// 0x0008 (0x0D20 - 0x0D18)
class AFortPlayerStateKeep final : public AFortPlayerStateZone
{
public:
	uint8                                         Pad_D18[0x8];                                      // 0x0D18(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerStateKeep">();
	}
	static class AFortPlayerStateKeep* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerStateKeep>();
	}
};
static_assert(alignof(AFortPlayerStateKeep) == 0x000008, "Wrong alignment on AFortPlayerStateKeep");
static_assert(sizeof(AFortPlayerStateKeep) == 0x000D20, "Wrong size on AFortPlayerStateKeep");

// Class FortniteGame.FortPlayerStateOutpost
// 0x0008 (0x0D20 - 0x0D18)
class AFortPlayerStateOutpost final : public AFortPlayerStateZone
{
public:
	bool                                          bCanEditOutpost;                                   // 0x0D18(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D19[0x3];                                      // 0x0D19(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CraftingTableItemsRemaing;                         // 0x0D1C(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_CanEditOutpost();
	void OnRep_CraftingTableItemsRemaing();
	void ServerSetCanEditOutpost(class AFortPlayerStateOutpost* InPlayer, bool bCanEdit);
	void SetCanEditOutpost(class AFortPlayerStateOutpost* InPlayer, bool bCanEdit);

	bool CanEditOutpost() const;
	bool IsOutpostOwner() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerStateOutpost">();
	}
	static class AFortPlayerStateOutpost* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerStateOutpost>();
	}
};
static_assert(alignof(AFortPlayerStateOutpost) == 0x000008, "Wrong alignment on AFortPlayerStateOutpost");
static_assert(sizeof(AFortPlayerStateOutpost) == 0x000D20, "Wrong size on AFortPlayerStateOutpost");
static_assert(offsetof(AFortPlayerStateOutpost, bCanEditOutpost) == 0x000D18, "Member 'AFortPlayerStateOutpost::bCanEditOutpost' has a wrong offset!");
static_assert(offsetof(AFortPlayerStateOutpost, CraftingTableItemsRemaing) == 0x000D1C, "Member 'AFortPlayerStateOutpost::CraftingTableItemsRemaing' has a wrong offset!");

// Class FortniteGame.FortProceduralFoliageComponent
// 0x0000 (0x0118 - 0x0118)
class UFortProceduralFoliageComponent final : public UProceduralFoliageComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortProceduralFoliageComponent">();
	}
	static class UFortProceduralFoliageComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortProceduralFoliageComponent>();
	}
};
static_assert(alignof(UFortProceduralFoliageComponent) == 0x000008, "Wrong alignment on UFortProceduralFoliageComponent");
static_assert(sizeof(UFortProceduralFoliageComponent) == 0x000118, "Wrong size on UFortProceduralFoliageComponent");

// Class FortniteGame.FortPrototypingContext
// 0x0040 (0x0068 - 0x0028)
class UFortPrototypingContext final : public UBlueprintContextBase
{
public:
	UMulticastDelegateProperty_                   OnPrototypingStatusChangedEvent;                   // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x30];                                      // 0x0038(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	EFortPrototypingStatus GetPrototypingStatus() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPrototypingContext">();
	}
	static class UFortPrototypingContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPrototypingContext>();
	}
};
static_assert(alignof(UFortPrototypingContext) == 0x000008, "Wrong alignment on UFortPrototypingContext");
static_assert(sizeof(UFortPrototypingContext) == 0x000068, "Wrong size on UFortPrototypingContext");
static_assert(offsetof(UFortPrototypingContext, OnPrototypingStatusChangedEvent) == 0x000028, "Member 'UFortPrototypingContext::OnPrototypingStatusChangedEvent' has a wrong offset!");

// Class FortniteGame.FortPvPFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UFortPvPFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void DestroyAllFortPickupsWithItem(class UObject* WorldContextObject, const class UFortWorldItemDefinition* ItemDefinitionToCheck);
	static void FirePvPVictoryMissionEvent(class UObject* WorldContextObject, EFortTeam InWinningTeam);
	static int32 GetBaseBuildingCost(class ABuildingActor* BuildingActor);
	static class AFortTeamInfoPvPBaseDestruction* GetBaseDestructionTeamInfo(class UObject* WorldContextObject, EFortTeam Team);
	static void GetDifficultyRowNamesFromPvPRating(TArray<class FName>* OutDifficultyRows, const float InPvPRating);
	static int32 GetMatchLevel(class UObject* WorldContextObject);
	static int32 GetRoundTimeAccumulated(class UObject* WorldContextObject);
	static class AFortPvPBaseCornerstone* GetTeamCornerstone(class UObject* WorldContextObject, EFortTeam Team);
	static class AStrategicBuildingActor* GetTeamStrategicBuildingActor(class UObject* WorldContextObject, EFortTeam Team, const struct FTeamStrategicBuildingHandle& SBAHandle);
	static void SetMatchLevel(class UObject* WorldContextObject, int32 MatchLevel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPvPFunctionLibrary">();
	}
	static class UFortPvPFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPvPFunctionLibrary>();
	}
};
static_assert(alignof(UFortPvPFunctionLibrary) == 0x000008, "Wrong alignment on UFortPvPFunctionLibrary");
static_assert(sizeof(UFortPvPFunctionLibrary) == 0x000028, "Wrong size on UFortPvPFunctionLibrary");

// Class FortniteGame.FortPvPPlayerStart
// 0x0010 (0x03C8 - 0x03B8)
class AFortPvPPlayerStart final : public APlayerStart
{
public:
	uint8                                         Pad_3B8[0x8];                                      // 0x03B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EFortTeam                                     Team;                                              // 0x03C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C1[0x3];                                      // 0x03C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bDynamicStartLocation : 1;                         // 0x03C4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_3C5[0x3];                                      // 0x03C5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPvPPlayerStart">();
	}
	static class AFortPvPPlayerStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPvPPlayerStart>();
	}
};
static_assert(alignof(AFortPvPPlayerStart) == 0x000008, "Wrong alignment on AFortPvPPlayerStart");
static_assert(sizeof(AFortPvPPlayerStart) == 0x0003C8, "Wrong size on AFortPvPPlayerStart");
static_assert(offsetof(AFortPvPPlayerStart, Team) == 0x0003C0, "Member 'AFortPvPPlayerStart::Team' has a wrong offset!");

// Class FortniteGame.FortQueryContext_AllPlayers
// 0x0000 (0x0028 - 0x0028)
class UFortQueryContext_AllPlayers final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_AllPlayers">();
	}
	static class UFortQueryContext_AllPlayers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_AllPlayers>();
	}
};
static_assert(alignof(UFortQueryContext_AllPlayers) == 0x000008, "Wrong alignment on UFortQueryContext_AllPlayers");
static_assert(sizeof(UFortQueryContext_AllPlayers) == 0x000028, "Wrong size on UFortQueryContext_AllPlayers");

// Class FortniteGame.FortQueryContext_EncounterPrimaryAssignmentGoals
// 0x0000 (0x0028 - 0x0028)
class UFortQueryContext_EncounterPrimaryAssignmentGoals final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_EncounterPrimaryAssignmentGoals">();
	}
	static class UFortQueryContext_EncounterPrimaryAssignmentGoals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_EncounterPrimaryAssignmentGoals>();
	}
};
static_assert(alignof(UFortQueryContext_EncounterPrimaryAssignmentGoals) == 0x000008, "Wrong alignment on UFortQueryContext_EncounterPrimaryAssignmentGoals");
static_assert(sizeof(UFortQueryContext_EncounterPrimaryAssignmentGoals) == 0x000028, "Wrong size on UFortQueryContext_EncounterPrimaryAssignmentGoals");

// Class FortniteGame.FortQueryContext_Goal
// 0x0000 (0x0028 - 0x0028)
class UFortQueryContext_Goal final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_Goal">();
	}
	static class UFortQueryContext_Goal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_Goal>();
	}
};
static_assert(alignof(UFortQueryContext_Goal) == 0x000008, "Wrong alignment on UFortQueryContext_Goal");
static_assert(sizeof(UFortQueryContext_Goal) == 0x000028, "Wrong size on UFortQueryContext_Goal");

// Class FortniteGame.FortQueryContext_TwoPointSolverRotationA
// 0x0000 (0x0028 - 0x0028)
class UFortQueryContext_TwoPointSolverRotationA final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_TwoPointSolverRotationA">();
	}
	static class UFortQueryContext_TwoPointSolverRotationA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_TwoPointSolverRotationA>();
	}
};
static_assert(alignof(UFortQueryContext_TwoPointSolverRotationA) == 0x000008, "Wrong alignment on UFortQueryContext_TwoPointSolverRotationA");
static_assert(sizeof(UFortQueryContext_TwoPointSolverRotationA) == 0x000028, "Wrong size on UFortQueryContext_TwoPointSolverRotationA");

// Class FortniteGame.FortQueryGenerator_GoalOnCircle
// 0x0008 (0x01F0 - 0x01E8)
class UFortQueryGenerator_GoalOnCircle final : public UEnvQueryGenerator_OnCircle
{
public:
	bool                                          bIncludeCenterActorInGeneratedGoals;               // 0x01E8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E9[0x7];                                      // 0x01E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_GoalOnCircle">();
	}
	static class UFortQueryGenerator_GoalOnCircle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_GoalOnCircle>();
	}
};
static_assert(alignof(UFortQueryGenerator_GoalOnCircle) == 0x000008, "Wrong alignment on UFortQueryGenerator_GoalOnCircle");
static_assert(sizeof(UFortQueryGenerator_GoalOnCircle) == 0x0001F0, "Wrong size on UFortQueryGenerator_GoalOnCircle");
static_assert(offsetof(UFortQueryGenerator_GoalOnCircle, bIncludeCenterActorInGeneratedGoals) == 0x0001E8, "Member 'UFortQueryGenerator_GoalOnCircle::bIncludeCenterActorInGeneratedGoals' has a wrong offset!");

// Class FortniteGame.FortQueryGenerator_SpecificAssignmentGoals
// 0x0040 (0x0090 - 0x0050)
class UFortQueryGenerator_SpecificAssignmentGoals final : public UEnvQueryGenerator
{
public:
	struct FFortAIAssignmentIdentifier            AssignmentIdentifier;                              // 0x0050(0x0030)(Edit, Protected, NativeAccessSpecifierProtected)
	class UFortAIAssignmentSettings*              AssignmentSettings;                                // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UFortAIGoalProvider>        GoalProvider;                                      // 0x0088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_SpecificAssignmentGoals">();
	}
	static class UFortQueryGenerator_SpecificAssignmentGoals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_SpecificAssignmentGoals>();
	}
};
static_assert(alignof(UFortQueryGenerator_SpecificAssignmentGoals) == 0x000008, "Wrong alignment on UFortQueryGenerator_SpecificAssignmentGoals");
static_assert(sizeof(UFortQueryGenerator_SpecificAssignmentGoals) == 0x000090, "Wrong size on UFortQueryGenerator_SpecificAssignmentGoals");
static_assert(offsetof(UFortQueryGenerator_SpecificAssignmentGoals, AssignmentIdentifier) == 0x000050, "Member 'UFortQueryGenerator_SpecificAssignmentGoals::AssignmentIdentifier' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_SpecificAssignmentGoals, AssignmentSettings) == 0x000080, "Member 'UFortQueryGenerator_SpecificAssignmentGoals::AssignmentSettings' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_SpecificAssignmentGoals, GoalProvider) == 0x000088, "Member 'UFortQueryGenerator_SpecificAssignmentGoals::GoalProvider' has a wrong offset!");

// Class FortniteGame.FortQueryItemType_PointOrSlot
// 0x0000 (0x0030 - 0x0030)
class UFortQueryItemType_PointOrSlot final : public UEnvQueryItemType_Point
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryItemType_PointOrSlot">();
	}
	static class UFortQueryItemType_PointOrSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryItemType_PointOrSlot>();
	}
};
static_assert(alignof(UFortQueryItemType_PointOrSlot) == 0x000008, "Wrong alignment on UFortQueryItemType_PointOrSlot");
static_assert(sizeof(UFortQueryItemType_PointOrSlot) == 0x000030, "Wrong size on UFortQueryItemType_PointOrSlot");

// Class FortniteGame.FortQueryTest_CanAttackTarget
// 0x0000 (0x01D8 - 0x01D8)
class UFortQueryTest_CanAttackTarget final : public UFortQueryTest_GoalBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_CanAttackTarget">();
	}
	static class UFortQueryTest_CanAttackTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_CanAttackTarget>();
	}
};
static_assert(alignof(UFortQueryTest_CanAttackTarget) == 0x000008, "Wrong alignment on UFortQueryTest_CanAttackTarget");
static_assert(sizeof(UFortQueryTest_CanAttackTarget) == 0x0001D8, "Wrong size on UFortQueryTest_CanAttackTarget");

// Class FortniteGame.FortQueryTest_CanBeDamaged
// 0x0000 (0x01D8 - 0x01D8)
class UFortQueryTest_CanBeDamaged final : public UFortQueryTest_GoalBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_CanBeDamaged">();
	}
	static class UFortQueryTest_CanBeDamaged* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_CanBeDamaged>();
	}
};
static_assert(alignof(UFortQueryTest_CanBeDamaged) == 0x000008, "Wrong alignment on UFortQueryTest_CanBeDamaged");
static_assert(sizeof(UFortQueryTest_CanBeDamaged) == 0x0001D8, "Wrong size on UFortQueryTest_CanBeDamaged");

// Class FortniteGame.FortQueryTest_GoalDistance
// 0x0018 (0x01F0 - 0x01D8)
class UFortQueryTest_GoalDistance final : public UFortQueryTest_GoalBase
{
public:
	EDistanceMode                                 DistanceMode;                                      // 0x01D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D9[0x7];                                      // 0x01D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UEnvQueryContext>           DistanceTo;                                        // 0x01E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EEnvTestDistance                              TestMode;                                          // 0x01E8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E9[0x7];                                      // 0x01E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_GoalDistance">();
	}
	static class UFortQueryTest_GoalDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_GoalDistance>();
	}
};
static_assert(alignof(UFortQueryTest_GoalDistance) == 0x000008, "Wrong alignment on UFortQueryTest_GoalDistance");
static_assert(sizeof(UFortQueryTest_GoalDistance) == 0x0001F0, "Wrong size on UFortQueryTest_GoalDistance");
static_assert(offsetof(UFortQueryTest_GoalDistance, DistanceMode) == 0x0001D8, "Member 'UFortQueryTest_GoalDistance::DistanceMode' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalDistance, DistanceTo) == 0x0001E0, "Member 'UFortQueryTest_GoalDistance::DistanceTo' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalDistance, TestMode) == 0x0001E8, "Member 'UFortQueryTest_GoalDistance::TestMode' has a wrong offset!");

// Class FortniteGame.FortQueryTest_GoalMarkedByPlayer
// 0x0000 (0x01D8 - 0x01D8)
class UFortQueryTest_GoalMarkedByPlayer final : public UFortQueryTest_GoalBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_GoalMarkedByPlayer">();
	}
	static class UFortQueryTest_GoalMarkedByPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_GoalMarkedByPlayer>();
	}
};
static_assert(alignof(UFortQueryTest_GoalMarkedByPlayer) == 0x000008, "Wrong alignment on UFortQueryTest_GoalMarkedByPlayer");
static_assert(sizeof(UFortQueryTest_GoalMarkedByPlayer) == 0x0001D8, "Wrong size on UFortQueryTest_GoalMarkedByPlayer");

// Class FortniteGame.FortQueryTest_GoalNumberOfAIAssigned
// 0x0008 (0x01E0 - 0x01D8)
class UFortQueryTest_GoalNumberOfAIAssigned final : public UFortQueryTest_GoalBase
{
public:
	ECountAIAssignedToType                        TypeOfMatchToCount;                                // 0x01D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D9[0x7];                                      // 0x01D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_GoalNumberOfAIAssigned">();
	}
	static class UFortQueryTest_GoalNumberOfAIAssigned* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_GoalNumberOfAIAssigned>();
	}
};
static_assert(alignof(UFortQueryTest_GoalNumberOfAIAssigned) == 0x000008, "Wrong alignment on UFortQueryTest_GoalNumberOfAIAssigned");
static_assert(sizeof(UFortQueryTest_GoalNumberOfAIAssigned) == 0x0001E0, "Wrong size on UFortQueryTest_GoalNumberOfAIAssigned");
static_assert(offsetof(UFortQueryTest_GoalNumberOfAIAssigned, TypeOfMatchToCount) == 0x0001D8, "Member 'UFortQueryTest_GoalNumberOfAIAssigned::TypeOfMatchToCount' has a wrong offset!");

// Class FortniteGame.FortQueryTest_GoalOverallDamageCaused
// 0x0000 (0x01D8 - 0x01D8)
class UFortQueryTest_GoalOverallDamageCaused final : public UFortQueryTest_GoalBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_GoalOverallDamageCaused">();
	}
	static class UFortQueryTest_GoalOverallDamageCaused* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_GoalOverallDamageCaused>();
	}
};
static_assert(alignof(UFortQueryTest_GoalOverallDamageCaused) == 0x000008, "Wrong alignment on UFortQueryTest_GoalOverallDamageCaused");
static_assert(sizeof(UFortQueryTest_GoalOverallDamageCaused) == 0x0001D8, "Wrong size on UFortQueryTest_GoalOverallDamageCaused");

// Class FortniteGame.FortQueryTest_GoalType
// 0x0000 (0x01D8 - 0x01D8)
class UFortQueryTest_GoalType final : public UFortQueryTest_GoalBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_GoalType">();
	}
	static class UFortQueryTest_GoalType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_GoalType>();
	}
};
static_assert(alignof(UFortQueryTest_GoalType) == 0x000008, "Wrong alignment on UFortQueryTest_GoalType");
static_assert(sizeof(UFortQueryTest_GoalType) == 0x0001D8, "Wrong size on UFortQueryTest_GoalType");

// Class FortniteGame.FortQueryTest_GoalWithinTetheredBounds
// 0x0000 (0x01D8 - 0x01D8)
class UFortQueryTest_GoalWithinTetheredBounds final : public UFortQueryTest_GoalBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_GoalWithinTetheredBounds">();
	}
	static class UFortQueryTest_GoalWithinTetheredBounds* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_GoalWithinTetheredBounds>();
	}
};
static_assert(alignof(UFortQueryTest_GoalWithinTetheredBounds) == 0x000008, "Wrong alignment on UFortQueryTest_GoalWithinTetheredBounds");
static_assert(sizeof(UFortQueryTest_GoalWithinTetheredBounds) == 0x0001D8, "Wrong size on UFortQueryTest_GoalWithinTetheredBounds");

// Class FortniteGame.FortQueryTest_PerceptionAll
// 0x0180 (0x0358 - 0x01D8)
class UFortQueryTest_PerceptionAll final : public UFortQueryTest_GoalBase
{
public:
	struct FAIDataProviderFloatValue              SenseScores[0x6];                                  // 0x01D8(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              MinSenseAge;                                       // 0x02F8(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              MaxSenseAge;                                       // 0x0328(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_PerceptionAll">();
	}
	static class UFortQueryTest_PerceptionAll* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_PerceptionAll>();
	}
};
static_assert(alignof(UFortQueryTest_PerceptionAll) == 0x000008, "Wrong alignment on UFortQueryTest_PerceptionAll");
static_assert(sizeof(UFortQueryTest_PerceptionAll) == 0x000358, "Wrong size on UFortQueryTest_PerceptionAll");
static_assert(offsetof(UFortQueryTest_PerceptionAll, SenseScores) == 0x0001D8, "Member 'UFortQueryTest_PerceptionAll::SenseScores' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_PerceptionAll, MinSenseAge) == 0x0002F8, "Member 'UFortQueryTest_PerceptionAll::MinSenseAge' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_PerceptionAll, MaxSenseAge) == 0x000328, "Member 'UFortQueryTest_PerceptionAll::MaxSenseAge' has a wrong offset!");

// Class FortniteGame.FortQueryTest_PrimaryAssignment
// 0x00F8 (0x02D0 - 0x01D8)
class UFortQueryTest_PrimaryAssignment final : public UFortQueryTest_GoalBase
{
public:
	bool                                          bUseItemActorLocation;                             // 0x01D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D9[0x7];                                      // 0x01D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIDataProviderFloatValue              DistanceClose;                                     // 0x01E0(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              DistanceFar;                                       // 0x0210(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              PercentValueClose;                                 // 0x0240(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              PercentValueRegular;                               // 0x0270(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              PercentValueFar;                                   // 0x02A0(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_PrimaryAssignment">();
	}
	static class UFortQueryTest_PrimaryAssignment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_PrimaryAssignment>();
	}
};
static_assert(alignof(UFortQueryTest_PrimaryAssignment) == 0x000008, "Wrong alignment on UFortQueryTest_PrimaryAssignment");
static_assert(sizeof(UFortQueryTest_PrimaryAssignment) == 0x0002D0, "Wrong size on UFortQueryTest_PrimaryAssignment");
static_assert(offsetof(UFortQueryTest_PrimaryAssignment, bUseItemActorLocation) == 0x0001D8, "Member 'UFortQueryTest_PrimaryAssignment::bUseItemActorLocation' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_PrimaryAssignment, DistanceClose) == 0x0001E0, "Member 'UFortQueryTest_PrimaryAssignment::DistanceClose' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_PrimaryAssignment, DistanceFar) == 0x000210, "Member 'UFortQueryTest_PrimaryAssignment::DistanceFar' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_PrimaryAssignment, PercentValueClose) == 0x000240, "Member 'UFortQueryTest_PrimaryAssignment::PercentValueClose' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_PrimaryAssignment, PercentValueRegular) == 0x000270, "Member 'UFortQueryTest_PrimaryAssignment::PercentValueRegular' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_PrimaryAssignment, PercentValueFar) == 0x0002A0, "Member 'UFortQueryTest_PrimaryAssignment::PercentValueFar' has a wrong offset!");

// Class FortniteGame.FortQueryTest_HasNearbyBuildings
// 0x0010 (0x01D0 - 0x01C0)
class UFortQueryTest_HasNearbyBuildings final : public UEnvQueryTest
{
public:
	uint8                                         bIncludeCenter : 1;                                // 0x01C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIncludeFloors : 1;                                // 0x01C0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIncludeFloorsAbove : 1;                           // 0x01C0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIncludeWalls : 1;                                 // 0x01C0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1C1[0x3];                                      // 0x01C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ExtentXY;                                          // 0x01C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExtentZ;                                           // 0x01C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CC[0x4];                                      // 0x01CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_HasNearbyBuildings">();
	}
	static class UFortQueryTest_HasNearbyBuildings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_HasNearbyBuildings>();
	}
};
static_assert(alignof(UFortQueryTest_HasNearbyBuildings) == 0x000008, "Wrong alignment on UFortQueryTest_HasNearbyBuildings");
static_assert(sizeof(UFortQueryTest_HasNearbyBuildings) == 0x0001D0, "Wrong size on UFortQueryTest_HasNearbyBuildings");
static_assert(offsetof(UFortQueryTest_HasNearbyBuildings, ExtentXY) == 0x0001C4, "Member 'UFortQueryTest_HasNearbyBuildings::ExtentXY' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_HasNearbyBuildings, ExtentZ) == 0x0001C8, "Member 'UFortQueryTest_HasNearbyBuildings::ExtentZ' has a wrong offset!");

// Class FortniteGame.FortQueryTest_HotspotSlotState
// 0x0008 (0x01C8 - 0x01C0)
class UFortQueryTest_HotspotSlotState final : public UEnvQueryTest
{
public:
	EAIHotSpotSlot                                SlotState;                                         // 0x01C0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C1[0x7];                                      // 0x01C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_HotspotSlotState">();
	}
	static class UFortQueryTest_HotspotSlotState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_HotspotSlotState>();
	}
};
static_assert(alignof(UFortQueryTest_HotspotSlotState) == 0x000008, "Wrong alignment on UFortQueryTest_HotspotSlotState");
static_assert(sizeof(UFortQueryTest_HotspotSlotState) == 0x0001C8, "Wrong size on UFortQueryTest_HotspotSlotState");
static_assert(offsetof(UFortQueryTest_HotspotSlotState, SlotState) == 0x0001C0, "Member 'UFortQueryTest_HotspotSlotState::SlotState' has a wrong offset!");

// Class FortniteGame.FortQueryTest_InsideBuilding
// 0x0000 (0x01C0 - 0x01C0)
class UFortQueryTest_InsideBuilding final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_InsideBuilding">();
	}
	static class UFortQueryTest_InsideBuilding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_InsideBuilding>();
	}
};
static_assert(alignof(UFortQueryTest_InsideBuilding) == 0x000008, "Wrong alignment on UFortQueryTest_InsideBuilding");
static_assert(sizeof(UFortQueryTest_InsideBuilding) == 0x0001C0, "Wrong size on UFortQueryTest_InsideBuilding");

// Class FortniteGame.FortQueryTest_InsideWater
// 0x0008 (0x01C8 - 0x01C0)
class UFortQueryTest_InsideWater final : public UEnvQueryTest
{
public:
	float                                         TestRadius;                                        // 0x01C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C4[0x4];                                      // 0x01C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_InsideWater">();
	}
	static class UFortQueryTest_InsideWater* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_InsideWater>();
	}
};
static_assert(alignof(UFortQueryTest_InsideWater) == 0x000008, "Wrong alignment on UFortQueryTest_InsideWater");
static_assert(sizeof(UFortQueryTest_InsideWater) == 0x0001C8, "Wrong size on UFortQueryTest_InsideWater");
static_assert(offsetof(UFortQueryTest_InsideWater, TestRadius) == 0x0001C0, "Member 'UFortQueryTest_InsideWater::TestRadius' has a wrong offset!");

// Class FortniteGame.FortQueryTest_IsCloseToPatrolWard
// 0x0008 (0x01C8 - 0x01C0)
class UFortQueryTest_IsCloseToPatrolWard final : public UEnvQueryTest
{
public:
	EWardAffectType                               WardEffectTypeFilter;                              // 0x01C0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C1[0x7];                                      // 0x01C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_IsCloseToPatrolWard">();
	}
	static class UFortQueryTest_IsCloseToPatrolWard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_IsCloseToPatrolWard>();
	}
};
static_assert(alignof(UFortQueryTest_IsCloseToPatrolWard) == 0x000008, "Wrong alignment on UFortQueryTest_IsCloseToPatrolWard");
static_assert(sizeof(UFortQueryTest_IsCloseToPatrolWard) == 0x0001C8, "Wrong size on UFortQueryTest_IsCloseToPatrolWard");
static_assert(offsetof(UFortQueryTest_IsCloseToPatrolWard, WardEffectTypeFilter) == 0x0001C0, "Member 'UFortQueryTest_IsCloseToPatrolWard::WardEffectTypeFilter' has a wrong offset!");

// Class FortniteGame.FortQueryTest_OnFlatSurface
// 0x0010 (0x01D0 - 0x01C0)
class UFortQueryTest_OnFlatSurface final : public UEnvQueryTest
{
public:
	float                                         Radius;                                            // 0x01C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ToleranceZ;                                        // 0x01C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceOffsetUp;                                     // 0x01C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceOffsetDown;                                   // 0x01CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_OnFlatSurface">();
	}
	static class UFortQueryTest_OnFlatSurface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_OnFlatSurface>();
	}
};
static_assert(alignof(UFortQueryTest_OnFlatSurface) == 0x000008, "Wrong alignment on UFortQueryTest_OnFlatSurface");
static_assert(sizeof(UFortQueryTest_OnFlatSurface) == 0x0001D0, "Wrong size on UFortQueryTest_OnFlatSurface");
static_assert(offsetof(UFortQueryTest_OnFlatSurface, Radius) == 0x0001C0, "Member 'UFortQueryTest_OnFlatSurface::Radius' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_OnFlatSurface, ToleranceZ) == 0x0001C4, "Member 'UFortQueryTest_OnFlatSurface::ToleranceZ' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_OnFlatSurface, TraceOffsetUp) == 0x0001C8, "Member 'UFortQueryTest_OnFlatSurface::TraceOffsetUp' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_OnFlatSurface, TraceOffsetDown) == 0x0001CC, "Member 'UFortQueryTest_OnFlatSurface::TraceOffsetDown' has a wrong offset!");

// Class FortniteGame.FortQueryTwoPointSolver
// 0x00C8 (0x00F0 - 0x0028)
class UFortQueryTwoPointSolver final : public UObject
{
public:
	class UEnvQuery*                              QueryPointA;                                       // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEnvQuery*                              QueryPointB;                                       // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FEnvNamedValue>                 QueryParamsA;                                      // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FEnvNamedValue>                 QueryParamsB;                                      // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnFinished;                                        // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnFailed;                                          // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	ETwoPointSolverRotationA                      RotationMode;                                      // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               MinRotationOffset;                                 // 0x007C(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               MaxRotationOffset;                                 // 0x0088(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bUseNegativeAngleOffsets : 1;                      // 0x0094(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUsePositiveAngleOffsets : 1;                      // 0x0094(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_95[0x4B];                                      // 0x0095(0x004B)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAISystem*                          AISys;                                             // 0x00E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObject*                                CachedQuerier;                                     // 0x00E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddNamedFloatParamA(class FName ParamName, float Value);
	void AddNamedFloatParamB(class FName ParamName, float Value);
	void OnCustomRotationMode(const struct FVector& PointA, const struct FVector& Querier);
	void SetCustomRotationA(const struct FRotator& Rotation);
	void SkipToNextPointA();
	void Start(class UObject* Querier);

	struct FRotator GetRandomRotationOffset() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTwoPointSolver">();
	}
	static class UFortQueryTwoPointSolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTwoPointSolver>();
	}
};
static_assert(alignof(UFortQueryTwoPointSolver) == 0x000008, "Wrong alignment on UFortQueryTwoPointSolver");
static_assert(sizeof(UFortQueryTwoPointSolver) == 0x0000F0, "Wrong size on UFortQueryTwoPointSolver");
static_assert(offsetof(UFortQueryTwoPointSolver, QueryPointA) == 0x000028, "Member 'UFortQueryTwoPointSolver::QueryPointA' has a wrong offset!");
static_assert(offsetof(UFortQueryTwoPointSolver, QueryPointB) == 0x000030, "Member 'UFortQueryTwoPointSolver::QueryPointB' has a wrong offset!");
static_assert(offsetof(UFortQueryTwoPointSolver, QueryParamsA) == 0x000038, "Member 'UFortQueryTwoPointSolver::QueryParamsA' has a wrong offset!");
static_assert(offsetof(UFortQueryTwoPointSolver, QueryParamsB) == 0x000048, "Member 'UFortQueryTwoPointSolver::QueryParamsB' has a wrong offset!");
static_assert(offsetof(UFortQueryTwoPointSolver, OnFinished) == 0x000058, "Member 'UFortQueryTwoPointSolver::OnFinished' has a wrong offset!");
static_assert(offsetof(UFortQueryTwoPointSolver, OnFailed) == 0x000068, "Member 'UFortQueryTwoPointSolver::OnFailed' has a wrong offset!");
static_assert(offsetof(UFortQueryTwoPointSolver, RotationMode) == 0x000078, "Member 'UFortQueryTwoPointSolver::RotationMode' has a wrong offset!");
static_assert(offsetof(UFortQueryTwoPointSolver, MinRotationOffset) == 0x00007C, "Member 'UFortQueryTwoPointSolver::MinRotationOffset' has a wrong offset!");
static_assert(offsetof(UFortQueryTwoPointSolver, MaxRotationOffset) == 0x000088, "Member 'UFortQueryTwoPointSolver::MaxRotationOffset' has a wrong offset!");
static_assert(offsetof(UFortQueryTwoPointSolver, AISys) == 0x0000E0, "Member 'UFortQueryTwoPointSolver::AISys' has a wrong offset!");
static_assert(offsetof(UFortQueryTwoPointSolver, CachedQuerier) == 0x0000E8, "Member 'UFortQueryTwoPointSolver::CachedQuerier' has a wrong offset!");

// Class FortniteGame.FortRarityData
// 0x0500 (0x0528 - 0x0028)
class UFortRarityData final : public UDataAsset
{
public:
	struct FFortRarityItemData                    RarityCollection[0xA];                             // 0x0028(0x0080)(Edit, NativeAccessSpecifierPublic)

public:
	static struct FFortRarityItemData BPGetRarityData(EFortRarity Rarity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortRarityData">();
	}
	static class UFortRarityData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortRarityData>();
	}
};
static_assert(alignof(UFortRarityData) == 0x000008, "Wrong alignment on UFortRarityData");
static_assert(sizeof(UFortRarityData) == 0x000528, "Wrong size on UFortRarityData");
static_assert(offsetof(UFortRarityData, RarityCollection) == 0x000028, "Member 'UFortRarityData::RarityCollection' has a wrong offset!");

// Class FortniteGame.FortScoreStylingData
// 0x1530 (0x1558 - 0x0028)
class UFortScoreStylingData final : public UDataAsset
{
public:
	struct FFortScoreStylingInfo                  ScoreStyles[0x6];                                  // 0x0028(0x0388)(Edit, NativeAccessSpecifierPublic)

public:
	static bool GetScoreStylingData(EFortUIScoreType Rarity, struct FFortScoreStylingInfo* ScoreStylingInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortScoreStylingData">();
	}
	static class UFortScoreStylingData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortScoreStylingData>();
	}
};
static_assert(alignof(UFortScoreStylingData) == 0x000008, "Wrong alignment on UFortScoreStylingData");
static_assert(sizeof(UFortScoreStylingData) == 0x001558, "Wrong size on UFortScoreStylingData");
static_assert(offsetof(UFortScoreStylingData, ScoreStyles) == 0x000028, "Member 'UFortScoreStylingData::ScoreStyles' has a wrong offset!");

// Class FortniteGame.FortScriptedActionManager
// 0x0050 (0x03D8 - 0x0388)
class AFortScriptedActionManager final : public AActor
{
public:
	uint8                                         Pad_388[0x8];                                      // 0x0388(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AFortScriptedAction*>            ActiveScriptedActions;                             // 0x0390(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortAvailableScriptedAction>   AvailableScriptedActions;                          // 0x03A0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortAvailableScriptedAction>   PendingAvailableScriptedActions;                   // 0x03B0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortClientEventName>           PendingClientEvents;                               // 0x03C0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsProcessingClientEvent;                          // 0x03D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D1[0x7];                                      // 0x03D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleClientEvent_Undefined(class UObject* EventSource, class UObject* EventFocus, const struct FFortClientEvent& ClientEvent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortScriptedActionManager">();
	}
	static class AFortScriptedActionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortScriptedActionManager>();
	}
};
static_assert(alignof(AFortScriptedActionManager) == 0x000008, "Wrong alignment on AFortScriptedActionManager");
static_assert(sizeof(AFortScriptedActionManager) == 0x0003D8, "Wrong size on AFortScriptedActionManager");
static_assert(offsetof(AFortScriptedActionManager, ActiveScriptedActions) == 0x000390, "Member 'AFortScriptedActionManager::ActiveScriptedActions' has a wrong offset!");
static_assert(offsetof(AFortScriptedActionManager, AvailableScriptedActions) == 0x0003A0, "Member 'AFortScriptedActionManager::AvailableScriptedActions' has a wrong offset!");
static_assert(offsetof(AFortScriptedActionManager, PendingAvailableScriptedActions) == 0x0003B0, "Member 'AFortScriptedActionManager::PendingAvailableScriptedActions' has a wrong offset!");
static_assert(offsetof(AFortScriptedActionManager, PendingClientEvents) == 0x0003C0, "Member 'AFortScriptedActionManager::PendingClientEvents' has a wrong offset!");
static_assert(offsetof(AFortScriptedActionManager, bIsProcessingClientEvent) == 0x0003D0, "Member 'AFortScriptedActionManager::bIsProcessingClientEvent' has a wrong offset!");

// Class FortniteGame.FortServerBehaviorTrackerConfig
// 0x04C8 (0x04F0 - 0x0028)
class UFortServerBehaviorTrackerConfig final : public UDataAsset
{
public:
	struct FRuntimeFloatCurve                     DisembarkBonus;                                    // 0x0028(0x0078)(Edit, Config, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     TouchdownBonus;                                    // 0x00A0(0x0078)(Edit, Config, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     MutualDamagePenalty;                               // 0x0118(0x0078)(Edit, Config, NativeAccessSpecifierPublic)
	bool                                          bEvaluateSquadmates;                               // 0x0190(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_191[0x3];                                      // 0x0191(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDistanceToConsider;                             // 0x0194(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     NearnessScaleByDistance;                           // 0x0198(0x0078)(Edit, Config, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     NearnessScaleByPopulation;                         // 0x0210(0x0078)(Edit, Config, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     SightScaleByNearness;                              // 0x0288(0x0078)(Edit, Config, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     SightScaleByMaxSpeed;                              // 0x0300(0x0078)(Edit, Config, NativeAccessSpecifierPublic)
	float                                         SightSmoothingMultiplier;                          // 0x0378(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37C[0x4];                                      // 0x037C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     ThirdPartyKillBonus;                               // 0x0380(0x0078)(Edit, Config, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     ThirdPartyDamageScaleByNearness;                   // 0x03F8(0x0078)(Edit, Config, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     ThirdPartyDamageScaleBySight;                      // 0x0470(0x0078)(Edit, Config, NativeAccessSpecifierPublic)
	float                                         ThirdPartyDamageBonusPerPoint;                     // 0x04E8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4EC[0x4];                                      // 0x04EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortServerBehaviorTrackerConfig">();
	}
	static class UFortServerBehaviorTrackerConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortServerBehaviorTrackerConfig>();
	}
};
static_assert(alignof(UFortServerBehaviorTrackerConfig) == 0x000008, "Wrong alignment on UFortServerBehaviorTrackerConfig");
static_assert(sizeof(UFortServerBehaviorTrackerConfig) == 0x0004F0, "Wrong size on UFortServerBehaviorTrackerConfig");
static_assert(offsetof(UFortServerBehaviorTrackerConfig, DisembarkBonus) == 0x000028, "Member 'UFortServerBehaviorTrackerConfig::DisembarkBonus' has a wrong offset!");
static_assert(offsetof(UFortServerBehaviorTrackerConfig, TouchdownBonus) == 0x0000A0, "Member 'UFortServerBehaviorTrackerConfig::TouchdownBonus' has a wrong offset!");
static_assert(offsetof(UFortServerBehaviorTrackerConfig, MutualDamagePenalty) == 0x000118, "Member 'UFortServerBehaviorTrackerConfig::MutualDamagePenalty' has a wrong offset!");
static_assert(offsetof(UFortServerBehaviorTrackerConfig, bEvaluateSquadmates) == 0x000190, "Member 'UFortServerBehaviorTrackerConfig::bEvaluateSquadmates' has a wrong offset!");
static_assert(offsetof(UFortServerBehaviorTrackerConfig, MaxDistanceToConsider) == 0x000194, "Member 'UFortServerBehaviorTrackerConfig::MaxDistanceToConsider' has a wrong offset!");
static_assert(offsetof(UFortServerBehaviorTrackerConfig, NearnessScaleByDistance) == 0x000198, "Member 'UFortServerBehaviorTrackerConfig::NearnessScaleByDistance' has a wrong offset!");
static_assert(offsetof(UFortServerBehaviorTrackerConfig, NearnessScaleByPopulation) == 0x000210, "Member 'UFortServerBehaviorTrackerConfig::NearnessScaleByPopulation' has a wrong offset!");
static_assert(offsetof(UFortServerBehaviorTrackerConfig, SightScaleByNearness) == 0x000288, "Member 'UFortServerBehaviorTrackerConfig::SightScaleByNearness' has a wrong offset!");
static_assert(offsetof(UFortServerBehaviorTrackerConfig, SightScaleByMaxSpeed) == 0x000300, "Member 'UFortServerBehaviorTrackerConfig::SightScaleByMaxSpeed' has a wrong offset!");
static_assert(offsetof(UFortServerBehaviorTrackerConfig, SightSmoothingMultiplier) == 0x000378, "Member 'UFortServerBehaviorTrackerConfig::SightSmoothingMultiplier' has a wrong offset!");
static_assert(offsetof(UFortServerBehaviorTrackerConfig, ThirdPartyKillBonus) == 0x000380, "Member 'UFortServerBehaviorTrackerConfig::ThirdPartyKillBonus' has a wrong offset!");
static_assert(offsetof(UFortServerBehaviorTrackerConfig, ThirdPartyDamageScaleByNearness) == 0x0003F8, "Member 'UFortServerBehaviorTrackerConfig::ThirdPartyDamageScaleByNearness' has a wrong offset!");
static_assert(offsetof(UFortServerBehaviorTrackerConfig, ThirdPartyDamageScaleBySight) == 0x000470, "Member 'UFortServerBehaviorTrackerConfig::ThirdPartyDamageScaleBySight' has a wrong offset!");
static_assert(offsetof(UFortServerBehaviorTrackerConfig, ThirdPartyDamageBonusPerPoint) == 0x0004E8, "Member 'UFortServerBehaviorTrackerConfig::ThirdPartyDamageBonusPerPoint' has a wrong offset!");

// Class FortniteGame.FortSharedMissionLists
// 0x0130 (0x0158 - 0x0028)
class UFortSharedMissionLists : public UObject
{
public:
	TArray<struct FFortGlobalMission>             SharedMissionList;                                 // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortQuestDrivenMission>        QuestDrivenMissionList;                            // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagQuery                      PrimaryMissionTagQuery;                            // 0x0048(0x0048)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FGameplayTagQuery                      TheaterTagQuery;                                   // 0x0090(0x0048)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FGameplayTagQuery                      RegionTagQuery;                                    // 0x00D8(0x0048)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<struct FFortQuestDrivenMission>        AvailableQuestDrivenMissionList;                   // 0x0120(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AFortPlayerController*>          PendingPIEPlayers;                                 // 0x0130(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_140[0x18];                                     // 0x0140(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdatePIEPlayers();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortSharedMissionLists">();
	}
	static class UFortSharedMissionLists* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortSharedMissionLists>();
	}
};
static_assert(alignof(UFortSharedMissionLists) == 0x000008, "Wrong alignment on UFortSharedMissionLists");
static_assert(sizeof(UFortSharedMissionLists) == 0x000158, "Wrong size on UFortSharedMissionLists");
static_assert(offsetof(UFortSharedMissionLists, SharedMissionList) == 0x000028, "Member 'UFortSharedMissionLists::SharedMissionList' has a wrong offset!");
static_assert(offsetof(UFortSharedMissionLists, QuestDrivenMissionList) == 0x000038, "Member 'UFortSharedMissionLists::QuestDrivenMissionList' has a wrong offset!");
static_assert(offsetof(UFortSharedMissionLists, PrimaryMissionTagQuery) == 0x000048, "Member 'UFortSharedMissionLists::PrimaryMissionTagQuery' has a wrong offset!");
static_assert(offsetof(UFortSharedMissionLists, TheaterTagQuery) == 0x000090, "Member 'UFortSharedMissionLists::TheaterTagQuery' has a wrong offset!");
static_assert(offsetof(UFortSharedMissionLists, RegionTagQuery) == 0x0000D8, "Member 'UFortSharedMissionLists::RegionTagQuery' has a wrong offset!");
static_assert(offsetof(UFortSharedMissionLists, AvailableQuestDrivenMissionList) == 0x000120, "Member 'UFortSharedMissionLists::AvailableQuestDrivenMissionList' has a wrong offset!");
static_assert(offsetof(UFortSharedMissionLists, PendingPIEPlayers) == 0x000130, "Member 'UFortSharedMissionLists::PendingPIEPlayers' has a wrong offset!");

// Class FortniteGame.FortSpawnPointsPercentageCurveSequence
// 0x0018 (0x0040 - 0x0028)
class UFortSpawnPointsPercentageCurveSequence final : public UDataAsset
{
public:
	TArray<struct FDataTableRowHandle>            SpawnPointsPercentageCurves;                       // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	EFortIntensityCurveSequenceType               SequenceType;                                      // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortSpawnPointsPercentageCurveSequence">();
	}
	static class UFortSpawnPointsPercentageCurveSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortSpawnPointsPercentageCurveSequence>();
	}
};
static_assert(alignof(UFortSpawnPointsPercentageCurveSequence) == 0x000008, "Wrong alignment on UFortSpawnPointsPercentageCurveSequence");
static_assert(sizeof(UFortSpawnPointsPercentageCurveSequence) == 0x000040, "Wrong size on UFortSpawnPointsPercentageCurveSequence");
static_assert(offsetof(UFortSpawnPointsPercentageCurveSequence, SpawnPointsPercentageCurves) == 0x000028, "Member 'UFortSpawnPointsPercentageCurveSequence::SpawnPointsPercentageCurves' has a wrong offset!");
static_assert(offsetof(UFortSpawnPointsPercentageCurveSequence, SequenceType) == 0x000038, "Member 'UFortSpawnPointsPercentageCurveSequence::SequenceType' has a wrong offset!");

// Class FortniteGame.FortStaticMeshUserData
// 0x0010 (0x0038 - 0x0028)
class UFortStaticMeshUserData final : public UAssetUserData
{
public:
	TArray<struct FTransformableNavLinkClass>     NavLinks;                                          // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortStaticMeshUserData">();
	}
	static class UFortStaticMeshUserData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortStaticMeshUserData>();
	}
};
static_assert(alignof(UFortStaticMeshUserData) == 0x000008, "Wrong alignment on UFortStaticMeshUserData");
static_assert(sizeof(UFortStaticMeshUserData) == 0x000038, "Wrong size on UFortStaticMeshUserData");
static_assert(offsetof(UFortStaticMeshUserData, NavLinks) == 0x000028, "Member 'UFortStaticMeshUserData::NavLinks' has a wrong offset!");

// Class FortniteGame.FortTaggedActorsManager
// 0x03A8 (0x03D0 - 0x0028)
class UFortTaggedActorsManager final : public UObject
{
public:
	uint8                                         Pad_28[0x3A8];                                     // 0x0028(0x03A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTaggedActorsManager">();
	}
	static class UFortTaggedActorsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortTaggedActorsManager>();
	}
};
static_assert(alignof(UFortTaggedActorsManager) == 0x000008, "Wrong alignment on UFortTaggedActorsManager");
static_assert(sizeof(UFortTaggedActorsManager) == 0x0003D0, "Wrong size on UFortTaggedActorsManager");

// Class FortniteGame.FortTeamIdentification
// 0x0010 (0x0038 - 0x0028)
class UFortTeamIdentification : public UObject
{
public:
	struct FColor                                 HUDColor;                                          // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCustomAccessoryColorSwatch*            CharacterAccessoryColorSwatch;                     // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTeamIdentification">();
	}
	static class UFortTeamIdentification* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortTeamIdentification>();
	}
};
static_assert(alignof(UFortTeamIdentification) == 0x000008, "Wrong alignment on UFortTeamIdentification");
static_assert(sizeof(UFortTeamIdentification) == 0x000038, "Wrong size on UFortTeamIdentification");
static_assert(offsetof(UFortTeamIdentification, HUDColor) == 0x000028, "Member 'UFortTeamIdentification::HUDColor' has a wrong offset!");
static_assert(offsetof(UFortTeamIdentification, CharacterAccessoryColorSwatch) == 0x000030, "Member 'UFortTeamIdentification::CharacterAccessoryColorSwatch' has a wrong offset!");

// Class FortniteGame.FortTestControllerMemoryReport
// 0x0070 (0x00C0 - 0x0050)
class UFortTestControllerMemoryReport final : public UFortTestControllerBase
{
public:
	uint8                                         Pad_50[0x70];                                      // 0x0050(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTestControllerMemoryReport">();
	}
	static class UFortTestControllerMemoryReport* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortTestControllerMemoryReport>();
	}
};
static_assert(alignof(UFortTestControllerMemoryReport) == 0x000008, "Wrong alignment on UFortTestControllerMemoryReport");
static_assert(sizeof(UFortTestControllerMemoryReport) == 0x0000C0, "Wrong size on UFortTestControllerMemoryReport");

// Class FortniteGame.FortTips
// 0x0010 (0x0038 - 0x0028)
class UFortTips final : public UDataAsset
{
public:
	TArray<class FText>                           Tips;                                              // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTips">();
	}
	static class UFortTips* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortTips>();
	}
};
static_assert(alignof(UFortTips) == 0x000008, "Wrong alignment on UFortTips");
static_assert(sizeof(UFortTips) == 0x000038, "Wrong size on UFortTips");
static_assert(offsetof(UFortTips, Tips) == 0x000028, "Member 'UFortTips::Tips' has a wrong offset!");

// Class FortniteGame.FortTokenToTextTable
// 0x0060 (0x0088 - 0x0028)
class UFortTokenToTextTable final : public UDataAsset
{
public:
	TArray<struct FFortTooltipTokenInfo>          TokenInfoList;                                     // 0x0028(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTokenToTextTable">();
	}
	static class UFortTokenToTextTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortTokenToTextTable>();
	}
};
static_assert(alignof(UFortTokenToTextTable) == 0x000008, "Wrong alignment on UFortTokenToTextTable");
static_assert(sizeof(UFortTokenToTextTable) == 0x000088, "Wrong size on UFortTokenToTextTable");
static_assert(offsetof(UFortTokenToTextTable, TokenInfoList) == 0x000028, "Member 'UFortTokenToTextTable::TokenInfoList' has a wrong offset!");

// Class FortniteGame.FortGadgetItemDefinitionTooltip
// 0x0000 (0x0090 - 0x0090)
class UFortGadgetItemDefinitionTooltip final : public UFortWorldItemDefinitionTooltip
{
public:
	bool GetNumericValue(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, float* OutVal) const;
	bool GetTextForToken(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, class FText* OutText) const;
	bool GetTokenizedDescriptionText(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, TArray<class FText>* OutDescription) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGadgetItemDefinitionTooltip">();
	}
	static class UFortGadgetItemDefinitionTooltip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGadgetItemDefinitionTooltip>();
	}
};
static_assert(alignof(UFortGadgetItemDefinitionTooltip) == 0x000008, "Wrong alignment on UFortGadgetItemDefinitionTooltip");
static_assert(sizeof(UFortGadgetItemDefinitionTooltip) == 0x000090, "Wrong size on UFortGadgetItemDefinitionTooltip");

// Class FortniteGame.FortWeaponRangedItemDefinitionTooltip
// 0x0000 (0x0090 - 0x0090)
class UFortWeaponRangedItemDefinitionTooltip final : public UFortWeaponItemDefinitionTooltip
{
public:
	bool GetNumericValue(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, float* OutVal) const;
	bool GetTextForToken(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, class FText* OutText) const;
	bool GetTokenizedDescriptionText(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, TArray<class FText>* OutDescription) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortWeaponRangedItemDefinitionTooltip">();
	}
	static class UFortWeaponRangedItemDefinitionTooltip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortWeaponRangedItemDefinitionTooltip>();
	}
};
static_assert(alignof(UFortWeaponRangedItemDefinitionTooltip) == 0x000008, "Wrong alignment on UFortWeaponRangedItemDefinitionTooltip");
static_assert(sizeof(UFortWeaponRangedItemDefinitionTooltip) == 0x000090, "Wrong size on UFortWeaponRangedItemDefinitionTooltip");

// Class FortniteGame.FortHeroTooltip
// 0x0000 (0x00B0 - 0x00B0)
class UFortHeroTooltip final : public UFortCharacterTooltip
{
public:
	bool GetNumericValue(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, float* OutVal) const;
	bool GetTextForToken(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, class FText* OutText) const;
	bool GetTokenizedDescriptionText(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, TArray<class FText>* OutDescription) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortHeroTooltip">();
	}
	static class UFortHeroTooltip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortHeroTooltip>();
	}
};
static_assert(alignof(UFortHeroTooltip) == 0x000008, "Wrong alignment on UFortHeroTooltip");
static_assert(sizeof(UFortHeroTooltip) == 0x0000B0, "Wrong size on UFortHeroTooltip");

// Class FortniteGame.FortHomebaseNodeItemTooltip
// 0x0000 (0x0090 - 0x0090)
class UFortHomebaseNodeItemTooltip final : public UFortItemTooltip
{
public:
	bool GetNumericValue(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, float* OutVal) const;
	bool GetTextForToken(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, class FText* OutText) const;
	bool GetTokenizedDescriptionText(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, TArray<class FText>* OutDescription) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortHomebaseNodeItemTooltip">();
	}
	static class UFortHomebaseNodeItemTooltip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortHomebaseNodeItemTooltip>();
	}
};
static_assert(alignof(UFortHomebaseNodeItemTooltip) == 0x000008, "Wrong alignment on UFortHomebaseNodeItemTooltip");
static_assert(sizeof(UFortHomebaseNodeItemTooltip) == 0x000090, "Wrong size on UFortHomebaseNodeItemTooltip");

// Class FortniteGame.FortConsumableItemTooltip
// 0x0000 (0x0090 - 0x0090)
class UFortConsumableItemTooltip final : public UFortWorldItemTooltip
{
public:
	bool GetNumericValue(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, float* OutVal) const;
	bool GetTextForToken(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const struct FGameplayTag& Token, class FText* OutText) const;
	bool GetTokenizedDescriptionText(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, TArray<class FText>* OutDescription) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortConsumableItemTooltip">();
	}
	static class UFortConsumableItemTooltip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortConsumableItemTooltip>();
	}
};
static_assert(alignof(UFortConsumableItemTooltip) == 0x000008, "Wrong alignment on UFortConsumableItemTooltip");
static_assert(sizeof(UFortConsumableItemTooltip) == 0x000090, "Wrong size on UFortConsumableItemTooltip");

// Class FortniteGame.FortTrackMovementComponent
// 0x0098 (0x01D0 - 0x0138)
class UFortTrackMovementComponent final : public UMovementComponent
{
public:
	struct FVector                                TrackSnapExtent;                                   // 0x0138(0x000C)(Edit, BlueprintVisible, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TurnSpeed;                                         // 0x0144(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SplineLocationOffsetZ;                             // 0x0150(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DiscoverSplineFrequency;                           // 0x0154(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrackVelocity;                                     // 0x0158(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReverseYawWhenReversedOnSpline;                   // 0x015C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15D[0x3];                                      // 0x015D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnOutOfTrack;                                      // 0x0160(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnLostTrack;                                       // 0x0170(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FTrackMovement                         TrackMovement;                                     // 0x0180(0x0010)(Transient, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRepTrackMovement                      ReplicatedTrackMovement;                           // 0x0190(0x0018)(Net, RepNotify, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A8[0x10];                                     // 0x01A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClientPredictionSpeedModifier;                     // 0x01B8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1BC[0x14];                                     // 0x01BC(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FlipDirection();
	void OnRep_ReplicatedTrackMovement();

	float GetDistanceAlongSpline() const;
	class USplineComponent* GetSpline() const;
	class AFortTrack* GetTrack() const;
	bool IsReverseDirection() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTrackMovementComponent">();
	}
	static class UFortTrackMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortTrackMovementComponent>();
	}
};
static_assert(alignof(UFortTrackMovementComponent) == 0x000008, "Wrong alignment on UFortTrackMovementComponent");
static_assert(sizeof(UFortTrackMovementComponent) == 0x0001D0, "Wrong size on UFortTrackMovementComponent");
static_assert(offsetof(UFortTrackMovementComponent, TrackSnapExtent) == 0x000138, "Member 'UFortTrackMovementComponent::TrackSnapExtent' has a wrong offset!");
static_assert(offsetof(UFortTrackMovementComponent, TurnSpeed) == 0x000144, "Member 'UFortTrackMovementComponent::TurnSpeed' has a wrong offset!");
static_assert(offsetof(UFortTrackMovementComponent, SplineLocationOffsetZ) == 0x000150, "Member 'UFortTrackMovementComponent::SplineLocationOffsetZ' has a wrong offset!");
static_assert(offsetof(UFortTrackMovementComponent, DiscoverSplineFrequency) == 0x000154, "Member 'UFortTrackMovementComponent::DiscoverSplineFrequency' has a wrong offset!");
static_assert(offsetof(UFortTrackMovementComponent, TrackVelocity) == 0x000158, "Member 'UFortTrackMovementComponent::TrackVelocity' has a wrong offset!");
static_assert(offsetof(UFortTrackMovementComponent, bReverseYawWhenReversedOnSpline) == 0x00015C, "Member 'UFortTrackMovementComponent::bReverseYawWhenReversedOnSpline' has a wrong offset!");
static_assert(offsetof(UFortTrackMovementComponent, OnOutOfTrack) == 0x000160, "Member 'UFortTrackMovementComponent::OnOutOfTrack' has a wrong offset!");
static_assert(offsetof(UFortTrackMovementComponent, OnLostTrack) == 0x000170, "Member 'UFortTrackMovementComponent::OnLostTrack' has a wrong offset!");
static_assert(offsetof(UFortTrackMovementComponent, TrackMovement) == 0x000180, "Member 'UFortTrackMovementComponent::TrackMovement' has a wrong offset!");
static_assert(offsetof(UFortTrackMovementComponent, ReplicatedTrackMovement) == 0x000190, "Member 'UFortTrackMovementComponent::ReplicatedTrackMovement' has a wrong offset!");
static_assert(offsetof(UFortTrackMovementComponent, ClientPredictionSpeedModifier) == 0x0001B8, "Member 'UFortTrackMovementComponent::ClientPredictionSpeedModifier' has a wrong offset!");

// Class FortniteGame.FortUIPvPBaseDestruction
// 0x0000 (0x08C0 - 0x08C0)
class AFortUIPvPBaseDestruction final : public AFortUIPvP
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortUIPvPBaseDestruction">();
	}
	static class AFortUIPvPBaseDestruction* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortUIPvPBaseDestruction>();
	}
};
static_assert(alignof(AFortUIPvPBaseDestruction) == 0x000008, "Wrong alignment on AFortUIPvPBaseDestruction");
static_assert(sizeof(AFortUIPvPBaseDestruction) == 0x0008C0, "Wrong size on AFortUIPvPBaseDestruction");

// Class FortniteGame.FortUIManagerInterface
// 0x0000 (0x0028 - 0x0028)
class IFortUIManagerInterface final : public IInterface
{
public:
	void KillConfirmation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortUIManagerInterface">();
	}
	static class IFortUIManagerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortUIManagerInterface>();
	}
};
static_assert(alignof(IFortUIManagerInterface) == 0x000008, "Wrong alignment on IFortUIManagerInterface");
static_assert(sizeof(IFortUIManagerInterface) == 0x000028, "Wrong size on IFortUIManagerInterface");

// Class FortniteGame.FortUIFriendNotification
// 0x0008 (0x0098 - 0x0090)
class UFortUIFriendNotification : public UFortUINotification
{
public:
	EFortUIFriendNotificationType                 FriendActionType;                                  // 0x0090(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortUIFriendNotification">();
	}
	static class UFortUIFriendNotification* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortUIFriendNotification>();
	}
};
static_assert(alignof(UFortUIFriendNotification) == 0x000008, "Wrong alignment on UFortUIFriendNotification");
static_assert(sizeof(UFortUIFriendNotification) == 0x000098, "Wrong size on UFortUIFriendNotification");
static_assert(offsetof(UFortUIFriendNotification, FriendActionType) == 0x000090, "Member 'UFortUIFriendNotification::FriendActionType' has a wrong offset!");

// Class FortniteGame.FortUIProxyActor
// 0x0098 (0x0420 - 0x0388)
class AFortUIProxyActor final : public AActor
{
public:
	uint8                                         Pad_388[0x10];                                     // 0x0388(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAttributeSet*>                  AttributeSets;                                     // 0x0398(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UFortAbilitySystemComponent*            AbilitySystemComponent;                            // 0x03A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortItemDefinition*                    ItemDef;                                           // 0x03B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFortAttributeInitializationKey        InitializerKey;                                    // 0x03B8(0x0010)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C8[0x58];                                     // 0x03C8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortUIProxyActor">();
	}
	static class AFortUIProxyActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortUIProxyActor>();
	}
};
static_assert(alignof(AFortUIProxyActor) == 0x000008, "Wrong alignment on AFortUIProxyActor");
static_assert(sizeof(AFortUIProxyActor) == 0x000420, "Wrong size on AFortUIProxyActor");
static_assert(offsetof(AFortUIProxyActor, AttributeSets) == 0x000398, "Member 'AFortUIProxyActor::AttributeSets' has a wrong offset!");
static_assert(offsetof(AFortUIProxyActor, AbilitySystemComponent) == 0x0003A8, "Member 'AFortUIProxyActor::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(AFortUIProxyActor, ItemDef) == 0x0003B0, "Member 'AFortUIProxyActor::ItemDef' has a wrong offset!");
static_assert(offsetof(AFortUIProxyActor, InitializerKey) == 0x0003B8, "Member 'AFortUIProxyActor::InitializerKey' has a wrong offset!");

// Class FortniteGame.FortValidationInterface
// 0x0000 (0x0028 - 0x0028)
class IFortValidationInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortValidationInterface">();
	}
	static class IFortValidationInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortValidationInterface>();
	}
};
static_assert(alignof(IFortValidationInterface) == 0x000008, "Wrong alignment on IFortValidationInterface");
static_assert(sizeof(IFortValidationInterface) == 0x000028, "Wrong size on IFortValidationInterface");

// Class FortniteGame.FortTrapTool
// 0x0000 (0x0AD0 - 0x0AD0)
class AFortTrapTool final : public AFortDecoTool
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTrapTool">();
	}
	static class AFortTrapTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortTrapTool>();
	}
};
static_assert(alignof(AFortTrapTool) == 0x000008, "Wrong alignment on AFortTrapTool");
static_assert(sizeof(AFortTrapTool) == 0x000AD0, "Wrong size on AFortTrapTool");

// Class FortniteGame.FortWeap_BuildingToolBase
// 0x0020 (0x0AA8 - 0x0A88)
class AFortWeap_BuildingToolBase : public AFortWeapon
{
public:
	class UStaticMeshComponent*                   PencilMeshComponent;                               // 0x0A88(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   BlueprintPaperSocket;                              // 0x0A90(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BlueprintPencilSocket;                             // 0x0A98(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortPlayerController*                  InstigatorController;                              // 0x0AA0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortWeap_BuildingToolBase">();
	}
	static class AFortWeap_BuildingToolBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortWeap_BuildingToolBase>();
	}
};
static_assert(alignof(AFortWeap_BuildingToolBase) == 0x000008, "Wrong alignment on AFortWeap_BuildingToolBase");
static_assert(sizeof(AFortWeap_BuildingToolBase) == 0x000AA8, "Wrong size on AFortWeap_BuildingToolBase");
static_assert(offsetof(AFortWeap_BuildingToolBase, PencilMeshComponent) == 0x000A88, "Member 'AFortWeap_BuildingToolBase::PencilMeshComponent' has a wrong offset!");
static_assert(offsetof(AFortWeap_BuildingToolBase, BlueprintPaperSocket) == 0x000A90, "Member 'AFortWeap_BuildingToolBase::BlueprintPaperSocket' has a wrong offset!");
static_assert(offsetof(AFortWeap_BuildingToolBase, BlueprintPencilSocket) == 0x000A98, "Member 'AFortWeap_BuildingToolBase::BlueprintPencilSocket' has a wrong offset!");
static_assert(offsetof(AFortWeap_BuildingToolBase, InstigatorController) == 0x000AA0, "Member 'AFortWeap_BuildingToolBase::InstigatorController' has a wrong offset!");

// Class FortniteGame.FortWeap_BuildingTool
// 0x0158 (0x0C00 - 0x0AA8)
class AFortWeap_BuildingTool final : public AFortWeap_BuildingToolBase
{
public:
	class UMaterialInterface*                     BlueprintPaperMaterial;                            // 0x0AA8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             BlueprintDiffuseTextures[0x4];                     // 0x0AB0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             BlueprintEmissiveMaskTextures[0x4];                // 0x0AD0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            BlueprintPaperPulseCurve;                          // 0x0AF0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBuildingEditModeMetadata*              DefaultMetadata;                                   // 0x0AF8(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               BlueprintPaperMID;                                 // 0x0B00(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B08[0x8];                                      // 0x0B08(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimeline                              BlueprintPaperPulseTimeline;                       // 0x0B10(0x00E0)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	EFortResourceType                             LastResourceType;                                  // 0x0BF0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BF1[0xF];                                      // 0x0BF1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBlueprintPaperPulseUpdate(float InCurveVal);
	void OnRep_DefaultMetadata();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortWeap_BuildingTool">();
	}
	static class AFortWeap_BuildingTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortWeap_BuildingTool>();
	}
};
static_assert(alignof(AFortWeap_BuildingTool) == 0x000010, "Wrong alignment on AFortWeap_BuildingTool");
static_assert(sizeof(AFortWeap_BuildingTool) == 0x000C00, "Wrong size on AFortWeap_BuildingTool");
static_assert(offsetof(AFortWeap_BuildingTool, BlueprintPaperMaterial) == 0x000AA8, "Member 'AFortWeap_BuildingTool::BlueprintPaperMaterial' has a wrong offset!");
static_assert(offsetof(AFortWeap_BuildingTool, BlueprintDiffuseTextures) == 0x000AB0, "Member 'AFortWeap_BuildingTool::BlueprintDiffuseTextures' has a wrong offset!");
static_assert(offsetof(AFortWeap_BuildingTool, BlueprintEmissiveMaskTextures) == 0x000AD0, "Member 'AFortWeap_BuildingTool::BlueprintEmissiveMaskTextures' has a wrong offset!");
static_assert(offsetof(AFortWeap_BuildingTool, BlueprintPaperPulseCurve) == 0x000AF0, "Member 'AFortWeap_BuildingTool::BlueprintPaperPulseCurve' has a wrong offset!");
static_assert(offsetof(AFortWeap_BuildingTool, DefaultMetadata) == 0x000AF8, "Member 'AFortWeap_BuildingTool::DefaultMetadata' has a wrong offset!");
static_assert(offsetof(AFortWeap_BuildingTool, BlueprintPaperMID) == 0x000B00, "Member 'AFortWeap_BuildingTool::BlueprintPaperMID' has a wrong offset!");
static_assert(offsetof(AFortWeap_BuildingTool, BlueprintPaperPulseTimeline) == 0x000B10, "Member 'AFortWeap_BuildingTool::BlueprintPaperPulseTimeline' has a wrong offset!");
static_assert(offsetof(AFortWeap_BuildingTool, LastResourceType) == 0x000BF0, "Member 'AFortWeap_BuildingTool::LastResourceType' has a wrong offset!");

// Class FortniteGame.FortWeap_EditingTool
// 0x0010 (0x0AB8 - 0x0AA8)
class AFortWeap_EditingTool final : public AFortWeap_BuildingToolBase
{
public:
	class ABuildingSMActor*                       EditActor;                                         // 0x0AA8(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEditConfirmed;                                    // 0x0AB0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AB1[0x7];                                      // 0x0AB1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_EditActor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortWeap_EditingTool">();
	}
	static class AFortWeap_EditingTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortWeap_EditingTool>();
	}
};
static_assert(alignof(AFortWeap_EditingTool) == 0x000008, "Wrong alignment on AFortWeap_EditingTool");
static_assert(sizeof(AFortWeap_EditingTool) == 0x000AB8, "Wrong size on AFortWeap_EditingTool");
static_assert(offsetof(AFortWeap_EditingTool, EditActor) == 0x000AA8, "Member 'AFortWeap_EditingTool::EditActor' has a wrong offset!");
static_assert(offsetof(AFortWeap_EditingTool, bEditConfirmed) == 0x000AB0, "Member 'AFortWeap_EditingTool::bEditConfirmed' has a wrong offset!");

// Class FortniteGame.HoverDroneMovementComponent
// 0x00C8 (0x0260 - 0x0198)
class UHoverDroneMovementComponent final : public USpectatorPawnMovement
{
public:
	uint8                                         Pad_198[0x48];                                     // 0x0198(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotAcceleration;                                   // 0x01E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RotDeceleration;                                   // 0x01E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxPitchRotSpeed;                                  // 0x01E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxYawRotSpeed;                                    // 0x01EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurboRotAcceleration;                              // 0x01F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurboRotDeceleration;                              // 0x01F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurboMaxPitchRotSpeed;                             // 0x01F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurboMaxYawRotSpeed;                               // 0x01FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              TurboAccelerationRange;                            // 0x0200(0x0008)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              TurboAccelerationAltitudeRange;                    // 0x0208(0x0008)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurboDeceleration;                                 // 0x0210(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurboHoverThrustScale;                             // 0x0214(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FullAirFrictionVelocity;                           // 0x0218(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21C[0x44];                                     // 0x021C(0x0044)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HoverDroneMovementComponent">();
	}
	static class UHoverDroneMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHoverDroneMovementComponent>();
	}
};
static_assert(alignof(UHoverDroneMovementComponent) == 0x000008, "Wrong alignment on UHoverDroneMovementComponent");
static_assert(sizeof(UHoverDroneMovementComponent) == 0x000260, "Wrong size on UHoverDroneMovementComponent");
static_assert(offsetof(UHoverDroneMovementComponent, RotAcceleration) == 0x0001E0, "Member 'UHoverDroneMovementComponent::RotAcceleration' has a wrong offset!");
static_assert(offsetof(UHoverDroneMovementComponent, RotDeceleration) == 0x0001E4, "Member 'UHoverDroneMovementComponent::RotDeceleration' has a wrong offset!");
static_assert(offsetof(UHoverDroneMovementComponent, MaxPitchRotSpeed) == 0x0001E8, "Member 'UHoverDroneMovementComponent::MaxPitchRotSpeed' has a wrong offset!");
static_assert(offsetof(UHoverDroneMovementComponent, MaxYawRotSpeed) == 0x0001EC, "Member 'UHoverDroneMovementComponent::MaxYawRotSpeed' has a wrong offset!");
static_assert(offsetof(UHoverDroneMovementComponent, TurboRotAcceleration) == 0x0001F0, "Member 'UHoverDroneMovementComponent::TurboRotAcceleration' has a wrong offset!");
static_assert(offsetof(UHoverDroneMovementComponent, TurboRotDeceleration) == 0x0001F4, "Member 'UHoverDroneMovementComponent::TurboRotDeceleration' has a wrong offset!");
static_assert(offsetof(UHoverDroneMovementComponent, TurboMaxPitchRotSpeed) == 0x0001F8, "Member 'UHoverDroneMovementComponent::TurboMaxPitchRotSpeed' has a wrong offset!");
static_assert(offsetof(UHoverDroneMovementComponent, TurboMaxYawRotSpeed) == 0x0001FC, "Member 'UHoverDroneMovementComponent::TurboMaxYawRotSpeed' has a wrong offset!");
static_assert(offsetof(UHoverDroneMovementComponent, TurboAccelerationRange) == 0x000200, "Member 'UHoverDroneMovementComponent::TurboAccelerationRange' has a wrong offset!");
static_assert(offsetof(UHoverDroneMovementComponent, TurboAccelerationAltitudeRange) == 0x000208, "Member 'UHoverDroneMovementComponent::TurboAccelerationAltitudeRange' has a wrong offset!");
static_assert(offsetof(UHoverDroneMovementComponent, TurboDeceleration) == 0x000210, "Member 'UHoverDroneMovementComponent::TurboDeceleration' has a wrong offset!");
static_assert(offsetof(UHoverDroneMovementComponent, TurboHoverThrustScale) == 0x000214, "Member 'UHoverDroneMovementComponent::TurboHoverThrustScale' has a wrong offset!");
static_assert(offsetof(UHoverDroneMovementComponent, FullAirFrictionVelocity) == 0x000218, "Member 'UHoverDroneMovementComponent::FullAirFrictionVelocity' has a wrong offset!");

// Class FortniteGame.LevelTestingActorBase
// 0x0000 (0x0388 - 0x0388)
class ALevelTestingActorBase final : public AActor
{
public:
	static class USkeletalMesh* ExtractSkeletalMesh(TSubclassOf<class AActor> BlueprintClass);
	static struct FVector ExtractSkeletalMeshScale(TSubclassOf<class AActor> BlueprintClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelTestingActorBase">();
	}
	static class ALevelTestingActorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALevelTestingActorBase>();
	}
};
static_assert(alignof(ALevelTestingActorBase) == 0x000008, "Wrong alignment on ALevelTestingActorBase");
static_assert(sizeof(ALevelTestingActorBase) == 0x000388, "Wrong size on ALevelTestingActorBase");

// Class FortniteGame.MatchHeartbeatManager
// 0x0030 (0x0058 - 0x0028)
class UMatchHeartbeatManager final : public UObject
{
public:
	class AFortGameMode*                          OwningGameMode;                                    // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ServerMetricsLOD;                                  // 0x0030(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x18];                                      // 0x0034(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HighFrequencyServerMetricsDurationSec;             // 0x004C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         HighFrequencyEventsLOD;                            // 0x0050(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchHeartbeatManager">();
	}
	static class UMatchHeartbeatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchHeartbeatManager>();
	}
};
static_assert(alignof(UMatchHeartbeatManager) == 0x000008, "Wrong alignment on UMatchHeartbeatManager");
static_assert(sizeof(UMatchHeartbeatManager) == 0x000058, "Wrong size on UMatchHeartbeatManager");
static_assert(offsetof(UMatchHeartbeatManager, OwningGameMode) == 0x000028, "Member 'UMatchHeartbeatManager::OwningGameMode' has a wrong offset!");
static_assert(offsetof(UMatchHeartbeatManager, ServerMetricsLOD) == 0x000030, "Member 'UMatchHeartbeatManager::ServerMetricsLOD' has a wrong offset!");
static_assert(offsetof(UMatchHeartbeatManager, HighFrequencyServerMetricsDurationSec) == 0x00004C, "Member 'UMatchHeartbeatManager::HighFrequencyServerMetricsDurationSec' has a wrong offset!");
static_assert(offsetof(UMatchHeartbeatManager, HighFrequencyEventsLOD) == 0x000050, "Member 'UMatchHeartbeatManager::HighFrequencyEventsLOD' has a wrong offset!");

// Class FortniteGame.StatManager
// 0x0078 (0x00A0 - 0x0028)
class UStatManager final : public UObject
{
public:
	TArray<class UStat*>                          Stats;                                             // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 StatPrefix;                                        // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AFortPlayerController*                  FPC;                                               // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x50];                                      // 0x0050(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatManager">();
	}
	static class UStatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatManager>();
	}
};
static_assert(alignof(UStatManager) == 0x000008, "Wrong alignment on UStatManager");
static_assert(sizeof(UStatManager) == 0x0000A0, "Wrong size on UStatManager");
static_assert(offsetof(UStatManager, Stats) == 0x000028, "Member 'UStatManager::Stats' has a wrong offset!");
static_assert(offsetof(UStatManager, StatPrefix) == 0x000038, "Member 'UStatManager::StatPrefix' has a wrong offset!");
static_assert(offsetof(UStatManager, FPC) == 0x000048, "Member 'UStatManager::FPC' has a wrong offset!");

// Class FortniteGame.WaterVolume_Deep
// 0x0018 (0x03E8 - 0x03D0)
class AWaterVolume_Deep final : public APhysicsVolume
{
public:
	class USoundBase*                             EntrySound;                                        // 0x03D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             ExitSound;                                         // 0x03D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DamagePerSec;                                      // 0x03E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E4[0x4];                                      // 0x03E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaterVolume_Deep">();
	}
	static class AWaterVolume_Deep* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWaterVolume_Deep>();
	}
};
static_assert(alignof(AWaterVolume_Deep) == 0x000008, "Wrong alignment on AWaterVolume_Deep");
static_assert(sizeof(AWaterVolume_Deep) == 0x0003E8, "Wrong size on AWaterVolume_Deep");
static_assert(offsetof(AWaterVolume_Deep, EntrySound) == 0x0003D0, "Member 'AWaterVolume_Deep::EntrySound' has a wrong offset!");
static_assert(offsetof(AWaterVolume_Deep, ExitSound) == 0x0003D8, "Member 'AWaterVolume_Deep::ExitSound' has a wrong offset!");
static_assert(offsetof(AWaterVolume_Deep, DamagePerSec) == 0x0003E0, "Member 'AWaterVolume_Deep::DamagePerSec' has a wrong offset!");

// Class FortniteGame.WaterVolume_Shallow
// 0x0010 (0x03E0 - 0x03D0)
class AWaterVolume_Shallow final : public APhysicsVolume
{
public:
	class USoundBase*                             EntrySound;                                        // 0x03D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             ExitSound;                                         // 0x03D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaterVolume_Shallow">();
	}
	static class AWaterVolume_Shallow* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWaterVolume_Shallow>();
	}
};
static_assert(alignof(AWaterVolume_Shallow) == 0x000008, "Wrong alignment on AWaterVolume_Shallow");
static_assert(sizeof(AWaterVolume_Shallow) == 0x0003E0, "Wrong size on AWaterVolume_Shallow");
static_assert(offsetof(AWaterVolume_Shallow, EntrySound) == 0x0003D0, "Member 'AWaterVolume_Shallow::EntrySound' has a wrong offset!");
static_assert(offsetof(AWaterVolume_Shallow, ExitSound) == 0x0003D8, "Member 'AWaterVolume_Shallow::ExitSound' has a wrong offset!");

}

